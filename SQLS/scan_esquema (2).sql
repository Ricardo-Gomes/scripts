--
-- PostgreSQL database dump
--

-- Dumped from database version 9.0.23
-- Dumped by pg_dump version 9.5.5

-- Started on 2019-11-08 10:38:00

SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = off;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET escape_string_warning = off;
SET row_security = off;

--
-- TOC entry 6 (class 2615 OID 563808)
-- Name: sc__buxo; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc__buxo;


ALTER SCHEMA sc__buxo OWNER TO scan;

--
-- TOC entry 7462 (class 0 OID 0)
-- Dependencies: 6
-- Name: SCHEMA sc__buxo; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc__buxo IS 'esquema para inserir rotinas que visam a correcao de problemas em geral';


--
-- TOC entry 7 (class 2615 OID 563809)
-- Name: sc_acc; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_acc;


ALTER SCHEMA sc_acc OWNER TO scan;

--
-- TOC entry 7463 (class 0 OID 0)
-- Dependencies: 7
-- Name: SCHEMA sc_acc; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_acc IS 'ESQUEMA DE ARQUIVO DE CADASTRO DE CARTAO. CONTEM TODAS AS TABELAS, PROCEDURES E FUNCOES RELACIONADAS AO ARQUIVO DE CADASTRO DE CARTAO';


--
-- TOC entry 8 (class 2615 OID 563810)
-- Name: sc_ace; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_ace;


ALTER SCHEMA sc_ace OWNER TO scan;

--
-- TOC entry 9 (class 2615 OID 563811)
-- Name: sc_adp; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_adp;


ALTER SCHEMA sc_adp OWNER TO scan;

--
-- TOC entry 7464 (class 0 OID 0)
-- Dependencies: 9
-- Name: SCHEMA sc_adp; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_adp IS 'ESQUEMA ARQUIVO DE DEPOSITO. CONTEM TODAS AS TABELAS, PROCEDURES E FUNCOES RELACIONADAS AO ARQUIVO DE DEPOSITO.';


--
-- TOC entry 10 (class 2615 OID 563812)
-- Name: sc_aeo; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_aeo;


ALTER SCHEMA sc_aeo OWNER TO scan;

--
-- TOC entry 7465 (class 0 OID 0)
-- Dependencies: 10
-- Name: SCHEMA sc_aeo; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_aeo IS 'esquema que contem todas as tabelas e funtions relacionadas a exportação de operações';


--
-- TOC entry 65 (class 2615 OID 1667131)
-- Name: sc_analise; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_analise;


ALTER SCHEMA sc_analise OWNER TO scan;

--
-- TOC entry 7466 (class 0 OID 0)
-- Dependencies: 65
-- Name: SCHEMA sc_analise; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_analise IS 'esquema que contem tabelas criadas para armazenar dados que ajudem a analisar o comportamento dos clientes';


--
-- TOC entry 11 (class 2615 OID 563813)
-- Name: sc_arq; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_arq;


ALTER SCHEMA sc_arq OWNER TO scan;

--
-- TOC entry 12 (class 2615 OID 563814)
-- Name: sc_atb; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_atb;


ALTER SCHEMA sc_atb OWNER TO scan;

--
-- TOC entry 7467 (class 0 OID 0)
-- Dependencies: 12
-- Name: SCHEMA sc_atb; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_atb IS 'esquema que contem todos os objetos de bancos de dados relacionados ao arquivo de transferencia bancaria';


--
-- TOC entry 13 (class 2615 OID 563815)
-- Name: sc_cad; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_cad;


ALTER SCHEMA sc_cad OWNER TO scan;

--
-- TOC entry 7468 (class 0 OID 0)
-- Dependencies: 13
-- Name: SCHEMA sc_cad; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_cad IS 'ESQUEMA QUE POSSUI TODOS AS TABELAS, PROCEDURES E FUNCOES RELACIONADAS AO CADASTRO DE CLIENTES.';


--
-- TOC entry 14 (class 2615 OID 563816)
-- Name: sc_calc; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_calc;


ALTER SCHEMA sc_calc OWNER TO scan;

--
-- TOC entry 15 (class 2615 OID 563817)
-- Name: sc_cap; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_cap;


ALTER SCHEMA sc_cap OWNER TO scan;

--
-- TOC entry 7469 (class 0 OID 0)
-- Dependencies: 15
-- Name: SCHEMA sc_cap; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_cap IS 'ESQUEMA DE CONTAS A PAGAR';


--
-- TOC entry 51 (class 2615 OID 840859)
-- Name: sc_cbe; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_cbe;


ALTER SCHEMA sc_cbe OWNER TO scan;

--
-- TOC entry 7470 (class 0 OID 0)
-- Dependencies: 51
-- Name: SCHEMA sc_cbe; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_cbe IS 'esquema de cobranca externa';


--
-- TOC entry 16 (class 2615 OID 563818)
-- Name: sc_cbr; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_cbr;


ALTER SCHEMA sc_cbr OWNER TO scan;

--
-- TOC entry 55 (class 2615 OID 885393)
-- Name: sc_ccb; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_ccb;


ALTER SCHEMA sc_ccb OWNER TO scan;

--
-- TOC entry 66 (class 2615 OID 1630841)
-- Name: sc_cce; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_cce;


ALTER SCHEMA sc_cce OWNER TO scan;

--
-- TOC entry 17 (class 2615 OID 563819)
-- Name: sc_cci; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_cci;


ALTER SCHEMA sc_cci OWNER TO scan;

--
-- TOC entry 7471 (class 0 OID 0)
-- Dependencies: 17
-- Name: SCHEMA sc_cci; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_cci IS 'esquema de controle de cobranca individual';


--
-- TOC entry 18 (class 2615 OID 563820)
-- Name: sc_cnt; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_cnt;


ALTER SCHEMA sc_cnt OWNER TO scan;

--
-- TOC entry 7472 (class 0 OID 0)
-- Dependencies: 18
-- Name: SCHEMA sc_cnt; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_cnt IS 'ESQUEMA ONDE CONTEM TODAS AS TABELAS, PROCEDURES E FUNCOES RELACIONADAS A CONTA';


--
-- TOC entry 19 (class 2615 OID 563821)
-- Name: sc_crr; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_crr;


ALTER SCHEMA sc_crr OWNER TO scan;

--
-- TOC entry 7473 (class 0 OID 0)
-- Dependencies: 19
-- Name: SCHEMA sc_crr; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_crr IS 'esquema de correio';


--
-- TOC entry 20 (class 2615 OID 563822)
-- Name: sc_ctb; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_ctb;


ALTER SCHEMA sc_ctb OWNER TO scan;

--
-- TOC entry 7474 (class 0 OID 0)
-- Dependencies: 20
-- Name: SCHEMA sc_ctb; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_ctb IS 'esquema que contem todos os objetos de bancos relacionados a exportacao dos dados para a contabilidade';


--
-- TOC entry 58 (class 2615 OID 966386)
-- Name: sc_dgt; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_dgt;


ALTER SCHEMA sc_dgt OWNER TO scan;

--
-- TOC entry 21 (class 2615 OID 563823)
-- Name: sc_dsp; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_dsp;


ALTER SCHEMA sc_dsp OWNER TO scan;

--
-- TOC entry 22 (class 2615 OID 563824)
-- Name: sc_dwn; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_dwn;


ALTER SCHEMA sc_dwn OWNER TO scan;

--
-- TOC entry 7475 (class 0 OID 0)
-- Dependencies: 22
-- Name: SCHEMA sc_dwn; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_dwn IS 'schema de download de arquivos';


--
-- TOC entry 64 (class 2615 OID 1085831)
-- Name: sc_exp; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_exp;


ALTER SCHEMA sc_exp OWNER TO scan;

--
-- TOC entry 7476 (class 0 OID 0)
-- Dependencies: 64
-- Name: SCHEMA sc_exp; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_exp IS 'esquema de tabelas expurgadas';


--
-- TOC entry 23 (class 2615 OID 563825)
-- Name: sc_fcr; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_fcr;


ALTER SCHEMA sc_fcr OWNER TO scan;

--
-- TOC entry 7477 (class 0 OID 0)
-- Dependencies: 23
-- Name: SCHEMA sc_fcr; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_fcr IS 'ESQUEMA DE FATURAMENTO DO CARTAO. CONTEM TODAS AS TABELAS, PROCEDURES E FUNCOES RELACIONADAS AO FATURAMENTO DOS CARTOES';


--
-- TOC entry 24 (class 2615 OID 563826)
-- Name: sc_fep; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_fep;


ALTER SCHEMA sc_fep OWNER TO scan;

--
-- TOC entry 25 (class 2615 OID 563827)
-- Name: sc_fin; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_fin;


ALTER SCHEMA sc_fin OWNER TO scan;

--
-- TOC entry 7478 (class 0 OID 0)
-- Dependencies: 25
-- Name: SCHEMA sc_fin; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_fin IS 'ESQUEMA FINANCEIRO. CONTEM TODAS AS TABELAS, PROCEDURES E FUNCOES RELACIONADAS AO FINANCEIRO';


--
-- TOC entry 26 (class 2615 OID 563828)
-- Name: sc_fsc; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_fsc;


ALTER SCHEMA sc_fsc OWNER TO scan;

--
-- TOC entry 7479 (class 0 OID 0)
-- Dependencies: 26
-- Name: SCHEMA sc_fsc; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_fsc IS 'ESQUEMA FISCAL';


--
-- TOC entry 27 (class 2615 OID 563829)
-- Name: sc_grl; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_grl;


ALTER SCHEMA sc_grl OWNER TO scan;

--
-- TOC entry 7480 (class 0 OID 0)
-- Dependencies: 27
-- Name: SCHEMA sc_grl; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_grl IS 'esquema geral';


--
-- TOC entry 53 (class 2615 OID 873242)
-- Name: sc_hlt; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_hlt;


ALTER SCHEMA sc_hlt OWNER TO scan;

--
-- TOC entry 28 (class 2615 OID 563830)
-- Name: sc_ind; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_ind;


ALTER SCHEMA sc_ind OWNER TO scan;

--
-- TOC entry 62 (class 2615 OID 1010966)
-- Name: sc_iso8583; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_iso8583;


ALTER SCHEMA sc_iso8583 OWNER TO scan;

--
-- TOC entry 7481 (class 0 OID 0)
-- Dependencies: 62
-- Name: SCHEMA sc_iso8583; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_iso8583 IS 'Esquema da iso8583';


--
-- TOC entry 29 (class 2615 OID 563831)
-- Name: sc_job; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_job;


ALTER SCHEMA sc_job OWNER TO scan;

--
-- TOC entry 7482 (class 0 OID 0)
-- Dependencies: 29
-- Name: SCHEMA sc_job; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_job IS 'Schema de jobs';


--
-- TOC entry 30 (class 2615 OID 563832)
-- Name: sc_meta; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_meta;


ALTER SCHEMA sc_meta OWNER TO scan;

--
-- TOC entry 7483 (class 0 OID 0)
-- Dependencies: 30
-- Name: SCHEMA sc_meta; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_meta IS 'ESQUEMA RELACIONADO AO CONTROLE DA META';


--
-- TOC entry 31 (class 2615 OID 563833)
-- Name: sc_mgr; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_mgr;


ALTER SCHEMA sc_mgr OWNER TO scan;

--
-- TOC entry 54 (class 2615 OID 875703)
-- Name: sc_mnt; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_mnt;


ALTER SCHEMA sc_mnt OWNER TO scan;

--
-- TOC entry 60 (class 2615 OID 992912)
-- Name: sc_mrk; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_mrk;


ALTER SCHEMA sc_mrk OWNER TO scan;

--
-- TOC entry 32 (class 2615 OID 563834)
-- Name: sc_msg; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_msg;


ALTER SCHEMA sc_msg OWNER TO scan;

--
-- TOC entry 7484 (class 0 OID 0)
-- Dependencies: 32
-- Name: SCHEMA sc_msg; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_msg IS 'mensagem';


--
-- TOC entry 33 (class 2615 OID 563835)
-- Name: sc_opr; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_opr;


ALTER SCHEMA sc_opr OWNER TO scan;

--
-- TOC entry 7485 (class 0 OID 0)
-- Dependencies: 33
-- Name: SCHEMA sc_opr; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_opr IS 'ESQUEMA QUE ARMAZENA TODAS AS TABELAS, PROCEDURES E FUNCOES RELACIONADAS DIRETAMENTE COM AS OPERACOES';


--
-- TOC entry 63 (class 2615 OID 1040615)
-- Name: sc_opr_exp; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_opr_exp;


ALTER SCHEMA sc_opr_exp OWNER TO scan;

--
-- TOC entry 34 (class 2615 OID 563836)
-- Name: sc_pbl; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_pbl;


ALTER SCHEMA sc_pbl OWNER TO scan;

--
-- TOC entry 7486 (class 0 OID 0)
-- Dependencies: 34
-- Name: SCHEMA sc_pbl; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_pbl IS 'Schema publico';


--
-- TOC entry 56 (class 2615 OID 889030)
-- Name: sc_pgc; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_pgc;


ALTER SCHEMA sc_pgc OWNER TO scan;

--
-- TOC entry 7487 (class 0 OID 0)
-- Dependencies: 56
-- Name: SCHEMA sc_pgc; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_pgc IS 'SCHEMA DE PAGAMENTO DE CONTAS';


--
-- TOC entry 61 (class 2615 OID 1007288)
-- Name: sc_ppr; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_ppr;


ALTER SCHEMA sc_ppr OWNER TO scan;

--
-- TOC entry 7488 (class 0 OID 0)
-- Dependencies: 61
-- Name: SCHEMA sc_ppr; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_ppr IS 'esquema de ppr';


--
-- TOC entry 35 (class 2615 OID 563837)
-- Name: sc_rcg; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_rcg;


ALTER SCHEMA sc_rcg OWNER TO scan;

--
-- TOC entry 7489 (class 0 OID 0)
-- Dependencies: 35
-- Name: SCHEMA sc_rcg; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_rcg IS 'recarga';


--
-- TOC entry 36 (class 2615 OID 563838)
-- Name: sc_rct; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_rct;


ALTER SCHEMA sc_rct OWNER TO scan;

--
-- TOC entry 37 (class 2615 OID 563839)
-- Name: sc_rdc; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_rdc;


ALTER SCHEMA sc_rdc OWNER TO scan;

--
-- TOC entry 7490 (class 0 OID 0)
-- Dependencies: 37
-- Name: SCHEMA sc_rdc; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_rdc IS 'Schema da rede de compra';


--
-- TOC entry 38 (class 2615 OID 563840)
-- Name: sc_rds; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_rds;


ALTER SCHEMA sc_rds OWNER TO scan;

--
-- TOC entry 7491 (class 0 OID 0)
-- Dependencies: 38
-- Name: SCHEMA sc_rds; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_rds IS 'ESQUEMA DE REDE DE SAQUE. CONTEM TODAS AS TABELAS, PROCEDURES E FUNCOES RELACIONADOS A REDE DE SAQUE.';


--
-- TOC entry 59 (class 2615 OID 1041891)
-- Name: sc_rel; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_rel;


ALTER SCHEMA sc_rel OWNER TO scan;

--
-- TOC entry 39 (class 2615 OID 563841)
-- Name: sc_rnc; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_rnc;


ALTER SCHEMA sc_rnc OWNER TO scan;

--
-- TOC entry 7492 (class 0 OID 0)
-- Dependencies: 39
-- Name: SCHEMA sc_rnc; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_rnc IS 'schema de renegociacao';


--
-- TOC entry 40 (class 2615 OID 563842)
-- Name: sc_rsc; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_rsc;


ALTER SCHEMA sc_rsc OWNER TO scan;

--
-- TOC entry 52 (class 2615 OID 844326)
-- Name: sc_scan_cbe; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_scan_cbe;


ALTER SCHEMA sc_scan_cbe OWNER TO scan;

--
-- TOC entry 41 (class 2615 OID 563843)
-- Name: sc_sds; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_sds;


ALTER SCHEMA sc_sds OWNER TO scan;

--
-- TOC entry 42 (class 2615 OID 563844)
-- Name: sc_sgr; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_sgr;


ALTER SCHEMA sc_sgr OWNER TO scan;

--
-- TOC entry 7493 (class 0 OID 0)
-- Dependencies: 42
-- Name: SCHEMA sc_sgr; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_sgr IS 'SCHEMA DE SEGURANCA';


--
-- TOC entry 43 (class 2615 OID 563845)
-- Name: sc_spc; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_spc;


ALTER SCHEMA sc_spc OWNER TO scan;

--
-- TOC entry 7494 (class 0 OID 0)
-- Dependencies: 43
-- Name: SCHEMA sc_spc; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_spc IS 'esquema de integracao com o SPC';


--
-- TOC entry 57 (class 2615 OID 899498)
-- Name: sc_srs; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_srs;


ALTER SCHEMA sc_srs OWNER TO scan;

--
-- TOC entry 44 (class 2615 OID 563846)
-- Name: sc_srv; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_srv;


ALTER SCHEMA sc_srv OWNER TO scan;

--
-- TOC entry 7495 (class 0 OID 0)
-- Dependencies: 44
-- Name: SCHEMA sc_srv; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_srv IS 'ESQUEMA DE SERVICOS';


--
-- TOC entry 45 (class 2615 OID 563847)
-- Name: sc_ssp; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_ssp;


ALTER SCHEMA sc_ssp OWNER TO scan;

--
-- TOC entry 46 (class 2615 OID 563848)
-- Name: sc_svg; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_svg;


ALTER SCHEMA sc_svg OWNER TO scan;

--
-- TOC entry 7496 (class 0 OID 0)
-- Dependencies: 46
-- Name: SCHEMA sc_svg; Type: COMMENT; Schema: -; Owner: scan
--

COMMENT ON SCHEMA sc_svg IS 'schema de seguro de vida em grupo';


--
-- TOC entry 47 (class 2615 OID 563849)
-- Name: sc_tem; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_tem;


ALTER SCHEMA sc_tem OWNER TO scan;

--
-- TOC entry 48 (class 2615 OID 563850)
-- Name: sc_trg; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sc_trg;


ALTER SCHEMA sc_trg OWNER TO scan;

--
-- TOC entry 50 (class 2615 OID 563851)
-- Name: sqlj; Type: SCHEMA; Schema: -; Owner: scan
--

CREATE SCHEMA sqlj;


ALTER SCHEMA sqlj OWNER TO scan;

SET search_path = sqlj, pg_catalog;

--
-- TOC entry 1000 (class 1255 OID 563852)
-- Name: java_call_handler(); Type: FUNCTION; Schema: sqlj; Owner: postgres
--

CREATE FUNCTION java_call_handler() RETURNS language_handler
    LANGUAGE c
    AS 'pljava', 'java_call_handler';


ALTER FUNCTION sqlj.java_call_handler() OWNER TO postgres;

--
-- TOC entry 3990 (class 2612 OID 563853)
-- Name: java; Type: PROCEDURAL LANGUAGE; Schema: sqlj; Owner: postgres
--

CREATE TRUSTED PROCEDURAL LANGUAGE java HANDLER java_call_handler;


ALTER PROCEDURAL LANGUAGE java OWNER TO postgres;

--
-- TOC entry 1004 (class 1255 OID 563854)
-- Name: javau_call_handler(); Type: FUNCTION; Schema: sqlj; Owner: postgres
--

CREATE FUNCTION javau_call_handler() RETURNS language_handler
    LANGUAGE c
    AS 'pljava', 'javau_call_handler';


ALTER FUNCTION sqlj.javau_call_handler() OWNER TO postgres;

--
-- TOC entry 3991 (class 2612 OID 563855)
-- Name: javau; Type: PROCEDURAL LANGUAGE; Schema: sqlj; Owner: postgres
--

CREATE PROCEDURAL LANGUAGE javau HANDLER javau_call_handler;


ALTER PROCEDURAL LANGUAGE javau OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- TOC entry 2167 (class 1247 OID 563858)
-- Name: breakpoint; Type: TYPE; Schema: public; Owner: scan
--

CREATE TYPE breakpoint AS (
	func oid,
	linenumber integer,
	targetname text
);


ALTER TYPE breakpoint OWNER TO scan;

--
-- TOC entry 2170 (class 1247 OID 563861)
-- Name: dblink_pkey_results; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE dblink_pkey_results AS (
	"position" integer,
	colname text
);


ALTER TYPE dblink_pkey_results OWNER TO postgres;

--
-- TOC entry 2173 (class 1247 OID 563864)
-- Name: frame; Type: TYPE; Schema: public; Owner: scan
--

CREATE TYPE frame AS (
	level integer,
	targetname text,
	func oid,
	linenumber integer,
	args text
);


ALTER TYPE frame OWNER TO scan;

--
-- TOC entry 2176 (class 1247 OID 563867)
-- Name: proxyinfo; Type: TYPE; Schema: public; Owner: scan
--

CREATE TYPE proxyinfo AS (
	serverversionstr text,
	serverversionnum integer,
	proxyapiver integer,
	serverprocessid integer
);


ALTER TYPE proxyinfo OWNER TO scan;

--
-- TOC entry 2179 (class 1247 OID 563870)
-- Name: targetinfo; Type: TYPE; Schema: public; Owner: scan
--

CREATE TYPE targetinfo AS (
	target oid,
	schema oid,
	nargs integer,
	argtypes oidvector,
	targetname name,
	argmodes "char"[],
	argnames text[],
	targetlang oid,
	fqname text,
	returnsset boolean,
	returntype oid
);


ALTER TYPE targetinfo OWNER TO scan;

--
-- TOC entry 2182 (class 1247 OID 563873)
-- Name: valor_evento; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE valor_evento AS (
	nome character varying(200),
	valor numeric(13,2)
);


ALTER TYPE valor_evento OWNER TO postgres;

--
-- TOC entry 2185 (class 1247 OID 563876)
-- Name: var; Type: TYPE; Schema: public; Owner: scan
--

CREATE TYPE var AS (
	name text,
	varclass character(1),
	linenumber integer,
	isunique boolean,
	isconst boolean,
	isnotnull boolean,
	dtype oid,
	value text
);


ALTER TYPE var OWNER TO scan;

--
-- TOC entry 1074 (class 1255 OID 1667423)
-- Name: _final_median(numeric[]); Type: FUNCTION; Schema: public; Owner: scan
--

CREATE FUNCTION _final_median(numeric[]) RETURNS numeric
    LANGUAGE sql IMMUTABLE
    AS $_$ 
SELECT AVG(val) 
FROM ( 
SELECT val 
FROM unnest($1) val 
ORDER BY 1 
LIMIT 2 - MOD(array_upper($1, 1), 2) 
OFFSET CEIL(array_upper($1, 1) / 2.0) - 1 
) sub; 
$_$;


ALTER FUNCTION public._final_median(numeric[]) OWNER TO scan;

--
-- TOC entry 1005 (class 1255 OID 563877)
-- Name: dblink(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink(text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text) OWNER TO postgres;

--
-- TOC entry 1007 (class 1255 OID 563879)
-- Name: dblink(text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink(text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text, boolean) OWNER TO postgres;

--
-- TOC entry 1006 (class 1255 OID 563878)
-- Name: dblink(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink(text, text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text, text) OWNER TO postgres;

--
-- TOC entry 1008 (class 1255 OID 563880)
-- Name: dblink(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink(text, text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_record';


ALTER FUNCTION public.dblink(text, text, boolean) OWNER TO postgres;

--
-- TOC entry 1009 (class 1255 OID 563881)
-- Name: dblink_build_sql_delete(text, int2vector, integer, text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_build_sql_delete(text, int2vector, integer, text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_delete';


ALTER FUNCTION public.dblink_build_sql_delete(text, int2vector, integer, text[]) OWNER TO postgres;

--
-- TOC entry 1010 (class 1255 OID 563882)
-- Name: dblink_build_sql_insert(text, int2vector, integer, text[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_build_sql_insert(text, int2vector, integer, text[], text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_insert';


ALTER FUNCTION public.dblink_build_sql_insert(text, int2vector, integer, text[], text[]) OWNER TO postgres;

--
-- TOC entry 1011 (class 1255 OID 563883)
-- Name: dblink_build_sql_update(text, int2vector, integer, text[], text[]); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_build_sql_update(text, int2vector, integer, text[], text[]) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_build_sql_update';


ALTER FUNCTION public.dblink_build_sql_update(text, int2vector, integer, text[], text[]) OWNER TO postgres;

--
-- TOC entry 1012 (class 1255 OID 563884)
-- Name: dblink_cancel_query(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_cancel_query(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_cancel_query';


ALTER FUNCTION public.dblink_cancel_query(text) OWNER TO postgres;

--
-- TOC entry 1013 (class 1255 OID 563885)
-- Name: dblink_close(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_close(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text) OWNER TO postgres;

--
-- TOC entry 1014 (class 1255 OID 563886)
-- Name: dblink_close(text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_close(text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text, boolean) OWNER TO postgres;

--
-- TOC entry 1015 (class 1255 OID 563887)
-- Name: dblink_close(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_close(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text, text) OWNER TO postgres;

--
-- TOC entry 1016 (class 1255 OID 563888)
-- Name: dblink_close(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_close(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_close';


ALTER FUNCTION public.dblink_close(text, text, boolean) OWNER TO postgres;

--
-- TOC entry 1017 (class 1255 OID 563889)
-- Name: dblink_connect(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_connect(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect(text) OWNER TO postgres;

--
-- TOC entry 1018 (class 1255 OID 563890)
-- Name: dblink_connect(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_connect(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect(text, text) OWNER TO postgres;

--
-- TOC entry 1488 (class 1255 OID 563891)
-- Name: dblink_connect_u(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_connect_u(text) RETURNS text
    LANGUAGE c STRICT SECURITY DEFINER
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect_u(text) OWNER TO postgres;

--
-- TOC entry 1489 (class 1255 OID 563892)
-- Name: dblink_connect_u(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_connect_u(text, text) RETURNS text
    LANGUAGE c STRICT SECURITY DEFINER
    AS '$libdir/dblink', 'dblink_connect';


ALTER FUNCTION public.dblink_connect_u(text, text) OWNER TO postgres;

--
-- TOC entry 1019 (class 1255 OID 563893)
-- Name: dblink_current_query(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_current_query() RETURNS text
    LANGUAGE c
    AS '$libdir/dblink', 'dblink_current_query';


ALTER FUNCTION public.dblink_current_query() OWNER TO postgres;

--
-- TOC entry 1020 (class 1255 OID 563894)
-- Name: dblink_disconnect(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_disconnect() RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_disconnect';


ALTER FUNCTION public.dblink_disconnect() OWNER TO postgres;

--
-- TOC entry 1021 (class 1255 OID 563895)
-- Name: dblink_disconnect(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_disconnect(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_disconnect';


ALTER FUNCTION public.dblink_disconnect(text) OWNER TO postgres;

--
-- TOC entry 1022 (class 1255 OID 563896)
-- Name: dblink_error_message(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_error_message(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_error_message';


ALTER FUNCTION public.dblink_error_message(text) OWNER TO postgres;

--
-- TOC entry 1023 (class 1255 OID 563897)
-- Name: dblink_exec(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_exec(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text) OWNER TO postgres;

--
-- TOC entry 1025 (class 1255 OID 563899)
-- Name: dblink_exec(text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_exec(text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text, boolean) OWNER TO postgres;

--
-- TOC entry 1024 (class 1255 OID 563898)
-- Name: dblink_exec(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_exec(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text, text) OWNER TO postgres;

--
-- TOC entry 1026 (class 1255 OID 563900)
-- Name: dblink_exec(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_exec(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_exec';


ALTER FUNCTION public.dblink_exec(text, text, boolean) OWNER TO postgres;

--
-- TOC entry 1027 (class 1255 OID 563901)
-- Name: dblink_fetch(text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_fetch(text, integer) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, integer) OWNER TO postgres;

--
-- TOC entry 1028 (class 1255 OID 563902)
-- Name: dblink_fetch(text, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_fetch(text, integer, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, integer, boolean) OWNER TO postgres;

--
-- TOC entry 1029 (class 1255 OID 563903)
-- Name: dblink_fetch(text, text, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_fetch(text, text, integer) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, text, integer) OWNER TO postgres;

--
-- TOC entry 1030 (class 1255 OID 563904)
-- Name: dblink_fetch(text, text, integer, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_fetch(text, text, integer, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_fetch';


ALTER FUNCTION public.dblink_fetch(text, text, integer, boolean) OWNER TO postgres;

--
-- TOC entry 1031 (class 1255 OID 563905)
-- Name: dblink_get_connections(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_get_connections() RETURNS text[]
    LANGUAGE c
    AS '$libdir/dblink', 'dblink_get_connections';


ALTER FUNCTION public.dblink_get_connections() OWNER TO postgres;

--
-- TOC entry 1032 (class 1255 OID 563906)
-- Name: dblink_get_notify(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_get_notify(OUT notify_name text, OUT be_pid integer, OUT extra text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_notify';


ALTER FUNCTION public.dblink_get_notify(OUT notify_name text, OUT be_pid integer, OUT extra text) OWNER TO postgres;

--
-- TOC entry 1033 (class 1255 OID 563907)
-- Name: dblink_get_notify(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_get_notify(conname text, OUT notify_name text, OUT be_pid integer, OUT extra text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_notify';


ALTER FUNCTION public.dblink_get_notify(conname text, OUT notify_name text, OUT be_pid integer, OUT extra text) OWNER TO postgres;

--
-- TOC entry 1034 (class 1255 OID 563908)
-- Name: dblink_get_pkey(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_get_pkey(text) RETURNS SETOF dblink_pkey_results
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_pkey';


ALTER FUNCTION public.dblink_get_pkey(text) OWNER TO postgres;

--
-- TOC entry 1035 (class 1255 OID 563909)
-- Name: dblink_get_result(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_get_result(text) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_result';


ALTER FUNCTION public.dblink_get_result(text) OWNER TO postgres;

--
-- TOC entry 1036 (class 1255 OID 563910)
-- Name: dblink_get_result(text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_get_result(text, boolean) RETURNS SETOF record
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_get_result';


ALTER FUNCTION public.dblink_get_result(text, boolean) OWNER TO postgres;

--
-- TOC entry 1037 (class 1255 OID 563911)
-- Name: dblink_is_busy(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_is_busy(text) RETURNS integer
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_is_busy';


ALTER FUNCTION public.dblink_is_busy(text) OWNER TO postgres;

--
-- TOC entry 1038 (class 1255 OID 563912)
-- Name: dblink_open(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_open(text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text) OWNER TO postgres;

--
-- TOC entry 1039 (class 1255 OID 563913)
-- Name: dblink_open(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_open(text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text, boolean) OWNER TO postgres;

--
-- TOC entry 1040 (class 1255 OID 563914)
-- Name: dblink_open(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_open(text, text, text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text, text) OWNER TO postgres;

--
-- TOC entry 1041 (class 1255 OID 563915)
-- Name: dblink_open(text, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_open(text, text, text, boolean) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_open';


ALTER FUNCTION public.dblink_open(text, text, text, boolean) OWNER TO postgres;

--
-- TOC entry 1042 (class 1255 OID 563916)
-- Name: dblink_send_query(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION dblink_send_query(text, text) RETURNS integer
    LANGUAGE c STRICT
    AS '$libdir/dblink', 'dblink_send_query';


ALTER FUNCTION public.dblink_send_query(text, text) OWNER TO postgres;

--
-- TOC entry 1043 (class 1255 OID 563917)
-- Name: instr(character varying, character varying); Type: FUNCTION; Schema: public; Owner: scan
--

CREATE FUNCTION instr(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
    pos integer;
BEGIN
    pos:= instr($1, $2, 1);
    RETURN pos;
END;
$_$;


ALTER FUNCTION public.instr(character varying, character varying) OWNER TO scan;

--
-- TOC entry 1044 (class 1255 OID 563918)
-- Name: instr(character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: scan
--

CREATE FUNCTION instr(string character varying, string_to_search character varying, beg_index integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index > 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos > 0 THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    END IF;
END;
$$;


ALTER FUNCTION public.instr(string character varying, string_to_search character varying, beg_index integer) OWNER TO scan;

--
-- TOC entry 1046 (class 1255 OID 563919)
-- Name: instr(character varying, character varying, integer, integer); Type: FUNCTION; Schema: public; Owner: scan
--

CREATE FUNCTION instr(string character varying, string_to_search character varying, beg_index integer, occur_index integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index > 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;
    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos > 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    END IF;
END;
$$;


ALTER FUNCTION public.instr(string character varying, string_to_search character varying, beg_index integer, occur_index integer) OWNER TO scan;

--
-- TOC entry 1047 (class 1255 OID 563920)
-- Name: pldbg_abort_target(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_abort_target(session integer) RETURNS SETOF boolean
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_abort_target';


ALTER FUNCTION public.pldbg_abort_target(session integer) OWNER TO postgres;

--
-- TOC entry 1048 (class 1255 OID 563921)
-- Name: pldbg_attach_to_port(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_attach_to_port(portnumber integer) RETURNS integer
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_attach_to_port';


ALTER FUNCTION public.pldbg_attach_to_port(portnumber integer) OWNER TO postgres;

--
-- TOC entry 1049 (class 1255 OID 563922)
-- Name: pldbg_continue(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_continue(session integer) RETURNS breakpoint
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_continue';


ALTER FUNCTION public.pldbg_continue(session integer) OWNER TO postgres;

--
-- TOC entry 1050 (class 1255 OID 563923)
-- Name: pldbg_create_listener(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_create_listener() RETURNS integer
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_create_listener';


ALTER FUNCTION public.pldbg_create_listener() OWNER TO postgres;

--
-- TOC entry 1051 (class 1255 OID 563924)
-- Name: pldbg_deposit_value(integer, text, integer, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_deposit_value(session integer, varname text, linenumber integer, value text) RETURNS boolean
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_deposit_value';


ALTER FUNCTION public.pldbg_deposit_value(session integer, varname text, linenumber integer, value text) OWNER TO postgres;

--
-- TOC entry 1052 (class 1255 OID 563925)
-- Name: pldbg_drop_breakpoint(integer, oid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_drop_breakpoint(session integer, func oid, linenumber integer) RETURNS boolean
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_drop_breakpoint';


ALTER FUNCTION public.pldbg_drop_breakpoint(session integer, func oid, linenumber integer) OWNER TO postgres;

--
-- TOC entry 1053 (class 1255 OID 563926)
-- Name: pldbg_get_breakpoints(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_get_breakpoints(session integer) RETURNS SETOF breakpoint
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_get_breakpoints';


ALTER FUNCTION public.pldbg_get_breakpoints(session integer) OWNER TO postgres;

--
-- TOC entry 1054 (class 1255 OID 563927)
-- Name: pldbg_get_proxy_info(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_get_proxy_info() RETURNS proxyinfo
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_get_proxy_info';


ALTER FUNCTION public.pldbg_get_proxy_info() OWNER TO postgres;

--
-- TOC entry 1055 (class 1255 OID 563928)
-- Name: pldbg_get_source(integer, oid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_get_source(session integer, func oid) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_get_source';


ALTER FUNCTION public.pldbg_get_source(session integer, func oid) OWNER TO postgres;

--
-- TOC entry 1056 (class 1255 OID 563929)
-- Name: pldbg_get_stack(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_get_stack(session integer) RETURNS SETOF frame
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_get_stack';


ALTER FUNCTION public.pldbg_get_stack(session integer) OWNER TO postgres;

--
-- TOC entry 1057 (class 1255 OID 563930)
-- Name: pldbg_get_target_info(text, "char"); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_get_target_info(signature text, targettype "char") RETURNS targetinfo
    LANGUAGE c STRICT
    AS '$libdir/targetinfo', 'pldbg_get_target_info';


ALTER FUNCTION public.pldbg_get_target_info(signature text, targettype "char") OWNER TO postgres;

--
-- TOC entry 1058 (class 1255 OID 563931)
-- Name: pldbg_get_variables(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_get_variables(session integer) RETURNS SETOF var
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_get_variables';


ALTER FUNCTION public.pldbg_get_variables(session integer) OWNER TO postgres;

--
-- TOC entry 1059 (class 1255 OID 563932)
-- Name: pldbg_select_frame(integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_select_frame(session integer, frame integer) RETURNS breakpoint
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_select_frame';


ALTER FUNCTION public.pldbg_select_frame(session integer, frame integer) OWNER TO postgres;

--
-- TOC entry 1060 (class 1255 OID 563933)
-- Name: pldbg_set_breakpoint(integer, oid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_set_breakpoint(session integer, func oid, linenumber integer) RETURNS boolean
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_set_breakpoint';


ALTER FUNCTION public.pldbg_set_breakpoint(session integer, func oid, linenumber integer) OWNER TO postgres;

--
-- TOC entry 1061 (class 1255 OID 563934)
-- Name: pldbg_set_global_breakpoint(integer, oid, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_set_global_breakpoint(session integer, func oid, linenumber integer, targetpid integer) RETURNS boolean
    LANGUAGE c
    AS '$libdir/pldbgapi', 'pldbg_set_global_breakpoint';


ALTER FUNCTION public.pldbg_set_global_breakpoint(session integer, func oid, linenumber integer, targetpid integer) OWNER TO postgres;

--
-- TOC entry 1062 (class 1255 OID 563935)
-- Name: pldbg_step_into(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_step_into(session integer) RETURNS breakpoint
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_step_into';


ALTER FUNCTION public.pldbg_step_into(session integer) OWNER TO postgres;

--
-- TOC entry 1063 (class 1255 OID 563936)
-- Name: pldbg_step_over(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_step_over(session integer) RETURNS breakpoint
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_step_over';


ALTER FUNCTION public.pldbg_step_over(session integer) OWNER TO postgres;

--
-- TOC entry 1064 (class 1255 OID 563937)
-- Name: pldbg_wait_for_breakpoint(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_wait_for_breakpoint(session integer) RETURNS breakpoint
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_wait_for_breakpoint';


ALTER FUNCTION public.pldbg_wait_for_breakpoint(session integer) OWNER TO postgres;

--
-- TOC entry 1065 (class 1255 OID 563938)
-- Name: pldbg_wait_for_target(integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION pldbg_wait_for_target(session integer) RETURNS integer
    LANGUAGE c STRICT
    AS '$libdir/pldbgapi', 'pldbg_wait_for_target';


ALTER FUNCTION public.pldbg_wait_for_target(session integer) OWNER TO postgres;

--
-- TOC entry 1066 (class 1255 OID 563939)
-- Name: plpgsql_oid_debug(oid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION plpgsql_oid_debug(functionoid oid) RETURNS integer
    LANGUAGE c STRICT
    AS '$libdir/plugins/plugin_debugger', 'plpgsql_oid_debug';


ALTER FUNCTION public.plpgsql_oid_debug(functionoid oid) OWNER TO postgres;

SET search_path = sc__buxo, pg_catalog;

--
-- TOC entry 1514 (class 1255 OID 858598)
-- Name: alterar_matricula(numeric, numeric, character varying); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION alterar_matricula(vp_empresa numeric, vp_usuario numeric, vp_motivo character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;

begin

  for rg in select fa.*, fnc.cd_fnc, fnc.nr_idt_fnc as matricula_anterior
	    from sc__buxo.tbl_fnc_aux fa
		inner join sc_cad.tbl_cun cun on cun.nr_cpf_cnpj_cun = fa.cpf
		inner join  sc_cad.tbl_fnc fnc on cun.cd_cun = fnc.cd_cun
	    where fa.matricula != fnc.nr_idt_fnc 
	      and empresa = vp_empresa
	    order by cpf
  loop
      
    -- alterando a matricula do funcionario 
    update sc_cad.tbl_fnc set nr_idt_fnc = rg.matricula where cd_fnc = rg.cd_fnc;
    
    -- gravando auditoria da alteracao realizada
    insert into sc_cad.tbl_ham(cd_ham, cd_fnc, nr_mtr_ant_ham, nr_mtr_atl_ham, cd_mtv_ham, ds_obs_ham, cd_inc_usr, dt_inc_usr)
		values (nextval('sc_cad.sq_ham'), rg.cd_fnc, rg.matricula_anterior, rg.matricula, 1, vp_motivo, vp_usuario, now()); 
               
  end loop;
  

end;$$;


ALTER FUNCTION sc__buxo.alterar_matricula(vp_empresa numeric, vp_usuario numeric, vp_motivo character varying) OWNER TO scan;

--
-- TOC entry 1045 (class 1255 OID 563940)
-- Name: atualiza_cartao_renegociacao(numeric, numeric); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION atualiza_cartao_renegociacao(vp_cartao numeric, vp_dia_vencimento numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;
vl_data_vencimento date;
str_data_vencimento varchar;
vl_vencimento date;

begin

    if to_char(current_date, 'dd')::numeric > vp_dia_vencimento then
       vl_data_vencimento := current_date + interval '1 month';
    else
       vl_data_vencimento := current_date;
    end if;

    str_data_vencimento := vp_dia_vencimento || '/' || to_char(vl_data_vencimento, 'MM/yyyy');
    vl_data_vencimento := str_data_vencimento::date;
    vl_vencimento := vl_data_vencimento;
    
    for rg in 
	select * from sc_fcr.tbl_prc where cd_crt = vp_cartao and st_prc = 1 order by nr_prc
    loop 
    
       update sc_fcr.tbl_prc set dt_vnc_prc = vl_data_vencimento where cd_prc = rg.cd_prc;
       vl_data_vencimento := vl_data_vencimento + interval '1 month';
    
    end loop;

    update sc_opr.tbl_crt 
        set dt_prx_apr_crt = vl_vencimento - interval '5 day',
             dt_prx_vnc_crt = vl_vencimento
    where cd_crt = vp_cartao;

end;$$;


ALTER FUNCTION sc__buxo.atualiza_cartao_renegociacao(vp_cartao numeric, vp_dia_vencimento numeric) OWNER TO scan;

--
-- TOC entry 1068 (class 1255 OID 563941)
-- Name: atualiza_data_admissao(text[]); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION atualiza_data_admissao(vp_registro text[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  rg record;
    
begin

  for i in 1..array_length(vp_registro,1) loop
      update sc_cad.tbl_fnc 	
         set dt_adm_fnc = vp_registro[i][5]::date,
         dt_adm_atu_fnc = now()
      where cd_emp = vp_registro[i][1]::numeric
        and cd_fem = vp_registro[i][2]::numeric
        and nr_idt_fnc = vp_registro[i][3]::varchar
        and exists (select 1 from sc_cad.tbl_cun c where c.cd_cun = cd_cun and c.nr_cpf_cnpj_cun = vp_registro[i][4]::numeric);
  end loop;
    
end;
$$;


ALTER FUNCTION sc__buxo.atualiza_data_admissao(vp_registro text[]) OWNER TO scan;

--
-- TOC entry 7500 (class 0 OID 0)
-- Dependencies: 1068
-- Name: FUNCTION atualiza_data_admissao(vp_registro text[]); Type: COMMENT; Schema: sc__buxo; Owner: scan
--

COMMENT ON FUNCTION atualiza_data_admissao(vp_registro text[]) IS 'atualiza data admissao saqcard para saqpag';


--
-- TOC entry 1573 (class 1255 OID 887554)
-- Name: atualiza_digito_9_telefone(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION atualiza_digito_9_telefone() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;

begin

  for rg in select *
	    from sc_cad.tbl_tlf
            where fg_atv_tlf = 'S' 
            AND tp_tlf = 2
            and nr_tlf > 80000000
            and length(nr_tlf::varchar) < 9
            order by cd_tlf
   loop


        update sc_cad.tbl_tlf set nr_tlf = (9 || nr_tlf::varchar)::numeric where cd_tlf = rg.cd_tlf;
    

        --raise notice 'atualiza esse %, %', rg.cd_tlf, (9 || rg.nr_tlf::varchar)::numeric;

	 
  
               
  end loop;
  

end;$$;


ALTER FUNCTION sc__buxo.atualiza_digito_9_telefone() OWNER TO scan;

--
-- TOC entry 1069 (class 1255 OID 563942)
-- Name: atualiza_limite_intermedium(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION atualiza_limite_intermedium() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;
vl_cartao numeric;
vl_limite_anterior numeric;

begin

  for rg in select cun.nr_cpf_cnpj_cun, lmt.vl_cnc_lmt
            from sc_opr.tbl_lmt lmt
            inner join sc_opr.tbl_crt crt on crt.cd_crt = lmt.cd_crt
            inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
            inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
             where fnc.cd_emp = 168
             and fnc.cd_fem = 1
            order by cun.nr_cpf_cnpj_cun loop

    select crt.cd_crt
     into vl_cartao
    from sc_opr.tbl_lmt lmt
      inner join sc_opr.tbl_crt crt on crt.cd_crt = lmt.cd_crt
      inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
      inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
    where fnc.cd_emp = 307
      and fnc.cd_fem = 2
      and cun.nr_cpf_cnpj_cun = rg.nr_cpf_cnpj_cun;

  if vl_cartao is not null then

    select vl_cnc_lmt
      into vl_limite_anterior
    from sc_opr.tbl_lmt
    where cd_crt = vl_cartao;
  
    --inserindo ocorrencia
    insert into sc_opr.tbl_ocr values (nextval('sc_opr.sq_ocr'),4,vl_cartao,null,'SOLICITADO NO CHAMADO 842','S',2,NOW());

    -- inserindo historico de alteracao de limite
    insert into sc_opr.tbl_hlm values (nextval('sc_opr.sq_hlm'),vl_cartao,1,vl_limite_anterior,rg.vl_cnc_lmt,2,NOW());

    --alterando o limite
    update sc_opr.tbl_lmt set vl_cnc_lmt = rg.vl_cnc_lmt
     where cd_crt = vl_cartao;
   
   end if;

 end loop;     

end; 
    $$;


ALTER FUNCTION sc__buxo.atualiza_limite_intermedium() OWNER TO scan;

--
-- TOC entry 1582 (class 1255 OID 880113)
-- Name: atualiza_telefone(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION atualiza_telefone() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;
rg_tel record;
vl_existe numeric = 0;

begin

  for rg in select ta.*, cun.cd_cun
	    from sc__buxo.tbl_tel_aux ta
		inner join sc_cad.tbl_cun cun on cun.nr_cpf_cnpj_cun = ta.cpf
           order by ta.cpf 
   loop


   vl_existe = 0;

    -- retornando a lista de telefones do cadastro unico
   for rg_tel in select *
       from sc_cad.tbl_tlf
       where nsu_org_tlf = rg.cd_cun
         and tp_org_tlf = 1
         and tp_tlf = 2
         and fg_atv_tlf = 'S' loop
 
        if rg_tel.nr_tlf = rg.telefone then
          vl_existe = 1;
        end if;

    end loop;


     -- inserindo o telfone
     if vl_existe = 0 then
    
        insert into sc_cad.tbl_tlf(cd_tlf, nsu_org_tlf, tp_org_tlf, nr_ddd_tlf,
                                 nr_tlf, tp_tlf, fg_atv_tlf, cd_inc_usr, dt_inc_usr, fg_prn_tlf)
        values(nextval('sc_cad.sq_tlf'), rg.cd_cun, 1, rg.ddd, 
             rg.telefone, 2, 'S', 1, current_timestamp, 'N');

        --raise notice 'atualiza esse %', rg.cd_cun;

	 
     end if;
    
               
  end loop;
  

end;$$;


ALTER FUNCTION sc__buxo.atualiza_telefone() OWNER TO scan;

--
-- TOC entry 1690 (class 1255 OID 997587)
-- Name: atualiza_telefone_outra(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION atualiza_telefone_outra() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;
rg_tel record;
vl_existe numeric = 0;

begin

  for rg in select ta.*, cun.cd_cun
	    from sc_cad.tbl_tlf_aux ta
		inner join sc_cad.tbl_cun cun on cun.nr_cpf_cnpj_cun = ta.cpf
           order by ta.cpf 
   loop


   vl_existe = 0;

    -- retornando a lista de telefones do cadastro unico
   for rg_tel in select *
       from sc_cad.tbl_tlf
       where nsu_org_tlf = rg.cd_cun
         and tp_org_tlf = 1
         and tp_tlf = 2
         and fg_atv_tlf = 'S' loop
 
        if rg_tel.nr_tlf = rg.telefone then
          vl_existe = 1;
        end if;

    end loop;


     -- inserindo o telfone
     if vl_existe = 0 then
    
        insert into sc_cad.tbl_tlf(cd_tlf, nsu_org_tlf, tp_org_tlf, nr_ddd_tlf,
                                 nr_tlf, tp_tlf, fg_atv_tlf, cd_inc_usr, dt_inc_usr, fg_prn_tlf)
        values(nextval('sc_cad.sq_tlf'), rg.cd_cun, 1, rg.ddd, 
             rg.telefone, 2, 'S', 1, current_timestamp, 'N');

        --raise notice 'atualiza esse %', rg.cd_cun;

	 
     end if;
    
               
  end loop;
  

end;$$;


ALTER FUNCTION sc__buxo.atualiza_telefone_outra() OWNER TO scan;

--
-- TOC entry 1070 (class 1255 OID 563943)
-- Name: atualizar_contratos_valor_saque_maximo_diario(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION atualizar_contratos_valor_saque_maximo_diario() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

vl_data date;
begin

  if to_char(current_date, 'dd') = '02' then
     update sc_cad.tbl_pce_ctr set vl_pce_ctr = '1.000,00', cd_alt_usr = 2, dt_alt_usr = now() where cd_pce = 18 and cd_ctr <> 146;
  end if;

  
  if to_char(current_date, 'dd') = '05' then
     update sc_cad.tbl_pce_ctr set vl_pce_ctr = '3.000,00', cd_alt_usr = 2, dt_alt_usr = now() where cd_pce = 18 and cd_ctr <> 146;
  end if;
  
end;$$;


ALTER FUNCTION sc__buxo.atualizar_contratos_valor_saque_maximo_diario() OWNER TO scan;

--
-- TOC entry 1823 (class 1255 OID 1001267)
-- Name: cadastrar_conta_bancaria(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION cadastrar_conta_bancaria() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  
  vl_conta_bancaria numeric;
  vl_existe integer;

begin
   for rg in select aux.*, cun.nr_cpf_cnpj_cun, cun.nm_cun, cun.tp_pss_cun, cun.cd_cun
		from sc__buxo.tbl_cbf_aux aux
		        inner join sc_cad.tbl_cun cun on cun.nr_cpf_cnpj_cun = aux.nr_cpf_cnpj_cbf
		where aux.dt_grc_cbf is null loop
     select count(*)
       into vl_existe
     from sc_cad.tbl_cbf 
     where cd_cun = rg.cd_cun
       and cd_inc_usr = 1
       and pc_dps_cbf = 100;

     if vl_existe > 0 then
       update sc_cad.tbl_cbf 
          set fg_atv_cbf = 'N' 
       where cd_cun = rg.cd_cun
         and cd_inc_usr = 1
         and pc_dps_cbf = 100;
     end if;
     
     select nextval('sc_cad.sq_cbf') into vl_conta_bancaria;

     insert into sc_cad.tbl_cbf (cd_cbf,cd_bnc,nr_agc_cbf,nr_dgt_agc_cbf,nr_cba_cbf,nr_dgt_cba_cbf,tp_cba_cbf,fg_atv_cbf,nr_cpf_cnpj_cbf,tp_pss_cbf,nm_cbf,pc_dps_cbf,cd_inc_usr,dt_inc_usr,cd_cun)
                      values (vl_conta_bancaria,rg.cd_bnc,rg.nr_agc_cbf,coalesce(rg.nr_dgt_agc_cbf,''),rg.nr_cba_cbf,rg.nr_dgt_cba_cbf,rg.tp_cba_cbf,'S',rg.nr_cpf_cnpj_cun,rg.tp_pss_cun,rg.nm_cun,100,1,now(),rg.cd_cun);

     update sc__buxo.tbl_cbf_aux 
        set cd_cbf = vl_conta_bancaria,
            dt_grc_cbf = now()
     where cd_cbf_aux = rg.cd_cbf_aux;
  end loop;
  
end;$$;


ALTER FUNCTION sc__buxo.cadastrar_conta_bancaria() OWNER TO scan;

--
-- TOC entry 1759 (class 1255 OID 563944)
-- Name: cadastrar_transferencia_bancaria(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION cadastrar_transferencia_bancaria() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  vl_valor_tarifa numeric := 0;
  vl_valor_transferencia numeric := 0;

begin
   for rg in select fnc.cd_emp, fnc.cd_fem, crt.cd_crt, cun.nm_cun, cun.nr_cpf_cnpj_cun, cnt.vl_sld_cnt, fnc.cd_fnc, cbf.*
		from sc_opr.tbl_crt crt
		        inner join sc_srv.tbl_tsc tsc on tsc.cd_crt = crt.cd_crt 
			inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
			inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt
			inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cc.cd_cnt
			inner join sc_cad.tbl_cbf cbf on cbf.cd_cun = fnc.cd_cun
			inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
		where tsc.dt_inc_usr in ('2017-12-04 13:02:39.215','2017-12-04 13:03:32.012') and tsc.st_tsc = 3
		order by cun.nm_cun
  loop
     vl_valor_transferencia := rg.vl_sld_cnt - vl_valor_tarifa;
     perform sc_atb.transferencia_bancaria(rg.cd_bnc, rg.nr_agc_cbf, rg.nr_dgt_agc_cbf, rg.nr_cba_cbf, rg.nr_dgt_cba_cbf, rg.tp_cba_cbf, 
				vl_valor_transferencia, rg.cd_fnc, 'TRANSFERENCIA AUTOMATICA'::varchar, 1, now()::timestamp with time zone);
  end loop;
  
end;$$;


ALTER FUNCTION sc__buxo.cadastrar_transferencia_bancaria() OWNER TO scan;

--
-- TOC entry 1071 (class 1255 OID 563945)
-- Name: carga_inicial_saque_arredondado(date, date); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION carga_inicial_saque_arredondado(vp_data_inicio date, vp_data_fim date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

vl_data date;

begin

vl_data := vp_data_inicio;

while vl_data <= vp_data_fim loop

  perform sc_srv.cobrar_servico_saque_arredondado(vl_data);
  vl_data := vl_data + interval '1 day';

end loop;


end;$$;


ALTER FUNCTION sc__buxo.carga_inicial_saque_arredondado(vp_data_inicio date, vp_data_fim date) OWNER TO scan;

--
-- TOC entry 1075 (class 1255 OID 563946)
-- Name: carga_relatorio_divida_consolidada_funcionario(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION carga_relatorio_divida_consolidada_funcionario() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

  rg record;
  vl_fatura numeric;
  vl_parcela numeric;
  vl_tarifa_saq_arr numeric;
  vl_tarifa_outras numeric;
begin

  -- limpando a tabela de divida
  delete from sc__buxo.tbl_dvd;

  -- realizando a carga nos devidos cartões solicitados
  for rg in select * 
	    from sc_opr.tbl_crt 
	    where cd_crt in (62015585976818,62015597925751,62015569557324,62015533333937,62015540412575,
			     62015590183949,62015543570600,62015553315833,62015525637488)
	    order by cd_crt
  loop
    -- 1. SALDO DEVEDOR DA FATURA
    select vl_sld_dvd_fcr
      into vl_fatura
    from sc_fcr.tbl_fcr fcr 
	 inner join sc_opr.tbl_crt crt on crt.cd_fcr = fcr.cd_fcr
    where crt.cd_crt = rg.cd_crt
      and fcr.st_fcr = 1;

    -- 2. PARCELAS A VENCER
    select sum(vl_prc)
      into vl_parcela
    from sc_fcr.tbl_prc prc
    where prc.cd_crt = rg.cd_crt
      and prc.st_prc = 1
      and prc.fg_dcr_prc = 'D';

    -- 3. TARIFAS DE SAQUE ARREDONDADO EM ABERTO
    select sum(vl_tsc)
      into vl_tarifa_saq_arr
    from sc_srv.tbl_tsc tsc
    where tsc.cd_crt = rg.cd_crt
      and tsc.st_tsc = 1
      and tsc.cd_srv = 6;

    -- 4. OUTRAS TARIFAS EM ABERTO
    select sum(vl_tsc)
      into vl_tarifa_outras
    from sc_srv.tbl_tsc tsc
    where tsc.cd_crt = rg.cd_crt
      and tsc.st_tsc = 1
      and tsc.cd_srv not in (6);


    insert into sc__buxo.tbl_dvd values (nextval('sc__buxo.sq_dvd'), rg.cd_crt, COALESCE(vl_fatura, 0), COALESCE(vl_parcela, 0), COALESCE(vl_tarifa_saq_arr, 0), COALESCE(vl_tarifa_outras, 0));
    
  end loop;
end;$$;


ALTER FUNCTION sc__buxo.carga_relatorio_divida_consolidada_funcionario() OWNER TO scan;

--
-- TOC entry 1076 (class 1255 OID 563947)
-- Name: cobrar_liberacao_imediata(numeric, double precision, double precision, numeric); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION cobrar_liberacao_imediata(vp_cd_recebimento numeric, vp_valor_cobrado double precision, vp_valor_antecipado double precision, vp_forma_cobranca numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

vl_cod_conta_empresa numeric;

begin

end;$$;


ALTER FUNCTION sc__buxo.cobrar_liberacao_imediata(vp_cd_recebimento numeric, vp_valor_cobrado double precision, vp_valor_antecipado double precision, vp_forma_cobranca numeric) OWNER TO scan;

--
-- TOC entry 1077 (class 1255 OID 563948)
-- Name: cobrar_primeira_via_cartao_funcionario(numeric, date, boolean); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION cobrar_primeira_via_cartao_funcionario(vp_empresa numeric, vp_data_vencimento date, vp_gerar_fatura boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;

vl_cd_operacao numeric;
vl_valor_primeira_via numeric;

begin
for rg in 
	select fnc.cd_emp as empresa, pls.cd_pls as plastico, crt.cd_crt as cartao, crt.dt_prx_vnc_crt as data_vencimento
	from sc_opr.tbl_pls pls
		inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
		inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	where fnc.cd_emp = vp_empresa
	  and pls.fg_blq_pls = 'N'
	  and crt.fg_atv_crt = 'S'
	  and not exists (select 1 from sc_opr.tbl_opr opr where opr.cd_pls = pls.cd_pls and opr.cd_top = 10)
	
loop
   -- codigo da operacao
   select nextval('sc_opr.sq_opr') into vl_cd_operacao;

   -- valor da primeira via
   select replace(replace(pc.vl_pce_ctr, '.', ''), ',', '.') into strict vl_valor_primeira_via
   from sc_cad.tbl_ctr ctr
	inner join sc_cad.tbl_pce_ctr pc on pc.cd_ctr = ctr.cd_ctr
   where pc.cd_pce = 8
     and ctr.cd_emp = vp_empresa
     and ctr.fg_atv_ctr = 'S'; 

   -- gerando a operacao de PRIMEIRA VIA
   INSERT INTO sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, vl_trf_opr, 
			    nr_prc_opr, vl_prc_opr, vl_iof_opr, nr_nsu_org_opr, st_opr, st_saq_opr, 
			    dt_prc_opr, cd_pai_opr, tp_err_exp_opr, cd_aeo)
		VALUES (vl_cd_operacao, 10, rg.plastico, null, now(), vl_valor_primeira_via, 0, 0, 
			    1, vl_valor_primeira_via, 0, vl_cd_operacao, 2, null, 
			    now(), null, null, null);

  -- gerando a parcela
  insert into sc_fcr.tbl_prc(cd_prc,cd_crt,vl_prc,fg_dcr_prc,st_prc,cd_opr,ds_prc,dt_grc_prc,dt_vnc_prc,nr_prc)
	values(nextval('sc_fcr.sq_prc'),rg.cartao,vl_valor_primeira_via,'D',1,vl_cd_operacao,'PRIMEIRA VIA CARTAO',now(),vp_data_vencimento,1);

  -- verificando se deve gerar fatura
  if vp_gerar_fatura then
    perform sc_fcr.gerar_fatura_cartao(rg.cartao, vp_data_vencimento, vp_data_vencimento, false, false);
  end if;

end loop;

end;$$;


ALTER FUNCTION sc__buxo.cobrar_primeira_via_cartao_funcionario(vp_empresa numeric, vp_data_vencimento date, vp_gerar_fatura boolean) OWNER TO scan;

--
-- TOC entry 7501 (class 0 OID 0)
-- Dependencies: 1077
-- Name: FUNCTION cobrar_primeira_via_cartao_funcionario(vp_empresa numeric, vp_data_vencimento date, vp_gerar_fatura boolean); Type: COMMENT; Schema: sc__buxo; Owner: scan
--

COMMENT ON FUNCTION cobrar_primeira_via_cartao_funcionario(vp_empresa numeric, vp_data_vencimento date, vp_gerar_fatura boolean) IS 'rotina que gera operacao, parcela e fatura para os cartoes que foram desbloqueados e nao foram cobrados';


--
-- TOC entry 1078 (class 1255 OID 563949)
-- Name: correcao(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION correcao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;

begin
for rg in 
	select ocr.cd_ocr as ocorrencia, crt.cd_crt as cartao
	from sc_opr.tbl_ocr ocr
		inner join sc_opr.tbl_crt crt on crt.cd_crt = ocr.cd_crt
		inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
		inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
		inner join sc_cad.tbl_fem fem on fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
	where ocr.cd_toc = 6
	  and ocr.dt_inc_usr > now() - interval '1 hour'
	  and ocr.cd_inc_usr = 1 
loop
   update sc_opr.tbl_crt set fg_atv_crt = 'S' where cd_crt = rg.cartao;

   delete from sc_opr.tbl_ocr where cd_ocr = rg.ocorrencia;
end loop;

end;$$;


ALTER FUNCTION sc__buxo.correcao() OWNER TO scan;

--
-- TOC entry 1080 (class 1255 OID 563950)
-- Name: corrige_contra_partida_lancamento_saque_arredondado(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION corrige_contra_partida_lancamento_saque_arredondado() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

vl_cod_lancto_1 numeric;
vl_cod_lancto_3 numeric;

vl_valor_lancto_1 numeric(13,2);
vl_valor_lancto_3 numeric(13,2);

rg record;

begin


  for rg in
    select * from sc_cnt.tbl_lcn where cd_cnt = 13 and cd_tlc = 174 and cd_ctp_lcn is null order by cd_lcn
  loop
    
    -- obtendo o lancamento 1
    vl_cod_lancto_1 := rg.cd_lcn - 1;

    select cd_lcn, vl_lcn 
      into vl_cod_lancto_1,vl_valor_lancto_1
    from sc_cnt.tbl_lcn
      where cd_lcn < rg.cd_lcn 
        and cd_sst = 15
        and nsu_lcn = rg.nsu_lcn; 

    -- obtendo o lancamento 3
    select cd_lcn, vl_lcn 
      into vl_cod_lancto_3,vl_valor_lancto_3
    from sc_cnt.tbl_lcn
      where cd_lcn > rg.cd_lcn 
        and cd_sst = 15
        and nsu_lcn = rg.nsu_lcn;   


   vl_valor_lancto_1 := vl_valor_lancto_1 - rg.vl_lcn::numeric(13,2);
   vl_valor_lancto_1 := vl_valor_lancto_1 - vl_valor_lancto_3;

    -- validando os lancamentos
    if vl_valor_lancto_1 = 0 then

        raise notice 'entrou aqui';

        -- atualizando o lancamento de contra partida correta
        update sc_cnt.tbl_lcn set cd_ctp_lcn = null where cd_lcn = vl_cod_lancto_1;
        update sc_cnt.tbl_lcn set cd_ctp_lcn = vl_cod_lancto_1 where cd_lcn in (rg.cd_lcn,vl_cod_lancto_3);

    end if;

  end loop;


end;$$;


ALTER FUNCTION sc__buxo.corrige_contra_partida_lancamento_saque_arredondado() OWNER TO scan;

--
-- TOC entry 1081 (class 1255 OID 563951)
-- Name: corrige_erro_arquivo(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION corrige_erro_arquivo() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;

begin

  for rg in 
    select tba.*
    from sc_atb.tbl_tba tba
      inner join sc_cad.tbl_cun cun on cun.nr_cpf_cnpj_cun = tba.nr_cpf_cnpj_tba
      inner join sc_cad.tbl_fnc fnc on fnc.cd_cun = cun.cd_cun
      inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
      inner join sc_adp.tbl_rdp rdp on rdp.cd_crt = crt.cd_crt
    where rdp.cd_hfe = 14623
      and tba.dt_inc_usr >= '2013-04-15 14:42:40.597'
    order by tba.cd_tba 
  loop


  perform sc_cnt.lancar_debito_credito(5751, rg.cd_dbt_cnt, 92, null, 'ERRO DEPOSITO ARQUIVO NSU 14623. ARQUIVO DEPOSITADO 3 VEZES.', rg.vl_tba, now()::timestamp without time zone, 1, 11, rg.cd_tba);

  update sc_atb.tbl_tba 
    set st_tba = 3, 
        ds_mtv_cnc_tba = 'CANCELAMENTO AUTOMATICO. ERRO DEPOSITO ARQUIVO NSU 14623', 
        cd_cnc_usr = 1, 
        dt_cnc_usr = now() 
    where cd_tba = rg.cd_tba;

 end loop;   

end;$$;


ALTER FUNCTION sc__buxo.corrige_erro_arquivo() OWNER TO scan;

--
-- TOC entry 1510 (class 1255 OID 852278)
-- Name: corrigir_cartoes_vinculados_contrato_inativo(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION corrigir_cartoes_vinculados_contrato_inativo() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;

  vl_contrato_new numeric;
  vl_empresa numeric := 0;
  vl_filial numeric := 0;
  vl_qtde numeric:= 0;
begin
  for rg in select distinct fnc.cd_emp, fnc.cd_fem, crt.cd_ctr as contrato_old
	    from sc_opr.tbl_crt crt
		inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	    where fg_atv_crt = 'S' 
	      and cd_ctr in (select cd_ctr from sc_cad.tbl_ctr where fg_atv_ctr = 'N')
	    order by cd_emp
  loop

    if vl_empresa != rg.cd_emp or vl_filial != rg.cd_fem then

       vl_empresa := rg.cd_emp;
       vl_filial := rg.cd_fem;
       
      -- capturando o novo contrato do cartao, caso exista
      select count(distinct ctr.cd_ctr)
        into vl_qtde
      from sc_cad.tbl_ctr ctr
	inner join sc_cad.tbl_fem_ctr fc on fc.cd_ctr = ctr.cd_ctr
      where ctr.cd_emp = rg.cd_emp 
        and fc.cd_fem = rg.cd_fem
        and ctr.fg_atv_ctr = 'S'
        and fc.fg_atv_fem_ctr = 'S';

      if vl_qtde > 0 then  
        select distinct ctr.cd_ctr
	  into vl_contrato_new
        from sc_cad.tbl_ctr ctr
	  inner join sc_cad.tbl_fem_ctr fc on fc.cd_ctr = ctr.cd_ctr
        where ctr.cd_emp = rg.cd_emp 
	  and fc.cd_fem = rg.cd_fem
	  and ctr.fg_atv_ctr = 'S'
	  and fc.fg_atv_fem_ctr = 'S';

         -- caso queira atualizar todos os cartões de uma só vez
	update sc_opr.tbl_crt set cd_ctr = vl_contrato_new where cd_ctr = rg.contrato_old;  
       end if;
    end if;
    
    -- gravando na tabela para verificar a alteração
    /*
    insert into sc_opr.tbl_crt_aux (cd_crt, cd_ctr_old, cd_ctr_new) values (rg.cd_crt, rg.contrato_old, vl_contrato_new);
    */
  end loop;

end;$$;


ALTER FUNCTION sc__buxo.corrigir_cartoes_vinculados_contrato_inativo() OWNER TO scan;

--
-- TOC entry 1082 (class 1255 OID 563952)
-- Name: desfaz_operacao(numeric); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION desfaz_operacao(vp_operacao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

  vl_conta  numeric;
begin

   update sc_opr.tbl_opr set st_opr = 4 where cd_opr = vp_operacao; -- marcando para desfeita

   select cc.cd_cnt 
     into vl_conta
   from sc_opr.tbl_opr opr
	inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
	inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
	inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and fg_pdr_cnt_crt = 'S'
   where cd_opr = vp_operacao; 
   
   update sc_cnt.tbl_tbc_cnt set vl_blq_tbc_cnt = 0 where cd_cnt = vl_conta and cd_tbc = 4; -- zerando o valor bloqueado

end;$$;


ALTER FUNCTION sc__buxo.desfaz_operacao(vp_operacao numeric) OWNER TO scan;

--
-- TOC entry 1635 (class 1255 OID 932194)
-- Name: estorna_baixa_saque_arredondado(numeric, numeric, character varying); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION estorna_baixa_saque_arredondado(vp_codigo_tarifa_servico numeric, vp_usuario numeric, vp_motivo character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

ct_st_cadastrado numeric := 1;
ct_st_cobrado numeric := 2;

ct_cd_conta_saque_arredondado numeric := 13;
ct_lanc_estorno_tarifa_saque_arredondado numeric := 178;

ct_cd_srv_servico_saque_arredondado numeric := 6;


vl_nr_lanc_credito numeric;
vl_nr_lanc_debito numeric;
vl_tipo_lancamento_estorno numeric;
vl_conta_cartao numeric := 0;
vl_conta_receita numeric;
vl_valor_servico numeric;
vl_valor_tarifa_servico numeric;
vl_motivo varchar;

begin

   select cc.cd_cnt, tsc.vl_tsc, tlc.cd_est_tlc, opr.vl_trf_opr, srv.cd_cnt
     into vl_conta_cartao, vl_valor_servico, vl_tipo_lancamento_estorno, vl_valor_tarifa_servico, vl_conta_receita
   from sc_srv.tbl_tsc tsc
     inner join sc_srv.tbl_srv srv on srv.cd_srv = tsc.cd_srv
     inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
     inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and cc.fg_pdr_cnt_crt = 'S'
     inner join sc_opr.tbl_opr opr on opr.cd_opr = tsc.cd_opr 
     inner join sc_cnt.tbl_tlc tlc on tlc.cd_tlc = srv.cd_tlc
   where tsc.cd_tsc = vp_codigo_tarifa_servico
     and tsc.cd_srv = ct_cd_srv_servico_saque_arredondado
     and tsc.st_tsc = ct_st_cobrado;

   if vl_conta_cartao > 0 then

           -- cancelando contabilizacao da baixa 
           perform sc_cnt.lancar_debito_credito(ct_cd_conta_saque_arredondado, vl_conta_cartao, vl_tipo_lancamento_estorno, null, 
           vp_motivo, vl_valor_servico, now()::timestamp, vp_usuario, 15, vp_codigo_tarifa_servico);

           -- retornando servico para cadastrado
           update sc_srv.tbl_tsc set st_tsc = ct_st_cadastrado, dt_pgto_tsc = null where cd_tsc = vp_codigo_tarifa_servico;

   else
     raise exception 'Não foi possível efetuar o estorno. Motivo: tarifa de serviço código % não existe', vp_codigo_tarifa_servico;
   end if;

end;$$;


ALTER FUNCTION sc__buxo.estorna_baixa_saque_arredondado(vp_codigo_tarifa_servico numeric, vp_usuario numeric, vp_motivo character varying) OWNER TO scan;

--
-- TOC entry 1079 (class 1255 OID 563954)
-- Name: estorna_credito_saque_arredondado(numeric, date); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION estorna_credito_saque_arredondado(vp_cartao numeric, vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

ct_st_cadastrado numeric := 1;
ct_st_cobrado numeric := 2;

ct_cd_conta_saque_arredondado numeric := 13;

ct_cd_srv_servico_saque_arredondado numeric := 6;


vl_conta_cartao numeric := 0;
vl_valor_operacao numeric := 0;
vl_codigo_operacao numeric := 0;
vl_qtde numeric := 0;

begin

    select opr.cd_opr, opr.vl_opr - 0.99
      into vl_codigo_operacao, vl_valor_operacao
    from sc_opr.tbl_opr opr
	inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
    where pls.cd_crt = vp_cartao
      and cd_top = 19
      and dt_opr::date = vp_data
      and st_opr = 2; -- confirmada
      
      if vl_codigo_operacao > 0 then

	   -- cancelando a tarifa, caso tenha gerado
           select count(*) 
             into vl_qtde
           from sc_srv.tbl_tsc tsc
           where cd_crt = vp_cartao
	     and cd_opr = vl_codigo_operacao
             and cd_srv = 6 
             and st_tsc = 1;
           
           if vl_qtde > 0 then
             update sc_srv.tbl_tsc tsc
                set st_tsc = 3 -- cancelando
             where cd_crt = vp_cartao
               and cd_opr = vl_codigo_operacao
               and cd_srv = 6 
               and st_tsc = 1;
           end if;

	   -- cancelando a operacao gerada
	   update sc_opr.tbl_opr 
	      set st_opr = 3
	   where cd_opr = vl_codigo_operacao;
           
           -- obtendo da conta do cartao
           select cd_cnt
             into vl_conta_cartao
           from sc_opr.tbl_cnt_crt
           where cd_crt = vp_cartao
             and fg_pdr_cnt_crt = 'S';

           -- debitando a conta do cartao e creditando a conta de SAQUE ARREDONDADO com o valor "emprestado"
	   perform sc_cnt.lancar_debito_credito(vl_conta_cartao, ct_cd_conta_saque_arredondado, 171, 'ESTORNO SAQUE ARREDONDADO', 'ESTORNO SAQUE ARREDONDADO', vl_valor_operacao, now()::timestamp, 1, 7, vl_codigo_operacao);

   else
     raise exception 'Não foi possível efetuar o estorno. Motivo: Não foi encontrado nenhuma operação para este cartão neste dia informado.';
   end if;

end;$$;


ALTER FUNCTION sc__buxo.estorna_credito_saque_arredondado(vp_cartao numeric, vp_data date) OWNER TO scan;

--
-- TOC entry 1083 (class 1255 OID 563955)
-- Name: estorna_fatura_pago_principal(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION estorna_fatura_pago_principal() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;

begin

for rg in select crt.cd_crt, vl_sld_dvd_fcr, dt_vnc_fcr
 from sc_cci.tbl_cci cci
   inner join sc_opr.tbl_crt crt on cci.cd_crt = crt.cd_crt
   inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
 where cci.fg_atv_cci  = 'S'
  and crt.fg_ind_crt = 'S'
  and fcr.vl_sld_dvd_fcr - fcr.vl_rst_enc_fcr = 0
  and fcr.vl_sld_dvd_fcr > 0
  and fcr.st_fcr = 1
 order by fcr.vl_sld_dvd_fcr desc loop


   -- baixando saldo devedor por estorno
   perform sc_fcr.contabilizar_baixar_cartao(rg.cd_crt, rg.vl_sld_dvd_fcr, 4, rg.dt_vnc_fcr::timestamp without time zone, 1, null);


 end loop;

end;$$;


ALTER FUNCTION sc__buxo.estorna_fatura_pago_principal() OWNER TO scan;

--
-- TOC entry 1877 (class 1255 OID 1657045)
-- Name: estornar_tarifa_saque_que_deveriam_ser_abonadas(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION estornar_tarifa_saque_que_deveriam_ser_abonadas() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;

  vl_qtde_estornados integer := 0;
  vl_cartao_anterior numeric := 0;
  CT_TIPO_LANCAMENTO_ESTORNO constant numeric := 186;

  vl_nr_lanc_debito sc_cnt.tbl_lcn.cd_lcn%type;
  vl_nr_lanc_credito sc_cnt.tbl_lcn.cd_lcn%type;
begin
  for vl_rg in select lcn_dbt.cd_lcn as nr_lanc_dbt, lcn_crd.cd_lcn as nr_lanc_crd, 
                      lcn_dbt.cd_cnt as conta_debito, lcn_crd.cd_cnt as conta_credito, 
                      crt.cd_crt as cartao,
                      'ESTORNO REALIZADO PELO ROTINA sc__buxo.estornar_tarifa_saque_que_deveriam_ser_abonadas'::character varying as complemento,
                      lcn_dbt.vl_lcn::double precision as valor, lcn_dbt.cd_inc_usr as usuario, lcn_dbt.cd_sst as sistema, lcn_dbt.nsu_lcn as nsu,
                      sc_cad.get_parametro_contrato_cartao(28, crt.cd_crt)::integer as qtde_abonada, lcn_dbt.cd_est_lcn as nr_lanc_estorno
               from sc_opr.tbl_crt crt
                    inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
                    inner join sc_cnt.tbl_cnt cnt on cnt_crt.cd_cnt = cnt.cd_cnt
                    inner join sc_cnt.tbl_lcn lcn_dbt on cnt.cd_cnt = lcn_dbt.cd_cnt
                    inner join sc_cnt.tbl_lcn lcn_crd on lcn_dbt.cd_ctp_lcn = lcn_crd.cd_lcn
                    inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
                    inner join sc_cad.tbl_cun cun on fnc.cd_cun = cun.cd_cun
               where lcn_dbt.dt_ref_lcn >= '2019-08-01'
                 and lcn_dbt.cd_tlc = 187
                 and lcn_crd.cd_cnt = 467
                 and fnc.cd_emp in (367, 368, 372, 370, 367)
                 --and crt.cd_crt = 62015587396176
                 --and cun.nr_cpf_cnpj_cun = 44874510353
                 and sc_cad.get_parametro_contrato_cartao(28, crt.cd_crt) <> '0'
               order by cartao, coalesce(lcn_dbt.cd_est_lcn, 0) desc loop
    if vl_cartao_anterior <> vl_rg.cartao then
      vl_qtde_estornados := 0;
    end if;

    if vl_qtde_estornados < vl_rg.qtde_abonada and vl_rg.nr_lanc_estorno is null then
      raise notice 'abonando cartão: % pela % vez', vl_rg.cartao, vl_qtde_estornados + 1;
      select nextval('SC_CNT.SQ_LCN')
      into vl_nr_lanc_debito;

      update sc_cnt.tbl_lcn set cd_est_lcn = vl_nr_lanc_debito where cd_lcn = vl_rg.nr_lanc_crd;

      select nextval('SC_CNT.SQ_LCN')
      into vl_nr_lanc_credito;

      update sc_cnt.tbl_lcn set cd_est_lcn = vl_nr_lanc_credito where cd_lcn = vl_rg.nr_lanc_dbt;

      perform sc_cnt.lancar_movimento(vl_nr_lanc_debito, vl_nr_lanc_credito, CT_TIPO_LANCAMENTO_ESTORNO, vl_rg.conta_credito, 'D'::character, vl_rg.valor, now()::timestamp without time zone, vl_rg.usuario, null::character varying, vl_rg.complemento, vl_rg.sistema, vl_rg.nsu);

      perform sc_cnt.lancar_movimento(vl_nr_lanc_credito, vl_nr_lanc_debito, CT_TIPO_LANCAMENTO_ESTORNO, vl_rg.conta_debito, 'C'::character, vl_rg.valor, now()::timestamp without time zone, vl_rg.usuario, null::character varying, vl_rg.complemento, vl_rg.sistema, vl_rg.nsu);
    else
      if vl_rg.nr_lanc_estorno is not null then
        raise notice 'lancamento já foi estornado';
      else
        raise notice 'cartão % já foi abonado: % vezes, não deve ser abonado pela % vez', vl_rg.cartao, vl_rg.qtde_abonada, vl_qtde_estornados + 1;
      end if;
    end if;
    vl_qtde_estornados := vl_qtde_estornados + 1;
    vl_cartao_anterior := vl_rg.cartao;
  end loop;               
end;$$;


ALTER FUNCTION sc__buxo.estornar_tarifa_saque_que_deveriam_ser_abonadas() OWNER TO scan;

--
-- TOC entry 1866 (class 1255 OID 1657042)
-- Name: estornar_tarifa_ted_que_deveriam_ser_abonadas(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION estornar_tarifa_ted_que_deveriam_ser_abonadas() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;

  vl_qtde_estornados integer := 0;
  vl_cartao_anterior numeric := 0;
  CT_TIPO_LANCAMENTO_ESTORNO constant numeric := 92;

  vl_nr_lanc_debito sc_cnt.tbl_lcn.cd_lcn%type;
  vl_nr_lanc_credito sc_cnt.tbl_lcn.cd_lcn%type;
begin
  for vl_rg in select lcn_dbt.cd_lcn as nr_lanc_dbt, lcn_crd.cd_lcn as nr_lanc_crd, 
                      lcn_dbt.cd_cnt as conta_debito, lcn_crd.cd_cnt as conta_credito, 
                      crt.cd_crt as cartao,
                      'ESTORNO REALIZADO PELO ROTINA sc__buxo.estornar_tarifa_ted_que_deveriam_ser_abonadas'::character varying as complemento,
                      lcn_dbt.vl_lcn::double precision as valor, lcn_dbt.cd_inc_usr as usuario, lcn_dbt.cd_sst as sistema, lcn_dbt.nsu_lcn as nsu,
                      sc_cad.get_parametro_contrato_cartao(30, crt.cd_crt)::integer as qtde_abonada, lcn_dbt.cd_est_lcn as nr_lanc_estorno
               from sc_opr.tbl_crt crt
                    inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
                    inner join sc_cnt.tbl_cnt cnt on cnt_crt.cd_cnt = cnt.cd_cnt
                    inner join sc_cnt.tbl_lcn lcn_dbt on cnt.cd_cnt = lcn_dbt.cd_cnt
                    inner join sc_cnt.tbl_lcn lcn_crd on lcn_dbt.cd_ctp_lcn = lcn_crd.cd_lcn
                    inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
                    inner join sc_cad.tbl_cun cun on fnc.cd_cun = cun.cd_cun
               where lcn_dbt.dt_ref_lcn >= '2019-08-01'
                 and lcn_dbt.cd_tlc = 93
                 and lcn_crd.cd_cnt = 468
                 and fnc.cd_emp = 366
                 --and cun.nr_cpf_cnpj_cun = 37015109387
                 and sc_cad.get_parametro_contrato_cartao(30, crt.cd_crt) <> '0'
               order by cartao, coalesce(lcn_dbt.cd_est_lcn, 0) desc loop
    if vl_cartao_anterior <> vl_rg.cartao then
      vl_qtde_estornados := 0;
    end if;

    if vl_qtde_estornados < vl_rg.qtde_abonada and vl_rg.nr_lanc_estorno is null then
      raise notice 'abonando cartão: % pela % vez', vl_rg.cartao, vl_qtde_estornados + 1;
      select nextval('SC_CNT.SQ_LCN')
      into vl_nr_lanc_debito;

      update sc_cnt.tbl_lcn set cd_est_lcn = vl_nr_lanc_debito where cd_lcn = vl_rg.nr_lanc_crd;

      select nextval('SC_CNT.SQ_LCN')
      into vl_nr_lanc_credito;

      update sc_cnt.tbl_lcn set cd_est_lcn = vl_nr_lanc_credito where cd_lcn = vl_rg.nr_lanc_dbt;

      perform sc_cnt.lancar_movimento(vl_nr_lanc_debito, vl_nr_lanc_credito, CT_TIPO_LANCAMENTO_ESTORNO, vl_rg.conta_credito, 'D'::character, vl_rg.valor, now()::timestamp without time zone, vl_rg.usuario, null::character varying, vl_rg.complemento, vl_rg.sistema, vl_rg.nsu);

      perform sc_cnt.lancar_movimento(vl_nr_lanc_credito, vl_nr_lanc_debito, CT_TIPO_LANCAMENTO_ESTORNO, vl_rg.conta_debito, 'C'::character, vl_rg.valor, now()::timestamp without time zone, vl_rg.usuario, null::character varying, vl_rg.complemento, vl_rg.sistema, vl_rg.nsu);
    else
      if vl_rg.nr_lanc_estorno is not null then
        raise notice 'lancamento já foi estornado';
      else
        raise notice 'cartão já foi abonado: % vezes, não deve ser abonado pela % vez', vl_rg.qtde_abonada, vl_qtde_estornados + 1;
      end if;
    end if;
    vl_qtde_estornados := vl_qtde_estornados + 1;
    vl_cartao_anterior := vl_rg.cartao;
  end loop;               
end;$$;


ALTER FUNCTION sc__buxo.estornar_tarifa_ted_que_deveriam_ser_abonadas() OWNER TO scan;

--
-- TOC entry 1700 (class 1255 OID 1010444)
-- Name: exclui_cartao_somente_seguro(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION exclui_cartao_somente_seguro() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;
vl_codigo_conta numeric;

begin

  for rg in 
      select ssp.cd_ssp, ssp.st_ssp, pls.cd_pls, crt.cd_crt, fnc.cd_fnc, crt.cd_cnt
      from sc_opr.tbl_crt crt 
        inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc 
        inner join sc_opr.tbl_pls pls on pls.cd_crt = crt.cd_crt
        left join sc_ssp.tbl_ssp ssp on ssp.cd_pls = pls.cd_pls
	 where crt.dt_pri_dps_crt is null 
	       --and crt.cd_crt = 62015598116304
	       and fnc.cd_emp in (
               select distinct cd_emp 
               from sc_cad.tbl_emp emp 
               where cd_emp in 
                     (select cd_emp 
                       from sc_cad.tbl_ctr 
                      where cd_prd = 2) and not exists (select 1 from sc_adp.tbl_hfe where cd_emp = emp.cd_emp))
   loop


     -- se tiver gerado arquivo, delete o registro de detalhe do arquivo de emissão
     if rg.cd_ssp is not null then

       delete from sc_ssp.tbl_daep where cd_ssp = rg.cd_ssp;

       -- solicitacao
       delete from sc_ssp.tbl_ssp where cd_ssp = rg.cd_ssp;

     end if;

     -- arquivo de cadastro
     update sc_acc.tbl_rct set cd_pls = null, cd_crt = null where cd_pls = rg.cd_pls;
     
     -- plastico
     delete from sc_opr.tbl_pls where cd_pls = rg.cd_pls;

     -- excluindo a conta de debito
    select cd_cnt
      into vl_codigo_conta
    from sc_opr.tbl_cnt_crt where cd_crt = rg.cd_crt;   

    delete from sc_opr.tbl_cnt_crt where cd_crt = rg.cd_crt;

    delete from sc_cnt.tbl_cnt where cd_cnt = vl_codigo_conta;

    -- excluindo a conta de credito
    delete from sc_cnt.tbl_cnt where cd_cnt = rg.cd_cnt;
    
    -- excluindo a cobranca interna
    delete from sc_cci.tbl_cci where cd_crt = rg.cd_crt;

    -- exlcuindo o limite do cartao
    delete from sc_opr.tbl_lmt where cd_crt = rg.cd_crt;

     -- ocorrencia do cartao
     delete from sc_opr.tbl_ocr where cd_crt = rg.cd_crt;

     -- rescisao
     delete from sc_rsc.tbl_rsc where cd_crt = rg.cd_crt;
     
     -- cartao
     insert into sc_opr.tbl_crt_exc(select crt.*,now(),2,'CONTRATO SOMENTE DE SEGURO' from sc_opr.tbl_crt crt where crt.cd_crt = rg.cd_crt);
     delete from sc_opr.tbl_crt where cd_crt = rg.cd_crt;
               
  end loop;
  

end;$$;


ALTER FUNCTION sc__buxo.exclui_cartao_somente_seguro() OWNER TO scan;

--
-- TOC entry 1704 (class 1255 OID 1010575)
-- Name: exclui_contrato_somente_seguro(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION exclui_contrato_somente_seguro() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;
 
begin

  for rg in 
    select cd_ctr 
    from sc_cad.tbl_ctr ctr 
    where cd_prd = 2 
    and not exists  (select 1 from sc_opr.tbl_crt where cd_ctr = ctr.cd_ctr) 
    and not exists (select 1 from sc_fep.tbl_fep where cd_ctr = ctr.cd_ctr) loop

     -- deletanto as referencias de endereco
     delete from sc_cad.tbl_edr_ctr where cd_ctr = rg.cd_ctr; 

     -- deletando os registro de tipo de limite contrato
     delete from sc_cad.tbl_tlt_ctr where cd_fem_ctr in (select cd_fem_ctr from sc_cad.tbl_fem_ctr where cd_ctr = rg.cd_ctr);

     -- deletanto as referencias de filial de contrato
     delete from sc_cad.tbl_fem_ctr where cd_ctr = rg.cd_ctr; 

     -- deletanto as referencias de parametros de contrato
     delete from sc_cad.tbl_pce_ctr where cd_ctr = rg.cd_ctr; 
       
     -- deletando os contratos
     insert into sc_cad.tbl_ctr_exc(select ctr.*,now(),2,'CONTRATO SOMENTE DE SEGURO' from sc_cad.tbl_ctr ctr where ctr.cd_ctr = rg.cd_ctr);
     delete from sc_cad.tbl_ctr where cd_ctr = rg.cd_ctr;

  end loop;
  

end;$$;


ALTER FUNCTION sc__buxo.exclui_contrato_somente_seguro() OWNER TO scan;

--
-- TOC entry 1626 (class 1255 OID 948985)
-- Name: inclui_telefone(); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION inclui_telefone() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

  rg record;
  vl_cun numeric;
  vl_existe numeric;


begin

  for rg in select * from sc_cad.tbl_tlf_aux loop

     select coalesce(cd_cun,0) 
     into vl_cun
     from sc_cad.tbl_cun
     where nr_cpf_cnpj_cun = rg.cpf;

     if vl_cun > 0 then

         select count(cd_tlf)
         into vl_existe
         from sc_cad.tbl_tlf
         where nsu_org_tlf = vl_cun
           and tp_org_tlf = 1
           and tp_tlf = 2
           ANd nr_ddd_tlf = rg.ddd
           AND nr_tlf = rg.telefone;

          if vl_existe = 0 then
  
             if length(rg.telefone::varchar) = 8 then
                raise notice 'inclui telefone';
                insert into sc_cad.tbl_tlf values (nextval('sc_cad.sq_tlf'),rg.ddd, rg.telefone,1,1,vl_cun,'S',1,null,now(),null,'N');
             else
                raise notice 'inclui celular';
                insert into sc_cad.tbl_tlf values (nextval('sc_cad.sq_tlf'),rg.ddd, rg.telefone,2,1,vl_cun,'S',1,null,now(),null,'N');
             end if;

          end if;   

     end if;

  end loop;
  

end;$$;


ALTER FUNCTION sc__buxo.inclui_telefone() OWNER TO scan;

--
-- TOC entry 1084 (class 1255 OID 563956)
-- Name: repetir_transferencia_bancaria_do_arquivo_cpg(numeric); Type: FUNCTION; Schema: sc__buxo; Owner: scan
--

CREATE FUNCTION repetir_transferencia_bancaria_do_arquivo_cpg(vp_cod_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin


  for rg in 
	select tba.*, fnc.cd_fnc
	from sc_atb.tbl_tba tba
	 inner join sc_atb.tbl_dtb dtb on dtb.cd_dtb = tba.cd_dtb
	 inner join sc_opr.tbl_cnt_crt cc on cc.cd_cnt = tba.cd_dbt_cnt
	 inner join sc_opr.tbl_crt crt on crt.cd_crt = cc.cd_crt
	 inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	where dtb.cd_atb = vp_cod_arquivo 
  loop

    perform sc_atb.transferencia_bancaria(rg.cd_bnc, rg.nr_agc_tba, rg.nr_dgt_agc_tba, rg.nr_cba_tba, rg.nr_dgt_cba_tba, rg.tp_cba_tba, rg.vl_tba, rg.cd_fnc, rg.ds_mtv_cad_tba, rg.cd_inc_usr, now()::timestamp with time zone);

  end loop;

end;$$;


ALTER FUNCTION sc__buxo.repetir_transferencia_bancaria_do_arquivo_cpg(vp_cod_arquivo numeric) OWNER TO scan;

SET search_path = sc_acc, pg_catalog;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- TOC entry 209 (class 1259 OID 563957)
-- Name: tbl_rct; Type: TABLE; Schema: sc_acc; Owner: scan
--

CREATE TABLE tbl_rct (
    cd_rct numeric(10,0) NOT NULL,
    tp_pss_rct character(1) NOT NULL,
    nr_cpf_cnpj_rct numeric(14,0) NOT NULL,
    cd_crt_emp_rct character(14) NOT NULL,
    nm_rct character varying(50) NOT NULL,
    rg_rct numeric(20,0),
    dt_nsc_rct date,
    nm_mae_rct character varying(50),
    eml_rct character varying(50),
    cd_crt numeric(16,0),
    st_rct numeric(2,0) DEFAULT 1 NOT NULL,
    st_prc_rct numeric(2,0),
    cd_hdr numeric(10,0) NOT NULL,
    cd_hfe numeric(10,0) NOT NULL,
    cd_pls numeric(16,0),
    fg_sex_rct character(1),
    dt_ems_rg_rct date,
    nm_org_ems_rg_rct character varying(20),
    uf_org_ems_rg_rct character varying(2),
    cd_est_rct numeric(2,0),
    ds_nat_rct character varying(50),
    ds_nac_rct character varying(20),
    dt_adm_rct date,
    CONSTRAINT ck_fg_sex_rct CHECK ((fg_sex_rct = ANY (ARRAY['F'::bpchar, 'M'::bpchar]))),
    CONSTRAINT ck_tp_pss_rct CHECK ((tp_pss_rct = ANY (ARRAY['F'::bpchar, 'J'::bpchar])))
);


ALTER TABLE tbl_rct OWNER TO scan;

--
-- TOC entry 7502 (class 0 OID 0)
-- Dependencies: 209
-- Name: TABLE tbl_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON TABLE tbl_rct IS 'TABELA DE REGISTRO DE CARTAO';


--
-- TOC entry 7503 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.cd_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.cd_rct IS 'CODIGO DO REGISTRO DE CARTAO';


--
-- TOC entry 7504 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.tp_pss_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.tp_pss_rct IS 'TIPO DE PESSOA. F - PESSOA FISICA; J - PESSOA JURIDICA';


--
-- TOC entry 7505 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.nr_cpf_cnpj_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.nr_cpf_cnpj_rct IS 'CPF (PF) OU CNPJ (PJ)';


--
-- TOC entry 7506 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.cd_crt_emp_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.cd_crt_emp_rct IS 'CODIGO DE IDENTIFICACAO DO CARTAO PARA A EMPRESA';


--
-- TOC entry 7507 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.nm_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.nm_rct IS 'NOME (PF) OU RAZAO SOCIAL (PJ)';


--
-- TOC entry 7508 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.rg_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.rg_rct IS 'RG (PF) OU INSCRICAO ESTADUAL (PJ)';


--
-- TOC entry 7509 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.dt_nsc_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.dt_nsc_rct IS 'DATA NASCIMENTO(PF) OU DATA DE REGISTRO (PJ)';


--
-- TOC entry 7510 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.nm_mae_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.nm_mae_rct IS 'NOME DA MAE. USADO APENAS PARA PESSOA FISICA';


--
-- TOC entry 7511 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.eml_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.eml_rct IS 'EMAIL';


--
-- TOC entry 7512 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.cd_crt; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.cd_crt IS 'CODIGO DO CARTAO GERADO';


--
-- TOC entry 7513 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.st_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.st_rct IS 'SITUACAO. VER TABELA DE DOMINIO';


--
-- TOC entry 7514 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.st_prc_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.st_prc_rct IS 'SITUACAO DE PROCESSAMENTO. VER TABELA DE DOMINIO.';


--
-- TOC entry 7515 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.cd_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.cd_hdr IS 'CODIGO DO HEADER DO ARQUIVO';


--
-- TOC entry 7516 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.cd_hfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.cd_hfe IS 'CODIGO DO HEADER DA FILIAL';


--
-- TOC entry 7517 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.dt_ems_rg_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.dt_ems_rg_rct IS 'data emissao rg';


--
-- TOC entry 7518 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.nm_org_ems_rg_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.nm_org_ems_rg_rct IS 'nome orgao emissor do rg';


--
-- TOC entry 7519 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.uf_org_ems_rg_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.uf_org_ems_rg_rct IS 'uf do orgao emissor do rg';


--
-- TOC entry 7520 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.cd_est_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.cd_est_rct IS 'estado civil do orgao emissor, dominio CD_EST_CIVIL_CPF';


--
-- TOC entry 7521 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.ds_nat_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.ds_nat_rct IS 'naturalidade';


--
-- TOC entry 7522 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.ds_nac_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.ds_nac_rct IS 'nacionalidade';


--
-- TOC entry 7523 (class 0 OID 0)
-- Dependencies: 209
-- Name: COLUMN tbl_rct.dt_adm_rct; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rct.dt_adm_rct IS 'DATA DE ADMISSÃO DO FUNCIONARIO';


--
-- TOC entry 1085 (class 1255 OID 563963)
-- Name: altera_cpf(tbl_rct, numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION altera_cpf(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_nr_rg numeric;
  vl_nome_mae character varying;
  vl_data_nascimento date;
  
  vl_flag_alteracao boolean := false;
begin
  select nr_rg_cpf, nm_mae_cpf, dt_nsc_cpf
  into vl_nr_rg, vl_nome_mae, vl_data_nascimento
  from sc_cad.tbl_cpf
  where cd_cun = vp_codigo_cun;

  if vl_nr_rg is null then
    update sc_cad.tbl_cpf
       set nr_rg_cpf = vp_dados_cartao.rg_rct
    where cd_cun = vp_codigo_cun;
    
    vl_flag_alteracao := true;
  end if;

  if vl_nome_mae is null then
    update sc_cad.tbl_cpf
       set nm_mae_cpf = vp_dados_cartao.nm_mae_rct
    where cd_cun = vp_codigo_cun;
    vl_flag_alteracao := true;
  end if;

  if vl_data_nascimento is null then
    update sc_cad.tbl_cpf
       set dt_nsc_cpf = vp_dados_cartao.dt_nsc_rct
    where cd_cun = vp_codigo_cun;
    vl_flag_alteracao := true;
  end if;
  
  if vl_flag_alteracao then
    update sc_cad.tbl_cun
       set cd_alt_usr = vp_codigo_usuario,
           dt_alt_usr = current_timestamp
    where cd_cun = vp_codigo_cun;
  end if;
end;$$;


ALTER FUNCTION sc_acc.altera_cpf(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) OWNER TO scan;

--
-- TOC entry 1086 (class 1255 OID 563964)
-- Name: altera_cpj(tbl_rct, numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION altera_cpj(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_inscricao_estadual numeric;
  vl_data_registro date;
  
  vl_flag_alteracao boolean := false;
begin
  select nr_ins_edl_cpj, dt_reg_cpj
  into vl_inscricao_estadual, vl_data_registro
  from sc_cad.tbl_cpj
  where cd_cun = vp_codigo_cun;

  if vl_inscricao_estadual is null then
    update sc_cad.tbl_cpj
       set nr_ins_edl_cpj = vp_dados_cartao.rg_rct
    where cd_cun = vp_codigo_cun;
    
    vl_flag_alteracao := true;
  end if;

  if vl_data_registro is null then
    update sc_cad.tbl_cpj
       set dt_reg_cpj = vp_dados_cartao.dt_nsc_rct
    where cd_cun = vp_codigo_cun;
    
    vl_flag_alteracao := true;
  end if;
  
  if vl_flag_alteracao then
    update sc_cad.tbl_cun
       set cd_alt_usr = vp_codigo_usuario,
           dt_alt_usr = current_timestamp
    where cd_cun = vp_codigo_cun;
    
    vl_flag_alteracao := true;
  end if;
end;$$;


ALTER FUNCTION sc_acc.altera_cpj(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) OWNER TO scan;

--
-- TOC entry 1087 (class 1255 OID 563965)
-- Name: altera_cun(tbl_rct, numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION altera_cun(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_email character varying;
  
  --tipos de pessoas
  ct_pessoa_juridica constant char := 'J';
  ct_pessoa_fisica constant char := 'F';
begin
  select eml_cun
  into vl_email
  from sc_cad.tbl_cun
  where cd_cun = vp_codigo_cun;
	
  if vl_email is null and sc_acc.valida_email(vp_dados_cartao.eml_rct) then
		update sc_cad.tbl_cun
		  set eml_cun = trim(vp_dados_cartao.eml_rct),
		      cd_alt_usr = vp_codigo_usuario,
		      dt_alt_usr = current_timestamp
		where cd_cun = vp_codigo_cun;
  end if;
  
  if vp_dados_cartao.tp_pss_rct = ct_pessoa_fisica then
    perform sc_acc.altera_cpf(vp_dados_cartao, vp_codigo_cun, vp_codigo_usuario);
  else
    perform sc_acc.altera_cpj(vp_dados_cartao, vp_codigo_cun, vp_codigo_usuario);
  end if;
end;
$$;


ALTER FUNCTION sc_acc.altera_cun(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) OWNER TO scan;

--
-- TOC entry 1088 (class 1255 OID 563966)
-- Name: atualiza_arquivo(numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION atualiza_arquivo(vp_codigo numeric, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  
begin
  -- 1. atualizando o codigo do usuario que importou o arquivo
  update sc_acc.tbl_hdr 
     set cd_rcb_usr = vp_usuario
  where cd_hdr = vp_codigo;
  
end;$$;


ALTER FUNCTION sc_acc.atualiza_arquivo(vp_codigo numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 7524 (class 0 OID 0)
-- Dependencies: 1088
-- Name: FUNCTION atualiza_arquivo(vp_codigo numeric, vp_usuario numeric); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION atualiza_arquivo(vp_codigo numeric, vp_usuario numeric) IS 'ROTINA QUE ATUALIZA OS DADOS DO ARQUIVO';


--
-- TOC entry 1089 (class 1255 OID 563967)
-- Name: cancelar_arquivo_processado(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION cancelar_arquivo_processado(vp_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
    rg record;
    --vp_arquivo numeric := 1735;
begin
   for rg in 
        select distinct crt.cd_crt as cartao, cc.cd_cnt as conta, fnc.cd_fnc as funcionario
        from sc_acc.tbl_hdr hdr
		inner join sc_acc.tbl_hfe hfe on hfe.cd_hdr = hdr.cd_hdr
		inner join sc_acc.tbl_rct rct on rct.cd_hfe = hfe.cd_hfe
		inner join sc_opr.tbl_crt crt on crt.cd_crt = rct.cd_crt
		inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc 
		inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt
        where hdr.cd_hdr = vp_arquivo
          and rct.st_rct = 3 -- VALIDADO
          and rct.st_prc_rct = 0 -- SUCESSO
   loop
     -- atualizando o registro de cartao
     update sc_acc.tbl_rct set cd_crt = null, cd_pls = null, st_rct = 4 where cd_hdr = vp_arquivo; 
     -- historico de alteracao empresa e filial
     delete from sc_cad.tbl_haef where cd_fnc = rg.funcionario;
     -- ocorrencia
     delete from sc_opr.tbl_ocr where cd_crt = rg.cartao;
     -- conta cartao
     delete from sc_opr.tbl_cnt_crt where cd_crt = rg.cartao;
     -- conta
     delete from sc_cnt.tbl_cnt where cd_cnt = rg.conta;
     -- limite
     delete from sc_opr.tbl_lmt where cd_crt = rg.cartao;
     -- solicitação
     delete from sc_ssp.tbl_ssp 
     where st_ssp in (1,3) -- cadastrada e cancelada
       and cd_pls in (select cd_pls from sc_opr.tbl_pls where cd_crt = rg.cartao);
     -- plastico
     delete from sc_opr.tbl_pls where cd_crt = rg.cartao;
     -- rescisão
     delete from sc_rsc.tbl_rsc where cd_crt = rg.cartao;
     -- cartao
     delete from sc_opr.tbl_crt where cd_crt = rg.cartao;
     -- funcionario
     delete from sc_cad.tbl_fnc where cd_fnc = rg.funcionario;     
   end loop;

   -- marcando o arquivo como invalido
   update sc_acc.tbl_hfe set st_hfe = 2 where cd_hfe = vp_arquivo;
   update sc_acc.tbl_hdr set st_hdr = 2 where cd_hdr = vp_arquivo;
   
END;
$$;


ALTER FUNCTION sc_acc.cancelar_arquivo_processado(vp_arquivo numeric) OWNER TO scan;

--
-- TOC entry 210 (class 1259 OID 563970)
-- Name: tbl_hfe; Type: TABLE; Schema: sc_acc; Owner: scan
--

CREATE TABLE tbl_hfe (
    cd_hfe numeric(10,0) NOT NULL,
    cd_hdr numeric(10,0) NOT NULL,
    cd_prd numeric(5,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    cd_fem numeric(5,0) NOT NULL,
    tp_pss_hfe character(1) NOT NULL,
    nr_cpf_cnpj_hfe numeric(14,0) NOT NULL,
    st_hfe numeric(2,0) DEFAULT 1 NOT NULL,
    st_prc_hfe numeric(2,0),
    CONSTRAINT ck_tp_pss_hfe CHECK ((tp_pss_hfe = ANY (ARRAY['F'::bpchar, 'J'::bpchar])))
);


ALTER TABLE tbl_hfe OWNER TO scan;

--
-- TOC entry 7525 (class 0 OID 0)
-- Dependencies: 210
-- Name: TABLE tbl_hfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON TABLE tbl_hfe IS 'TABELA DE HEADER DE FILIAL';


--
-- TOC entry 7526 (class 0 OID 0)
-- Dependencies: 210
-- Name: COLUMN tbl_hfe.cd_hfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_hfe IS 'CODIGO DO HEADER DE FILIAL';


--
-- TOC entry 7527 (class 0 OID 0)
-- Dependencies: 210
-- Name: COLUMN tbl_hfe.cd_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_hdr IS 'CODIGO DO HEADER DO ARQUIVO';


--
-- TOC entry 7528 (class 0 OID 0)
-- Dependencies: 210
-- Name: COLUMN tbl_hfe.cd_prd; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_prd IS 'CODIGO DO PRODUTO';


--
-- TOC entry 7529 (class 0 OID 0)
-- Dependencies: 210
-- Name: COLUMN tbl_hfe.cd_emp; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_emp IS 'CODIGO DA EMPRESA';


--
-- TOC entry 7530 (class 0 OID 0)
-- Dependencies: 210
-- Name: COLUMN tbl_hfe.cd_fem; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_fem IS 'CODIGO DA FILIAL';


--
-- TOC entry 7531 (class 0 OID 0)
-- Dependencies: 210
-- Name: COLUMN tbl_hfe.tp_pss_hfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.tp_pss_hfe IS 'TIPO DE PESSOA DO HEADER DE FILIAL';


--
-- TOC entry 7532 (class 0 OID 0)
-- Dependencies: 210
-- Name: COLUMN tbl_hfe.nr_cpf_cnpj_hfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.nr_cpf_cnpj_hfe IS 'NUMERO DO CPF/CNPJ DO HEADER DE FILIAL';


--
-- TOC entry 1717 (class 1255 OID 1010379)
-- Name: eh_pra_incluir_cartao(tbl_hfe); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION eh_pra_incluir_cartao(vp_dados_filial tbl_hfe) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  vl_existe numeric;
  
  ct_st_flag_ativo constant char := 'S';
begin
  select count(*)
  into vl_existe
  from sc_cad.tbl_ctr ctr
       inner join sc_cad.tbl_fem_ctr fem_ctr on ctr.cd_ctr = fem_ctr.cd_ctr
  where fem_ctr.cd_emp = vp_dados_filial.cd_emp
    and fem_ctr.cd_fem = vp_dados_filial.cd_fem
    and fem_ctr.fg_atv_fem_ctr = ct_st_flag_ativo
    and ctr.cd_prd = 1 -- PRODUTO SALARIO
    and ctr.fg_atv_ctr = ct_st_flag_ativo;

  return (vl_existe >= 1);
end;
$$;


ALTER FUNCTION sc_acc.eh_pra_incluir_cartao(vp_dados_filial tbl_hfe) OWNER TO scan;

--
-- TOC entry 7533 (class 0 OID 0)
-- Dependencies: 1717
-- Name: FUNCTION eh_pra_incluir_cartao(vp_dados_filial tbl_hfe); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION eh_pra_incluir_cartao(vp_dados_filial tbl_hfe) IS 'verifica se eh necessario a inclusao do cartao';


--
-- TOC entry 1090 (class 1255 OID 563968)
-- Name: existe_cadastro_unico(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION existe_cadastro_unico(vp_nr_cpf_cnpj numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  existe numeric;
begin
  select count(*)
  into existe
  from sc_cad.tbl_cun 
  where nr_cpf_cnpj_cun = vp_nr_cpf_cnpj;

  return (existe > 0);
end;
$$;


ALTER FUNCTION sc_acc.existe_cadastro_unico(vp_nr_cpf_cnpj numeric) OWNER TO scan;

--
-- TOC entry 7534 (class 0 OID 0)
-- Dependencies: 1090
-- Name: FUNCTION existe_cadastro_unico(vp_nr_cpf_cnpj numeric); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION existe_cadastro_unico(vp_nr_cpf_cnpj numeric) IS 'verifica se existe registro na tabela de cadastro unico com o numero de CPF/CNPJ passado como parametro';


--
-- TOC entry 1091 (class 1255 OID 563969)
-- Name: existe_cartao(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION existe_cartao(nr_cartao numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  existe numeric;
begin
  select count(*)
  into existe
  from sc_opr.tbl_crt 
  where cd_crt = nr_cartao;

  return (existe > 0);
end;
$$;


ALTER FUNCTION sc_acc.existe_cartao(nr_cartao numeric) OWNER TO scan;

--
-- TOC entry 7535 (class 0 OID 0)
-- Dependencies: 1091
-- Name: FUNCTION existe_cartao(nr_cartao numeric); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION existe_cartao(nr_cartao numeric) IS 'verifica se existe registro na tabela de cartao com o numero passado como parametro';


--
-- TOC entry 1712 (class 1255 OID 563975)
-- Name: existe_contrato(tbl_hfe); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION existe_contrato(vp_dados_filial tbl_hfe) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  vl_existe numeric;
  
  ct_st_flag_ativo constant char := 'S';
begin
  select count(*)
  into vl_existe
  from sc_cad.tbl_ctr ctr
       inner join sc_cad.tbl_fem_ctr fem_ctr on ctr.cd_ctr = fem_ctr.cd_ctr
  where fem_ctr.cd_emp = vp_dados_filial.cd_emp
    and fem_ctr.cd_fem = vp_dados_filial.cd_fem
    and fem_ctr.fg_atv_fem_ctr = ct_st_flag_ativo
    and ctr.cd_prd = 1 -- PRODUTO SALARIO
    and ctr.fg_atv_ctr = ct_st_flag_ativo;

  if vl_existe = 0 then
    -- EM CASO DO PRODUTO SEGURO
    select count(*)
    into vl_existe
    from sc_svg.tbl_csg csg
       inner join sc_svg.tbl_fem_csg fem_csg on csg.cd_csg = fem_csg.cd_csg
    where fem_csg.cd_emp =  vp_dados_filial.cd_emp
      and fem_csg.cd_fem = vp_dados_filial.cd_fem 
      and fem_csg.fg_atv_fem_csg = ct_st_flag_ativo
      and csg.fg_atv_csg = ct_st_flag_ativo;     
  end if;

  return (vl_existe = 1);
end;
$$;


ALTER FUNCTION sc_acc.existe_contrato(vp_dados_filial tbl_hfe) OWNER TO scan;

--
-- TOC entry 7536 (class 0 OID 0)
-- Dependencies: 1712
-- Name: FUNCTION existe_contrato(vp_dados_filial tbl_hfe); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION existe_contrato(vp_dados_filial tbl_hfe) IS 'verifica se existe registro na tabela de contrato para a empresa, filial e produto passado como parametro';


--
-- TOC entry 1092 (class 1255 OID 563976)
-- Name: existe_funcionario(tbl_hfe, tbl_rct); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION existe_funcionario(vp_dados_filial tbl_hfe, vp_dados_cartao tbl_rct) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  existe numeric;
  
  ct_st_fnc_ativo constant numeric := 1;
begin
  select count(*)
  into existe
  from sc_cad.tbl_fnc fnc
       inner join sc_cad.tbl_cun cun on fnc.cd_cun = cun.cd_cun
  where cun.nr_cpf_cnpj_cun = vp_dados_cartao.nr_cpf_cnpj_rct
    and fnc.cd_emp = vp_dados_filial.cd_emp
    and fnc.cd_fem = vp_dados_filial.cd_fem
    and fnc.st_fnc = ct_st_fnc_ativo
    and fnc.nr_idt_fnc = vp_dados_cartao.cd_crt_emp_rct;

  return (existe > 0);
end;
$$;


ALTER FUNCTION sc_acc.existe_funcionario(vp_dados_filial tbl_hfe, vp_dados_cartao tbl_rct) OWNER TO scan;

--
-- TOC entry 7537 (class 0 OID 0)
-- Dependencies: 1092
-- Name: FUNCTION existe_funcionario(vp_dados_filial tbl_hfe, vp_dados_cartao tbl_rct); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION existe_funcionario(vp_dados_filial tbl_hfe, vp_dados_cartao tbl_rct) IS 'verifica se existe registro na tabela de funcionario com o numero de CPF/CNPJ, empresa e filial passado como parametro';


--
-- TOC entry 1093 (class 1255 OID 563977)
-- Name: existe_plastico(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION existe_plastico(vp_numero_plastico numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
  existe numeric;
begin
  select count(*)
  into existe
  from sc_opr.tbl_pls
  where cd_pls = vp_numero_plastico;

  return (existe > 0);
end;
$$;


ALTER FUNCTION sc_acc.existe_plastico(vp_numero_plastico numeric) OWNER TO scan;

--
-- TOC entry 7538 (class 0 OID 0)
-- Dependencies: 1093
-- Name: FUNCTION existe_plastico(vp_numero_plastico numeric); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION existe_plastico(vp_numero_plastico numeric) IS 'verifica se existe registro na tabela de plastico com o numero passado como parametro';


--
-- TOC entry 1067 (class 1255 OID 563978)
-- Name: existe_plastico_operador(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION existe_plastico_operador(vp_cd_pop numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$declare
  existe numeric;
begin
  select count(*)
  into existe
  from sc_rds.tbl_pop 
  where cd_pop = vp_cd_pop;

  return (existe > 0);
end;
$$;


ALTER FUNCTION sc_acc.existe_plastico_operador(vp_cd_pop numeric) OWNER TO scan;

--
-- TOC entry 1094 (class 1255 OID 563979)
-- Name: gera_nome_cartao(character varying); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION gera_nome_cartao(vp_nome_cliente character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  vl_nome_plastico varchar;
  vl_indice integer := 0;
  vl_nr_nomes integer;
  
  vl_partes_nome varchar[10];

  vl_nome_cliente varchar;
begin
  vl_nome_cliente := trim(vp_nome_cliente);

  vl_nome_cliente := replace(vl_nome_cliente, ' DAS ', ' ');
  vl_nome_cliente := replace(vl_nome_cliente, ' DOS ', ' ');
  vl_nome_cliente := replace(vl_nome_cliente, ' DE ', ' ');
  vl_nome_cliente := replace(vl_nome_cliente, ' E ', ' ');
  vl_nome_cliente := replace(vl_nome_cliente, ' DI ', ' ');
  vl_nome_cliente := replace(vl_nome_cliente, ' DA ', ' ');
  vl_nome_cliente := replace(vl_nome_cliente, ' DO ', ' ');

  loop
    vl_nome_cliente := replace(vl_nome_cliente, '  ', ' ');
    exit when not (vl_nome_cliente similar to '%  %');
  end loop;

  loop
    vl_indice := vl_indice + 1;
    vl_partes_nome[vl_indice] := split_part(vl_nome_cliente, ' ', vl_indice);
    
    exit when split_part(vl_nome_cliente, ' ', vl_indice) = '';
  end loop;
  
  vl_nr_nomes := vl_indice - 1;
  for vl_indice IN 1..vl_nr_nomes loop
    if vl_indice not in (1, vl_nr_nomes) and length(vl_partes_nome[vl_indice]) > 3 then
      vl_partes_nome[vl_indice] := substring(vl_partes_nome[vl_indice], 1, 1);
    end if;
    if vl_indice = 1 then
      vl_nome_plastico := vl_partes_nome[vl_indice];
    else
      vl_nome_plastico := vl_nome_plastico || ' ' || vl_partes_nome[vl_indice];
    end if;
  end loop;

  vl_nome_plastico := sc_pbl.sem_acento(vl_nome_plastico);
  
  return upper(vl_nome_plastico);
end;
$$;


ALTER FUNCTION sc_acc.gera_nome_cartao(vp_nome_cliente character varying) OWNER TO scan;

--
-- TOC entry 7539 (class 0 OID 0)
-- Dependencies: 1094
-- Name: FUNCTION gera_nome_cartao(vp_nome_cliente character varying); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION gera_nome_cartao(vp_nome_cliente character varying) IS 'funcao que gera o nome do cartao a partir do nome do cliente';


--
-- TOC entry 1095 (class 1255 OID 563980)
-- Name: gera_numero_aleatorio(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION gera_numero_aleatorio(vp_numero_digitos numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_retorno numeric;
begin
  loop
    select round(cast (random()*power(10, vp_numero_digitos) as numeric),0)
    into vl_retorno;
  
    exit when vl_retorno >= power(10, vp_numero_digitos - 1) and vl_retorno < power(10, vp_numero_digitos);
  end loop;
  
  return vl_retorno;
end;$$;


ALTER FUNCTION sc_acc.gera_numero_aleatorio(vp_numero_digitos numeric) OWNER TO scan;

--
-- TOC entry 7540 (class 0 OID 0)
-- Dependencies: 1095
-- Name: FUNCTION gera_numero_aleatorio(vp_numero_digitos numeric); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION gera_numero_aleatorio(vp_numero_digitos numeric) IS 'funcao que gera um numero de aleatorio com a quantidade de digitos passados como parametro';


--
-- TOC entry 1096 (class 1255 OID 563981)
-- Name: gera_numero_cartao(); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION gera_numero_cartao() RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  bin numeric;
  numero_aleatorio numeric;
  sequencia numeric;
  numero_cartao numeric;
begin
  loop
    select cast (vl_prm as numeric)
    into bin
    from sc_cad.tbl_prm
    where nm_prm = 'BIN';

    select sc_acc.gera_numero_aleatorio(7)
    into numero_aleatorio;

    select nextval('sc_acc.sq_crt')
    into sequencia;

    numero_cartao := (bin * 100000000) + (numero_aleatorio * 10) + sequencia;
    exit when not sc_acc.existe_cartao(numero_cartao);
  end loop;

  return numero_cartao;
end;$$;


ALTER FUNCTION sc_acc.gera_numero_cartao() OWNER TO scan;

--
-- TOC entry 7541 (class 0 OID 0)
-- Dependencies: 1096
-- Name: FUNCTION gera_numero_cartao(); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION gera_numero_cartao() IS 'funcao que gera um numero de cartao que ainda nao foi cadastrado no banco de dados, obedecendo a seguinte regra de formacao: Bin (6 digitos) + Numero aleatorio (7 digitos) + Sequencia (1 digito)';


--
-- TOC entry 1604 (class 1255 OID 563982)
-- Name: gera_numero_plastico(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION gera_numero_plastico(vp_codigo_cartao numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_via numeric;
  vl_numero_plastico numeric;
  
  vl_cod_bin_cartao numeric;
  vl_bin_atual numeric;
  vl_codigo_cartao_plastico numeric;
begin
  loop

    select trunc(random() * 99)::numeric
    into vl_via;

    vl_codigo_cartao_plastico := vp_codigo_cartao;

    select cast (vl_prm as numeric)
    into vl_bin_atual
    from sc_cad.tbl_prm
    where nm_prm = 'BIN';

    vl_cod_bin_cartao := trim(substr(vp_codigo_cartao::varchar,1,6))::numeric;

    if vl_cod_bin_cartao <> vl_bin_atual then
      vl_codigo_cartao_plastico := sc_acc.gera_numero_cartao();
    end if;
    
    vl_numero_plastico := (vl_codigo_cartao_plastico * 100) + vl_via;
    exit when not sc_acc.existe_plastico(vl_numero_plastico);
  end loop;

  return vl_numero_plastico;
end;$$;


ALTER FUNCTION sc_acc.gera_numero_plastico(vp_codigo_cartao numeric) OWNER TO scan;

--
-- TOC entry 7542 (class 0 OID 0)
-- Dependencies: 1604
-- Name: FUNCTION gera_numero_plastico(vp_codigo_cartao numeric); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION gera_numero_plastico(vp_codigo_cartao numeric) IS 'funcao que gera um numero de plastico que ainda nao foi cadastrado no banco de dados, obedecendo a seguinte regra de formacao: numero cartao (14 digitos) + Numero de via (2 digitos)';


--
-- TOC entry 1097 (class 1255 OID 563983)
-- Name: gera_numero_plastico_operador(); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION gera_numero_plastico_operador() RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  bin numeric;
  numero_aleatorio numeric;
  sequencia numeric;
  numero_cartao numeric;
begin
  loop
    select cast (vl_prm as numeric)
    into bin
    from sc_cad.tbl_prm
    where nm_prm = 'BIN_POP';

    select sc_acc.gera_numero_aleatorio(9)
    into numero_aleatorio;

    select nextval('sc_rds.sq_pop')
    into sequencia;

    numero_cartao := (bin * 10000000000) + (numero_aleatorio * 10) + sequencia;
    exit when not sc_acc.existe_plastico_operador(numero_cartao);
  end loop;

  return numero_cartao;
end;$$;


ALTER FUNCTION sc_acc.gera_numero_plastico_operador() OWNER TO scan;

--
-- TOC entry 1098 (class 1255 OID 563984)
-- Name: get_data_vencimento_apuracao(numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION get_data_vencimento_apuracao(vp_dia_vencimento numeric, vp_qt_dias_corte numeric, OUT vp_data_vencimento date, OUT vp_data_apuracao date) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
 --variaveis utilizadas na inclusão do cartao
  vl_dia_prx_corte	numeric;
  vl_dia_atual      numeric;
  vl_mes_atual		numeric;
  vl_ano_atual		numeric;
  vl_dias_corte		character varying(50);

  vl_data_aux date;
begin
  select *
  into vp_data_vencimento, vp_data_apuracao
  from sc_acc.get_data_vencimento_apuracao(current_date, vp_dia_vencimento, vp_qt_dias_corte);
end;
$$;


ALTER FUNCTION sc_acc.get_data_vencimento_apuracao(vp_dia_vencimento numeric, vp_qt_dias_corte numeric, OUT vp_data_vencimento date, OUT vp_data_apuracao date) OWNER TO scan;

--
-- TOC entry 7543 (class 0 OID 0)
-- Dependencies: 1098
-- Name: FUNCTION get_data_vencimento_apuracao(vp_dia_vencimento numeric, vp_qt_dias_corte numeric, OUT vp_data_vencimento date, OUT vp_data_apuracao date); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION get_data_vencimento_apuracao(vp_dia_vencimento numeric, vp_qt_dias_corte numeric, OUT vp_data_vencimento date, OUT vp_data_apuracao date) IS 'ROTINA QUE DEFINE A DATA DE VENCIMENTO E A DATA DE APURACAO';


--
-- TOC entry 1751 (class 1255 OID 1030714)
-- Name: get_data_vencimento_apuracao(date, numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION get_data_vencimento_apuracao(vp_data_referencia date, vp_dia_vencimento numeric, vp_qt_dias_corte numeric, OUT vp_data_vencimento date, OUT vp_data_apuracao date) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
 --variaveis utilizadas na inclusão do cartao
  vl_dia_prx_corte	numeric;
  vl_dia_atual      numeric;
  vl_mes_atual		numeric;
  vl_ano_atual		numeric;
  vl_dias_corte		character varying(50);

  vl_data_aux date;
begin
  --calculando a data do primeiro dia do mês atual
  vl_data_aux := vp_data_referencia - (interval '1 day' * (extract(day from vp_data_referencia) - 1));

  --calculando a data de vencimento do cartao no mes atual
  vp_data_vencimento := vl_data_aux + (interval '1 day' * (vp_dia_vencimento - 1));

  --tratando os casos de meses que nao tem 30 dias
  while extract(month from vp_data_vencimento) > extract(month from vl_data_aux) loop
    vp_data_vencimento := vp_data_vencimento - interval '1 day';
  end loop;
  
  --calculando a data de apuracao do cartao no mes atual
  vp_data_apuracao := vp_data_vencimento - (interval '1 day' * vp_qt_dias_corte);
  
  --verificando se a data de apuracao é maior do que a data atual
   while vp_data_apuracao <= vp_data_referencia loop
    vp_data_vencimento := vp_data_vencimento + interval '1 month';
    vp_data_apuracao := vp_data_vencimento - (interval '1 day' * vp_qt_dias_corte);
   end loop;
  
  --verificando se o dia da data de vencimento é igual ao dia de vencimento passado por parametro
  -- alterao pelo Renato em 31/05/2016
  --vl_data_aux := vp_data_vencimento + interval '1 day';
  --while extract(day from vp_data_vencimento) < vp_qt_dias_corte and 
  vl_data_aux := vp_data_vencimento;
  while extract(day from vp_data_vencimento) != vp_dia_vencimento and 
        extract(month from vl_data_aux) = extract(month from vp_data_vencimento) loop
    vp_data_vencimento := vl_data_aux;
    vp_data_apuracao := vp_data_vencimento - (interval '1 day' * vp_qt_dias_corte);
    vl_data_aux := vp_data_vencimento + interval '1 day';
  end loop;


  if(to_char(vp_data_apuracao,'dd') = '31') then
    vp_data_apuracao := vp_data_apuracao - INTERVAL '1 day';
  end if;
  
end;
$$;


ALTER FUNCTION sc_acc.get_data_vencimento_apuracao(vp_data_referencia date, vp_dia_vencimento numeric, vp_qt_dias_corte numeric, OUT vp_data_vencimento date, OUT vp_data_apuracao date) OWNER TO scan;

--
-- TOC entry 7544 (class 0 OID 0)
-- Dependencies: 1751
-- Name: FUNCTION get_data_vencimento_apuracao(vp_data_referencia date, vp_dia_vencimento numeric, vp_qt_dias_corte numeric, OUT vp_data_vencimento date, OUT vp_data_apuracao date); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION get_data_vencimento_apuracao(vp_data_referencia date, vp_dia_vencimento numeric, vp_qt_dias_corte numeric, OUT vp_data_vencimento date, OUT vp_data_apuracao date) IS 'ROTINA QUE DEFINE A DATA DE VENCIMENTO E A DATA DE APURACAO, CONSIDERANDO UMA DETERMINADA DATA DE REFERENCIA';


--
-- TOC entry 1750 (class 1255 OID 563985)
-- Name: get_data_vencimento_apuracao_OLD(date, numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION "get_data_vencimento_apuracao_OLD"(vp_data_referencia date, vp_dia_vencimento numeric, vp_qt_dias_corte numeric, OUT vp_data_vencimento date, OUT vp_data_apuracao date) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
 --variaveis utilizadas na inclusão do cartao
  vl_dia_prx_corte	numeric;
  vl_dia_atual      numeric;
  vl_mes_atual		numeric;
  vl_ano_atual		numeric;
  vl_dias_corte		character varying(50);

  vl_data_aux date;
begin
  --calculando a data do primeiro dia do mês atual
  vl_data_aux := vp_data_referencia - (interval '1 day' * (extract(day from vp_data_referencia) - 1));

  --calculando a data de vencimento do cartao no mes atual
  vp_data_vencimento := vl_data_aux + (interval '1 day' * (vp_dia_vencimento - 1));

  --tratando os casos de meses que nao tem 30 dias
  while extract(month from vp_data_vencimento) > extract(month from vl_data_aux) loop
    vp_data_vencimento := vp_data_vencimento - interval '1 day';
  end loop;
  
  --calculando a data de apuracao do cartao no mes atual
  vp_data_apuracao := vp_data_vencimento - (interval '1 day' * vp_qt_dias_corte);
  
  --verificando se a data de apuracao é maior do que a data atual
   while vp_data_apuracao <= vp_data_referencia loop
    vp_data_vencimento := vp_data_vencimento + interval '1 month';
    vp_data_apuracao := vp_data_vencimento - (interval '1 day' * vp_qt_dias_corte);
   end loop;
  
  --verificando se o dia da data de vencimento é igual ao dia de vencimento passado por parametro
  -- alterao pelo Renato em 31/05/2016
  --vl_data_aux := vp_data_vencimento + interval '1 day';
  --while extract(day from vp_data_vencimento) < vp_qt_dias_corte and 
  vl_data_aux := vp_data_vencimento;
  while extract(day from vp_data_vencimento) != vp_dia_vencimento and 
        extract(month from vl_data_aux) = extract(month from vp_data_vencimento) loop
    vp_data_vencimento := vl_data_aux;
    vp_data_apuracao := vp_data_apuracao + interval '1 day';
    vl_data_aux := vp_data_vencimento + interval '1 day';
  end loop;

  if(to_char(vp_data_apuracao,'dd') = '31') then
    vp_data_apuracao := vp_data_apuracao - INTERVAL '1 day';
  end if;
  
end;
$$;


ALTER FUNCTION sc_acc."get_data_vencimento_apuracao_OLD"(vp_data_referencia date, vp_dia_vencimento numeric, vp_qt_dias_corte numeric, OUT vp_data_vencimento date, OUT vp_data_apuracao date) OWNER TO scan;

--
-- TOC entry 7545 (class 0 OID 0)
-- Dependencies: 1750
-- Name: FUNCTION "get_data_vencimento_apuracao_OLD"(vp_data_referencia date, vp_dia_vencimento numeric, vp_qt_dias_corte numeric, OUT vp_data_vencimento date, OUT vp_data_apuracao date); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION "get_data_vencimento_apuracao_OLD"(vp_data_referencia date, vp_dia_vencimento numeric, vp_qt_dias_corte numeric, OUT vp_data_vencimento date, OUT vp_data_apuracao date) IS 'ROTINA QUE DEFINE A DATA DE VENCIMENTO E A DATA DE APURACAO, CONSIDERANDO UMA DETERMINADA DATA DE REFERENCIA';


--
-- TOC entry 1100 (class 1255 OID 563986)
-- Name: get_prioridade_conta_cartao(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION get_prioridade_conta_cartao(vp_cartao numeric, vp_conta numeric, vp_tp_conta numeric, OUT vp_prioridade numeric, OUT vp_flag_padrao character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

declare
 --variaveis utilizadas na inclusão do cartao
  vl_qtde  		numeric;
  vl_existe     numeric;
  vl_prioridade numeric;
  vl_flag		varchar;
begin
  
  select count(*)
    into vl_qtde
  from sc_opr.tbl_cnt_crt c
  where c.cd_crt = vp_cartao
    and c.tp_cnt_crt = vp_tp_conta;
  
  if vl_qtde = 0 then
  	-- nesse caso nao existe nenhuma conta, entao a conta a ser criada deverá ser de prioridade 1 e flag padrao SIM
  	vl_flag := 'S';
  	vl_prioridade := 1;
  else
  	-- nesse caso já existe conta, entao a conta a ser criada deverá ser uma prioridade acima da existente da maior existente e flag padrao SIM caso as conta que já existam nao sejam padrao, caso existe pelo menos uma, NAO será padrao
    -- flag
    select count(*)
	  into vl_existe
	from sc_opr.tbl_cnt_crt c
	where c.cd_crt = vp_cartao
	  and c.tp_cnt_crt = vp_tp_conta
	  and c.fg_pdr_cnt_crt = 'S';
	
	if vl_existe = 0 then
	  vl_flag := 'S';
	else
	  vl_flag := 'N';
	end if;
	
	-- prioridade
	select max(prp_cnt_crt)
	  into vl_prioridade
	from sc_opr.tbl_cnt_crt c
	where c.cd_crt = vp_cartao
	  and c.tp_cnt_crt = vp_tp_conta;
	
	vl_prioridade := vl_prioridade + 1;
  end if;
  
  vp_flag_padrao := vl_flag;
  vp_prioridade := vl_prioridade;
end;
$$;


ALTER FUNCTION sc_acc.get_prioridade_conta_cartao(vp_cartao numeric, vp_conta numeric, vp_tp_conta numeric, OUT vp_prioridade numeric, OUT vp_flag_padrao character varying) OWNER TO scan;

--
-- TOC entry 7546 (class 0 OID 0)
-- Dependencies: 1100
-- Name: FUNCTION get_prioridade_conta_cartao(vp_cartao numeric, vp_conta numeric, vp_tp_conta numeric, OUT vp_prioridade numeric, OUT vp_flag_padrao character varying); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION get_prioridade_conta_cartao(vp_cartao numeric, vp_conta numeric, vp_tp_conta numeric, OUT vp_prioridade numeric, OUT vp_flag_padrao character varying) IS 'ROTINA QUE DEFINE A DATA DE VENCIMENTO E A DATA DE APURACAO';


--
-- TOC entry 1865 (class 1255 OID 563987)
-- Name: inclui_cartao(tbl_hfe, tbl_rct, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION inclui_cartao(vp_dados_filial tbl_hfe, vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric, vp_codigo_funcionario numeric, OUT vp_codigo_cartao numeric, OUT vp_codigo_plastico numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare 
  --variaveis utilizadas na inclusão do cartao
  vl_prm_vencim		numeric;
  vl_dia_prx_vencim numeric;
  vl_qt_dias_corte	numeric;
  vl_dt_prx_vencim  date;
  vl_dt_prx_corte	date;
  vl_cd_tarifas		numeric;
  vl_cd_contrato	numeric;
  vl_cd_modelo   	numeric;
  vl_emitir_senha_junto_cartao varchar;
  
  --variaveis utilizadas na inclusão da conta
  vl_codigo_conta numeric;
  vl_codigo_conta_credito numeric;
  vl_nome_conta_credito varchar;
  vl_nome_conta varchar;
  vl_prioridade  numeric;
  vl_flag_conta_padrao varchar;
  
  --variaveis utilizadas na inclusão do plastico
  vl_senha numeric;
  vl_security_code numeric;
  vl_data_validade date;
  vl_nome_plastico varchar;
  vl_valor_seguro_perda_roubo numeric;
  vl_valor_seguro_affinity numeric;
  vl_cd_scr numeric;
  
  ct_tp_cnt_pagamento  constant numeric := 1;
  ct_produto_pagamento constant numeric := 1;
  ct_produto_seguro    constant numeric := 2;
  ct_st_flag_ativo	   constant varchar := 'S';
  ct_tp_lmt_saque_extra constant numeric := 1;
  ct_tp_lmt_compras constant numeric := 2;
  ct_ssp_plastico numeric := 1;
  ct_ssp_senha numeric := 2;
  ct_ssp_st_cadastrada numeric := 1;
  ct_cd_pce_seguro_perda_roubo numeric := 21;
  ct_cd_srv_seguro_perda_roubo numeric := 1;
  ct_cd_srv_seguro_affinity numeric := 2;
  ct_tp_ads_srv_empresa numeric := 2;
  ct_cd_sga_mapfre numeric := 1;
  ct_qt_prs numeric := 60;

  VL_PLANO_CONTAS_SAQPAG sc_cnt.tbl_pcn.cd_pcn%type := 1;
  
  VL_SUB_CONTA_CREDITO_CARTAO sc_cnt.tbl_tcn.cd_tcn%type := 1;
  VL_SUB_CONTA_DEBITO_CARTAO sc_cnt.tbl_tcn.cd_tcn%type := 20;

  
  VL_TIPO_CONTA_CREDITO_CARTAO sc_cnt.tbl_tcn.cd_tcn%type := 1;
  VL_TIPO_CONTA_DEBITO_CARTAO sc_cnt.tbl_tcn.cd_tcn%type := 7;

  CT_PARAMETRO_TABELA_TARIFAS numeric := 33;
  
begin
  vp_codigo_cartao := sc_acc.gera_numero_cartao();
  
  -- pegando o número do contrato e a tabela de tarifas da empresa e da filial do funcionario
  select ctr.cd_ctr, ctr.cd_mpl, mpl.fg_snh_mpl
  into vl_cd_contrato, vl_cd_modelo, vl_emitir_senha_junto_cartao
  from sc_cad.tbl_ctr ctr
       inner join sc_cad.tbl_fem_ctr fem_ctr on ctr.cd_ctr = fem_ctr.cd_ctr
       inner join sc_ssp.tbl_mpl mpl on ctr.cd_mpl = mpl.cd_mpl
  where fem_ctr.cd_emp = vp_dados_filial.cd_emp
    and fem_ctr.cd_fem = vp_dados_filial.cd_fem
    and fem_ctr.fg_atv_fem_ctr = ct_st_flag_ativo
    and ctr.cd_prd  = vp_dados_filial.cd_prd--in (ct_produto_pagamento, ct_produto_seguro)
    and ctr.fg_atv_ctr = ct_st_flag_ativo;

  -- retornando parametros de contrato por filial
  vl_cd_tarifas := sc_cad.get_parametro_contrato(CT_PARAMETRO_TABELA_TARIFAS, vl_cd_contrato, vp_dados_filial.cd_fem)::numeric; 
    
  -- pegando os parametros necessários para obter a dia do vencimento e o dia do corte do cartao e a tabela de tarifas 
  select vl_prm
    into vl_prm_vencim
  from sc_cad.tbl_prm 
  where nm_prm = 'CD_PRM_DT_VENC';

  /*select vl_pce_ctr
    into vl_dia_prx_vencim
  from sc_cad.tbl_pce_ctr pce
  where pce.cd_ctr = vl_cd_contrato
    and pce.cd_pce = vl_prm_vencim;*/

  -- retornando o dia de vencimento do cartao
  vl_dia_prx_vencim := sc_cad.get_parametro_contrato(vl_prm_vencim, vl_cd_contrato, vp_dados_filial.cd_fem)::numeric; 

  select vl_prm
    into vl_qt_dias_corte
  from sc_cad.tbl_prm 
  where nm_prm = 'QT_DT_DIAS_CORTE_CRT_ATIVO';
  
  -- chamando a rotina para poder gerar a data de vencimento e a data de corte 
  select *
    into vl_dt_prx_vencim, vl_dt_prx_corte
  from sc_acc.get_data_vencimento_apuracao(vl_dia_prx_vencim, vl_qt_dias_corte);


  --Inserindo nova conta de Credito Vitor Vasconcelos 16/12/2014
  select nextval('sc_cnt.sq_cnt') into vl_codigo_conta_credito;
  
  vl_nome_conta_credito := 'CRT CRD PG ' || vp_dados_cartao.nm_rct;
  
  insert into sc_cnt.tbl_cnt(cd_cnt, nm_cnt, vl_sld_cnt, fg_ntr_cnt, cd_inc_usr, dt_inc_usr, cd_pcn, cd_scn)
  values(vl_codigo_conta_credito, vl_nome_conta_credito, 0, 'D', vp_codigo_usuario, current_timestamp,VL_PLANO_CONTAS_SAQPAG, VL_SUB_CONTA_CREDITO_CARTAO);

  --  
  --inserindo registro na tabela de cartao
  insert into sc_opr.tbl_crt(cd_crt, cd_fnc, cd_prd, fg_atv_crt, fg_ind_crt, 
  						   dt_prx_vnc_crt, dt_prx_apr_crt, cd_tvt, cd_inc_usr, dt_inc_usr, cd_ctr, cd_cnt)
  values(vp_codigo_cartao, vp_codigo_funcionario, vp_dados_filial.cd_prd, 'S', 'N', 
  							vl_dt_prx_vencim, vl_dt_prx_corte, vl_cd_tarifas, vp_codigo_usuario, current_timestamp, vl_cd_contrato, vl_codigo_conta_credito);

  --inserindo os limites do cartao
  insert into sc_opr.tbl_lmt(cd_crt, cd_tlt, vl_cnc_lmt, vl_utl_lmt) values(vp_codigo_cartao, ct_tp_lmt_saque_extra, 0, 0);
  insert into sc_opr.tbl_lmt(cd_crt, cd_tlt, vl_cnc_lmt, vl_utl_lmt) values(vp_codigo_cartao, ct_tp_lmt_compras, 0, 0);

  --inserindo registro na tabela de conta
  select nextval('sc_cnt.sq_cnt') into vl_codigo_conta;
  
  vl_nome_conta := 'CRT PG ' || vp_dados_cartao.nm_rct;
  
  insert into sc_cnt.tbl_cnt(cd_cnt, nm_cnt, vl_sld_cnt, fg_ntr_cnt, cd_inc_usr, dt_inc_usr, cd_pcn, cd_scn)
  values(vl_codigo_conta, vl_nome_conta, 0, 'C', vp_codigo_usuario, current_timestamp, VL_PLANO_CONTAS_SAQPAG, VL_SUB_CONTA_DEBITO_CARTAO);
  
  --chamando a rotina para identificar a prioridade e flag de conta padrao para inserir registro na tabela de conta do cartao
  select *
    into vl_prioridade, vl_flag_conta_padrao
  from sc_acc.get_prioridade_conta_cartao(vp_codigo_cartao, vl_codigo_conta, ct_tp_cnt_pagamento);
    
  insert into sc_opr.tbl_cnt_crt(cd_crt, cd_cnt, tp_cnt_crt, cd_inc_usr, dt_inc_usr, prp_cnt_crt, fg_pdr_cnt_crt)
  values(vp_codigo_cartao, vl_codigo_conta, ct_tp_cnt_pagamento, vp_codigo_usuario, current_timestamp, vl_prioridade, vl_flag_conta_padrao);
  
  --inserindo registro na tabela de plastico
  vp_codigo_plastico := sc_acc.inclui_plastico(vp_codigo_cartao, vl_cd_modelo, vp_codigo_usuario, vp_dados_cartao.nm_rct, vp_codigo_cun);

   -- inserindo registro na tabela de cobranca
  insert into sc_cci.tbl_cci (cd_crt, fg_pas_cbr_cci, fg_pas_ngv_cci, cd_emc, cd_inc_usr, dt_inc_usr, cd_alt_usr, dt_alt_usr, fg_atv_cci)
    values (vp_codigo_cartao,'S','S',1,1,now(),null,null,'N');

  -- cobrar seguro perda ou roubo
  select replace(replace(pce.vl_pce_ctr,'.',''),',','.')
    into vl_valor_seguro_perda_roubo
  from sc_cad.tbl_pce_ctr pce
  where pce.cd_pce = ct_cd_pce_seguro_perda_roubo
    and pce.cd_ctr = vl_cd_contrato;

  if vl_valor_seguro_perda_roubo is null then
    vl_valor_seguro_perda_roubo := 0;
  end if;

  if vl_valor_seguro_perda_roubo > 0 then
    select nextval('sc_srv.sq_scr') into vl_cd_scr;
    
    insert into sc_srv.tbl_scr (cd_scr, cd_srv, cd_crt, st_scr, tp_ads_scr, cd_inc_usr, dt_inc_usr)
      values (vl_cd_scr, ct_cd_srv_seguro_perda_roubo, vp_codigo_cartao, 1, ct_tp_ads_srv_empresa, 1, now());

    insert into sc_srv.tbl_sgr (cd_sgr, cd_sga, cd_scr, vl_sgr, vl_prs_sgr, qt_prs_sgr, dt_vnc_sgr, vl_fin_sgr)
      values (nextval('sc_srv.sq_sgr'), ct_cd_sga_mapfre, vl_cd_scr, vl_valor_seguro_perda_roubo * ct_qt_prs, vl_valor_seguro_perda_roubo, ct_qt_prs, vl_dt_prx_vencim, vl_valor_seguro_perda_roubo * ct_qt_prs);
  end if;

  -- cobrar seguro affinity
  select replace(replace(pce.vl_pce_ctr,'.',''),',','.')
    into vl_valor_seguro_affinity
  from sc_cad.tbl_pce_ctr pce
  where pce.cd_pce = ct_cd_pce_seguro_perda_roubo
    and pce.cd_ctr = vl_cd_contrato;

  if vl_valor_seguro_affinity is null then
    vl_valor_seguro_affinity := 0;
  end if;

  if vl_valor_seguro_affinity > 0 then
    select nextval('sc_srv.sq_scr') into vl_cd_scr;
    
    insert into sc_srv.tbl_scr (cd_scr, cd_srv, cd_crt, st_scr, tp_ads_scr, cd_inc_usr, dt_inc_usr)
      values (vl_cd_scr, ct_cd_srv_seguro_affinity, vp_codigo_cartao, 1, ct_tp_ads_srv_empresa, 1, now());

    insert into sc_srv.tbl_sgr (cd_sgr, cd_sga, cd_scr, vl_sgr, vl_prs_sgr, qt_prs_sgr, dt_vnc_sgr, vl_fin_sgr)
      values (nextval('sc_srv.sq_sgr'), ct_cd_sga_mapfre, vl_cd_scr, vl_valor_seguro_affinity * ct_qt_prs, vl_valor_seguro_affinity, ct_qt_prs, vl_dt_prx_vencim, vl_valor_seguro_affinity * ct_qt_prs);
  end if;

end;
$$;


ALTER FUNCTION sc_acc.inclui_cartao(vp_dados_filial tbl_hfe, vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric, vp_codigo_funcionario numeric, OUT vp_codigo_cartao numeric, OUT vp_codigo_plastico numeric) OWNER TO scan;

--
-- TOC entry 1640 (class 1255 OID 563990)
-- Name: inclui_cpf(tbl_rct, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION inclui_cpf(vp_dados_cartao tbl_rct, vp_codigo_cun numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

 vl_nome_mae sc_acc.tbl_rct.nm_mae_rct%type;
 vl_naturalidade sc_acc.tbl_rct.ds_nat_rct%type;
 vl_nacionalidade sc_acc.tbl_rct.ds_nac_rct%type;

begin

    vl_nome_mae := upper(trim(sc_pbl.remove_caracter_especial(sc_pbl.sem_acento(vp_dados_cartao.nm_mae_rct))));
    vl_naturalidade := upper(trim(sc_pbl.sem_acento(vp_dados_cartao.ds_nat_rct)));
    vl_nacionalidade := upper(trim(sc_pbl.sem_acento(vp_dados_cartao.ds_nac_rct)));

    insert into sc_cad.tbl_cpf(cd_cun, nr_rg_cpf, nm_mae_cpf, dt_nsc_cpf, sexo_cpf,
                               dt_ems_rg_cpf, nm_org_ems_rg_cpf, cd_est_civil_cpf,
			       ds_nat_cpf, ds_nac_cpf)
    values(vp_codigo_cun, vp_dados_cartao.rg_rct, vl_nome_mae, vp_dados_cartao.dt_nsc_rct, vp_dados_cartao.fg_sex_rct,
           vp_dados_cartao.dt_ems_rg_rct, vp_dados_cartao.nm_org_ems_rg_rct || '-' || vp_dados_cartao.uf_org_ems_rg_rct, vp_dados_cartao.cd_est_rct,
           vl_naturalidade, vl_nacionalidade);
end;
$$;


ALTER FUNCTION sc_acc.inclui_cpf(vp_dados_cartao tbl_rct, vp_codigo_cun numeric) OWNER TO scan;

--
-- TOC entry 1102 (class 1255 OID 563991)
-- Name: inclui_cpj(tbl_rct, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION inclui_cpj(vp_dados_cartao tbl_rct, vp_codigo_cun numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
begin  
  insert into sc_cad.tbl_cpj(cd_cun, nm_fts_cpj, nr_ins_edl_cpj, dt_reg_cpj)
  values(vp_codigo_cun, upper(trim(sc_pbl.remove_caracter_especial(sc_pbl.sem_acento(vp_dados_cartao.nm_mae_rct)))), vp_dados_cartao.rg_rct, vp_dados_cartao.dt_nsc_rct);
end;
$$;


ALTER FUNCTION sc_acc.inclui_cpj(vp_dados_cartao tbl_rct, vp_codigo_cun numeric) OWNER TO scan;

--
-- TOC entry 1103 (class 1255 OID 563992)
-- Name: inclui_cun(tbl_rct, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION inclui_cun(vp_dados_cartao tbl_rct, vp_codigo_usuario numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
  --tipos de pessoas
  ct_pessoa_juridica constant char := 'J';
  ct_pessoa_fisica constant char := 'F';
  vl_email varchar := null;
  vl_codigo_cun numeric;
begin
  if sc_acc.valida_email(vp_dados_cartao.eml_rct) then
    vl_email := trim(sc_pbl.remove_caracter_especial(sc_pbl.sem_acento(vp_dados_cartao.eml_rct)));
  end if;
  
  select nextval('sc_cad.sq_cun') into vl_codigo_cun;
  
  insert into sc_cad.tbl_cun(cd_cun, nm_cun, nr_cpf_cnpj_cun, tp_pss_cun, eml_cun, cd_inc_usr, dt_inc_usr)
  values(vl_codigo_cun, UPPER(trim(sc_pbl.remove_caracter_especial(sc_pbl.sem_acento(vp_dados_cartao.nm_rct)))), vp_dados_cartao.nr_cpf_cnpj_rct, vp_dados_cartao.tp_pss_rct, vl_email, vp_codigo_usuario, current_timestamp);
  
  if vp_dados_cartao.tp_pss_rct = ct_pessoa_fisica then
    perform sc_acc.inclui_cpf(vp_dados_cartao, vl_codigo_cun);
  else
    perform sc_acc.inclui_cpj(vp_dados_cartao, vl_codigo_cun);
  end if;
  
  return vl_codigo_cun;
end;$$;


ALTER FUNCTION sc_acc.inclui_cun(vp_dados_cartao tbl_rct, vp_codigo_usuario numeric) OWNER TO scan;

--
-- TOC entry 1101 (class 1255 OID 563993)
-- Name: inclui_funcionario(tbl_hfe, tbl_rct, numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION inclui_funcionario(vp_dados_filial tbl_hfe, vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
  --situacao do funcionario
  ct_st_fnc_ativo numeric := 1;
  
  vl_codigo_funcionario numeric;

  vl_matricula varchar(20);
begin
  
  --obtendo o código do funcionario
  select nextval('sc_cad.sq_fnc') into vl_codigo_funcionario;

  --vl_matricula := trim(leading '0' from vp_dados_cartao.cd_crt_emp_rct);
  vl_matricula := trim(vp_dados_cartao.cd_crt_emp_rct);
  
  --inserindo o registro na tabela de funcionario
  insert into sc_cad.tbl_fnc(cd_fnc, cd_cun, cd_emp, cd_fem, nr_idt_fnc, 
			     dt_adm_fnc, st_fnc, cd_inc_usr, dt_inc_usr)
              values(vl_codigo_funcionario, vp_codigo_cun, vp_dados_filial.cd_emp, vp_dados_filial.cd_fem, vl_matricula, 
                          vp_dados_cartao.dt_adm_rct, ct_st_fnc_ativo, vp_codigo_usuario, current_timestamp);
  
  return vl_codigo_funcionario;
end;
$$;


ALTER FUNCTION sc_acc.inclui_funcionario(vp_dados_filial tbl_hfe, vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) OWNER TO scan;

--
-- TOC entry 1104 (class 1255 OID 563994)
-- Name: inclui_plastico(numeric, numeric, numeric, character varying, numeric, character varying); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION inclui_plastico(vp_codigo_cartao numeric, vp_codigo_modelo numeric, vp_codigo_usuario numeric, vp_nome_cliente character varying, vp_codigo_cun numeric, vp_flag_primeira_via character varying DEFAULT 'S'::character varying) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_senha varchar;
  vl_security_code numeric;
  vl_data_validade date;
  vl_codigo_plastico numeric;
  vl_nome_plastico varchar;
  vl_emitir_senha_junto_cartao varchar;
  vl_cpf_cnpj numeric;
  vl_codigo_grupo_empresarial numeric;
  vl_existe_cartao_ativo numeric;
  vl_fg_emitir_plastico varchar;

  ct_ssp_plastico numeric := 1;
  ct_ssp_senha numeric := 2;
  ct_ssp_st_cadastrada numeric := 1;
  vl_flag_emitir_cartao varchar;
begin
  select mpl.fg_snh_mpl
  into vl_emitir_senha_junto_cartao
  from sc_ssp.tbl_mpl mpl
  where mpl.cd_mpl = vp_codigo_modelo;
  
  --inserindo registro na tabela de plastico
  vl_senha := sc_acc.gera_numero_aleatorio(4);
  vl_security_code := sc_acc.gera_numero_aleatorio(3);
  vl_data_validade := current_date + interval '5 year';
  vl_codigo_plastico := sc_acc.gera_numero_plastico(vp_codigo_cartao);
  vl_nome_plastico := sc_acc.gera_nome_cartao(vp_nome_cliente);

  -- verificar se existe algum cartao ativo no mesmo grupo para este funcionário
  -- caso existe nao inserir na table se solicitacao de emissao de plastico
  -- e gravar o plastico com o flag de não é pra ser emitido
  select cun.nr_cpf_cnpj_cun, emp.cd_gem, coalesce(fem.fg_emt_crt_fem, 'S')
    into vl_cpf_cnpj, vl_codigo_grupo_empresarial, vl_flag_emitir_cartao
  from sc_opr.tbl_crt crt
    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
    inner join sc_cad.tbl_fem fem on fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
  where crt.cd_crt = vp_codigo_cartao;

  select count(*)
    into vl_existe_cartao_ativo
  from sc_cad.tbl_fnc fnc
    inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
    inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
  where cun.nr_cpf_cnpj_cun = vl_cpf_cnpj
    and emp.cd_gem = vl_codigo_grupo_empresarial
    and crt.fg_atv_crt = 'S'
    and crt.cd_crt not in (vp_codigo_cartao);

  if vl_flag_emitir_cartao = 'N' then
    vl_fg_emitir_plastico := 'N';
  else
    if vl_existe_cartao_ativo = 0 or vp_flag_primeira_via = 'N' then
       vl_fg_emitir_plastico := 'S';
    else
       vl_fg_emitir_plastico := 'N';
    end if;
  end if;
  
  insert into sc_opr.tbl_pls(cd_pls, cd_crt, dt_vld_pls, nr_scc_pls, nm_snh_pls, 
			    nm_pls, cd_inc_usr, dt_inc_usr, cd_cun, cd_mpl,
			    fg_blq_pls, cd_tbl, fg_ems_pls, fg_ems_snh, fg_prm_via, fg_emt_pls)
       values(vl_codigo_plastico, vp_codigo_cartao, vl_data_validade, vl_security_code, vl_senha, 
		           vl_nome_plastico, vp_codigo_usuario, current_timestamp, vp_codigo_cun, vp_codigo_modelo,
		           'S', 1, 'S', 'S', vp_flag_primeira_via, vl_fg_emitir_plastico);

  if vl_flag_emitir_cartao = 'S' then
     if vl_existe_cartao_ativo = 0 or vp_flag_primeira_via = 'N' then 
        --inserindo na tabela de solicitacao de personalizacao de plastico
        insert into sc_ssp.tbl_ssp(cd_ssp,cd_pls,tp_ssp,st_ssp,cd_mpl,msg_crt_ssp,dt_prv_grc_ssp,
			       dt_grc_ssp,dt_inc_usr)
             values(nextval('sc_ssp.sq_ssp'),vl_codigo_plastico,ct_ssp_plastico,ct_ssp_st_cadastrada,
	             vp_codigo_modelo,null,(now() + interval '1 day')::date,NULL,now());
     
        --inserindo na tabela de solicitacao de personalizacao de senha
        if vl_emitir_senha_junto_cartao = 'N' then
           insert into sc_ssp.tbl_ssp(cd_ssp,cd_pls,tp_ssp,st_ssp,cd_mpl,msg_crt_ssp,dt_prv_grc_ssp,
				dt_grc_ssp,dt_inc_usr)
                values(nextval('sc_ssp.sq_ssp'),vl_codigo_plastico,ct_ssp_senha,ct_ssp_st_cadastrada,
	               vp_codigo_modelo,null,(now() + interval '1 day')::date,NULL,now());                       
        end if;
     end if;
  end if;

  return vl_codigo_plastico;
end;$$;


ALTER FUNCTION sc_acc.inclui_plastico(vp_codigo_cartao numeric, vp_codigo_modelo numeric, vp_codigo_usuario numeric, vp_nome_cliente character varying, vp_codigo_cun numeric, vp_flag_primeira_via character varying) OWNER TO scan;

--
-- TOC entry 7547 (class 0 OID 0)
-- Dependencies: 1104
-- Name: FUNCTION inclui_plastico(vp_codigo_cartao numeric, vp_codigo_modelo numeric, vp_codigo_usuario numeric, vp_nome_cliente character varying, vp_codigo_cun numeric, vp_flag_primeira_via character varying); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION inclui_plastico(vp_codigo_cartao numeric, vp_codigo_modelo numeric, vp_codigo_usuario numeric, vp_nome_cliente character varying, vp_codigo_cun numeric, vp_flag_primeira_via character varying) IS 'inclui um registro na tabela de plastico';


--
-- TOC entry 1111 (class 1255 OID 563995)
-- Name: processa_arquivo(); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION processa_arquivo() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg sc_acc.tbl_hdr%rowtype;
  
  ct_st_recebido constant numeric := 1;
begin
  for vl_rg in select *
               from sc_acc.tbl_hdr
               where st_hdr = ct_st_recebido loop
      perform sc_acc.processa_arquivo(vl_rg.cd_hdr);
  end loop;
end;$$;


ALTER FUNCTION sc_acc.processa_arquivo() OWNER TO scan;

--
-- TOC entry 7548 (class 0 OID 0)
-- Dependencies: 1111
-- Name: FUNCTION processa_arquivo(); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION processa_arquivo() IS 'PROCESSA TODOS OS ARQUIVOS COM A SITUACAO RECEBIDO';


--
-- TOC entry 1110 (class 1255 OID 563996)
-- Name: processa_arquivo(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION processa_arquivo(vp_codigo_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg sc_acc.tbl_hdr%rowtype;
  
  vl_situacao numeric;
  vl_situacao_processamento numeric;
  vl_existe numeric;

  --situacao de processamento do arquivo
  ct_st_prc_sucesso numeric := 0;
  ct_st_prc_filial_invalido numeric := 2;
  
  --situacao do registro de header do arquivo
  ct_st_recebido constant numeric := 1;
  ct_st_invalidado constant numeric := 2; 
  ct_st_processado constant numeric := 3;
begin
  --validando os dados do arquivo
  select *
  into vl_situacao, vl_situacao_processamento
  from sc_acc.valida_arquivo(vp_codigo_arquivo);
  
  --se o arquivo for invalidado, marcar o arquivo como invalido e sair da rotina
  if vl_situacao <> ct_st_processado then
    update sc_acc.tbl_hdr
       set st_hdr = vl_situacao,
           st_prc_hdr = vl_situacao_processamento
    where cd_hdr = vp_codigo_arquivo;
  else
    --processando todos os registros de filial do arquivo
    perform sc_acc.processa_filial(vp_codigo_arquivo);
  
    --verificando se existe pelo menos um registro de filial valido no arquivo
    select count(*)
    into vl_existe
    from sc_acc.tbl_hfe
    where cd_hdr = vp_codigo_arquivo
      and st_hfe = ct_st_processado;
    
    if vl_existe = 0 then
      update sc_acc.tbl_hdr
         set st_hdr = ct_st_invalidado,
             st_prc_hdr = ct_st_prc_filial_invalido
      where cd_hdr = vp_codigo_arquivo;
    else
      update sc_acc.tbl_hdr
         set st_hdr = ct_st_processado,
             st_prc_hdr = ct_st_prc_sucesso
      where cd_hdr = vp_codigo_arquivo;
    end if;
  end if;
end;
$$;


ALTER FUNCTION sc_acc.processa_arquivo(vp_codigo_arquivo numeric) OWNER TO scan;

--
-- TOC entry 7549 (class 0 OID 0)
-- Dependencies: 1110
-- Name: FUNCTION processa_arquivo(vp_codigo_arquivo numeric); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION processa_arquivo(vp_codigo_arquivo numeric) IS 'PROCESSA UM DETERMINADO ARQUIVO';


--
-- TOC entry 1685 (class 1255 OID 563998)
-- Name: processa_cartao(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION processa_cartao(vp_codigo_registro_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_dados_filial sc_acc.tbl_hfe%rowtype;
  vl_codigo_header_filial numeric;
  vl_incluir_cartao boolean := true;

  --constantes
  ct_st_recebido constant numeric := 1;
  
begin
  --obtendo o código do header de filial
  select cd_hfe
  into vl_codigo_header_filial
  from sc_acc.tbl_rct
  where cd_rct = vp_codigo_registro_cartao;

  --obtendo todos os dados da tabela de header de filial
  select *
  into vl_dados_filial
  from sc_acc.tbl_hfe
  where cd_hfe = vl_codigo_header_filial;

  --atualizando o registro de cartao para recebido
  update sc_acc.tbl_rct 
     set st_rct = ct_st_recebido
  where cd_rct = vp_codigo_registro_cartao;

  --verificando se o contrato da empresa eh necessario a inclusao do cartao
  select * 
  into vl_incluir_cartao
  from sc_acc.eh_pra_incluir_cartao(vl_dados_filial);

  --executando a rotina de processamento de cartao
  perform sc_acc.processa_cartao(vl_dados_filial, vl_incluir_cartao);
end;$$;


ALTER FUNCTION sc_acc.processa_cartao(vp_codigo_registro_cartao numeric) OWNER TO scan;

--
-- TOC entry 1716 (class 1255 OID 1010375)
-- Name: processa_cartao(tbl_hfe, boolean); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION processa_cartao(vp_dados_filial tbl_hfe, vp_incluir_cartao boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  --constantes**********************************************
  --situacao do registro de cartao
  ct_st_recebido constant numeric := 1;
  ct_st_pendente_confirmacao constant numeric := 2; 
  ct_st_validado constant numeric := 3;
  ct_st_invalidado constant numeric := 4;
 
  --situacao de processamento do registro de cartao
  ct_st_prc_sucesso numeric := 0;
  ct_st_prc_nome_divergente numeric := 1;
  ct_st_prc_tipo_pessoa_divergente numeric := 2;

  --tipos de pessoas
  ct_pessoa_juridica constant char := 'J';
  ct_pessoa_fisica constant char := 'F';
  --********************************************************

  --variaveis***********************************************
  vl_rg sc_acc.tbl_rct%rowtype;
  
  vl_situacao numeric;
  vl_situacao_processamento numeric;
  vl_codigo_cun numeric;
  vl_codigo_funcionario numeric;
  vl_codigo_cartao numeric;
  vl_codigo_plastico numeric;
  vl_codigo_usuario numeric;
  --*********************************************************
begin
  select cast(vl_prm as numeric)
  into vl_codigo_usuario
  from sc_cad.tbl_prm
  where nm_prm = 'USUARIO ARQUIVO CADASTRO CARTAO';
  
  for vl_rg in select *
            from sc_acc.tbl_rct
            where cd_hdr = vp_dados_filial.cd_hdr
              and cd_hfe = vp_dados_filial.cd_hfe
              and st_rct = ct_st_recebido loop
    --verificando se existe cadastrao unico com o CPF/CNPJ informados
    if sc_acc.existe_cadastro_unico(vl_rg.nr_cpf_cnpj_rct) then
      --caso exista, valida os dados enviados no arquivo, com os dados ja cadastrados no banco 
      select *
      into vl_codigo_cun, vl_situacao, vl_situacao_processamento
      from sc_acc.valida_alteracao_cun(vl_rg);

      --se o registro não for valido passa pro proximo cartao
      if vl_situacao <> ct_st_validado then
        --atualizando os dados da tabela
        update sc_acc.tbl_rct
	      set st_rct = vl_situacao,
	          st_prc_rct = vl_situacao_processamento
	      where cd_rct = vl_rg.cd_rct;
      else
        --se o registro for valido procede com as alteracoes correspondentes
        perform sc_acc.altera_cun(vl_rg, vl_codigo_cun, vl_codigo_usuario);
      end if;      
    else
      --caso não exista, valida se os dados enviados no arquivo sao validos 
      select *
      into vl_situacao, vl_situacao_processamento
      from sc_acc.valida_inclusao_cun(vl_rg);

      --se o registro não for valido passa pro proximo registro
      if vl_situacao <> ct_st_validado then
        --atualizando os dados da tabela
        update sc_acc.tbl_rct
	      set st_rct = vl_situacao,
	          st_prc_rct = vl_situacao_processamento
	      where cd_rct = vl_rg.cd_rct;
      else
        --se o registro for valido procede com as inclusoes correspondentes
        select * 
        into vl_codigo_cun
        from sc_acc.inclui_cun(vl_rg, vl_codigo_usuario);
      end if;
    end if;

    if vl_situacao = ct_st_validado then
      --processando o(s) endereço(s) do cartão, que vieram no arquivo
      perform sc_acc.processa_endereco(vl_rg, vl_codigo_cun, vl_codigo_usuario);
    
      --processando o(s) telefone(s) do cartão, que vieram no arquivo
      if vl_rg.tp_pss_rct = ct_pessoa_fisica then
        perform sc_acc.processa_telefone_pf(vl_rg, vl_codigo_cun, vl_codigo_usuario);
      else
        perform sc_acc.processa_telefone_pj(vl_rg, vl_codigo_cun, vl_codigo_usuario);
      end if;
      
      --verificando se existe funcionario, o CPF/CNPJ, empresa e filial informados
      if sc_acc.existe_funcionario(vp_dados_filial, vl_rg) then
        --validando a inclusao do funcionario
        select *
        into vl_codigo_funcionario, vl_situacao, vl_situacao_processamento
        from sc_acc.valida_alteracao_funcionario(vp_dados_filial, vl_rg, vl_codigo_cun);
      
        --se o registro não for valido sai da rotina
        if vl_situacao <> ct_st_validado then
          --atualizando os dados da tabela
          update sc_acc.tbl_rct
	        set st_rct = vl_situacao,
	            st_prc_rct = vl_situacao_processamento
	        where cd_rct = vl_rg.cd_rct;
        end if;    
      else
        --validando a inclusao do funcionario
        select *
        into vl_situacao, vl_situacao_processamento
        from sc_acc.valida_inclusao_funcionario(vp_dados_filial, vl_rg, vl_codigo_cun);
    
        --se o registro não for valido sai da rotina
        if vl_situacao <> ct_st_validado then
          --atualizando os dados da tabela
          update sc_acc.tbl_rct
	        set st_rct = vl_situacao,
	            st_prc_rct = vl_situacao_processamento
	        where cd_rct = vl_rg.cd_rct;  
        else
          --incluindo um novo funcionario no banco de dados
          select *
          into vl_codigo_funcionario
          from sc_acc.inclui_funcionario(vp_dados_filial, vl_rg, vl_codigo_cun, vl_codigo_usuario);
        end if;
      end if;
    end if;
    
    if vl_situacao = ct_st_validado then
      --incluindo um novo cartao para o funcionario no banco de dados
      if vp_incluir_cartao then
        select *
        into vl_codigo_cartao, vl_codigo_plastico
        from sc_acc.inclui_cartao(vp_dados_filial, vl_rg, vl_codigo_cun, vl_codigo_usuario, vl_codigo_funcionario);
      end if;
    
      --atualizando registro com o código do cartão e do plástico
      update sc_acc.tbl_rct
	    set cd_crt = vl_codigo_cartao,
	        cd_pls = vl_codigo_plastico,
	        st_rct = ct_st_validado,
	        st_prc_rct = ct_st_prc_sucesso
      where cd_rct = vl_rg.cd_rct;
    end if;
  end loop;
end;
$$;


ALTER FUNCTION sc_acc.processa_cartao(vp_dados_filial tbl_hfe, vp_incluir_cartao boolean) OWNER TO scan;

--
-- TOC entry 7550 (class 0 OID 0)
-- Dependencies: 1716
-- Name: FUNCTION processa_cartao(vp_dados_filial tbl_hfe, vp_incluir_cartao boolean); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION processa_cartao(vp_dados_filial tbl_hfe, vp_incluir_cartao boolean) IS 'PROCESSA UM REGISTRO DE CARTAO DE UM DETERMINADO ARQUIVO';


--
-- TOC entry 1713 (class 1255 OID 563997)
-- Name: processa_cartao_OLD(tbl_hfe); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION "processa_cartao_OLD"(vp_dados_filial tbl_hfe) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  --constantes**********************************************
  --situacao do registro de cartao
  ct_st_recebido constant numeric := 1;
  ct_st_pendente_confirmacao constant numeric := 2; 
  ct_st_validado constant numeric := 3;
  ct_st_invalidado constant numeric := 4;
 
  --situacao de processamento do registro de cartao
  ct_st_prc_sucesso numeric := 0;
  ct_st_prc_nome_divergente numeric := 1;
  ct_st_prc_tipo_pessoa_divergente numeric := 2;

  --tipos de pessoas
  ct_pessoa_juridica constant char := 'J';
  ct_pessoa_fisica constant char := 'F';
  --********************************************************

  --variaveis***********************************************
  vl_rg sc_acc.tbl_rct%rowtype;
  
  vl_situacao numeric;
  vl_situacao_processamento numeric;
  vl_codigo_cun numeric;
  vl_codigo_funcionario numeric;
  vl_codigo_cartao numeric;
  vl_codigo_plastico numeric;
  vl_codigo_usuario numeric;
  --*********************************************************
begin
  select cast(vl_prm as numeric)
  into vl_codigo_usuario
  from sc_cad.tbl_prm
  where nm_prm = 'USUARIO ARQUIVO CADASTRO CARTAO';
  
  for vl_rg in select *
            from sc_acc.tbl_rct
            where cd_hdr = vp_dados_filial.cd_hdr
              and cd_hfe = vp_dados_filial.cd_hfe
              and st_rct = ct_st_recebido loop
    --verificando se existe cadastrao unico com o CPF/CNPJ informados
    if sc_acc.existe_cadastro_unico(vl_rg.nr_cpf_cnpj_rct) then
      --caso exista, valida os dados enviados no arquivo, com os dados ja cadastrados no banco 
      select *
      into vl_codigo_cun, vl_situacao, vl_situacao_processamento
      from sc_acc.valida_alteracao_cun(vl_rg);

      --se o registro não for valido passa pro proximo cartao
      if vl_situacao <> ct_st_validado then
        --atualizando os dados da tabela
        update sc_acc.tbl_rct
	      set st_rct = vl_situacao,
	          st_prc_rct = vl_situacao_processamento
	      where cd_rct = vl_rg.cd_rct;
      else
        --se o registro for valido procede com as alteracoes correspondentes
        perform sc_acc.altera_cun(vl_rg, vl_codigo_cun, vl_codigo_usuario);
      end if;      
    else
      --caso não exista, valida se os dados enviados no arquivo sao validos 
      select *
      into vl_situacao, vl_situacao_processamento
      from sc_acc.valida_inclusao_cun(vl_rg);

      --se o registro não for valido passa pro proximo registro
      if vl_situacao <> ct_st_validado then
        --atualizando os dados da tabela
        update sc_acc.tbl_rct
	      set st_rct = vl_situacao,
	          st_prc_rct = vl_situacao_processamento
	      where cd_rct = vl_rg.cd_rct;
      else
        --se o registro for valido procede com as inclusoes correspondentes
        select * 
        into vl_codigo_cun
        from sc_acc.inclui_cun(vl_rg, vl_codigo_usuario);
      end if;
    end if;

    if vl_situacao = ct_st_validado then
      --processando o(s) endereço(s) do cartão, que vieram no arquivo
      perform sc_acc.processa_endereco(vl_rg, vl_codigo_cun, vl_codigo_usuario);
    
      --processando o(s) telefone(s) do cartão, que vieram no arquivo
      if vl_rg.tp_pss_rct = ct_pessoa_fisica then
        perform sc_acc.processa_telefone_pf(vl_rg, vl_codigo_cun, vl_codigo_usuario);
      else
        perform sc_acc.processa_telefone_pj(vl_rg, vl_codigo_cun, vl_codigo_usuario);
      end if;
      
      --verificando se existe funcionario, o CPF/CNPJ, empresa e filial informados
      if sc_acc.existe_funcionario(vp_dados_filial, vl_rg) then
        --validando a inclusao do funcionario
        select *
        into vl_codigo_funcionario, vl_situacao, vl_situacao_processamento
        from sc_acc.valida_alteracao_funcionario(vp_dados_filial, vl_rg, vl_codigo_cun);
      
        --se o registro não for valido sai da rotina
        if vl_situacao <> ct_st_validado then
          --atualizando os dados da tabela
          update sc_acc.tbl_rct
	        set st_rct = vl_situacao,
	            st_prc_rct = vl_situacao_processamento
	        where cd_rct = vl_rg.cd_rct;
        end if;    
      else
        --validando a inclusao do funcionario
        select *
        into vl_situacao, vl_situacao_processamento
        from sc_acc.valida_inclusao_funcionario(vp_dados_filial, vl_rg, vl_codigo_cun);
    
        --se o registro não for valido sai da rotina
        if vl_situacao <> ct_st_validado then
          --atualizando os dados da tabela
          update sc_acc.tbl_rct
	        set st_rct = vl_situacao,
	            st_prc_rct = vl_situacao_processamento
	        where cd_rct = vl_rg.cd_rct;  
        else
          --incluindo um novo funcionario no banco de dados
          select *
          into vl_codigo_funcionario
          from sc_acc.inclui_funcionario(vp_dados_filial, vl_rg, vl_codigo_cun, vl_codigo_usuario);
        end if;
      end if;
    end if;
    
    if vl_situacao = ct_st_validado then
      --incluindo um novo cartao para o funcionario no banco de dados
      select *
      into vl_codigo_cartao, vl_codigo_plastico
      from sc_acc.inclui_cartao(vp_dados_filial, vl_rg, vl_codigo_cun, vl_codigo_usuario, vl_codigo_funcionario);
    
      --atualizando registro com o código do cartão e do plástico
      update sc_acc.tbl_rct
	    set cd_crt = vl_codigo_cartao,
	        cd_pls = vl_codigo_plastico,
	        st_rct = ct_st_validado,
	        st_prc_rct = ct_st_prc_sucesso
      where cd_rct = vl_rg.cd_rct;
    end if;
  end loop;
end;
$$;


ALTER FUNCTION sc_acc."processa_cartao_OLD"(vp_dados_filial tbl_hfe) OWNER TO scan;

--
-- TOC entry 7551 (class 0 OID 0)
-- Dependencies: 1713
-- Name: FUNCTION "processa_cartao_OLD"(vp_dados_filial tbl_hfe); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION "processa_cartao_OLD"(vp_dados_filial tbl_hfe) IS 'PROCESSA UM REGISTRO DE CARTAO DE UM DETERMINADO ARQUIVO';


--
-- TOC entry 1761 (class 1255 OID 563999)
-- Name: processa_endereco(tbl_rct, numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION processa_endereco(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg sc_acc.tbl_red%rowtype;
  
  ct_st_recebido constant numeric := 1;
  ct_st_pendente_confirmacao constant numeric := 2;
  ct_st_processado constant numeric := 3;
  ct_st_invalidado constant numeric := 4;
  
  ct_st_prc_sucesso constant numeric := 0;
  ct_st_prc_ja_existe_endereco constant numeric := 1;
  
  ct_situacao_ativo constant char := 'S';
  
  vl_existe numeric;
  vl_codigo_endereco numeric;
  vl_loc_eex varchar;
begin
  for vl_rg in select *
            from sc_acc.tbl_red
            where cd_hdr = vp_dados_cartao.cd_hdr
              and tp_pss_red = vp_dados_cartao.tp_pss_rct
              and nr_cpf_cnpj_red = vp_dados_cartao.nr_cpf_cnpj_rct
              and cd_crt_emp_red = vp_dados_cartao.cd_crt_emp_rct
              and st_red = ct_st_recebido loop
    select count(*)
    into vl_existe
    from sc_cad.tbl_edr
    where cd_cun = vp_codigo_cun
      and tp_edr = vl_rg.tp_edr_red
      and fg_atv_edr = 'S';
      
    if vl_existe > 0 then
      update sc_acc.tbl_red
         set st_red = ct_st_pendente_confirmacao,
             st_prc_red = ct_st_prc_ja_existe_endereco
      where cd_red = vl_rg.cd_red;
      
    else
      select nextval('sc_cad.sq_edr') into vl_codigo_endereco;

        if vl_rg.nr_red is null or vl_rg.cep_red is null then

           raise exception 'DADOS DO ENDERECO NAO INFORMAADO PARA %, CPF: %', vp_dados_cartao.nm_rct,vp_dados_cartao.nr_cpf_cnpj_rct ;
          
        end if;

    
      insert into sc_cad.tbl_edr(cd_edr, cd_cun, tp_edr, cep_edr, nr_edr, cpl_edr, fg_atv_edr, cd_inc_usr, dt_inc_usr)
      values(vl_codigo_endereco, vp_codigo_cun, vl_rg.tp_edr_red, vl_rg.cep_red, vl_rg.nr_red, vl_rg.cpl_red, ct_situacao_ativo, vp_codigo_usuario, current_timestamp);
    
      select count(*)
      into vl_existe
      from sc_crr.vw_crr crr
      where cep = vl_rg.cep_red
        and (crr.logradouro is not null and trim(crr.logradouro) != '');
    
      if vl_existe = 0 then
        
        if vl_rg.nm_loc_red is null then
          vl_loc_eex := 'FORTALEZA';
        else
          vl_loc_eex := vl_rg.nm_loc_red;
        end if; 

        if vl_rg.nm_brr_red is null or vl_rg.nm_log_red is null or vl_loc_eex is null or vl_rg.uf_red is null then

           raise exception 'DADOS DO ENDERECO NAO INFORMAADO PARA %, CPF: %', vp_dados_cartao.nm_rct,vp_dados_cartao.nr_cpf_cnpj_rct ;
          
        end if;
        
        insert into sc_cad.tbl_eex(cd_edr, nm_log_eex, nm_brr_eex, nm_loc_eex, uf_eex)
        values(vl_codigo_endereco, vl_rg.nm_log_red, vl_rg.nm_brr_red, vl_loc_eex, vl_rg.uf_red);
      end if;
    
      update sc_acc.tbl_red
         set st_red = ct_st_processado,
	     st_prc_red = ct_st_prc_sucesso,
	     cd_edr = vl_codigo_endereco
      where cd_red = vl_rg.cd_red;
    end if;
  end loop;
end;$$;


ALTER FUNCTION sc_acc.processa_endereco(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) OWNER TO scan;

--
-- TOC entry 7552 (class 0 OID 0)
-- Dependencies: 1761
-- Name: FUNCTION processa_endereco(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION processa_endereco(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) IS 'PROCESSA TODOS OS ENDERECOS DE UM DETERMINADO CPF/CNPJ DE UM DETERMINADO ARQUIVO';


--
-- TOC entry 1118 (class 1255 OID 564000)
-- Name: processa_filial(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION processa_filial(vp_codigo_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg sc_acc.tbl_hfe%rowtype;
  
  vl_situacao numeric;
  vl_situacao_processamento numeric;
  vl_existe numeric;

  --situacao de processamento do arquivo
  ct_st_prc_sucesso numeric := 0;
  ct_st_prc_cartao_invalido numeric := 4;
  
  --situacao do registro de header de filial
  ct_st_recebido constant numeric := 1;
  ct_st_invalidado constant numeric := 2; 
  ct_st_processado constant numeric := 3;
  
  --situacao do registro do cartao
  ct_st_rct_validado constant numeric := 3;
  ct_st_rct_pendente_confirmacao constant numeric := 2;

  -- flag de inclusao de cartao
  vl_incluir_cartao boolean := true;
begin
  for vl_rg in select *
            from sc_acc.tbl_hfe
            where cd_hdr = vp_codigo_arquivo
              and st_hfe = ct_st_recebido loop
    --validando os dados do registro de filial
    select *
    into vl_situacao, vl_situacao_processamento
    from sc_acc.valida_filial(vl_rg);
  
    --se o registro de filial for invalidado, marcar o registro de filial como invalido e sair da rotina
    if vl_situacao <> ct_st_processado then
      update sc_acc.tbl_hfe
         set st_hfe = vl_situacao,
             st_prc_hfe = vl_situacao_processamento
      where cd_hfe = vl_rg.cd_hfe;
      exit;
    end if;

    --verificando se o contrato da empresa eh necessario a inclusao do cartao
    select * 
    into vl_incluir_cartao
    from sc_acc.eh_pra_incluir_cartao(vl_rg);
  
    --processando todos os registros de cartao da filial
    perform sc_acc.processa_cartao(vl_rg, vl_incluir_cartao);

    --verificando se existe pelo menos um registro de cartao valido na filial
    select count(*)
    into vl_existe
    from sc_acc.tbl_rct
    where cd_hfe = vl_rg.cd_hfe
      and st_rct in (ct_st_rct_validado, ct_st_rct_pendente_confirmacao);
    
    if vl_existe = 0 then
      update sc_acc.tbl_hfe
         set st_hfe = ct_st_invalidado,
             st_prc_hfe = ct_st_prc_cartao_invalido
      where cd_hfe = vl_rg.cd_hfe;
    else
      update sc_acc.tbl_hfe
         set st_hfe = ct_st_processado,
             st_prc_hfe = ct_st_prc_sucesso
      where cd_hfe = vl_rg.cd_hfe;
    end if;
  end loop;
end;
$$;


ALTER FUNCTION sc_acc.processa_filial(vp_codigo_arquivo numeric) OWNER TO scan;

--
-- TOC entry 7553 (class 0 OID 0)
-- Dependencies: 1118
-- Name: FUNCTION processa_filial(vp_codigo_arquivo numeric); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION processa_filial(vp_codigo_arquivo numeric) IS 'PROCESSA TODOS AS FILIAIS DE UM DETERMINADO ARQUIVO';


--
-- TOC entry 1662 (class 1255 OID 564001)
-- Name: processa_telefone_pf(tbl_rct, numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION processa_telefone_pf(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg sc_acc.tbl_rtl%rowtype;
  
  ct_st_recebido constant numeric := 1;
  ct_st_pendente_confirmacao constant numeric := 2;
  ct_st_processado constant numeric := 3;
  ct_st_invalidado constant numeric := 4;
  
  ct_st_prc_sucesso constant numeric := 0;
  ct_st_prc_ja_existe_telefone constant numeric := 1;
  ct_st_prc_ddd_telefone_invalido constant numeric := 3;
  
  ct_origem_pessoa_fisica constant numeric := 1;
  
  ct_flag_ativo constant char := 'S'; 
  
  vl_existe numeric;
  vl_codigo_telefone numeric;

  vl_ddd_telefone numeric;
begin
  for vl_rg in select *
            from sc_acc.tbl_rtl
            where cd_hdr = vp_dados_cartao.cd_hdr
              and tp_pss_rtl = vp_dados_cartao.tp_pss_rct
              and nr_cpf_cnpj_rtl = vp_dados_cartao.nr_cpf_cnpj_rct
              and cd_crt_emp_rtl = vp_dados_cartao.cd_crt_emp_rct
              and st_rtl = ct_st_recebido loop
    select count(*)
    into vl_existe
    from sc_cad.tbl_tlf
    where nsu_org_tlf = vp_codigo_cun
      and tp_org_tlf = ct_origem_pessoa_fisica
      and tp_tlf = vl_rg.tp_tlf_rtl;

    vl_ddd_telefone := vl_rg.nr_ddd_rtl;
      
    if vl_existe > 0 then

      update sc_acc.tbl_rtl
         set st_rtl = ct_st_pendente_confirmacao,
             st_prc_rtl = ct_st_prc_ja_existe_telefone
      where cd_rtl = vl_rg.cd_rtl;
      
    else

      if vl_ddd_telefone = 0 then
         vl_ddd_telefone := 85;
      end if;

      if vl_ddd_telefone > 0 and  vl_rg.nr_tlf_rtl > 0 and length(vl_rg.nr_tlf_rtl::varchar) >= 8 then  

        select nextval('sc_cad.sq_tlf') into vl_codigo_telefone;
    
        insert into sc_cad.tbl_tlf(cd_tlf, nsu_org_tlf, tp_org_tlf, nr_ddd_tlf,
                                  nr_tlf, tp_tlf, fg_atv_tlf, cd_inc_usr, dt_inc_usr)
        values(vl_codigo_telefone, vp_codigo_cun, ct_origem_pessoa_fisica, vl_ddd_telefone, 
             vl_rg.nr_tlf_rtl, vl_rg.tp_tlf_rtl, ct_flag_ativo, vp_codigo_usuario, current_timestamp);

        update sc_acc.tbl_rtl
         set st_rtl = ct_st_processado,
             st_prc_rtl = ct_st_prc_sucesso,
             cd_tlf = vl_codigo_telefone
        where cd_rtl = vl_rg.cd_rtl;       

      else

        update sc_acc.tbl_rtl
         set st_rtl = ct_st_invalidado,
             st_prc_rtl = ct_st_prc_ddd_telefone_invalido
      where cd_rtl = vl_rg.cd_rtl;

      end if;
           
    end if;
  end loop;
end;$$;


ALTER FUNCTION sc_acc.processa_telefone_pf(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) OWNER TO scan;

--
-- TOC entry 7554 (class 0 OID 0)
-- Dependencies: 1662
-- Name: FUNCTION processa_telefone_pf(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION processa_telefone_pf(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) IS 'PROCESSA TODOS OS TELEFONES DE UM DETERMINADO CPF DE UM DETERMINADO ARQUIVO';


--
-- TOC entry 1114 (class 1255 OID 564002)
-- Name: processa_telefone_pj(tbl_rct, numeric, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION processa_telefone_pj(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg sc_acc.tbl_rtl%rowtype;
  
  ct_st_recebido constant numeric := 1;
  ct_st_pendente_confirmacao constant numeric := 2;
  ct_st_processado constant numeric := 3;
  ct_st_invalidado constant numeric := 4;
  
  ct_st_prc_sucesso constant numeric := 0;
  ct_st_prc_ja_existe_telefone constant numeric := 1;
  
  ct_origem_pessoa_juridica constant numeric := 2;
  
  ct_flag_ativo constant char := 'S'; 
  
  vl_existe numeric;
  vl_codigo_telefone numeric;
  vl_codigo_contato numeric;
begin
  for vl_rg in select *
            from sc_acc.tbl_rtl
            where cd_hdr = vp_dados_cartao.cd_hdr
              and tp_pss_rtl = vp_dados_cartao.tp_pss_rct
              and nr_cpf_cnpj_rtl = vp_dados_cartao.nr_cpf_cnpj_rct
              and cd_crt_emp_rtl = vp_dados_cartao.cd_crt_emp_rct
              and st_rtl = ct_st_recebido loop
    select count(*)
    into vl_existe
    from sc_cad.tbl_tlf tlf
         inner join sc_cad.tbl_ctt ctt on tlf.nsu_org_tlf = ctt.cd_ctt and tlf.tp_org_tlf = ct_origem_pessoa_juridica
    where ctt.cd_cun = vp_codigo_cun
      and tlf.tp_org_tlf = ct_origem_pessoa_juridica
      and tlf.tp_tlf = vl_rg.tp_tlf_rtl
      and ctt.fg_atv_ctt = ct_flag_ativo;
      
    if vl_existe > 0 then
      update sc_acc.tbl_rtl
         set st_rtl = ct_st_pendente_confirmacao,
             st_prc_rtl = ct_st_prc_ja_existe_telefone
      where cd_rtl = vl_rg.cd_rtl;
    else
      select count(*)
      into vl_existe
      from sc_cad.tbl_ctt ctt
      where ctt.cd_cun = vp_codigo_cun
        and ctt.fg_atv_ctt = ct_flag_ativo;
      
      if vl_existe > 0 then
        select max(cd_ctt)
        into vl_codigo_contato
        from sc_cad.tbl_ctt ctt
        where ctt.cd_cun = vp_codigo_cun
          and ctt.fg_atv_ctt = ct_flag_ativo;
      else
        select nextval('sc_cad.sq_ctt') into vl_codigo_contato;
        insert into sc_cad.tbl_ctt(cd_ctt, cd_cun, nm_ctt, fg_atv_ctt, cd_inc_usr, dt_inc_usr)
        values(vl_codigo_contato, vp_codigo_cun, 'CONTATO ARQUIVO CADASTRO', ct_flag_ativo, vp_codigo_usuario, current_timestamp);
      end if;
      
      select nextval('sc_cad.sq_tlf') into vl_codigo_telefone;
    
      insert into sc_cad.tbl_tlf(cd_tlf, nsu_org_tlf, tp_org_tlf, nr_ddd_tlf,
                                 nr_tlf, tp_tlf, fg_atv_tlf, cd_inc_usr, dt_inc_usr)
      values(vl_codigo_telefone, vl_codigo_contato, ct_origem_pessoa_juridica, vl_rg.nr_ddd_rtl, 
             vl_rg.nr_tlf_rtl, vl_rg.tp_tlf_rtl, ct_flag_ativo, vp_codigo_usuario, current_timestamp);
           
      update sc_acc.tbl_rtl
         set st_rtl = ct_st_processado,
             st_prc_rtl = ct_st_prc_sucesso,
             cd_tlf = vl_codigo_telefone
      where cd_rtl = vl_rg.cd_rtl;
    end if;
  end loop;
end;$$;


ALTER FUNCTION sc_acc.processa_telefone_pj(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) OWNER TO scan;

--
-- TOC entry 7555 (class 0 OID 0)
-- Dependencies: 1114
-- Name: FUNCTION processa_telefone_pj(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric); Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON FUNCTION processa_telefone_pj(vp_dados_cartao tbl_rct, vp_codigo_cun numeric, vp_codigo_usuario numeric) IS 'PROCESSA TODOS OS TELEFONES DE UM DETERMINADO CPF DE UM DETERMINADO ARQUIVO';


--
-- TOC entry 1117 (class 1255 OID 564003)
-- Name: valida_alteracao_cun(tbl_rct); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION valida_alteracao_cun(vp_dados_cartao tbl_rct, OUT vp_codigo_cun numeric, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare
   --situacao do registro de cartao
  ct_st_recebido constant numeric := 1;
  ct_st_pendente_confirmacao constant numeric := 2; 
  ct_st_validado constant numeric := 3;
  ct_st_invalidado constant numeric := 4;
 
  --situacao de processamento do registro de cartao
  ct_st_prc_sucesso numeric := 0;
  ct_st_prc_nome_divergente numeric := 1;
  ct_st_prc_tp_pessoa_divergente numeric := 2;
  
  vl_nome character varying;
  vl_tipo_pessoa character varying;
begin
  --sendo otimista e setando as variaveis como se tudo fosse dar certo
  vp_situacao := ct_st_validado;
  vp_situacao_processamento := ct_st_prc_sucesso;

  --obtendo os dados do cpf/cnpj no banco de dados
  select nm_cun, tp_pss_cun, cd_cun
  into vl_nome, vl_tipo_pessoa, vp_codigo_cun
  from sc_cad.tbl_cun
  where nr_cpf_cnpj_cun = vp_dados_cartao.nr_cpf_cnpj_rct;
  
  
  --se o nome que veio no arquivo for diferente do nome cadastrado no sistema, alterar o registro para pendente de confirmação
  if trim(vl_nome) <> trim(vp_dados_cartao.nm_rct) then
    vp_situacao := ct_st_pendente_confirmacao;
    vp_situacao_processamento := ct_st_prc_nome_divergente;
  elsif vl_tipo_pessoa <> vp_dados_cartao.tp_pss_rct then
    vp_situacao := ct_st_pendente_confirmacao;
    vp_situacao_processamento := ct_st_prc_tp_pessoa_divergente;
  end if;
end;
$$;


ALTER FUNCTION sc_acc.valida_alteracao_cun(vp_dados_cartao tbl_rct, OUT vp_codigo_cun numeric, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) OWNER TO scan;

--
-- TOC entry 1122 (class 1255 OID 564004)
-- Name: valida_alteracao_funcionario(tbl_hfe, tbl_rct, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION valida_alteracao_funcionario(vp_dados_filial tbl_hfe, vp_dados_cartao tbl_rct, vp_codigo_cun numeric, OUT vp_codigo_funcionario numeric, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare
   --situacao do registro de cartao
  ct_st_recebido constant numeric := 1;
  ct_st_pendente_confirmacao constant numeric := 2; 
  ct_st_validado constant numeric := 3;
  ct_st_invalidado constant numeric := 4;
 
  --situacao de processamento do registro de cartao
  ct_st_prc_sucesso numeric := 0;
  ct_st_prc_existe_cartao numeric := 8;
  
  --situacao do funcionario
  ct_st_fnc_ativo numeric := 1;
  
  vl_existe numeric;
begin
  --sendo otimista e setando as variaveis como se tudo fosse dar certo
  vp_situacao := ct_st_validado;
  vp_situacao_processamento := ct_st_prc_sucesso;
  
  --obtendo o codigo do funcionario
  select cd_fnc
  into vp_codigo_funcionario
  from sc_cad.tbl_fnc
  where cd_cun = vp_codigo_cun
    and cd_emp = vp_dados_filial.cd_emp
    and cd_fem = vp_dados_filial.cd_fem
    and st_fnc = ct_st_fnc_ativo
    and nr_idt_fnc = vp_dados_cartao.cd_crt_emp_rct;
  
  --verificando se existe um cartao para o funcionario no mesmo produto que esta querendo incluir
  select count(*)
  into vl_existe
  from sc_opr.tbl_crt
  where cd_fnc = vp_codigo_funcionario
    and cd_prd = vp_dados_filial.cd_prd;
  
  --se ja existe cartão nao pode ser feita a inclusão de um novo cartão para o mesmo produto
  if vl_existe > 0 then
    vp_situacao := ct_st_invalidado;
    vp_situacao_processamento := ct_st_prc_existe_cartao;
  end if;
end;
$$;


ALTER FUNCTION sc_acc.valida_alteracao_funcionario(vp_dados_filial tbl_hfe, vp_dados_cartao tbl_rct, vp_codigo_cun numeric, OUT vp_codigo_funcionario numeric, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) OWNER TO scan;

--
-- TOC entry 1125 (class 1255 OID 564005)
-- Name: valida_arquivo(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION valida_arquivo(vp_codigo_arquivo numeric, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare
   --situacao do registro do header do arquivo
  ct_st_recebido constant numeric := 1;
  ct_st_invalidado constant numeric := 2; 
  ct_st_processado constant numeric := 3;
 
  --situacao de processamento do registro de arquivo
  ct_st_prc_sucesso numeric := 0;
  ct_st_prc_nr_filial_diferente numeric := 1;
  ct_st_prc_trailler_inexistente numeric := 3;
  
  vl_existe numeric;
  vl_nr_reg_filial_trailler numeric;
  vl_nr_reg_filial numeric;
begin
  --sendo otimista e setando as variaveis como se tudo fosse dar certo
  vp_situacao := ct_st_processado;
  vp_situacao_processamento := ct_st_prc_sucesso;

  --verificando se ja existe trailler para o arquivo
  select count(*)
  into vl_existe
  from sc_acc.tbl_trl
  where cd_hdr = vp_codigo_arquivo;
  
  --se nao existe trailler para o arquivo, marcar o arquivo como invalidado
  if vl_existe = 0 then
    vp_situacao := ct_st_invalidado;
    vp_situacao_processamento := ct_st_prc_trailler_inexistente;
  else
	  --obtendo o numero de registros de filial presente no trailler do arquivo
	  select nr_reg_fem_trl
	  into vl_nr_reg_filial_trailler
	  from sc_acc.tbl_trl
	  where cd_hdr = vp_codigo_arquivo;
	
	  --obtendo o numero de registros filial
	  select count(*)
	  into vl_nr_reg_filial
	  from sc_acc.tbl_hfe
	  where cd_hdr = vp_codigo_arquivo;
	    
	  --comparando o numero de registros de filial do trailler com o numero de registros de filial presentes no banco de dados para o arquivo
	  if vl_nr_reg_filial <> vl_nr_reg_filial_trailler then
	    vp_situacao := ct_st_invalidado;
	    vp_situacao_processamento := ct_st_prc_nr_filial_diferente;
	  end if;
  end if;
end;
$$;


ALTER FUNCTION sc_acc.valida_arquivo(vp_codigo_arquivo numeric, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) OWNER TO scan;

--
-- TOC entry 1126 (class 1255 OID 564006)
-- Name: valida_cnpj(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION valida_cnpj(vp_cnpj numeric) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
 v_caldv1 int4;
 v_caldv2 int4;
 v_dv1 int4;
 v_dv2 int4;
 v_array1 text[] ;
 v_array2 text[] ;
 v_tst_string int4;
 vl_cnpj varchar(14);
BEGIN
  vl_cnpj := cast(vp_cnpj as varchar);
  
  -- preenchendo a variavel de cpf com zeros a esquerda ate completar 11 digitos 
  while char_length(vl_cnpj) < 14 loop
    vl_cnpj := '0' || vl_cnpj;
  end loop;
  
  SELECT INTO v_array1 '{5,4,3,2,9,8,7,6,5,4,3,2}';
  SELECT INTO v_array2 '{6,5,4,3,2,9,8,7,6,5,4,3,2}';
  v_dv1 := (substring(vl_cnpj, 13, 1))::int4;
  v_dv2 := (substring(vl_cnpj, 14, 1))::int4;
  
  /* COLETA DIG VER 1 CNPJ */
  v_caldv1 := 0;
  FOR va IN 1..12 LOOP
    v_caldv1 := v_caldv1 + ((SELECT substring(vl_cnpj, va, 1))::int4 * (v_array1[va]::int4));
  END LOOP;

  v_caldv1 := v_caldv1 % 11;
  
  IF (v_caldv1 = 0) OR (v_caldv1 = 1) THEN
    v_caldv1 := 0;
  ELSE
    v_caldv1 := 11 - v_caldv1;
  END IF;
  
  /* COLETA DIG VER 2 CNPJ */
  v_caldv2 := 0;
  FOR va IN 1..13 LOOP
    v_caldv2 := v_caldv2 + ((SELECT substring(vl_cnpj || v_caldv1::text, va, 1))::int4 * (v_array2[va]::int4));
  END LOOP;
  
  v_caldv2 := v_caldv2 % 11;
  IF (v_caldv2 = 0) OR (v_caldv2 = 1) THEN
    v_caldv2 := 0;
  ELSE
    v_caldv2 := 11 - v_caldv2;
  END IF;
  
  /* TESTA */
  IF (v_caldv1 = v_dv1) AND (v_caldv2 = v_dv2) THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
end;
$$;


ALTER FUNCTION sc_acc.valida_cnpj(vp_cnpj numeric) OWNER TO scan;

--
-- TOC entry 1127 (class 1255 OID 564007)
-- Name: valida_cpf(numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION valida_cpf(vp_cpf numeric) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- ROTINA DE VALIDAÇÃO DE CPF
-- Conversão para o PL/ PGSQL: Cláudio Leopoldino - http://postgresqlbr.blogspot.com/
-- Algoritmo original: http://webmasters.neting.com/msg07743.html
-- Retorna 1 para CPF correto.
DECLARE
  x real;
  y real; --Variável temporária
  soma integer;
  dig1 integer; --Primeiro dígito do CPF
  dig2 integer; --Segundo dígito do CPF
  len integer; -- Tamanho do CPF
  contloop integer; --Contador para loop
  vl_cpf varchar(11);
BEGIN
  vl_cpf := cast(vp_cpf as varchar);
  
  -- preenchendo a variavel de cpf com zeros a esquerda ate completar 11 digitos 
  while char_length(vl_cpf) < 11 loop
    vl_cpf := '0' || vl_cpf;
  end loop;
  
  -- Inicialização
  x := 0;
  soma := 0;
  dig1 := 0;
  dig2 := 0;
  contloop := 0;
  len := char_length(vl_cpf);
  x := len -1;
  
  --Loop de multiplicação - dígito 1
  contloop :=1;
  WHILE contloop <= (len -2) LOOP
    y := CAST(substring(vl_cpf from contloop for 1) AS NUMERIC);
    soma := soma + ( y * x);
    x := x - 1;
    contloop := contloop +1;
  END LOOP;
  
  dig1 := 11 - CAST((soma % 11) AS INTEGER);
  if (dig1 = 10) THEN dig1 :=0 ; END IF;
  if (dig1 = 11) THEN dig1 :=0 ; END IF;

  -- Dígito 2
  x := 11; soma :=0;
  contloop :=1;
  WHILE contloop <= (len -1) LOOP
    soma := soma + CAST((substring(vl_cpf FROM contloop FOR 1)) AS REAL) * x;
    x := x - 1;
    contloop := contloop +1;
  END LOOP;
  
  dig2 := 11 - CAST ((soma % 11) AS INTEGER);
  IF (dig2 = 10) THEN dig2 := 0; END IF;
  IF (dig2 = 11) THEN dig2 := 0; END IF;
  
  --Teste do CPF
  IF ((dig1 || '' || dig2) = substring(vl_cpf FROM len-1 FOR 2)) THEN
    RETURN true;
  ELSE
    return false;
  END IF;
END;
$$;


ALTER FUNCTION sc_acc.valida_cpf(vp_cpf numeric) OWNER TO scan;

--
-- TOC entry 1134 (class 1255 OID 564008)
-- Name: valida_email(character varying); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION valida_email(vp_email character varying) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
  vl_pos_arroba integer;
  vl_pos_1_ponto integer;
  vl_pos_2_ponto integer;
  vl_pos_espaco integer;
  
  vl_email varchar;
begin
  --retirando os espacos no inicio e no final do e-mail
  vl_email := trim(vp_email);
  if length(vl_email) < 8 then
    return false;
  end if;
  
  --verificando se existe espaco no meio do e-mail, se tiver retorna invalido
  vl_pos_espaco := instr(vl_email, ' ');
  if vl_pos_espaco > 0 then
    return false;
  end if;
  
  --verificando se existe @ no meio do e-mail, se não tiver retorna invalido
  vl_pos_arroba := instr(vl_email, '@');
  if vl_pos_arroba <= 0 then
    return false;
  end if;
  
  --verificando se existe . apos a @ no e-mail, se não tiver retorna invalido
  vl_pos_1_ponto := instr(vl_email, '.', vl_pos_arroba+1);
  if vl_pos_1_ponto <= 0 then
    return false;
  end if;
  
  --verificando se existe um segundo . apos o primeiro . no e-mail, 
  --se tiver deve estar a dois caracteres antes do final do e-mail e três caracteres depois do primeiro ponto
  vl_pos_2_ponto := instr(vl_email, '.', vl_pos_1_ponto+1);
  if vl_pos_2_ponto > 0 and (vl_pos_2_ponto <> length(vl_email) - 2 or vl_pos_1_ponto <> vl_pos_2_ponto - 4) then
    return false;
  end if;
  
  --senão tiver o primeiro ponto deve estar a três caracteres antes do final do e-mail
  if vl_pos_2_ponto <= 0 and vl_pos_1_ponto <> length(vl_email) - 3 then
    return false;
  end if;
  
  return true;
end;$$;


ALTER FUNCTION sc_acc.valida_email(vp_email character varying) OWNER TO scan;

--
-- TOC entry 1135 (class 1255 OID 564009)
-- Name: valida_filial(tbl_hfe); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION valida_filial(vp_dados_filial tbl_hfe, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare
   --situacao do registro do header de filial
  ct_st_recebido constant numeric := 1;
  ct_st_invalidado constant numeric := 2; 
  ct_st_processado constant numeric := 3;
 
  --situacao de processamento do header de filial
  ct_st_prc_sucesso numeric := 0;
  ct_st_prc_nr_cartao_diferente numeric := 1;
  ct_st_prc_nr_endereco_diferente numeric := 2;
  ct_st_prc_nr_telefone_diferente numeric := 3;
  ct_st_prc_trailler_inexistente numeric := 5;
  ct_st_prc_cpf_cnpj_diferente numeric := 6;
  ct_st_prc_tipo_pessoa_diferente numeric := 7;
  ct_st_prc_contrato_inexistente numeric := 8;
  
  vl_existe numeric;
  vl_nr_reg_cartao_trailler numeric;
  vl_nr_reg_endereco_trailler numeric;
  vl_nr_reg_telefone_trailler numeric;
  vl_nr_reg numeric;
  vl_cpf_cnpj_filial numeric;
  vl_tipo_pessoa_filial char;
begin
  --sendo otimista e setando as variaveis como se tudo fosse dar certo
  vp_situacao := ct_st_processado;
  vp_situacao_processamento := ct_st_prc_sucesso;

  --obtendo o cpf/cnpj e o tipo de pessoa da filial no banco de dados
  select cun.tp_pss_cun, cun.nr_cpf_cnpj_cun
  into vl_tipo_pessoa_filial, vl_cpf_cnpj_filial
  from sc_cad.tbl_fem fem
       inner join sc_cad.tbl_cun cun on fem.cd_cun = cun.cd_cun
  where fem.cd_emp = vp_dados_filial.cd_emp
    and fem.cd_fem = vp_dados_filial.cd_fem;
    
  --verificando se o cpf/cnpj da filial que veio no arquivo é igual ao cpf/cnpj da filial cadastrado no banco de dados
  if vl_cpf_cnpj_filial <> vp_dados_filial.nr_cpf_cnpj_hfe then
    vp_situacao := ct_st_invalidado;
    vp_situacao_processamento := ct_st_prc_cpf_cnpj_diferente;
  else
    --verificando se o tipo de pessoa da filial que veio no arquivo é igual ao tipo de pessoa da filial cadastrado no banco de dados
	  if vl_tipo_pessoa_filial <> vp_dados_filial.tp_pss_hfe then
	    vp_situacao := ct_st_invalidado;
	    vp_situacao_processamento := ct_st_prc_tipo_pessoa_diferente;
	  else
		  --verificando se ja existe trailler para o arquivo
		  select count(*)
		  into vl_existe
		  from sc_acc.tbl_tfe
		  where cd_hfe = vp_dados_filial.cd_hfe;
		  
		  --se nao existe trailler para o arquivo, marcar o arquivo como invalidado
		  if vl_existe = 0 then
		    vp_situacao := ct_st_invalidado;
		    vp_situacao_processamento := ct_st_prc_trailler_inexistente;
			else
			  --obtendo o numero de registros de cartao, endereco e telefone presente no trailler do arquivo
			  select nr_reg_crt_tfe, nr_reg_edr_tfe, nr_reg_tlf_tfe
			  into vl_nr_reg_cartao_trailler, vl_nr_reg_endereco_trailler, vl_nr_reg_telefone_trailler 
			  from sc_acc.tbl_tfe
			  where cd_hfe = vp_dados_filial.cd_hfe;
			
			  --obtendo o numero de registros cartao no banco de dados
			  select count(*)
			  into vl_nr_reg
			  from sc_acc.tbl_rct
			  where cd_hfe = vp_dados_filial.cd_hfe;
			    
			  --comparando o numero de registros de cartao do trailler com o numero de registros de cartao presentes no banco de dados para o arquivo
			  if vl_nr_reg <> vl_nr_reg_cartao_trailler then
			    vp_situacao := ct_st_invalidado;
			    vp_situacao_processamento := ct_st_prc_nr_cartao_diferente;
				else
				  --obtendo o numero de registros cartao no banco de dados
				  select count(*)
				  into vl_nr_reg
				  from sc_acc.tbl_red
				  where cd_hfe = vp_dados_filial.cd_hfe;
				    
				  --comparando o numero de registros de endereco do trailler com o numero de registros de endereco presentes no banco de dados para o arquivo
				  if vl_nr_reg <> vl_nr_reg_endereco_trailler then
				    vp_situacao := ct_st_invalidado;
				    vp_situacao_processamento := ct_st_prc_nr_endereco_diferente;
				  else
					  --obtendo o numero de registros cartao no banco de dados
					  select count(*)
					  into vl_nr_reg
					  from sc_acc.tbl_rtl
					  where cd_hfe = vp_dados_filial.cd_hfe;
					    
					  --comparando o numero de registros de telefone do trailler com o numero de registros de telefone presentes no banco de dados para o arquivo
					  if vl_nr_reg <> vl_nr_reg_telefone_trailler then
					    vp_situacao := ct_st_invalidado;
					    vp_situacao_processamento := ct_st_prc_nr_telefone_diferente;
					  else
						  --verificando se existe contrato para a empresa, filial e produto
						  if not sc_acc.existe_contrato(vp_dados_filial) then
						    vp_situacao := ct_st_invalidado;
						    vp_situacao_processamento := ct_st_prc_contrato_inexistente;
						  end if;
					  end if;
				  end if;
			  end if;
		  end if;
	  end if;
  end if;
end;
$$;


ALTER FUNCTION sc_acc.valida_filial(vp_dados_filial tbl_hfe, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) OWNER TO scan;

--
-- TOC entry 1625 (class 1255 OID 564010)
-- Name: valida_inclusao_cun(tbl_rct); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION valida_inclusao_cun(vp_dados_cartao tbl_rct, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare
  --situacao do registro de cartao
  ct_st_recebido constant numeric := 1;
  ct_st_pendente_confirmacao constant numeric := 2; 
  ct_st_validado constant numeric := 3;
  ct_st_invalidado constant numeric := 4;
 
  --situacao de processamento do registro de cartao
  ct_st_prc_sucesso numeric := 0;
  ct_st_prc_nome_divergente numeric := 1;
  ct_st_prc_tp_pessoa_divergente numeric := 2;
  ct_st_prc_cpf_invalido numeric := 3;
  ct_st_prc_nome_invalido numeric := 4;
  ct_st_prc_cnpj_invalido numeric := 5;
  ct_st_prc_muito_velho numeric := 6;
  ct_st_prc_muito_novo numeric := 7;
  ct_st_prc_sem_rg numeric := 14;
  
  --tipos de pessoas
  ct_pessoa_juridica constant char := 'J';
  ct_pessoa_fisica constant char := 'F';
begin
  --sendo otimista e setando as variaveis como se tudo fosse dar certo
  vp_situacao := ct_st_validado;
  vp_situacao_processamento := ct_st_prc_sucesso;
  
  --validando se o nome tem mais de 6 caracteres
  if char_length(trim(vp_dados_cartao.nm_rct)) < 6 then
    vp_situacao := ct_st_invalidado;
    vp_situacao_processamento := ct_st_prc_nome_invalido;
  else
	  --validando se o cpf e cnpj sao validos
	  if vp_dados_cartao.tp_pss_rct = ct_pessoa_fisica then 
			if not sc_acc.valida_cpf(vp_dados_cartao.nr_cpf_cnpj_rct) then
			  vp_situacao := ct_st_invalidado;
			  vp_situacao_processamento := ct_st_prc_cpf_invalido;
			else
			  if extract(year from age(current_date, vp_dados_cartao.dt_nsc_rct)) > 90 then
				  vp_situacao := ct_st_invalidado;
				  vp_situacao_processamento := ct_st_prc_muito_velho;
			  elsif extract(year from age(current_date, vp_dados_cartao.dt_nsc_rct)) < 14 then
			    vp_situacao := ct_st_invalidado;
				  vp_situacao_processamento := ct_st_prc_muito_novo;
                          else
                            if vp_dados_cartao.rg_rct is null or vp_dados_cartao.rg_rct <= 0 then
                              vp_situacao := ct_st_invalidado;
			      vp_situacao_processamento := ct_st_prc_sem_rg;
			    else
			        -- validando dados da pessoa fisica
				select *
				  into vp_situacao, vp_situacao_processamento
				from sc_acc.valida_inclusao_pf(vp_dados_cartao);  
				
                            end if;
			  end if;
			end if;

		else
		  if not sc_acc.valida_cnpj(vp_dados_cartao.nr_cpf_cnpj_rct) then
			  vp_situacao := ct_st_invalidado;
			  vp_situacao_processamento := ct_st_prc_cnpj_invalido;
			end if;
	  end if;
  end if;
end;
$$;


ALTER FUNCTION sc_acc.valida_inclusao_cun(vp_dados_cartao tbl_rct, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) OWNER TO scan;

--
-- TOC entry 1138 (class 1255 OID 564011)
-- Name: valida_inclusao_funcionario(tbl_hfe, tbl_rct, numeric); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION valida_inclusao_funcionario(vp_dados_filial tbl_hfe, vp_dados_cartao tbl_rct, vp_codigo_cun numeric, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare
   --situacao do registro de cartao
  ct_st_recebido constant numeric := 1;
  ct_st_pendente_confirmacao constant numeric := 2; 
  ct_st_validado constant numeric := 3;
  ct_st_invalidado constant numeric := 4;
 
  --situacao de processamento do registro de cartao
  ct_st_prc_sucesso numeric := 0;
  ct_st_prc_existe_func_ativo numeric := 9;
  ct_st_prc_existe_func_identificador numeric := 10;
  ct_st_prc_sem_endereco numeric := 15;
  
  --situacao do funcionario
  ct_st_fnc_ativo numeric := 1;
  
  vl_existe numeric;
begin
  --sendo otimista e setando as variaveis como se tudo fosse dar certo
  vp_situacao := ct_st_validado;
  vp_situacao_processamento := ct_st_prc_sucesso;

  --verificando se ja existe algum funcionario ativo, para o mesmo cadastro unico, empresa e filial
  select count(*)
  into vl_existe
  from sc_cad.tbl_fnc
  where cd_cun = vp_codigo_cun
    and cd_emp = vp_dados_filial.cd_emp
    and cd_fem = vp_dados_filial.cd_fem
    and st_fnc = ct_st_fnc_ativo;
  
  --se ja existe funcionario nao pode ser feita a inclusão de um novo funcionario
  if vl_existe > 0 then
    vp_situacao := ct_st_invalidado;
    vp_situacao_processamento := ct_st_prc_existe_func_ativo;
  else
	  --verificando se ja existe algum funcionario, para o mesmo identificador do cartão, empresa e filial
	  select count(*)
	  into vl_existe
	  from sc_cad.tbl_fnc
	  where nr_idt_fnc = vp_dados_cartao.cd_crt_emp_rct
	    and cd_emp = vp_dados_filial.cd_emp
	    and cd_fem = vp_dados_filial.cd_fem;
	    
	  --se ja existe funcionario nao pode ser feita a inclusão de um novo funcionario
	  if vl_existe > 0 then
	    vp_situacao := ct_st_invalidado;
	    vp_situacao_processamento := ct_st_prc_existe_func_identificador;
          else
            --verificando se o funcionario possui endereco cadastrado
            select count(*)
	    into vl_existe
	    from sc_cad.tbl_edr
	    where cd_cun = vp_codigo_cun
	      and fg_atv_edr = 'S';

	    if vl_existe = 0 then
	      vp_situacao := ct_st_invalidado;
	      vp_situacao_processamento := ct_st_prc_sem_endereco;
	    end if;
	  end if;
  end if;
end;
$$;


ALTER FUNCTION sc_acc.valida_inclusao_funcionario(vp_dados_filial tbl_hfe, vp_dados_cartao tbl_rct, vp_codigo_cun numeric, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) OWNER TO scan;

--
-- TOC entry 1139 (class 1255 OID 564012)
-- Name: valida_inclusao_pf(tbl_rct); Type: FUNCTION; Schema: sc_acc; Owner: scan
--

CREATE FUNCTION valida_inclusao_pf(vp_dados_cartao tbl_rct, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare
  --situacao do registro de cartao
  ct_st_recebido constant numeric := 1;
  ct_st_pendente_confirmacao constant numeric := 2; 
  ct_st_validado constant numeric := 3;
  ct_st_invalidado constant numeric := 4;
 
  --situacao de processamento do registro de cartao
  ct_st_prc_sucesso numeric := 0;
  ct_st_prc_naturalidade_sem_localidade numeric := 16;
  ct_st_prc_dados_cadastrais_incompleto numeric := 17;
  
  --variaveis de controle local
  vl_existe numeric := 0;
  vl_naturalidade sc_acc.tbl_rct.ds_nat_rct%type;
  
begin
  --sendo otimista e setando as variaveis como se tudo fosse dar certo
  vp_situacao := ct_st_validado;
  vp_situacao_processamento := ct_st_prc_sucesso;

  -- validando dados cadastrais
  if vp_dados_cartao.nr_cpf_cnpj_rct is null or
     vp_dados_cartao.nm_rct is null or
     vp_dados_cartao.rg_rct is null or
     vp_dados_cartao.dt_nsc_rct is null or
     vp_dados_cartao.nm_mae_rct is null or  
     vp_dados_cartao.fg_sex_rct is null or  
     vp_dados_cartao.dt_ems_rg_rct is null or  
     vp_dados_cartao.nm_org_ems_rg_rct is null or  
     vp_dados_cartao.cd_est_rct is null or  
     vp_dados_cartao.ds_nat_rct is null or  
     vp_dados_cartao.ds_nac_rct is null
  then
    vp_situacao_processamento := ct_st_prc_dados_cadastrais_incompleto;
  end if;


  if vp_dados_cartao.ds_nat_rct is not null then

    vl_naturalidade := upper(trim(sc_pbl.sem_acento(vp_dados_cartao.ds_nat_rct)));

    select 1
      into vl_existe
    from sc_crr.vw_crr
    where localidade = vl_naturalidade
    limit 1;

    vl_existe := coalesce(vl_existe,0);
    
    if vl_existe = 0 then

      vp_situacao := ct_st_invalidado;
      vp_situacao_processamento := ct_st_prc_naturalidade_sem_localidade;

    end if;
    
  else

    vp_situacao := ct_st_invalidado;
    vp_situacao_processamento := ct_st_prc_naturalidade_sem_localidade; 

  end if;
  
end;
$$;


ALTER FUNCTION sc_acc.valida_inclusao_pf(vp_dados_cartao tbl_rct, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) OWNER TO scan;

SET search_path = sc_ace, pg_catalog;

--
-- TOC entry 1140 (class 1255 OID 564013)
-- Name: atualiza_arquivo(numeric, numeric); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION atualiza_arquivo(vp_codigo numeric, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  
begin
  -- 1. atualizando o codigo do usuario que importou o arquivo
  update sc_ace.tbl_hdr_oboe 
     set cd_rcb_usr = vp_usuario
  where cd_hdr_oboe = vp_codigo;
  
end;$$;


ALTER FUNCTION sc_ace.atualiza_arquivo(vp_codigo numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 7556 (class 0 OID 0)
-- Dependencies: 1140
-- Name: FUNCTION atualiza_arquivo(vp_codigo numeric, vp_usuario numeric); Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON FUNCTION atualiza_arquivo(vp_codigo numeric, vp_usuario numeric) IS 'ROTINA QUE ATUALIZA OS DADOS DO ARQUIVO';


--
-- TOC entry 1141 (class 1255 OID 564014)
-- Name: atualizar_dados_nacionalidade(); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION atualizar_dados_nacionalidade() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin
  for rg in select distinct nr_cpf_det_oboe as cpf, ds_nat_det_oboe as naturalidade, ds_nac_det_oboe as nacionalidade, cd_est_det_oboe as estado_civil
            from sc_ace.tbl_det_oboe
            where ds_nat_det_oboe is not null
              and ds_nac_det_oboe is not null
              and cd_est_det_oboe is not null
              and nr_cpf_det_oboe > 0
            order by nr_cpf_det_oboe loop

    update sc_cad.tbl_cpf set 
      ds_nat_cpf = upper(rg.naturalidade),
      ds_nac_cpf = upper(rg.nacionalidade),
      cd_est_civil_cpf = rg.estado_civil
    where cd_cun in (select cd_cun from sc_cad.tbl_cun where nr_cpf_cnpj_cun = rg.cpf);

  end loop;
end;$$;


ALTER FUNCTION sc_ace.atualizar_dados_nacionalidade() OWNER TO scan;

--
-- TOC entry 1142 (class 1255 OID 564015)
-- Name: atualizar_dados_rg(); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION atualizar_dados_rg() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin
  for rg in select distinct nr_cpf_det_oboe as cpf, dt_ems_rg_det_oboe as data, nm_org_ems_rg_det_oboe as orgao, uf_org_ems_rg_det_oboe as uf
            from sc_ace.tbl_det_oboe
            where nm_org_ems_rg_det_oboe is not null
              and dt_ems_rg_det_oboe is not null
              and uf_org_ems_rg_det_oboe is not null
              and nr_cpf_det_oboe > 0
            order by nr_cpf_det_oboe loop

    update sc_cad.tbl_cpf set 
      dt_ems_rg_cpf = rg.data,
      nm_org_ems_rg_cpf = rg.orgao,
      uf_org_ems_rg_cpf = rg.uf
    where cd_cun in (select cd_cun from sc_cad.tbl_cun where nr_cpf_cnpj_cun = rg.cpf);

  end loop;
end;$$;


ALTER FUNCTION sc_ace.atualizar_dados_rg() OWNER TO scan;

--
-- TOC entry 1588 (class 1255 OID 564016)
-- Name: gravar_header(numeric); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION gravar_header(vp_codigo_arquivo numeric, OUT vp_arquivo numeric, OUT vp_arquivo_filial numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare
  vl_empresa  numeric(5,0);
  vl_filial	  numeric(5,0);
  vl_cpf_cnpj numeric(14,0);
  vl_tp_pss	  varchar(1);
  vl_usuario  numeric(10,0);
  vl_produto numeric;
  
  ct_st_recebido constant numeric := 1;
  ct_produto_pagamento constant numeric := 1;
begin

   select hdr.cd_tp_arq, emp.cd_emp, fem.cd_fem, cun.tp_pss_cun, cun.nr_cpf_cnpj_cun, cd_rcb_usr
      into vl_produto, vl_empresa, vl_filial, vl_tp_pss, vl_cpf_cnpj, vl_usuario
   from sc_ace.tbl_hdr_oboe hdr
         inner join sc_cad.tbl_emp emp on emp.cd_emp = hdr.cd_emp
         inner join sc_cad.tbl_fem fem on fem.cd_emp = hdr.cd_emp and hdr.cd_fem = fem.cd_fem
         inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
   where hdr.cd_hdr_oboe = vp_codigo_arquivo;
   
   -- gravando o header do arquivo
    select nextval('sc_acc.sq_hdr') into vp_arquivo;

    insert into sc_acc.tbl_hdr (cd_hdr, nr_vrs_hdr, cd_emp, dt_grc_hdr, st_hdr, dt_rcb_hdr, cd_rcb_usr)
    				values (vp_arquivo, 1, vl_empresa, now(), ct_st_recebido, now(), vl_usuario);
   
   -- verificando o produto
   -- 1 pagamento, 2 seguro
   if vl_produto > 2 then
    vl_produto := ct_produto_pagamento;
   end if;
 
   -- gravando o header da filial do arquivo
   select nextval('sc_acc.sq_hfe') into vp_arquivo_filial;
   
   insert into sc_acc.tbl_hfe (cd_hfe, cd_hdr, cd_prd, cd_emp, cd_fem, 
   								tp_pss_hfe, nr_cpf_cnpj_hfe, st_hfe)
						values (vp_arquivo_filial, vp_arquivo, vl_produto, vl_empresa, vl_filial,
                        	   vl_tp_pss, vl_cpf_cnpj, ct_st_recebido);

end;
$$;


ALTER FUNCTION sc_ace.gravar_header(vp_codigo_arquivo numeric, OUT vp_arquivo numeric, OUT vp_arquivo_filial numeric) OWNER TO scan;

--
-- TOC entry 7557 (class 0 OID 0)
-- Dependencies: 1588
-- Name: FUNCTION gravar_header(vp_codigo_arquivo numeric, OUT vp_arquivo numeric, OUT vp_arquivo_filial numeric); Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON FUNCTION gravar_header(vp_codigo_arquivo numeric, OUT vp_arquivo numeric, OUT vp_arquivo_filial numeric) IS 'GRAVAR O HEADER DO ARQUIVO E DA FILIAL NO LAYOUT DA SAQCARD';


--
-- TOC entry 211 (class 1259 OID 564017)
-- Name: tbl_det_oboe; Type: TABLE; Schema: sc_ace; Owner: scan
--

CREATE TABLE tbl_det_oboe (
    cd_det_oboe numeric(10,0) NOT NULL,
    cd_hdr_oboe numeric(10,0) NOT NULL,
    cd_ident_arq numeric(2,0) NOT NULL,
    nr_mtr_det_oboe character varying(20) NOT NULL,
    nm_det_oboe character varying(80) NOT NULL,
    dt_ctr_det_oboe date,
    tp_prd_pgt_det_oboe character varying(1),
    nr_dia_pgt_mensal numeric(2,0),
    nr_dia_pgt_quinzenal numeric(2,0),
    nr_cpf_det_oboe numeric(11,0) NOT NULL,
    rg_det_oboe numeric(20,0),
    nm_mae_det_oboe character varying(80),
    dt_ems_rg_det_oboe date,
    nm_org_ems_rg_det_oboe character varying(10),
    uf_org_ems_rg_det_oboe character varying(2),
    dt_nsc_det_oboe date,
    fg_sex_det_oboe character varying(1),
    cd_est_det_oboe numeric(2,0),
    ds_nat_det_oboe character varying(50),
    ds_nac_det_oboe character varying(20),
    eml_det_oboe character varying(50),
    cep_det_oboe numeric(8,0),
    nr_end_det_oboe character varying(5),
    cpl_end_det_oboe character varying(30),
    nm_log_det_oboe character varying(50),
    nm_brr_det_oboe character varying(30),
    nm_loc_det_oboe character varying(30),
    uf_end_det_oboe character varying(2),
    nr_ddd_rsd_det_oboe numeric(2,0),
    nr_tlf_rsd_det_oboe numeric(10,0),
    nr_ddd_cel_det_oboe numeric(2,0),
    nr_tlf_cel_det_oboe numeric(10,0),
    id_ent_crt_det_oboe character varying(1) NOT NULL,
    nr_cnpj_det_oboe numeric(14,0),
    st_det_oboe numeric(2,0) DEFAULT 1 NOT NULL,
    st_prc_det_oboe numeric(2,0),
    CONSTRAINT ck_fg_sex_det_oboe CHECK (((fg_sex_det_oboe)::bpchar = ANY (ARRAY['F'::bpchar, 'M'::bpchar])))
);


ALTER TABLE tbl_det_oboe OWNER TO scan;

--
-- TOC entry 7558 (class 0 OID 0)
-- Dependencies: 211
-- Name: TABLE tbl_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON TABLE tbl_det_oboe IS 'TABELA DE DETALHE DO ARQUIVO DE CADASTRO DA OBOÉ';


--
-- TOC entry 7559 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.cd_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.cd_det_oboe IS 'CODIGO';


--
-- TOC entry 7560 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.cd_hdr_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.cd_hdr_oboe IS 'CODIGO DO HEADER DO ARQUIVO';


--
-- TOC entry 7561 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.cd_ident_arq; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.cd_ident_arq IS 'IDENTIFICACAO DA LINHA DE DETALHE DO ARQUIVO';


--
-- TOC entry 7562 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nr_mtr_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nr_mtr_det_oboe IS 'MATRICULA DO FUNCIONARIO';


--
-- TOC entry 7563 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nm_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nm_det_oboe IS 'NOME DO FUNCIONARIO';


--
-- TOC entry 7564 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.dt_ctr_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.dt_ctr_det_oboe IS 'DATA DE CONTRATACAO';


--
-- TOC entry 7565 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.tp_prd_pgt_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.tp_prd_pgt_det_oboe IS 'PERIODICIDADE DE PAGAMENTO';


--
-- TOC entry 7566 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nr_dia_pgt_mensal; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nr_dia_pgt_mensal IS 'DIA DE PAGAMENTO MENSAL';


--
-- TOC entry 7567 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nr_dia_pgt_quinzenal; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nr_dia_pgt_quinzenal IS 'DIA DE PAGAMENTO QUINZENAL';


--
-- TOC entry 7568 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nr_cpf_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nr_cpf_det_oboe IS 'CPF';


--
-- TOC entry 7569 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.rg_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.rg_det_oboe IS 'RG (PF) OU INSCRICAO ESTADUAL (PJ)';


--
-- TOC entry 7570 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nm_mae_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nm_mae_det_oboe IS 'NOME DA MAE. USADO APENAS PARA PESSOA FISICA';


--
-- TOC entry 7571 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.dt_ems_rg_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.dt_ems_rg_det_oboe IS 'DATA DE EMISSAO RG';


--
-- TOC entry 7572 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nm_org_ems_rg_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nm_org_ems_rg_det_oboe IS 'ORGAO EMISSAOR RG';


--
-- TOC entry 7573 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.uf_org_ems_rg_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.uf_org_ems_rg_det_oboe IS 'UF EMISSOR RG';


--
-- TOC entry 7574 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.dt_nsc_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.dt_nsc_det_oboe IS 'DATA NASCIMENTO(PF) OU DATA DE REGISTRO (PJ)';


--
-- TOC entry 7575 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.fg_sex_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.fg_sex_det_oboe IS 'SEXO';


--
-- TOC entry 7576 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.cd_est_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.cd_est_det_oboe IS 'ESTADO CIVIL. VER TABELA DE DOMINIO';


--
-- TOC entry 7577 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.ds_nat_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.ds_nat_det_oboe IS 'NATURALIDADE';


--
-- TOC entry 7578 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.ds_nac_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.ds_nac_det_oboe IS 'NACIONALIDADE';


--
-- TOC entry 7579 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.eml_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.eml_det_oboe IS 'EMAIL';


--
-- TOC entry 7580 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.cep_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.cep_det_oboe IS 'CEP RESIDENCIAL';


--
-- TOC entry 7581 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nr_end_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nr_end_det_oboe IS 'NUMERO RESIDENCIAL';


--
-- TOC entry 7582 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.cpl_end_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.cpl_end_det_oboe IS 'COMPLEMENTO';


--
-- TOC entry 7583 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nm_log_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nm_log_det_oboe IS 'LOGRADOURO';


--
-- TOC entry 7584 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nm_brr_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nm_brr_det_oboe IS 'BAIRRO';


--
-- TOC entry 7585 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nm_loc_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nm_loc_det_oboe IS 'LOCALIDADE';


--
-- TOC entry 7586 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.uf_end_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.uf_end_det_oboe IS 'UF';


--
-- TOC entry 7587 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nr_ddd_rsd_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nr_ddd_rsd_det_oboe IS 'DDD RESIDENCIAL';


--
-- TOC entry 7588 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nr_tlf_rsd_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nr_tlf_rsd_det_oboe IS 'NUMERO DO TELEFONE RESIDENCIAL';


--
-- TOC entry 7589 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nr_ddd_cel_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nr_ddd_cel_det_oboe IS 'DDD CELULAR';


--
-- TOC entry 7590 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nr_tlf_cel_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nr_tlf_cel_det_oboe IS 'NUMERO DO TELEFONE CELULAR';


--
-- TOC entry 7591 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.nr_cnpj_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.nr_cnpj_det_oboe IS 'NUMERO DO CPNJ';


--
-- TOC entry 7592 (class 0 OID 0)
-- Dependencies: 211
-- Name: COLUMN tbl_det_oboe.st_det_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_det_oboe.st_det_oboe IS 'SITUACAO. VER TABELA DE DOMINIO';


--
-- TOC entry 1144 (class 1255 OID 564025)
-- Name: gravar_registro_cartao(numeric, numeric, tbl_det_oboe); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION gravar_registro_cartao(vp_arquivo numeric, vp_arquivo_filial numeric, vp_dados_detalhe tbl_det_oboe) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  ct_sit_recebido	constant numeric := 1;
  vl_sexo varchar(1) := 'M';
  vl_data_nascimento date := to_date('01-01-1900', 'dd-MM-yyyy');
  vl_rg numeric(20) := 0;
begin

  if vp_dados_detalhe.rg_det_oboe > 0 then
    vl_rg := vp_dados_detalhe.rg_det_oboe;
  end if;

  if vp_dados_detalhe.dt_nsc_det_oboe is not null then
	vl_data_nascimento := vp_dados_detalhe.dt_nsc_det_oboe;
  end if;

  if length(vp_dados_detalhe.fg_sex_det_oboe) > 0 then
	vl_sexo := vp_dados_detalhe.fg_sex_det_oboe;
  end if;

	INSERT INTO sc_acc.tbl_rct(
	    cd_rct, tp_pss_rct, nr_cpf_cnpj_rct, cd_crt_emp_rct, 
	    nm_rct, rg_rct, dt_nsc_rct, 
	    nm_mae_rct, eml_rct, st_rct, 
	    cd_hdr, cd_hfe, fg_sex_rct, dt_ems_rg_rct,
	    nm_org_ems_rg_rct, uf_org_ems_rg_rct, cd_est_rct,
	    ds_nat_rct, ds_nac_rct, dt_adm_rct)
	VALUES (nextval('sc_acc.sq_rct'), 'F', vp_dados_detalhe.nr_cpf_det_oboe, trim(leading '0' from vp_dados_detalhe.nr_mtr_det_oboe), 
	    vp_dados_detalhe.nm_det_oboe, vl_rg, vl_data_nascimento, 
	    vp_dados_detalhe.nm_mae_det_oboe, vp_dados_detalhe.eml_det_oboe, ct_sit_recebido,  
	    vp_arquivo, vp_arquivo_filial, vl_sexo, vp_dados_detalhe.dt_ems_rg_det_oboe,
	    vp_dados_detalhe.nm_org_ems_rg_det_oboe, vp_dados_detalhe.uf_org_ems_rg_det_oboe, vp_dados_detalhe.cd_est_det_oboe,
	    vp_dados_detalhe.ds_nat_det_oboe, vp_dados_detalhe.ds_nac_det_oboe, vp_dados_detalhe.dt_ctr_det_oboe);
end;
$$;


ALTER FUNCTION sc_ace.gravar_registro_cartao(vp_arquivo numeric, vp_arquivo_filial numeric, vp_dados_detalhe tbl_det_oboe) OWNER TO scan;

--
-- TOC entry 7593 (class 0 OID 0)
-- Dependencies: 1144
-- Name: FUNCTION gravar_registro_cartao(vp_arquivo numeric, vp_arquivo_filial numeric, vp_dados_detalhe tbl_det_oboe); Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON FUNCTION gravar_registro_cartao(vp_arquivo numeric, vp_arquivo_filial numeric, vp_dados_detalhe tbl_det_oboe) IS 'GRAVAR O REGISTRO DE CARTAO A PARTIR DO LAYOUT DA OBOE PARA O LAYOUT DA SAQCARD';


--
-- TOC entry 1147 (class 1255 OID 564026)
-- Name: gravar_registro_endereco(numeric, numeric, tbl_det_oboe); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION gravar_registro_endereco(vp_arquivo numeric, vp_arquivo_filial numeric, vp_dados_detalhe tbl_det_oboe) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  ct_tp_end_residencial constant numeric := 1;
  ct_sit_recebido	constant numeric := 1;
begin
  if vp_dados_detalhe.cep_det_oboe > 0
     and length(vp_dados_detalhe.nr_end_det_oboe) > 0
     and length(vp_dados_detalhe.nm_log_det_oboe) > 0
     and length(vp_dados_detalhe.nm_brr_det_oboe) > 0
     and length(vp_dados_detalhe.nm_loc_det_oboe) > 0
     and length(vp_dados_detalhe.uf_end_det_oboe) > 0 then
    INSERT INTO sc_acc.tbl_red(
              cd_red, tp_pss_red, nr_cpf_cnpj_red, cep_red, 
              nr_red, tp_edr_red, nm_log_red, 
              nm_brr_red, nm_loc_red, uf_red, 
              cpl_red, st_red, cd_hdr, cd_hfe, 
              cd_crt_emp_red)
    VALUES (nextval('sc_acc.sq_red'), 'F', vp_dados_detalhe.nr_cpf_det_oboe, vp_dados_detalhe.cep_det_oboe, 
       		  vp_dados_detalhe.nr_end_det_oboe, ct_tp_end_residencial, vp_dados_detalhe.nm_log_det_oboe, 
              vp_dados_detalhe.nm_brr_det_oboe, vp_dados_detalhe.nm_loc_det_oboe, vp_dados_detalhe.uf_end_det_oboe,
              vp_dados_detalhe.cpl_end_det_oboe, ct_sit_recebido, vp_arquivo, vp_arquivo_filial, 
              trim(leading '0' from vp_dados_detalhe.nr_mtr_det_oboe));
  end if;
end;
$$;


ALTER FUNCTION sc_ace.gravar_registro_endereco(vp_arquivo numeric, vp_arquivo_filial numeric, vp_dados_detalhe tbl_det_oboe) OWNER TO scan;

--
-- TOC entry 7594 (class 0 OID 0)
-- Dependencies: 1147
-- Name: FUNCTION gravar_registro_endereco(vp_arquivo numeric, vp_arquivo_filial numeric, vp_dados_detalhe tbl_det_oboe); Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON FUNCTION gravar_registro_endereco(vp_arquivo numeric, vp_arquivo_filial numeric, vp_dados_detalhe tbl_det_oboe) IS 'GRAVAR O REGISTRO DE CARTAO A PARTIR DO LAYOUT DA OBOE PARA O LAYOUT DA SAQCARD';


--
-- TOC entry 1148 (class 1255 OID 564027)
-- Name: gravar_registro_telefone(numeric, numeric, tbl_det_oboe); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION gravar_registro_telefone(vp_arquivo numeric, vp_arquivo_filial numeric, vp_dados_detalhe tbl_det_oboe) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  ct_tp_tel_residencial constant numeric := 1;
  ct_tp_tel_celular constant numeric := 2;
  
  ct_sit_recebido	constant numeric := 1;
  
  vl_ddd    numeric(2,0);
begin

  if vp_dados_detalhe.nr_tlf_rsd_det_oboe > 0 then
     
     if vp_dados_detalhe.nr_ddd_rsd_det_oboe > 0 then
       vl_ddd := vp_dados_detalhe.nr_ddd_rsd_det_oboe;
     else
       vl_ddd := 85;
     end if;
     
  	 INSERT INTO sc_acc.tbl_rtl(
              cd_rtl, tp_pss_rtl, nr_cpf_cnpj_rtl, 
              cd_crt_emp_rtl, tp_tlf_rtl, 
              nr_tlf_rtl, nr_ddd_rtl, st_rtl, cd_hdr, cd_hfe)
      VALUES (nextval('sc_acc.sq_rtl'), 'F', vp_dados_detalhe.nr_cpf_det_oboe, 
      		  trim(leading '0' from vp_dados_detalhe.nr_mtr_det_oboe), ct_tp_tel_residencial, 
              vp_dados_detalhe.nr_tlf_rsd_det_oboe, vl_ddd, ct_sit_recebido, vp_arquivo, vp_arquivo_filial);	
  
  end if;
  
  if vp_dados_detalhe.nr_tlf_cel_det_oboe > 0 then

     if vp_dados_detalhe.nr_ddd_cel_det_oboe > 0 then
       vl_ddd := vp_dados_detalhe.nr_ddd_cel_det_oboe;
     else
       vl_ddd := 85;
     end if;

     INSERT INTO sc_acc.tbl_rtl(
              cd_rtl, tp_pss_rtl, nr_cpf_cnpj_rtl, cd_crt_emp_rtl, tp_tlf_rtl, 
              nr_tlf_rtl, nr_ddd_rtl, st_rtl, cd_hdr, cd_hfe)
      VALUES (nextval('sc_acc.sq_rtl'), 'F', vp_dados_detalhe.nr_cpf_det_oboe, trim(leading '0' from vp_dados_detalhe.nr_mtr_det_oboe), ct_tp_tel_celular, 
              vp_dados_detalhe.nr_tlf_cel_det_oboe, vl_ddd, ct_sit_recebido, vp_arquivo, vp_arquivo_filial);	

  end if;
  
end;
$$;


ALTER FUNCTION sc_ace.gravar_registro_telefone(vp_arquivo numeric, vp_arquivo_filial numeric, vp_dados_detalhe tbl_det_oboe) OWNER TO scan;

--
-- TOC entry 7595 (class 0 OID 0)
-- Dependencies: 1148
-- Name: FUNCTION gravar_registro_telefone(vp_arquivo numeric, vp_arquivo_filial numeric, vp_dados_detalhe tbl_det_oboe); Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON FUNCTION gravar_registro_telefone(vp_arquivo numeric, vp_arquivo_filial numeric, vp_dados_detalhe tbl_det_oboe) IS 'GRAVAR O REGISTRO DE CARTAO A PARTIR DO LAYOUT DA OBOE PARA O LAYOUT DA SAQCARD';


--
-- TOC entry 1150 (class 1255 OID 564028)
-- Name: gravar_trailler(numeric, numeric); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION gravar_trailler(vp_arquivo numeric, vp_arquivo_filial numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_empresa  numeric(5,0);
  vl_filial	  numeric(5,0);
  vl_cpf_cnpj numeric(14,0);
  vl_tp_pss	  varchar(1);
  vl_qtde_crt	numeric(5,0);
  vl_qtde_end	numeric(5,0);
  vl_qtde_tel	numeric(5,0);
  
  ct_sit_recebido constant numeric := 1;
  ct_produto_pagamento constant numeric := 1;
begin

   -- pegando o cpf/cnpj da filial
   select hfe.tp_pss_hfe, hfe.nr_cpf_cnpj_hfe, hfe.cd_emp, hfe.cd_fem
   	 into vl_tp_pss, vl_cpf_cnpj, vl_empresa, vl_filial
   from sc_acc.tbl_hfe hfe
   where hfe.cd_hdr = vp_arquivo
     and hfe.cd_hfe = vp_arquivo_filial;
     
   -- pegando a quantidade de registros inseridos nas tabelas de detalhes
   select count(*)
     into vl_qtde_crt
   from sc_acc.tbl_rct rct
   where rct.cd_hdr = vp_arquivo
     and rct.cd_hfe = vp_arquivo_filial;

   select count(*)
     into vl_qtde_end
   from sc_acc.tbl_red e
   where e.cd_hdr = vp_arquivo
     and e.cd_hfe = vp_arquivo_filial;
     
   select count(*)
     into vl_qtde_tel
   from sc_acc.tbl_rtl rtl   
   where rtl.cd_hdr = vp_arquivo
     and rtl.cd_hfe = vp_arquivo_filial;      

   -- gravando o trailler da filial do arquivo
   INSERT INTO sc_acc.tbl_tfe(
            cd_tfe, cd_hdr, cd_hfe, cd_emp, cd_fem, tp_pss_tfe, nr_cpf_cnpj_tfe, 
            cd_prd, nr_reg_crt_tfe, nr_reg_edr_tfe, nr_reg_tlf_tfe, st_tfe)
    VALUES ( nextval('sc_acc.sq_tfe'), vp_arquivo, vp_arquivo_filial, vl_empresa, vl_filial, vl_tp_pss, vl_cpf_cnpj, 
            ct_produto_pagamento, vl_qtde_crt, vl_qtde_end, vl_qtde_tel, ct_sit_recebido);
            
    -- gravando o trailler do arquivo
   INSERT INTO sc_acc.tbl_trl(
            cd_trl, cd_hdr, cd_emp, nr_reg_fem_trl, st_trl)
    VALUES ( nextval('sc_acc.sq_trl'), vp_arquivo, vl_empresa, 1, ct_sit_recebido);

end;
$$;


ALTER FUNCTION sc_ace.gravar_trailler(vp_arquivo numeric, vp_arquivo_filial numeric) OWNER TO scan;

--
-- TOC entry 7596 (class 0 OID 0)
-- Dependencies: 1150
-- Name: FUNCTION gravar_trailler(vp_arquivo numeric, vp_arquivo_filial numeric); Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON FUNCTION gravar_trailler(vp_arquivo numeric, vp_arquivo_filial numeric) IS 'GRAVAR O TRAILLER DO ARQUIVO E DA FILIAL NO LAYOUT DA SAQCARD';


--
-- TOC entry 1151 (class 1255 OID 564029)
-- Name: processa_arquivo_oboe(); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION processa_arquivo_oboe() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

vl_rg sc_ace.tbl_hdr_oboe%rowtype;

--situacao do registro de header do arquivo
ct_st_importado constant numeric := 1;

begin

   for vl_rg in select *
                from sc_ace.tbl_hdr_oboe hdr
                where hdr.st_hdr_oboe = ct_st_importado loop

      --processando todos os registros de arquivo
      perform sc_ace.processa_arquivo_oboe(vl_rg.cd_hdr_oboe);
   end loop;
end;
$$;


ALTER FUNCTION sc_ace.processa_arquivo_oboe() OWNER TO scan;

--
-- TOC entry 7597 (class 0 OID 0)
-- Dependencies: 1151
-- Name: FUNCTION processa_arquivo_oboe(); Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON FUNCTION processa_arquivo_oboe() IS 'PROCESSA TODOS OS ARQUIVOS QUE ESTIVEREM NA SITUACAO IMPORTADO';


--
-- TOC entry 1152 (class 1255 OID 564030)
-- Name: processa_arquivo_oboe(numeric); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION processa_arquivo_oboe(vp_codigo_arquivo numeric, OUT vp_header_arquivo numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare

rg sc_acc.tbl_hdr%rowtype;

vl_situacao numeric;
vl_situacao_processamento numeric;
vl_existe numeric;


--situacao de processamento do arquivo
ct_sit_prc_sucesso numeric := 0;
ct_sit_prc_filial_invalido numeric := 3;

--situacao do registro de header do arquivo
ct_sit_recebido constant numeric := 1;
ct_sit_invalidado constant numeric := 4;
ct_sit_processado constant numeric := 2;
begin

--validando os dados do arquivo
select *
into vl_situacao, vl_situacao_processamento
from sc_ace.validar_arquivo_oboe(vp_codigo_arquivo);

--se o arquivo for invalidado, marcar o arquivo como invalido e sair da rotina
if vl_situacao <> ct_sit_processado then
  update sc_ace.tbl_hdr_oboe 
     set st_hdr_oboe = vl_situacao,
         st_prc_hdr_oboe = vl_situacao_processamento
  where cd_hdr_oboe = vp_codigo_arquivo;

  update sc_ace.tbl_det_oboe 
     set st_det_oboe = vl_situacao,
         st_prc_det_oboe = 1 -- INVALIDO
  where cd_hdr_oboe = vp_codigo_arquivo;
else

  -- validando os registros de detalhe para saber se pode processar
  --select *
  --  into vl_situacao 
  --from sc_ace.validar_arquivo_detalhe_oboe(vp_codigo_arquivo);

  --if vl_situacao = 0 then
     --processando todos os registros validos do detalhe
     select *
       into vp_header_arquivo
     from sc_ace.processa_detalhe_oboe(vp_codigo_arquivo);
  --end if;
    
  --verificando se existe pelo menos um registro de detalhe valido no arquivo
  select count(*)
  into vl_existe
  from sc_ace.tbl_det_oboe det
  where det.cd_hdr_oboe = vp_codigo_arquivo
  and det.st_det_oboe = ct_sit_processado;

  if vl_existe = 0 then
    update sc_ace.tbl_hdr_oboe 
       set st_hdr_oboe = ct_sit_invalidado,
           st_prc_hdr_oboe = ct_sit_prc_filial_invalido
    where cd_hdr_oboe = vp_codigo_arquivo;
  else
    update sc_ace.tbl_hdr_oboe
       set st_hdr_oboe = ct_sit_processado,
           st_prc_hdr_oboe = ct_sit_prc_sucesso
      where cd_hdr_oboe = vp_codigo_arquivo;
  end if;
end if;

end;
$$;


ALTER FUNCTION sc_ace.processa_arquivo_oboe(vp_codigo_arquivo numeric, OUT vp_header_arquivo numeric) OWNER TO scan;

--
-- TOC entry 7598 (class 0 OID 0)
-- Dependencies: 1152
-- Name: FUNCTION processa_arquivo_oboe(vp_codigo_arquivo numeric, OUT vp_header_arquivo numeric); Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON FUNCTION processa_arquivo_oboe(vp_codigo_arquivo numeric, OUT vp_header_arquivo numeric) IS 'PROCESSA UM DETERMINADO ARQUIVO';


--
-- TOC entry 1158 (class 1255 OID 564031)
-- Name: processa_detalhe_oboe(numeric); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION processa_detalhe_oboe(vp_codigo_arquivo numeric, OUT vp_header_cadastro numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
   vl_arquivo   numeric(10,0);
   vl_arquivo_filial  numeric(10,0);
   
   vl_rg 	sc_ace.tbl_det_oboe;

   -- situacao do detalhe
   ct_sit_recebido constant numeric := 1;
   ct_sit_processado constant numeric := 2;
   ct_sit_validado constant numeric := 5;
   
begin

  -- gravando os headers (arquivo e filial)
  select *
    into vl_arquivo, vl_arquivo_filial
  from sc_ace.gravar_header(vp_codigo_arquivo);
  
  -- gravando os detalhes ( cartao, endereco, telefone)
  for vl_rg in select *
  		from sc_ace.tbl_det_oboe det
                where det.cd_hdr_oboe = vp_codigo_arquivo
                  and det.st_det_oboe = ct_sit_recebido loop
  
    perform sc_ace.gravar_registro_cartao(vl_arquivo, vl_arquivo_filial, vl_rg);
    perform sc_ace.gravar_registro_endereco(vl_arquivo, vl_arquivo_filial, vl_rg);
    perform sc_ace.gravar_registro_telefone(vl_arquivo, vl_arquivo_filial, vl_rg);
    
    update sc_ace.tbl_det_oboe set st_det_oboe = ct_sit_processado where cd_det_oboe = vl_rg.cd_det_oboe;
    
  end loop;  
  
  -- gravando os traillers (arquivo e filial)
  perform sc_ace.gravar_trailler(vl_arquivo, vl_arquivo_filial);
  
  -- vinculando o arquivo gerado com o arquivo importado
  update sc_ace.tbl_hdr_oboe set cd_hdr = vl_arquivo where cd_hdr_oboe = vp_codigo_arquivo;

  vp_header_cadastro := vl_arquivo;
  
end;
$$;


ALTER FUNCTION sc_ace.processa_detalhe_oboe(vp_codigo_arquivo numeric, OUT vp_header_cadastro numeric) OWNER TO scan;

--
-- TOC entry 7599 (class 0 OID 0)
-- Dependencies: 1158
-- Name: FUNCTION processa_detalhe_oboe(vp_codigo_arquivo numeric, OUT vp_header_cadastro numeric); Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON FUNCTION processa_detalhe_oboe(vp_codigo_arquivo numeric, OUT vp_header_cadastro numeric) IS 'PROCESSA UM REGISTRO DE DETALHE DE UM DETERMINADO ARQUIVO';


--
-- TOC entry 1159 (class 1255 OID 564032)
-- Name: validar_arquivo_detalhe_oboe(numeric); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION validar_arquivo_detalhe_oboe(vp_codigo_arquivo numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare

  vl_retorno numeric;
  vl_situacao numeric;
  vl_sit_processamento numeric;
  vl_rg 	sc_ace.tbl_det_oboe;
  
  -- situacao do detalhe do arquivo de detalhe
  ct_sit_validado constant numeric := 5;
  ct_sit_invalido constant numeric := 4;
  
  -- situacao de processamento do arquivo de detalhe
  ct_sit_prc_sucesso constant numeric := 0;
  ct_sit_prc_erro_invalido constant numeric := 1;
  ct_sit_prc_erro_rg constant numeric := 2;
  ct_sit_prc_erro_data_nascimento constant numeric := 3;
  ct_sit_prc_erro_sexo constant numeric := 4;
  ct_sit_prc_erro_endereco constant numeric := 5;
  
  -- codigo de retorno da funcao
  ct_ret_sucesso constant numeric := 0; -- quando existir PELO MENOS UM registro de detalhe VALIDO
  ct_ret_erro constant numeric := 1; -- quando TODOS os registros de detalhe forem INVALIDOS
begin
	
	vl_retorno := ct_ret_erro;
	for vl_rg in select * 
		     from sc_ace.tbl_det_oboe det 
		     where det.cd_hdr_oboe = vp_codigo_arquivo loop
				
		vl_sit_processamento := ct_sit_prc_sucesso;
		-- validando se o rg está preenchido corretamente
		if vl_rg.rg_det_oboe is null or vl_rg.rg_det_oboe = 0 then
			vl_sit_processamento := ct_sit_prc_erro_rg;
		else 
			if vl_rg.dt_nsc_det_oboe is null then
				vl_sit_processamento := ct_sit_prc_erro_data_nascimento;
			else
				if vl_rg.fg_sex_det_oboe is null or vl_rg.fg_sex_det_oboe = '' then
					vl_sit_processamento := ct_sit_prc_erro_sexo;
				else
					if ((vl_rg.cep_det_oboe is null or vl_rg.cep_det_oboe = 0)
					   or (vl_rg.nr_end_det_oboe is null or vl_rg.nr_end_det_oboe = '')
					   or (vl_rg.nm_log_det_oboe is null or vl_rg.nm_log_det_oboe = '')
					   or (vl_rg.nm_brr_det_oboe is null or vl_rg.nm_brr_det_oboe = '')
					   or (vl_rg.nm_loc_det_oboe is null or vl_rg.nm_loc_det_oboe = '')
					   or (vl_rg.uf_end_det_oboe is null or vl_rg.uf_end_det_oboe = '')) then
						vl_sit_processamento := ct_sit_prc_erro_endereco;
					end if;
				end if;
			end if;
		end if;
		
		if vl_sit_processamento = ct_sit_prc_sucesso then
			vl_situacao := ct_sit_validado;
			vl_retorno := ct_ret_sucesso;
		else
			vl_situacao := ct_sit_invalido;
		end if;
		
		-- atualizando o registro de detalhe
		update sc_ace.tbl_det_oboe 
			set st_det_oboe = vl_situacao, 
				st_prc_det_oboe = vl_sit_processamento 
		where cd_det_oboe = vl_rg.cd_det_oboe;
		
	end loop;

return vl_retorno;
end;
$$;


ALTER FUNCTION sc_ace.validar_arquivo_detalhe_oboe(vp_codigo_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1160 (class 1255 OID 564033)
-- Name: validar_arquivo_oboe(numeric); Type: FUNCTION; Schema: sc_ace; Owner: scan
--

CREATE FUNCTION validar_arquivo_oboe(vp_codigo_arquivo numeric, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare

  vl_situacao numeric;
  vl_qtde numeric;
  vl_qtde_hdr numeric;
  vl_empresa numeric;
  vl_filial numeric;
  vl_existe numeric;
  
  -- situacao de processamento do arquivo
  ct_sit_prc_sucesso constant numeric := 0;
  ct_sit_prc_erro_situacao constant numeric := 1;
  ct_sit_prc_erro_qtde_reg constant numeric := 2;
  ct_sit_prc_erro_empresa constant numeric := 4;
  ct_sit_prc_erro_filial constant numeric := 5;
  
  --situacao do registro de header do arquivo
  ct_sit_recebido constant numeric := 1;
  ct_sit_processado constant numeric := 2;
  ct_sit_invalido constant numeric := 4;
begin

--validando os dados do arquivo
select nr_reg_hdr_oboe, hdr.st_hdr_oboe, hdr.cd_emp, hdr.cd_fem
  into vl_qtde_hdr, vl_situacao, vl_empresa, vl_filial
from sc_ace.tbl_hdr_oboe hdr
where hdr.cd_hdr_oboe = vp_codigo_arquivo;

if vl_situacao = ct_sit_recebido then
  -- verificando a quantidade de registros do detalhe para bater com a informacao enviada no header
  select count(*)
	into vl_qtde
  from sc_ace.tbl_det_oboe det
  where det.cd_hdr_oboe = vp_codigo_arquivo;
  
  --if vl_qtde != vl_qtde_hdr then
  --	vp_situacao_processamento := ct_sit_prc_erro_qtde_reg;
  --	vp_situacao := ct_sit_invalido;
  --else
    
    -- verificando se existe empresa
    select count(*)
     into vl_existe
    from sc_cad.tbl_emp emp
    where emp.cd_emp = vl_empresa;
      
    if vl_existe = 0 then
      vp_situacao_processamento := ct_sit_prc_erro_empresa;
  	  vp_situacao := ct_sit_invalido;  
    else
      -- verificando se existe filial
      select count(*)
       into vl_existe
      from sc_cad.tbl_fem fem
      where fem.cd_emp = vl_empresa
        and fem.cd_fem = vl_filial;
      
      if vl_existe = 0 then
        vp_situacao_processamento := ct_sit_prc_erro_filial;
        vp_situacao := ct_sit_invalido;  
      else
        vp_situacao_processamento := ct_sit_prc_sucesso;
	    vp_situacao := ct_sit_processado;
      end if;
      
    end if;
    
  --end if;
  
else
  vp_situacao_processamento := ct_sit_prc_erro_situacao;
  vp_situacao := ct_sit_invalido;
end if;
end;
$$;


ALTER FUNCTION sc_ace.validar_arquivo_oboe(vp_codigo_arquivo numeric, OUT vp_situacao numeric, OUT vp_situacao_processamento numeric) OWNER TO scan;

SET search_path = sc_adp, pg_catalog;

--
-- TOC entry 1803 (class 1255 OID 1081620)
-- Name: agendar_arquivo_prepago(); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION agendar_arquivo_prepago() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
     rg record;
     vl_bloqueado numeric;
     vl_existe numeric;
begin

    for rg in select cnt.cd_cnt,
                     tfe.vl_reg_env_tfe valor_arquivo, 
                     coalesce(tfe.vl_trf_tfe,0) valor_tarifa,
                     hfe.cd_hfe,
		      hfe.fg_dbt_aut_hfe
              from sc_adp.tbl_hfe hfe
                 inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = hfe.cd_ctr
                 inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = ctr.cd_cnt
                 inner join sc_adp.tbl_tfe tfe on tfe.cd_hfe = hfe.cd_hfe
              where cnt.vl_sld_cnt >= (tfe.vl_reg_env_tfe + coalesce(tfe.vl_trf_tfe,0))
                and hfe.st_hfe = 9
              order by hfe.cd_hfe   loop
                
       vl_existe := 0;
                
       select vl_blq_tbc_cnt
       into vl_bloqueado
       from sc_cnt.tbl_tbc_cnt
       where cd_cnt = rg.cd_cnt
         and cd_tbc = 8;

      
      if (vl_bloqueado >= rg.valor_arquivo + rg.valor_tarifa) or rg.fg_dbt_aut_hfe = 'S' then

	      -- Registrando RECEITA com Tarifas de Depósito
	      perform sc_cnt.lancar_debito_credito(rg.cd_cnt, 4077, 1126, null, 'REF A ARQUIVO NR'||rg.cd_hfe::varchar, rg.valor_tarifa, now()::timestamp,1,35, rg.cd_hfe);

	      update sc_adp.tbl_hfe set st_hfe = 4 where cd_hfe = rg.cd_hfe;
	      update sc_adp.tbl_tfe set dt_pgt_tfe = now() where cd_hfe = rg.cd_hfe;

	      update sc_cnt.tbl_tbc_cnt set vl_blq_tbc_cnt = vl_blq_tbc_cnt - rg.valor_arquivo - rg.valor_tarifa where cd_cnt = rg.cd_cnt and cd_tbc = 8;

	      -- bloqueando o valor do para agendamento
	      select count(*) 
		into vl_existe
	      from sc_cnt.tbl_tbc_cnt 
	      where cd_cnt = rg.cd_cnt
		and cd_tbc = 2; -- tipo de bloqueio recebimento de recursos

	      if vl_existe > 0 then
		update sc_cnt.tbl_tbc_cnt set vl_blq_tbc_cnt = COALESCE(vl_blq_tbc_cnt,0) + rg.valor_arquivo where cd_cnt = rg.cd_cnt and cd_tbc = 2;
	      else
		insert into sc_cnt.tbl_tbc_cnt(cd_tbc_cnt, cd_tbc, cd_cnt, vl_blq_tbc_cnt, fg_atv_tbc_cnt, cd_inc_usr, dt_inc_usr)
			    values (nextval('sc_cnt.sq_tbc_cnt'), 2, rg.cd_cnt, rg.valor_arquivo, 'S', 1, now());
	      end if;

      end if;    

      
                
    end loop;

end$$;


ALTER FUNCTION sc_adp.agendar_arquivo_prepago() OWNER TO scan;

--
-- TOC entry 1571 (class 1255 OID 564034)
-- Name: ativar_cartao_deposito(); Type: FUNCTION; Schema: sc_adp; Owner: postgres
--

CREATE FUNCTION ativar_cartao_deposito() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  CT_SITUACAO_FUNCIONARIO_ATIVO numeric  := 1;
  CT_SITUACAO_FUNCIONARIO_LICENCA_INSS numeric := 3;
  CT_SITUACAO_FUNCIONARIO_FERIAS numeric := 5;
  
  rg record;

  CT_SERVICO_CONTA_INATIVA numeric := 4;
  
begin

   for rg in select distinct rdp.cd_crt
	     from sc_adp.tbl_rdp rdp
	       inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
	       inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	       inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
	     where crt.fg_atv_crt = 'N'
	       and fnc.st_fnc in (CT_SITUACAO_FUNCIONARIO_ATIVO, CT_SITUACAO_FUNCIONARIO_FERIAS, CT_SITUACAO_FUNCIONARIO_LICENCA_INSS)
	       and rdp.cd_tdp in(1,8,3) -- tipo salario, outros e ferias
	       and hfe.dt_dps_hfe > current_date - interval '2 day' loop

	perform sc_opr.ativar_cartao(rg.cd_crt,1,'ATIVACAO DE CARTAO POR RECEBIMENTO DE DEPOSITO');

        -- inativando o servico de conta inativa
	perform sc_srv.cancelar_servico(CT_SERVICO_CONTA_INATIVA, rg.cd_crt, 'ATIVACAO DE CARTAO POR RECEBIMENTO DE DEPOSITO', 1);             

   end loop;
     
end$$;


ALTER FUNCTION sc_adp.ativar_cartao_deposito() OWNER TO postgres;

--
-- TOC entry 7600 (class 0 OID 0)
-- Dependencies: 1571
-- Name: FUNCTION ativar_cartao_deposito(); Type: COMMENT; Schema: sc_adp; Owner: postgres
--

COMMENT ON FUNCTION ativar_cartao_deposito() IS 'Ativa os cartoes que estavam inativos e que tiveram depositos';


--
-- TOC entry 1105 (class 1255 OID 564035)
-- Name: atualiza_cartao(numeric); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION atualiza_cartao(vp_codigo_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_data_primeiro_deposito timestamp without time zone;
begin
  select dt_pri_dps_crt
  into vl_data_primeiro_deposito
  from sc_opr.tbl_crt
  where cd_crt = vp_codigo_cartao;

  if vl_data_primeiro_deposito is null then
    vl_data_primeiro_deposito := now();
  end if;

  update sc_opr.tbl_crt
     set dt_pri_dps_crt = vl_data_primeiro_deposito,
         dt_ult_dps_crt = now()
  where cd_crt = vp_codigo_cartao;
end;$$;


ALTER FUNCTION sc_adp.atualiza_cartao(vp_codigo_cartao numeric) OWNER TO scan;

--
-- TOC entry 7601 (class 0 OID 0)
-- Dependencies: 1105
-- Name: FUNCTION atualiza_cartao(vp_codigo_cartao numeric); Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON FUNCTION atualiza_cartao(vp_codigo_cartao numeric) IS 'rotina que atualiza as informacoes da tabela de cartao a cada deposito realizado';


--
-- TOC entry 1149 (class 1255 OID 564036)
-- Name: atualiza_funcionario_ferias(numeric, numeric, date); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION atualiza_funcionario_ferias(vp_empresa numeric, vp_cartao numeric, vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
   rg record;

   CT_SIT_DEPOSITADO numeric := 5;
   CT_TIPO_DEPOSITO_FERIAS numeric := 3;
   CT_TIPO_DEPOSITO_SALARIO numeric := 1;
   CT_TIPO_DEPOSITO_OUTROS numeric := 8;
   CT_SIT_FUNCIONARIO_ATIVO numeric := 1;
   CT_SIT_FUNCIONARIO_DEMITIDO numeric := 2;
   CT_SIT_FUNCIONARIO_FERIAS numeric := 5;
   CT_SIT_FUNCIONARIO_INATIVO numeric := 6;
   CT_TIPO_OCORRENCIA_CARTAO numeric := 14;
   
   
   vl_data_referencia date := COALESCE(vp_data_referencia, current_date - 2);  
begin

   -- ATUALIZANDO DE ATIVO PARA FÉRIAS - INICIO
   for rg in select fnc.cd_fnc as funcionario, crt.cd_crt as cartao
             from sc_adp.tbl_rdp rdp
		inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
		inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
		inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	     where hfe.cd_tdp = CT_TIPO_DEPOSITO_FERIAS
	       and hfe.st_hfe = CT_SIT_DEPOSITADO
	       and rdp.st_rdp = CT_SIT_DEPOSITADO
	       and hfe.dt_dps_hfe >= vl_data_referencia
	       and crt.cd_crt = COALESCE(vp_cartao, crt.cd_crt)
	       and fnc.cd_emp = COALESCE(vp_empresa, fnc.cd_emp)
	       and fnc.st_fnc not in (CT_SIT_FUNCIONARIO_FERIAS, CT_SIT_FUNCIONARIO_DEMITIDO, CT_SIT_FUNCIONARIO_INATIVO)
   loop
     -- atualizar a situação do funcionario
     update sc_cad.tbl_fnc set st_fnc = CT_SIT_FUNCIONARIO_FERIAS where cd_fnc = rg.funcionario;
     
     -- gravar ocorrencia no cartao do funcionario
     insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
         values (nextval('sc_opr.sq_ocr'), CT_TIPO_OCORRENCIA_CARTAO, rg.cartao, null, 'ALTERACAO NA SITUACAO DO FUNCIONARIO PARA FÉRIAS DEVIDO TER RECEBIDO UM ARQUIVO DE DEPÓSITO DO TIPO FÉRIAS.', 'S', 1, now());
     
   end loop;
   -- ATUALIZANDO DE ATIVO PARA FÉRIAS - FIM

   -- ATUALIZANDO DE FÉRIAS PARA ATIVO - INICIO
   --1. caso tenha recebido deposito do tipo SALARIO ou FÉRIAS
   for rg in select fnc.cd_fnc as funcionario, crt.cd_crt as cartao
             from sc_adp.tbl_rdp rdp
		inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
		inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
		inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	     where hfe.cd_tdp in (CT_TIPO_DEPOSITO_SALARIO, CT_TIPO_DEPOSITO_OUTROS)
	       and hfe.st_hfe = CT_SIT_DEPOSITADO
	       and rdp.st_rdp = CT_SIT_DEPOSITADO
	       and hfe.dt_dps_hfe >= vl_data_referencia
	       and crt.cd_crt = COALESCE(vp_cartao, crt.cd_crt)
	       and fnc.cd_emp = COALESCE(vp_empresa, fnc.cd_emp)
	       and fnc.st_fnc in (CT_SIT_FUNCIONARIO_FERIAS)
               and COALESCE(fnc.dt_alt_sit_fnc, current_date) + interval '10 day' < current_date 

   loop
     -- atualizar a situação do funcionario
     update sc_cad.tbl_fnc set st_fnc = CT_SIT_FUNCIONARIO_ATIVO where cd_fnc = rg.funcionario;
     
     -- gravar ocorrencia no cartao do funcionario
     insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
         values (nextval('sc_opr.sq_ocr'), CT_TIPO_OCORRENCIA_CARTAO, rg.cartao, null, 'ALTERACAO NA SITUACAO DO FUNCIONARIO PARA ATIVO DEVIDO TER RECEBIDO UM ARQUIVO DE DEPÓSITO DO TIPO SALARIO ou OUTROS.', 'S', 1, now());

   end loop;  

   -- 2. caso o funcionario esteja de ferias a mais de 60 dias, alterar a sua situação para ativo
   for rg in select fnc.cd_fnc as funcionario
             from sc_cad.tbl_fnc fnc 
             where fnc.st_fnc in (CT_SIT_FUNCIONARIO_FERIAS) 
               and fnc.dt_alt_sit_fnc < current_date - interval '60 days'
   loop
      -- atualizar a situação do funcionario
     update sc_cad.tbl_fnc set st_fnc = CT_SIT_FUNCIONARIO_ATIVO where cd_fnc = rg.funcionario;
     
     -- gravar ocorrencia no cartao do funcionario
     insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
         values (nextval('sc_opr.sq_ocr'), CT_TIPO_OCORRENCIA_CARTAO, rg.cartao, null, 'ALTERACAO NA SITUACAO DO FUNCIONARIO PARA ATIVO DEVIDO PASSAR MAIS DE 60 DIAS SEM RECEBER DEPÓSITO.', 'S', 1, now());

   end loop;
   -- ATUALIZANDO DE FÉRIAS PARA ATIVO - FIM
   
end;
$$;


ALTER FUNCTION sc_adp.atualiza_funcionario_ferias(vp_empresa numeric, vp_cartao numeric, vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7602 (class 0 OID 0)
-- Dependencies: 1149
-- Name: FUNCTION atualiza_funcionario_ferias(vp_empresa numeric, vp_cartao numeric, vp_data_referencia date); Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON FUNCTION atualiza_funcionario_ferias(vp_empresa numeric, vp_cartao numeric, vp_data_referencia date) IS 'ROTINA QUE ATUALIZA A SITUAÇÃO DO FUNCIONÁRIO DE ATIVO PARA FERIAS QUANDO RECEBE UM ARQUIVO DE DEPOSITO DO TIPO FERIAS E ATUALIZA PARA ATIVO NOVAMENTE QUANDO O MESMO RECEBER UM ARQUIVO DE DEPOSITO DO TIPO SALARIO OU OUTROS.';


--
-- TOC entry 1555 (class 1255 OID 564037)
-- Name: atualizar_dia_deposito(character varying, timestamp without time zone); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION atualizar_dia_deposito(vp_arquivos character varying, vp_data_agendamento timestamp without time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_st_rrc_cadastrado numeric(1) := 1;
  ct_st_rrc_cancelado numeric(1) := 2;
  ct_st_rrc_finalizado numeric(1) := 3;

  ct_st_drr_cadastrado numeric(1) := 1;

  vl_cd_cnt numeric;
  vl_cd_ctr numeric;
  vl_cd_emp numeric;

  vl_arquivos numeric[];
  
  vl_saldo_conta numeric(13,2);
  vl_valor_agendamento numeric(13,2);
  vl_valor_liberacao_ate_1_dia numeric(13,2);
  vl_aux_valor_deposito_acumulado numeric(13,2);
  vl_desbloquear_liberar_recurso numeric(13,2);

  vl_saldo_d_mais_1 numeric(13,2);
  vl_saldo_d_mais_2 numeric(13,2);
  vl_somatorio_deposito numeric(13,2) := 0;

  rg_ddr record;
  rg_rdp record;

begin

  select string_to_array(vp_arquivos, '@') into vl_arquivos;

  begin
    select sum(coalesce(tfe.vl_reg_vld_tfe,0)), ctr.cd_cnt, hfe.cd_emp, ctr.cd_ctr
      into strict vl_valor_agendamento, vl_cd_cnt, vl_cd_emp, vl_cd_ctr
    from sc_adp.tbl_hfe hfe
      inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = hfe.cd_ctr
      inner join sc_adp.tbl_tfe tfe on tfe.cd_hfe = hfe.cd_hfe
    where hfe.cd_hfe = ANY (vl_arquivos)
    group by ctr.cd_cnt, hfe.cd_emp, ctr.cd_ctr;
  exception when others then
    raise 'Não existe este arquivo cadastrado.';
  end;

  -- limpando marcacao anterior
    update sc_adp.tbl_rdp
    set fg_dps_um_dia_rdp = null
  where cd_hfe = ANY (vl_arquivos);    

  vl_saldo_conta := coalesce(sc_cnt.saldo_conta(vl_cd_cnt, 'S', 'N'),0);

  -- valor a desbloquear até a liberacao do recurso
  begin
    select sum(coalesce(drr.vl_drr,0) - (coalesce(drr.vl_lbr_ant_drr,0) + coalesce(drr.vl_lbr_prz_drr,0)))
      into strict vl_desbloquear_liberar_recurso
    from sc_fin.tbl_drr drr
      inner join sc_fin.tbl_rrc rrc on rrc.cd_rrc = drr.cd_rrc
    where rrc.st_rrc = ct_st_rrc_cadastrado -- cadastrado
      and drr.st_drr = ct_st_drr_cadastrado -- cadastrado
      and drr.cd_ctr = vl_cd_ctr
      and rrc.dt_prv_lbr_rrc::date <= vp_data_agendamento::date;
  exception when others then
    vl_desbloquear_liberar_recurso := 0;
  end;

  -- considerar como saldo na conta o valor desbloqueado até a data do agendamento
  vl_saldo_conta := vl_saldo_conta + coalesce(vl_desbloquear_liberar_recurso,0);

  -- valor liberado de saldo a utilizar de 1 dia
  begin
      select coalesce(
                   sum(
                       case when rrc.st_rrc = 1 then 
                         --coalesce(drr.vl_drr,0) - (coalesce(drr.vl_lbr_ant_drr,0) + coalesce(drr.vl_lbr_prz_drr,0))
                         coalesce(drr.vl_drr,0) - coalesce(drr.vl_lbr_prz_drr,0)
                       else 
                         coalesce(drr.vl_lbr_ant_drr,0) + coalesce(drr.vl_lbr_prz_drr,0) 
                       end
                      )
                   ,0)
        into strict vl_saldo_d_mais_1
      from sc_fin.tbl_drr drr
        inner join sc_fin.tbl_rrc rrc on rrc.cd_rrc = drr.cd_rrc
      where drr.cd_ctr = vl_cd_ctr
        and rrc.st_rrc <> ct_st_rrc_cancelado
        and drr.st_drr = ct_st_drr_cadastrado
        and abs(vp_data_agendamento::date - rrc.dt_prv_lbr_rrc::date) < 1;
    exception when others then
      vl_saldo_d_mais_1 := 0;
    end;

  vl_saldo_d_mais_1 := coalesce(vl_saldo_d_mais_1,0);

  -- setando o valor de D + 2
  vl_saldo_d_mais_2 := vl_saldo_conta - vl_saldo_d_mais_1;

  -- atualizando registro para D + 2
  for rg_rdp in select *
                    from sc_adp.tbl_rdp rdp
                    where rdp.cd_hfe = ANY (vl_arquivos)
                    order by rdp.vl_dep_rdp loop

        vl_somatorio_deposito := vl_somatorio_deposito + rg_rdp.vl_dep_rdp;
        if vl_somatorio_deposito > vl_saldo_d_mais_2 then
          exit;
        end if;
        
        update sc_adp.tbl_rdp set
          fg_dps_um_dia_rdp = 'N'
        where cd_rdp = rg_rdp.cd_rdp;
  end loop;

  -- atualizando registro para D + 1
  update sc_adp.tbl_rdp
    set fg_dps_um_dia_rdp = 'S'
  where cd_hfe = ANY (vl_arquivos)  
    and fg_dps_um_dia_rdp is null;

end;$$;


ALTER FUNCTION sc_adp.atualizar_dia_deposito(vp_arquivos character varying, vp_data_agendamento timestamp without time zone) OWNER TO scan;

--
-- TOC entry 7603 (class 0 OID 0)
-- Dependencies: 1555
-- Name: FUNCTION atualizar_dia_deposito(vp_arquivos character varying, vp_data_agendamento timestamp without time zone); Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON FUNCTION atualizar_dia_deposito(vp_arquivos character varying, vp_data_agendamento timestamp without time zone) IS 'atualziar dias que foi liberado o deposito do funcionario';


--
-- TOC entry 1164 (class 1255 OID 564038)
-- Name: atualizar_dia_deposito_antigo(character varying, timestamp without time zone); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION atualizar_dia_deposito_antigo(vp_arquivos character varying, vp_data_agendamento timestamp without time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_st_rrc_cadastrado numeric(1) := 1;
  ct_st_rrc_cancelado numeric(1) := 2;
  ct_st_rrc_finalizado numeric(1) := 3;

  ct_st_drr_cadastrado numeric(1) := 1;

  vl_cd_cnt numeric;
  vl_cd_ctr numeric;
  vl_cd_emp numeric;

  vl_arquivos numeric[];
  
  vl_saldo_conta double precision;
  vl_valor_agendamento double precision;
  vl_valor_liberacao_ate_1_dia double precision;
  vl_aux_valor_deposito_acumulado double precision;
  vl_desbloquear_liberar_recurso double precision;

  rg_ddr record;
  rg_rdp record;

begin

  select string_to_array(vp_arquivos, '@') into vl_arquivos;

  begin
    select sum(coalesce(tfe.vl_reg_vld_tfe,0)), ctr.cd_cnt, hfe.cd_emp, ctr.cd_ctr
      into strict vl_valor_agendamento, vl_cd_cnt, vl_cd_emp, vl_cd_ctr
    from sc_adp.tbl_hfe hfe
      inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = hfe.cd_ctr
      inner join sc_adp.tbl_tfe tfe on tfe.cd_hfe = hfe.cd_hfe
    where hfe.cd_hfe = ANY (vl_arquivos)
    group by ctr.cd_cnt, hfe.cd_emp, ctr.cd_ctr;
  exception when others then
    raise 'Não existe este arquivo cadastrado.';
  end;

  vl_saldo_conta := coalesce(sc_cnt.saldo_conta(vl_cd_cnt, 'S', 'N'),0);

  -- valor a desbloquear até a liberacao do recurso
  begin
    select sum(coalesce(drr.vl_drr,0) - (coalesce(drr.vl_lbr_ant_drr,0) + coalesce(drr.vl_lbr_prz_drr,0)))
      into strict vl_desbloquear_liberar_recurso
    from sc_fin.tbl_drr drr
      inner join sc_fin.tbl_rrc rrc on rrc.cd_rrc = drr.cd_rrc
    where rrc.st_rrc = ct_st_rrc_cadastrado -- cadastrado
      and drr.st_drr = ct_st_drr_cadastrado -- cadastrado
      and drr.cd_ctr = vl_cd_ctr;
  exception when others then
    vl_desbloquear_liberar_recurso := 0;
  end;

  -- considerar como saldo na conta o valor desbloqueado até a data do agendamento
  vl_saldo_conta := vl_saldo_conta + coalesce(vl_desbloquear_liberar_recurso,0);

  -- caso tenha saldo na conta para o agendamento, vefificar os recebimentos finalizados pra ver a quantidade de dias por deposito
  if vl_saldo_conta >= vl_valor_agendamento then
    begin
      select sum(coalesce(drr.vl_drr,0) - (coalesce(drr.vl_lbr_ant_drr,0) + coalesce(drr.vl_lbr_prz_drr,0)))
        into strict vl_valor_liberacao_ate_1_dia
      from sc_fin.tbl_drr drr
        inner join sc_fin.tbl_rrc rrc on rrc.cd_rrc = drr.cd_rrc
      where drr.cd_ctr = vl_cd_ctr
        and rrc.st_rrc <> ct_st_rrc_cancelado
        and drr.st_drr = ct_st_drr_cadastrado
        and vp_data_agendamento - rrc.dt_prv_lbr_rrc < '1 day';
    exception when others then
      vl_valor_liberacao_ate_1_dia := 0;
    end;

    vl_valor_liberacao_ate_1_dia := coalesce(vl_valor_liberacao_ate_1_dia, 0);

    if vl_valor_liberacao_ate_1_dia > vl_valor_agendamento then
      -- atualizar todos os depositos desse arquivo para ate 1 dia
      update sc_adp.tbl_rdp set
        fg_dps_um_dia_rdp = 'S'
      where cd_hfe = ANY (vl_arquivos);

    elsif vl_valor_liberacao_ate_1_dia = 0 then
      -- atualizar todos os deposito desse arquivo para mais de 1 dia
      update sc_adp.tbl_rdp set
        fg_dps_um_dia_rdp = 'N'
      where cd_hfe = ANY (vl_arquivos);

    else
      -- atualizar os deposito desse arquivo para até um dia
      vl_aux_valor_deposito_acumulado := 0;
      for rg_rdp in select *
                    from sc_adp.tbl_rdp rdp
                    where rdp.cd_hfe = ANY (vl_arquivos)
                    order by rdp.cd_rdp loop

        vl_aux_valor_deposito_acumulado := vl_aux_valor_deposito_acumulado + rg_rdp.vl_dep_rdp;
        if vl_aux_valor_deposito_acumulado > vl_valor_liberacao_ate_1_dia then
          exit;
        end if;
        
        update sc_adp.tbl_rdp set
          fg_dps_um_dia_rdp = 'S'
        where cd_rdp = rg_rdp.cd_rdp;
      end loop;

      -- atualizar os deposito que faltam para mais de 1 dia
      update sc_adp.tbl_rdp set
        fg_dps_um_dia_rdp = 'N'
      where cd_hfe = ANY (vl_arquivos)
        and fg_dps_um_dia_rdp is null;
    end if;
  else
    -- caso não cobre antecipacao ou seja recisao
    update sc_adp.tbl_rdp set
        fg_dps_um_dia_rdp = 'S'
      where cd_hfe = ANY (vl_arquivos);
  end if;

end;$$;


ALTER FUNCTION sc_adp.atualizar_dia_deposito_antigo(vp_arquivos character varying, vp_data_agendamento timestamp without time zone) OWNER TO scan;

--
-- TOC entry 7604 (class 0 OID 0)
-- Dependencies: 1164
-- Name: FUNCTION atualizar_dia_deposito_antigo(vp_arquivos character varying, vp_data_agendamento timestamp without time zone); Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON FUNCTION atualizar_dia_deposito_antigo(vp_arquivos character varying, vp_data_agendamento timestamp without time zone) IS 'atualziar dias que foi liberado o deposito do funcionario';


--
-- TOC entry 1124 (class 1255 OID 1082915)
-- Name: calcula_tarifa_contrato_prepago(numeric, date); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION calcula_tarifa_contrato_prepago(vp_contrato numeric, vp_data_vencimento date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  ct_pce_d1 numeric := 6;
  ct_pce_d2 numeric := 20;
  vl_codigo_trf numeric;
  vl_tarifa numeric;
BEGIN

        --if vp_data_deposito - vp_data_vencimento <= 2 then
            vl_codigo_trf := ct_pce_d1;
        --else
        --    vl_codigo_trf := ct_pce_d2;
        --end if;

        select replace(vl_pce_ctr,',','.')::numeric
        into vl_tarifa
        from sc_cad.tbl_pce_ctr
        where cd_ctr = vp_contrato
          and cd_pce = vl_codigo_trf;
        
	return vl_tarifa;
END;
$$;


ALTER FUNCTION sc_adp.calcula_tarifa_contrato_prepago(vp_contrato numeric, vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 1161 (class 1255 OID 1085478)
-- Name: calcula_tarifa_contrato_prepago(numeric, date, numeric); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION calcula_tarifa_contrato_prepago(vp_contrato numeric, vp_data_vencimento date, vp_teste numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  ct_pce_d1 numeric := 6;
  ct_pce_d2 numeric := 20;
  vl_codigo_trf numeric;
  vl_tarifa numeric;
BEGIN

        --if vp_data_deposito - vp_data_vencimento <= 2 then
            vl_codigo_trf := ct_pce_d1;
        --else
        --    vl_codigo_trf := ct_pce_d2;
        --end if;

        select replace(vl_pce_ctr,',','.')::numeric
        into vl_tarifa
        from sc_cad.tbl_pce_ctr
        where cd_ctr = vp_contrato
          and cd_pce = vl_codigo_trf;
        
	return vl_tarifa;
END;
$$;


ALTER FUNCTION sc_adp.calcula_tarifa_contrato_prepago(vp_contrato numeric, vp_data_vencimento date, vp_teste numeric) OWNER TO scan;

--
-- TOC entry 1165 (class 1255 OID 564039)
-- Name: cancelar_arquivo_deposito(numeric); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION cancelar_arquivo_deposito(vp_cod_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;

  tp_lanc_deposito numeric;
  vl_somatorio double precision := 0;
  vl_cod_conta_empresa numeric;
  
begin

  for rg in select cnt.cd_cnt, rdp.vl_dep_rdp, rdp.cd_tdp
            from sc_adp.tbl_rdp rdp
              inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
              inner join sc_opr.tbl_cnt_crt cct on cct.cd_crt = crt.cd_crt
              inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cct.cd_cnt
            where rdp.cd_hfe = vp_cod_arquivo
              and st_rdp = 5 -- DEPOSITADO
               loop

    -- pegando o tipo de estorno do lancamento
     select tlc.cd_est_tlc
      into tp_lanc_deposito
      from sc_adp.tbl_tdp tdp
         inner join sc_cnt.tbl_tlc tlc on tlc.cd_tlc = tdp.cd_tlc
      where tdp.cd_tdp = rg.cd_tdp;
            
     -- efetuando o lancamento de DEBITO na conta de cada cartao
     perform sc_cnt.lancar_movimento(null, null, tp_lanc_deposito, rg.cd_cnt, 'D', rg.vl_dep_rdp, current_timestamp::timestamp without time zone, 1, null, 'CANCELAMENTO ARQ DEP NSU ' || vp_cod_arquivo, 2, vp_cod_arquivo);
     vl_somatorio := vl_somatorio + rg.vl_dep_rdp;
  
  end loop;

    -- pegando a conta da empresa
    select cd_cnt
    into vl_cod_conta_empresa
     from sc_cad.tbl_ctr ctr
       inner join sc_adp.tbl_hfe hfe on hfe.cd_ctr = ctr.cd_ctr
       where hfe.cd_hfe = vp_cod_arquivo;

  -- efetuando o lancamento de CREDITO na conta da empresa
  perform sc_cnt.lancar_movimento(null, null, tp_lanc_deposito, vl_cod_conta_empresa, 'C', vl_somatorio, current_timestamp::timestamp without time zone, 1, null, 'CANCELAMENTO ARQ DEP NSU ' || vp_cod_arquivo, 2, vp_cod_arquivo);


  -- atualizando a situacao do arquivo
  update sc_adp.tbl_rdp set st_rdp = 7 where st_rdp = 5 and cd_hfe = vp_cod_arquivo;
  update sc_adp.tbl_hfe set st_hfe = 7 where cd_hfe = vp_cod_arquivo;

end;$$;


ALTER FUNCTION sc_adp.cancelar_arquivo_deposito(vp_cod_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1166 (class 1255 OID 564040)
-- Name: cancelar_arquivo_deposito2(numeric); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION cancelar_arquivo_deposito2(vp_cod_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;

  tp_lanc_deposito numeric;
  vl_somatorio double precision := 0;
  vl_cod_conta_empresa numeric;
  
begin

  for rg in select cnt.cd_cnt, rdp.vl_dep_rdp, rdp.cd_tdp
            from sc_adp.tbl_rdp rdp
              inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
              inner join sc_opr.tbl_cnt_crt cct on cct.cd_crt = crt.cd_crt
              inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cct.cd_cnt
            where rdp.cd_hfe = vp_cod_arquivo
              and st_rdp = 5 -- DEPOSITADO
    loop

    -- pegando o tipo de estorno do lancamento
     select tlc.cd_est_tlc
      into tp_lanc_deposito
      from sc_adp.tbl_tdp tdp
         inner join sc_cnt.tbl_tlc tlc on tlc.cd_tlc = tdp.cd_tlc
      where tdp.cd_tdp = rg.cd_tdp;
            
     -- efetuando o lancamento de DEBITO na conta de cada cartao
     perform sc_cnt.lancar_movimento(null, null, tp_lanc_deposito, rg.cd_cnt, 'D', rg.vl_dep_rdp, current_timestamp::timestamp without time zone, 1, null, 'CANCELAMENTO ARQ DEP NSU ' || vp_cod_arquivo, 2, vp_cod_arquivo);
     vl_somatorio := vl_somatorio + rg.vl_dep_rdp;
  
  end loop;

    -- pegando a conta da empresa
    select cd_cnt
    into vl_cod_conta_empresa
     from sc_cad.tbl_ctr ctr
       inner join sc_adp.tbl_hfe hfe on hfe.cd_ctr = ctr.cd_ctr
       where hfe.cd_hfe = vp_cod_arquivo;

  -- efetuando o lancamento de CREDITO na conta da empresa
  perform sc_cnt.lancar_movimento(null, null, tp_lanc_deposito, vl_cod_conta_empresa, 'C', vl_somatorio, current_timestamp::timestamp without time zone, 1, null, 'CANCELAMENTO ARQ DEP NSU ' || vp_cod_arquivo, 2, vp_cod_arquivo);


  -- atualizando a situacao do arquivo
  --update sc_adp.tbl_rdp set st_rdp = 7 where st_rdp = 5 and cd_hfe = vp_cod_arquivo;
  --update sc_adp.tbl_hfe set st_hfe = 7 where cd_hfe = vp_cod_arquivo;

end;$$;


ALTER FUNCTION sc_adp.cancelar_arquivo_deposito2(vp_cod_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1167 (class 1255 OID 564041)
-- Name: cancelar_arquivo_deposito_rescisao(numeric); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION cancelar_arquivo_deposito_rescisao(vp_cod_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  rg_pgto record;
  rg_tarifa record;

  TP_ARQ_DEP_RESCISAO constant numeric := 5;
  TP_LANC_EST_DEP_RESCISAO constant numeric := 25;

  vl_lanc_contra_partida numeric;
  vl_somatorio double precision := 0;
  vl_cod_conta_empresa numeric;
  vl_data_referencia timestamp;

  vl_somatorio_estornado numeric(13,2);

  vl_saldo_conta_cartao numeric(13,2);
 

  vl_existe numeric:= 0;
begin

   select count(*)
     into vl_existe 
   from sc_adp.tbl_hfe
   where cd_hfe = vp_cod_arquivo
     and cd_tdp = TP_ARQ_DEP_RESCISAO;

   if vl_existe = 0 then

      raise exception 'Arquivo de depósito informado não é do tipo RESCISÃO!';
	
   end if;


  select nextval('sc_cnt.sq_lcn') into vl_lanc_contra_partida; 


  for rg in select cnt.cd_cnt, rdp.vl_dep_rdp, rdp.cd_tdp, crt.cd_fcr, crt.cd_fnc, hfe.dt_dps_hfe, crt.cd_crt
            from sc_adp.tbl_rdp rdp
              inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
              inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
              inner join sc_opr.tbl_cnt_crt cct on cct.cd_crt = crt.cd_crt
              inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cct.cd_cnt
            where rdp.cd_hfe = vp_cod_arquivo
              and st_rdp = 5 -- DEPOSITADO
               loop

     vl_data_referencia := rg.dt_dps_hfe;
     vl_somatorio_estornado := 0;

     -- PASSO [1] marcar a rescisao como cancelada
     update sc_rsc.tbl_rsc set st_rsc = 2 where cd_crt = rg.cd_crt and org_rsc = 2;


     -- PASSO [2] cancelar pagamento de fatura caso exista
     select count(*)
       into vl_existe
     from sc_fcr.tbl_fcr
     where cd_fcr = (select cd_fcr from sc_opr.tbl_crt where cd_crt = rg.cd_crt)
       and dt_ems_fcr::date = vl_data_referencia::date;

     if vl_existe > 0 then


       for rg_pgto in select * from sc_fcr.tbl_pfc where cd_fcr = rg.cd_fcr loop

	    vl_somatorio_estornado := vl_somatorio_estornado + rg_pgto.vl_pfc;
	    perform sc_fcr.estorno_pagamento(rg_pgto.cd_pfc,1);

       end loop; 

 

       --PASSO 3 cancelar a fatura
       perform sc_fcr.descontabilizar_fatura_cartao(rg.cd_fcr, 1, 'CANCELAMENTO ARQ DEP NSU ' || vp_cod_arquivo);
       perform sc_fcr.cancelar_fatura(rg.cd_fcr,1);

            
       
     end if;           


     -- PASSO 4 cancelar pagamento das tarifas e marcar para cadastrada
     for rg_tarifa in select * from sc_srv.tbl_tsc where cd_crt = rg.cd_crt and dt_pgto_tsc::date = vl_data_referencia::date loop

         --caso seja saque arredondado cancela pagamento e atualiza servico
         if (rg_tarifa.cd_srv = 6) then

               perform sc_cnt.lancar_debito_credito(13, rg.cd_cnt, 173, null, 'CANCELAMENTO ARQ DEP NSU ' || vp_cod_arquivo, rg_tarifa.vl_tsc, vl_data_referencia, 1, 15, rg_tarifa.cd_tsc);

               update sc_srv.tbl_tsc set st_tsc = 1, dt_pgto_tsc = null where cd_tsc = rg_tarifa.cd_tsc;

               vl_somatorio_estornado := vl_somatorio_estornado + rg_tarifa.vl_tsc;
               
         end if;
         

     end loop;

     --PASSO [5] ativar o funcionario marcar como ativo
     update sc_cad.tbl_fnc set st_fnc = 1 where cd_fnc = rg.cd_fnc;

     -- gravando a ocorrencia
     insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		     values (nextval('sc_opr.sq_ocr'), 14, rg.cd_crt, null, 
				 'RESCISAO EQUIVOCADA PELO ARQUIVO NSU ' || vp_cod_arquivo, 'N', 1, now());


     -- PASSO 6 ativar o cartao
     perform sc_opr.ativar_cartao(rg.cd_crt, 1, 'RESCISAO EQUIVOCADA PELO ARQUIVO NSU ' || vp_cod_arquivo);  
 

     --PASSO [7] efetuando o lancamento de DEBITO na conta de cada cartao 	
     select sc_cnt.saldo_conta(rg.cd_cnt, 'S', 'S')
       into vl_saldo_conta_cartao;

     if vl_saldo_conta_cartao < rg.vl_dep_rdp then
	raise exception 'Saldo da conta insuficiente para estorno do valor do deposito. Codigo da conta %', rg.cd_cnt; 
     end if;
     
     perform sc_cnt.lancar_movimento(null, vl_lanc_contra_partida, TP_LANC_EST_DEP_RESCISAO, rg.cd_cnt, 'D', rg.vl_dep_rdp, vl_data_referencia, 1, null, 'CANCELAMENTO ARQ DEP NSU ' || vp_cod_arquivo, 2, vp_cod_arquivo);
     vl_somatorio := vl_somatorio + rg.vl_dep_rdp;
       
  end loop;

    -- estornando o somatorio para conta da empresa
    -- pegando a conta da empresa
    select cd_cnt
    into vl_cod_conta_empresa
     from sc_cad.tbl_ctr ctr
       inner join sc_adp.tbl_hfe hfe on hfe.cd_ctr = ctr.cd_ctr
       where hfe.cd_hfe = vp_cod_arquivo;

  -- efetuando o lancamento de CREDITO na conta da empresa
  perform sc_cnt.lancar_movimento(vl_lanc_contra_partida, null, TP_LANC_EST_DEP_RESCISAO, vl_cod_conta_empresa, 'C', vl_somatorio, vl_data_referencia, 1, null, 'CANCELAMENTO ARQ DEP NSU ' || vp_cod_arquivo, 2, vp_cod_arquivo);
  

  -- PASSO [9] cancelando o arquivo
  update sc_adp.tbl_rdp set st_rdp = 7 where st_rdp = 5 and cd_hfe = vp_cod_arquivo;
  update sc_adp.tbl_hfe set st_hfe = 7 where cd_hfe = vp_cod_arquivo;

end;$$;


ALTER FUNCTION sc_adp.cancelar_arquivo_deposito_rescisao(vp_cod_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1168 (class 1255 OID 564044)
-- Name: correcao_squadrus(); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION correcao_squadrus() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  vl_cd_rdp numeric;
  vl_vl_valor_rdp double precision;
  vl_diferenca double precision;
  vl_somatorio double precision := 0;
begin

  for rg in select *
            from sc_adp.tbl_rdp rdp
              inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
              inner join sc_opr.tbl_cnt_crt cct on cct.cd_crt = crt.cd_crt
              inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cct.cd_cnt
            where rdp.cd_hfe = 2307 loop

    begin
      select rdp.cd_rdp, rdp.vl_dep_rdp
        into strict vl_cd_rdp, vl_vl_valor_rdp
      from sc_adp.tbl_rdp rdp
      where rdp.nr_mtr_rdp = rg.nr_mtr_rdp
        and rdp.cd_hfe = 2308;
    exception when others then
      vl_cd_rdp := 0;
    end;

    if vl_cd_rdp > 0 then
      vl_diferenca := rg.vl_dep_rdp - vl_vl_valor_rdp;

      if vl_diferenca < 0 then
        vl_diferenca := abs(vl_diferenca);

        perform sc_cnt.lancar_movimento(null, null, 18, rg.cd_cnt, 'D', vl_diferenca, current_timestamp::timestamp without time zone, 1, null, 'Erro arquivo nsu 2308', 2, 2308);
        vl_somatorio := vl_somatorio + vl_diferenca;
      end if;
    end if;

  end loop;

  perform sc_cnt.lancar_movimento(null, null, 18, 9470, 'C', vl_somatorio, current_timestamp::timestamp without time zone, 1, null, 'Erro arquivo nsu 2308', 2, 2308);

end;$$;


ALTER FUNCTION sc_adp.correcao_squadrus() OWNER TO scan;

--
-- TOC entry 1169 (class 1255 OID 564045)
-- Name: corrigir_cartao(); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION corrigir_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
   qtd numeric(2,0);
  rg_rdp record;
  cd_cartao sc_opr.tbl_crt.cd_crt%type;
begin
 for rg_rdp in select * from sc_adp.tbl_rdp where st_rdp = 2 and cd_crt is null loop

       select crt.cd_crt
       into cd_cartao
       from sc_opr.tbl_crt crt
        inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
        inner join sc_adp.tbl_hfe hfe on hfe.cd_emp = fnc.cd_emp and hfe.cd_fem = fnc.cd_fem
        inner join sc_adp.tbl_rdp rdp on rdp.cd_hfe = hfe.cd_hfe
       where rdp.cd_rdp = rg_rdp.cd_rdp
         and fnc.nr_idt_fnc = rg_rdp.nr_mtr_rdp
         and crt.cd_prd = 1
         and crt.fg_atv_crt = 'S';
         
       update sc_adp.tbl_rdp rdp set cd_crt=cd_cartao where rdp.cd_rdp = rg_rdp.cd_rdp;
  end loop;
end;
$$;


ALTER FUNCTION sc_adp.corrigir_cartao() OWNER TO scan;

--
-- TOC entry 1170 (class 1255 OID 564046)
-- Name: existe_cartao_funcionario(numeric, numeric, character varying, numeric); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION existe_cartao_funcionario(cd_empresa numeric, cd_filial numeric, nr_matricula character varying, cd_produto numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
   qtd numeric(2,0);
  
begin
   select count(*)
   into qtd
   from sc_opr.tbl_crt crt
     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
   where fnc.cd_emp = cd_empresa
     and fnc.cd_fem = cd_filial
     and fnc.nr_idt_fnc = nr_matricula
     and (cd_produto is null or crt.cd_prd = cd_produto);

   if( qtd > 0 ) then
     return true;
   else
     return false;  
   end if;
   
end;
$$;


ALTER FUNCTION sc_adp.existe_cartao_funcionario(cd_empresa numeric, cd_filial numeric, nr_matricula character varying, cd_produto numeric) OWNER TO scan;

--
-- TOC entry 7605 (class 0 OID 0)
-- Dependencies: 1170
-- Name: FUNCTION existe_cartao_funcionario(cd_empresa numeric, cd_filial numeric, nr_matricula character varying, cd_produto numeric); Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON FUNCTION existe_cartao_funcionario(cd_empresa numeric, cd_filial numeric, nr_matricula character varying, cd_produto numeric) IS 'ROTINA QUE VERIFICA SE EXISTE CARTAO COM AS CARACTERISTICAS PASSADAS COMO PARAMETRO';


--
-- TOC entry 1153 (class 1255 OID 564047)
-- Name: gerar_arquivo_correcao(); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION gerar_arquivo_correcao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg_hfe record;
  vl_rg_rdp record;
begin
  for vl_rg_hfe in select hfe.cd_emp, hfe.cd_fem, cun.tp_pss_cun, cun.nr_cpf_cnpj_cun, count(*) as qtde, sum(rdp.vl_dep_rdp) as valor
                   from sc_adp.tbl_rdp rdp
                        inner join sc_adp.tbl_hfe hfe on rdp.cd_hfe = hfe.cd_hfe
                        inner join sc_cad.tbl_fem fem on hfe.cd_emp = fem.cd_emp and hfe.cd_fem = fem.cd_fem
                        inner join sc_cad.tbl_cun cun on fem.cd_cun = cun.cd_cun
                   where rdp.st_rdp = 2 
                     and rdp.cd_crt is null
                   group by hfe.cd_emp, hfe.cd_fem, cun.tp_pss_cun, cun.nr_cpf_cnpj_cun loop
    insert into sc_adp.tbl_hdr
    values(nextval('sc_adp.sq_hdr'), 1, vl_rg_hfe.cd_emp, 1, now(), null, 1, null, now(), 1, null, null);

    insert into sc_adp.tbl_hfe
    values(nextval('sc_adp.sq_hfe'), currval('sc_adp.sq_hdr'), vl_rg_hfe.cd_emp, vl_rg_hfe.cd_fem, vl_rg_hfe.tp_pss_cun, vl_rg_hfe.nr_cpf_cnpj_cun,
           current_date, 1, null, null, null, null, null, null, '042012', null, null, null);

    for vl_rg_rdp in select rdp.nr_mtr_rdp, rdp.vl_dep_rdp, rdp.cd_tdp
                     from sc_adp.tbl_rdp rdp
                          inner join sc_adp.tbl_hfe hfe on rdp.cd_hfe = hfe.cd_hfe
                     where rdp.st_rdp = 2 
                       and rdp.cd_crt is null
                       and hfe.cd_emp = vl_rg_hfe.cd_emp
                       and hfe.cd_fem = vl_rg_hfe.cd_fem loop
      insert into sc_adp.tbl_rdp
      values(nextval('sc_adp.sq_rdp'), currval('sc_adp.sq_hfe'), currval('sc_adp.sq_hdr'), vl_rg_rdp.nr_mtr_rdp, vl_rg_rdp.vl_dep_rdp, 1, null, null, vl_rg_rdp.cd_tdp);
    end loop;

    insert into sc_adp.tbl_tfe
    values(nextval('sc_adp.sq_tfe'), currval('sc_adp.sq_hfe'), currval('sc_adp.sq_hdr'), vl_rg_hfe.cd_emp, vl_rg_hfe.cd_fem, vl_rg_hfe.tp_pss_cun, vl_rg_hfe.nr_cpf_cnpj_cun,
           vl_rg_hfe.qtde, vl_rg_hfe.valor, null, null, 1, null, null, null);

    insert into sc_adp.tbl_trl
    values(nextval('sc_adp.sq_trl'), currval('sc_adp.sq_hdr'), vl_rg_hfe.cd_emp, 1, 1, vl_rg_hfe.qtde, vl_rg_hfe.valor, null, null, 1, null);
  end loop;
end;$$;


ALTER FUNCTION sc_adp.gerar_arquivo_correcao() OWNER TO scan;

--
-- TOC entry 7606 (class 0 OID 0)
-- Dependencies: 1153
-- Name: FUNCTION gerar_arquivo_correcao(); Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON FUNCTION gerar_arquivo_correcao() IS 'rotina criada para gerar arquivo de deposito de correcao de registros de deposito validados sem cartao';


--
-- TOC entry 1154 (class 1255 OID 564048)
-- Name: get_cartao(numeric, numeric); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION get_cartao(vp_codigo_registro_deposito numeric, vp_codigo_produto numeric, OUT vp_codigo_cartao numeric, OUT vp_motivo_erro numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
  vl_existe numeric;
  
  ct_sem_cartao constant numeric := 4;
  ct_muitos_cartoes_ativos constant numeric := 5;
  ct_muitos_cartoes_inativos constant numeric := 6;
begin
  vp_codigo_cartao := null;
  vp_motivo_erro := null;
  
  select count(*)
  into vl_existe
  from sc_opr.tbl_crt crt
       inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
       inner join sc_adp.tbl_hfe hfe on hfe.cd_emp = fnc.cd_emp and hfe.cd_fem = fnc.cd_fem
       inner join sc_adp.tbl_rdp rdp on rdp.cd_hfe = hfe.cd_hfe
  where rdp.cd_rdp = vp_codigo_registro_deposito
    and fnc.nr_idt_fnc = rdp.nr_mtr_rdp
    and crt.cd_prd = vp_codigo_produto
    and crt.fg_atv_crt = 'S';

  if vl_existe = 0 then
    select count(*)
    into vl_existe
    from sc_opr.tbl_crt crt
	 inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
	 inner join sc_adp.tbl_hfe hfe on hfe.cd_emp = fnc.cd_emp and hfe.cd_fem = fnc.cd_fem
	 inner join sc_adp.tbl_rdp rdp on rdp.cd_hfe = hfe.cd_hfe
    where rdp.cd_rdp = vp_codigo_registro_deposito
      and fnc.nr_idt_fnc = rdp.nr_mtr_rdp
      and crt.cd_prd = vp_codigo_produto;

    if vl_existe = 0 then
      vp_motivo_erro := ct_sem_cartao;
    else
      if vl_existe = 1 then
        select crt.cd_crt
        into vp_codigo_cartao
        from sc_opr.tbl_crt crt
	     inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
	     inner join sc_adp.tbl_hfe hfe on hfe.cd_emp = fnc.cd_emp and hfe.cd_fem = fnc.cd_fem
	     inner join sc_adp.tbl_rdp rdp on rdp.cd_hfe = hfe.cd_hfe
        where rdp.cd_rdp = vp_codigo_registro_deposito
          and fnc.nr_idt_fnc = rdp.nr_mtr_rdp
          and crt.cd_prd = vp_codigo_produto;
      else
        vp_motivo_erro := ct_muitos_cartoes_inativos;
      end if;
    end if;
  else
    if vl_existe = 1 then
      select crt.cd_crt
      into vp_codigo_cartao
      from sc_opr.tbl_crt crt
           inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
           inner join sc_adp.tbl_hfe hfe on hfe.cd_emp = fnc.cd_emp and hfe.cd_fem = fnc.cd_fem
           inner join sc_adp.tbl_rdp rdp on rdp.cd_hfe = hfe.cd_hfe
      where rdp.cd_rdp = vp_codigo_registro_deposito
        and fnc.nr_idt_fnc = rdp.nr_mtr_rdp
        and crt.cd_prd = vp_codigo_produto
        and crt.fg_atv_crt = 'S';
    else
      vp_motivo_erro := ct_muitos_cartoes_ativos;
    end if;
  end if;
end;$$;


ALTER FUNCTION sc_adp.get_cartao(vp_codigo_registro_deposito numeric, vp_codigo_produto numeric, OUT vp_codigo_cartao numeric, OUT vp_motivo_erro numeric) OWNER TO scan;

--
-- TOC entry 7607 (class 0 OID 0)
-- Dependencies: 1154
-- Name: FUNCTION get_cartao(vp_codigo_registro_deposito numeric, vp_codigo_produto numeric, OUT vp_codigo_cartao numeric, OUT vp_motivo_erro numeric); Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON FUNCTION get_cartao(vp_codigo_registro_deposito numeric, vp_codigo_produto numeric, OUT vp_codigo_cartao numeric, OUT vp_motivo_erro numeric) IS 'rotina que tenta obter o codigo de cartao ativo, mas senao encontrar obtem um codigo de cartao inativo, senao existir ou existir mais de um inativo, retorna nulo';


--
-- TOC entry 1826 (class 1255 OID 564049)
-- Name: informar_cartoes_sem_deposito(); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION informar_cartoes_sem_deposito() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  texto text;
  rg record;
  assunto varchar;
  count numeric := 1;
begin

	texto := '<html xmlns=\"http://www.w3.org/1999/xhtml\">
			<head>
			<meta http-equiv=\"Content-Type\" content=\"text/html\" />
			<meta charset=\"UTF-8\">
			
			<title>Cartoes Sem Deposito</title>

			<style src=\"https://b2b.somacontadigital.com.br/internetlife/css/estilo.css\">
			</style>

			</head>

			<body>
			<table id=\"tabela\">
				<tr>
					<th>Empresa</th>
					<th>Cartao</th>
					<th>Data Ultimo Deposito</th>
					<th>Sld. Devedor Atual</th>
			       </tr>';


	for rg in select emp.nm_emp,
			 crt.cd_crt || '-' ||  cun.nm_cun cartao,
			 crt.dt_ult_dps_crt::date dt_ult_dps_crt,
			 f.vl_sld_dvd_fcr
		 from sc_opr.tbl_crt crt
		  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
		  inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
		  inner join sc_fcr.tbl_fcr f on f.cd_fcr = crt.cd_fcr
		  inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
		where exists( select 1
				  from sc_adp.tbl_hfe h
				     inner join sc_adp.tbl_rdp rdp on rdp.cd_hfe = h.cd_hfe
				   where h.dt_dps_hfe >= current_date - interval '1 day'  
				     and h.dt_dps_hfe < current_date
				     and h.cd_ctr = crt.cd_ctr
				     and h.cd_tdp = 1
				)
		  and not exists( select 1
				  from sc_adp.tbl_hfe h
				     inner join sc_adp.tbl_rdp rdp on rdp.cd_hfe = h.cd_hfe
				   where h.dt_dps_hfe >= current_date - interval '1 day'  
				     and h.dt_dps_hfe < current_date
				     and rdp.cd_crt = crt.cd_crt
				)              
		  and exists(select 1
			     from sc_fcr.tbl_fcr fcr
			       inner join sc_fcr.tbl_prc prc on prc.cd_fcr = fcr.cd_fcr
			       inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
			     where fcr.cd_fcr = crt.cd_fcr
			       and fcr.vl_sld_dvd_fcr > 0
			       and opr.cd_top = 5
			     )  
		order by emp.nm_emp,cun.nm_cun  loop
		
	  texto := texto || '<tr class=\"' || case when mod(count,2) = 0 then '' else 'impar' end || '\">';
	  texto := texto || '<td>'|| rg.nm_emp ||'</td>';
	  texto := texto || '<td>'|| rg.cartao ||'</td>';

          if rg.dt_ult_dps_crt is null then
            texto := texto || '<td align=''center''>NAO HOUVE</td>';
          else
	    texto := texto || '<td align=''center''>'|| to_char(rg.dt_ult_dps_crt,'dd/mm/yyyy') ||'</td>';
          end if;

	  texto := texto || '<td align=''right''>'|| coalesce(rg.vl_sld_dvd_fcr,0) ||'</td>';
	  texto := texto || '</tr>';

	  count := count + 1;
	
     end loop;	

     texto := texto || '</table></body></html>';

     --raise notice '%',texto;
     assunto := 'Atenção: Cartões sem Depósito';

     
     --perform sc_pbl.enviar_email_saqpag('tecnologia@somacontadigital.com.br',assunto,texto,null);
     perform sc_pbl.enviar_email_saqpag('risco@somacontadigital.com.br;comercial@somacontadigital.com.br;tecnologia@somacontadigital.com.br',assunto,texto,null);
end$$;


ALTER FUNCTION sc_adp.informar_cartoes_sem_deposito() OWNER TO scan;

--
-- TOC entry 1843 (class 1255 OID 564050)
-- Name: inserir_mensagem_agendamento(numeric); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION inserir_mensagem_agendamento(vp_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  ct_agendamento_salario numeric := 2;
  ct_agendamento_salario_sem_limite numeric := 4;
  ct_limite_saque_extra numeric := 1;

  rg record;
  vl_existe_mensagem numeric;
  vl_cd_tms numeric;
  vl_valor_limite_saque_extra numeric(13,2);
begin

  -- pegando dados do celular
  for rg in select tlf.nr_ddd_tlf as ddd, tlf.nr_tlf as telefone, crt.cd_crt as cartao,
                   substring(cun.nm_cun, 0, position(' ' in cun.nm_cun)) || '@' || to_char(hfe.dt_agd_dps_hfe,'dd/mm hh24') as parametro
            from sc_adp.tbl_rdp rdp
              inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
              inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
              inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
              inner join sc_cad.tbl_tlf tlf on tlf.nsu_org_tlf = fnc.cd_cun and tlf.tp_org_tlf = 1
              inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
            where hfe.cd_hfe = vp_arquivo
              and tlf.nr_tlf > 80000000
              and tlf.nr_tlf not in (800000000,866666666,88888888,888888888,900000000,99999999,999999999)
              and tlf.tp_tlf = 2
              and tlf.fg_atv_tlf = 'S'
              --27-POSTO ECO(CHAMADO 1132. VOLTOU NO CHAMADO 2626)
              and emp.cd_gem not in (132, 77, 211, 167, 243, 236, 325, 139,249)
              -- 132-DESTAK, 77-SPRING EMPREENDIMENTOS, 211-PROJEPISO(CHAMADO 1028), 167-LPM(CHAMADO 1100), 243-HECTOPLAST (CHAMADO 1483), 236-ESCOCIO CONSTRUCOES (CHAMADO 2601), 325-MM GESSO (CHAMADO 2779), 139-RODAN (CHAMADO 3951) 
              and tlf.cd_tlf = (select max(cd_tlf) from sc_cad.tbl_tlf where nsu_org_tlf = fnc.cd_cun and tp_tlf = 2 and tlf.nr_tlf <> 88888888 and tlf.nr_tlf > 80000000 and fg_atv_tlf = 'S') loop

      -- verificando se tem saldo de limite
      begin
        select lmt.vl_cnc_lmt 
          into strict vl_valor_limite_saque_extra
        from sc_opr.tbl_lmt lmt
        where lmt.cd_crt = rg.cartao
          and lmt.cd_tlt = ct_limite_saque_extra;
      exception when others then
        vl_valor_limite_saque_extra := 0;
      end;

      -- verificando qual vai ser a mensagem
      vl_cd_tms = ct_agendamento_salario;
      if vl_valor_limite_saque_extra = 0 then
        vl_cd_tms := ct_agendamento_salario_sem_limite;
      end if;

      -- verificando se ja existe mensagem de depoisto
      vl_existe_mensagem := 0;
      /*select count(*)
        into vl_existe_mensagem
      from sc_msg.tbl_msg msg
      where msg.cd_tms = vl_cd_tms
        and msg.prm_msg = rg.parametro
        and msg.ddd_msg = rg.ddd
        and msg.nr_msg = rg.telefone
        and msg.fg_atv_msg = 'S'
        and msg.fg_env_msg = 'N';*/

      if vl_existe_mensagem = 0 then
        insert into sc_msg.tbl_msg(cd_msg, cd_tms, ddd_msg, nr_msg, prm_msg, fg_atv_msg, fg_env_msg, cd_inc_usr, dt_inc_usr, cd_crt)
          values (nextval('sc_msg.sq_msg'), vl_cd_tms, rg.ddd, rg.telefone, rg.parametro, 'S', 'N', 1, now(), rg.cartao);
      end if;
  end loop;
end;$$;


ALTER FUNCTION sc_adp.inserir_mensagem_agendamento(vp_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1728 (class 1255 OID 564051)
-- Name: processa_arquivo(); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION processa_arquivo() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg_hfe record;
  
  st_hfe_agendado sc_adp.tbl_hfe.st_hfe%type := 4;
  st_hfe_processado_erro sc_adp.tbl_hfe.st_hfe%type := 8;

  _conn text;
begin

  _conn:='hostaddr=127.0.0.1 port=5432 dbname=scan user=scan password=scan';

  for rg_hfe in select h.cd_hfe
                from sc_adp.tbl_hfe h
                where h.st_hfe = st_hfe_agendado
                  and (h.dt_agd_dps_hfe <= now() + interval '2 hour'
                    or sc_cad.get_parametro_contrato(44,h.cd_ctr, null, 1) = 'SIM')
                order by h.dt_agd_dps_hfe, h.cd_hfe loop
     begin
       
        perform * from dblink(_conn,'select sc_adp.processa_arquivo_deposito(' || rg_hfe.cd_hfe || ')') as x (x text);
        
     exception
       when others then
         PERFORM dblink_exec(_conn,'
         update sc_adp.tbl_hfe
            set st_hfe = ' || st_hfe_processado_erro || '
         where cd_hfe = ' || rg_hfe.cd_hfe || ';');
     end;
                
  end loop;                

end
$$;


ALTER FUNCTION sc_adp.processa_arquivo() OWNER TO scan;

--
-- TOC entry 1781 (class 1255 OID 564052)
-- Name: processa_arquivo_deposito(numeric); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION processa_arquivo_deposito(cd_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  rg_rdp record;
  
  cd_conta_empresa sc_cnt.tbl_cnt.cd_cnt%type;
  cd_conta_cartao sc_cnt.tbl_cnt.cd_cnt%type;
  tp_lanc_deposito sc_cnt.tbl_tlc.cd_tlc%type;
  
  nr_lanc_empresa sc_cnt.tbl_lcn.cd_lcn%type;
  nr_lanc_deposito sc_cnt.tbl_lcn.cd_lcn%type;
  
  vlr_ttl_deposito sc_adp.tbl_tfe.vl_reg_vld_tfe%type;
  vlr_ttl_valido sc_adp.tbl_tfe.vl_reg_vld_tfe%type;
  qtd_ttl_depositos sc_adp.tbl_tfe.nr_reg_dep_tfe%type;
  
  rdp_st_validado "numeric"(2,0) := 2;
  rdp_st_depositado "numeric"(2,0) := 5;
  rdp_st_erro_processamento "numeric"(2,0) := 6;
  
  TP_RDP_RESCISAO sc_adp.tbl_tdp.cd_tdp%type := 5;
  TP_RDP_DECIMO sc_adp.tbl_tdp.cd_tdp%type := 2;

  vl_existe_divida numeric;

  hfe_st_agendado numeric(2,0) := 4;
  hfe_st_depositado numeric(2,0) := 5;
  hfe_st_em_processamento numeric(2,0) := 6;
  
  sst_deposito sc_cnt.tbl_sst.cd_sst%type := 2;
  vl_cd_tdp_recisao numeric := 5;
  vl_saldo_conta double precision;

  ct_contra_partida_baixa_cartao numeric := 5;
  ct_tlc_baixa_fatura numeric := 15;
  vl_valor_limite_utilizado double precision;

  -- variaveris de transferencia
  rg_cbf record;
  vl_valor_saldo numeric;
  vl_valor_transferencia numeric;
  vl_tarifa_transferencia numeric;
  vl_percentual_transferencia numeric;
  vl_percentual_transferencia_acm numeric;
  vl_existe_transferencia_gerada numeric;
  vl_quantidade_abono_contrato numeric;
  vl_tipo_pagamento_tarifa numeric;
  vl_codigo_contrato numeric;
  vl_saldo_inicial numeric;
  vl_data_agendamento timestamp;
  vl_valor_bloqueio numeric;
  vl_desconto numeric;


  _conn text;
begin

     --_conn:='hostaddr=localhost port=5432 dbname=scan user=postgres password=@pt%m0b123';

     _conn:='hostaddr=127.0.0.1 port=5432 dbname=scan user=scan password=scan';
     

     begin
     
       select ctr.cd_cnt, tfe.vl_reg_vld_tfe,hfe.dt_agd_dps_hfe
       into strict cd_conta_empresa, vlr_ttl_valido,vl_data_agendamento
       from sc_cad.tbl_ctr ctr
          inner join sc_adp.tbl_hfe hfe on hfe.cd_ctr = ctr.cd_ctr
          inner join sc_cad.tbl_fem_ctr fctr on ctr.cd_ctr = fctr.cd_ctr and fctr.cd_fem = hfe.cd_fem
          inner join sc_adp.tbl_tfe tfe on tfe.cd_hfe = hfe.cd_hfe
       where ctr.fg_atv_ctr = 'S'
         and fctr.fg_atv_fem_ctr = 'S'
         --and ctr.cd_prd = 1
	 and hfe.cd_hfe = cd_arquivo
	 and hfe.st_hfe = hfe_st_agendado;

         perform dblink_exec(_conn,'
         update sc_adp.tbl_hfe
            set st_hfe = ' || hfe_st_em_processamento || ',
                dt_ini_prc_hfe = clock_timestamp()
         where cd_hfe = ' || cd_arquivo || ';');
         
      exception when others THEN
        
        raise exception 'Não foi possível obter o número da conta do contrato da empresa.NSU ARQUVIO: % ERRO: %', cd_arquivo, SQLERRM;
               
      end;   

    vlr_ttl_deposito := 0;
    qtd_ttl_depositos := 0;

    select nextval('sc_cnt.sq_lcn') into nr_lanc_empresa;

    for rg_rdp in select *
                  from sc_adp.tbl_rdp rdp
                  where rdp.st_rdp = rdp_st_validado
                    and rdp.cd_hfe = cd_arquivo
                    and rdp.cd_crt is not null loop
    
      begin

          select sc_cnt.get_saldo_cartao(rg_rdp.cd_crt, 'N', 'N') into vl_saldo_inicial;
      
          update sc_adp.tbl_rdp set dt_ini_prc_rdp = clock_timestamp() where cd_rdp = rg_rdp.cd_rdp;

          select cnt_crt.cd_cnt
          into cd_conta_cartao
          from sc_opr.tbl_cnt_crt cnt_crt
            inner join sc_adp.tbl_tdp tpd on tpd.tp_cnt_tdp = cnt_crt.tp_cnt_crt
          where cnt_crt.cd_crt = rg_rdp.cd_crt;
             --and tpd.cd_tdp = rg_rdp.cd_tdp;
          
      exception when others then
      
         begin
         
            select cnt_crt.cd_cnt
            into cd_conta_cartao
            from sc_opr.tbl_cnt_crt cnt_crt
            where cnt_crt.cd_crt = rg_rdp.cd_crt
              and cnt_crt.fg_pdr_cnt_crt = 'S';
            
         exception when others then
            update sc_adp.tbl_rdp 
            set    st_rdp = rdp_st_erro_processamento,
                   dt_fin_prd_rdp = clock_timestamp()  
            where cd_rdp = rg_rdp.cd_rdp;

            continue;
         end;   
         
      end;    
      
      select tdp.cd_tlc
      into tp_lanc_deposito
      from sc_adp.tbl_tdp tdp
      where tdp.cd_tdp = rg_rdp.cd_tdp;
      
      nr_lanc_deposito := null;
      
      perform sc_cnt.lancar_movimento(nr_lanc_deposito, nr_lanc_empresa,tp_lanc_deposito,cd_conta_cartao,'C',
                                       rg_rdp.vl_dep_rdp,now()::timestamp,1::numeric,null,('Arq dep nsu '||cd_arquivo)::varchar,
                                       sst_deposito,cd_arquivo);
      
                                            
      vlr_ttl_deposito := vlr_ttl_deposito + rg_rdp.vl_dep_rdp;
      qtd_ttl_depositos := qtd_ttl_depositos + 1;
      
      update sc_adp.tbl_rdp set st_rdp = rdp_st_depositado where cd_rdp = rg_rdp.cd_rdp;

      -- Efetuando descontos  
      if rg_rdp.cd_tdp = TP_RDP_RESCISAO then
        perform sc_rsc.efetuar_rescisao_cartao_padrao(rg_rdp.cd_crt);
        perform sc_rsc.efetuar_rescisao(rg_rdp.cd_crt,now()::timestamp,1,'Rescisão via arquivo de depósito.',2, rg_rdp.vl_dep_rdp);
        perform sc_srv.cobrar_tarifa_servico(now()::date, null, rg_rdp.cd_crt); 
        perform sc_fcr.efetuar_baixa_cartao(rg_rdp.cd_crt,null,1,now()::timestamp,1,null,true);
      else
        if rg_rdp.cd_tdp <> TP_RDP_DECIMO then --if provisorio
           perform sc_srv.cobrar_tarifa_servico(now()::date, null, rg_rdp.cd_crt);
           if not sc_cbe.existe_acordo_vigente(1,rg_rdp.cd_crt) then
		perform sc_fcr.efetuar_baixa_cartao(rg_rdp.cd_crt,null,1,now()::timestamp,1,null,false);
	   end if;
        end if;   
      end if ;

        -- EFETUAR COBRANCA DE PARCELAS DE RENEGOCIACAO
      	perform sc_scan_cbe.cobrar_parcela_divida_cartao(rg_rdp.cd_crt);
      
      -- Verifica se o funcionario possui divida em outros cartoes e efetua a transferencia para quitar. 
        if rg_rdp.cd_tdp <> TP_RDP_DECIMO then --if provisorio
	  perform sc_fcr.efetuar_baixa_outros_cartoes(rg_rdp.cd_crt);
	end if;  

      -- Verifica se o CPF possui dividas ativas na SAQCARD e captura para realizar a quitação
      -- 20/04/2015 
        if rg_rdp.cd_tdp <> TP_RDP_DECIMO then --if provisorio
	  perform sc_mgr.efetuar_baixa_saqcard(rg_rdp.cd_crt);
	  perform sc_mgr.efetuar_baixa_saqcard_divida_antiga(rg_rdp.cd_crt);
	end if;  

      -- Cobrar a tarifa de TMC
      perform sc_srv.cobrar_servico_tmc_deposito(rg_rdp.cd_crt);
      perform sc_srv.cobrar_tarifa_servico_tmc_deposito(current_date, rg_rdp.cd_crt);
  		
      -- fazer a transferencia caso exista
      --if rg_rdp.cd_tdp = 1 then -- tipo de deposito salario
        vl_percentual_transferencia_acm := 0;
        for rg_cbf in select cbf.*,fnc.*,crt.*--,ctr.*,pce_ctr.*,coalesce(pce_ctr_abn.vl_pce_ctr::numeric,0) as quantidade_abono
                      from sc_cad.tbl_cbf cbf
                        inner join sc_cad.tbl_fnc fnc on cbf.cd_cun = fnc.cd_cun
                        inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
                        --inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
                        --inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 11 -- parametro contrato empresa de tarifa de transferencia
                        --left join sc_cad.tbl_pce_ctr pce_ctr_abn on pce_ctr_abn.cd_ctr = ctr.cd_ctr and pce_ctr_abn.cd_pce = 30 --parametro contrato empresa quantidade abono
                      where crt.cd_crt = rg_rdp.cd_crt 
                        and cbf.pc_dps_cbf > 0 
                        and cbf.fg_atv_cbf = 'S'
                        AND fnc.cd_emp <> 29
                      order by cbf.dt_inc_usr loop

          if vl_percentual_transferencia_acm + rg_cbf.pc_dps_cbf > 100 then
            exit;
          end if;

          vl_tarifa_transferencia := replace(replace(sc_cad.get_parametro_contrato_cartao(11, rg_rdp.cd_crt), '.', ''), ',', '.')::numeric;
          vl_tipo_pagamento_tarifa := sc_cad.get_parametro_contrato_cartao(11,rg_rdp.cd_crt,3)::numeric; 
          vl_quantidade_abono_contrato := sc_cad.get_parametro_contrato_cartao(30, rg_rdp.cd_crt)::numeric;

          select sum(cnt.vl_sld_cnt)
            into vl_valor_saldo
          from sc_cnt.tbl_cnt cnt
            inner join sc_opr.tbl_cnt_crt cnt_crt on cnt.cd_cnt = cnt_crt.cd_cnt
          where cnt_crt.cd_crt = rg_rdp.cd_crt;

          --vl_tarifa_transferencia = replace(replace(vl_tarifa_transferencia, '.', ''), ',', '.');

          -- Vitor Vasconcelos
          -- 06/10/2015
          if (vl_tipo_pagamento_tarifa = 1) then -- Se o tipo de Cobranca é Empresa
             vl_tarifa_transferencia := 0;
          end if;
          --

          -- Vitor Vasconcelos
          -- 19/10/2015
          -- Abono de tarifa de transferencia
          if(vl_quantidade_abono_contrato > 0) then

             if(coalesce(rg_cbf.qtd_abn_trf_crt,0) < vl_quantidade_abono_contrato) then
                  vl_tarifa_transferencia := 0;
             end if;
          
          end if;
          --

          vl_percentual_transferencia := rg_cbf.pc_dps_cbf;
          vl_valor_transferencia := rg_rdp.vl_dep_rdp;
          if vl_percentual_transferencia_acm > 0 then
            vl_valor_transferencia := rg_rdp.vl_dep_rdp - (vl_valor_transferencia * (vl_percentual_transferencia_acm / 100));
            vl_percentual_transferencia := 100 * vl_percentual_transferencia / (100 - vl_percentual_transferencia_acm);
          end if;
  
          vl_percentual_transferencia_acm := vl_percentual_transferencia_acm + rg_cbf.pc_dps_cbf;

          select count(*)
            into vl_existe_transferencia_gerada
          from sc_atb.tbl_tba tba
          where tba.st_tba = 1 -- gerada
            and tba.nr_cpf_cnpj_tba = rg_cbf.nr_cpf_cnpj_cbf
            and tba.cd_bnc = rg_cbf.cd_bnc
           and tba.nr_agc_tba = rg_cbf.nr_agc_cbf
            and tba.nr_dgt_agc_tba = rg_cbf.nr_dgt_agc_cbf
            and tba.nr_cba_tba = rg_cbf.nr_cba_cbf
            and tba.nr_dgt_cba_tba = rg_cbf.nr_dgt_cba_cbf;

          if vl_existe_transferencia_gerada > 0 then
            vl_tarifa_transferencia = 0;
          end if;
  
          if vl_valor_saldo > (vl_valor_transferencia * (vl_percentual_transferencia / 100)) + vl_tarifa_transferencia then
            vl_valor_transferencia := vl_valor_transferencia * (vl_percentual_transferencia / 100);
          else
            vl_valor_transferencia := (vl_valor_saldo * (vl_percentual_transferencia / 100)) - vl_tarifa_transferencia;
            perform sc_atb.transferencia_bancaria(rg_cbf.cd_bnc, rg_cbf.nr_agc_cbf, rg_cbf.nr_dgt_agc_cbf, rg_cbf.nr_cba_cbf, rg_cbf.nr_dgt_cba_cbf, rg_cbf.tp_cba_cbf, vl_valor_transferencia, rg_cbf.cd_fnc, 'TRANSFERENCIA AUTOMATICA'::varchar, 1, now()::timestamp with time zone);
            exit;
          end if;

          perform sc_atb.transferencia_bancaria(rg_cbf.cd_bnc, rg_cbf.nr_agc_cbf, rg_cbf.nr_dgt_agc_cbf, rg_cbf.nr_cba_cbf, rg_cbf.nr_dgt_cba_cbf, rg_cbf.tp_cba_cbf, vl_valor_transferencia, rg_cbf.cd_fnc, 'TRANSFERENCIA AUTOMATICA'::varchar, 1, now()::timestamp with time zone);
        
        end loop;
      --end if;

      perform sc_adp.atualiza_cartao(rg_rdp.cd_crt);

      -- Vitor Vasconcelos
      -- 23/08/2018
      -- Bloqueia para Saque no caso de contrato D0
      select cd_ctr 
      into vl_codigo_contrato 
      from sc_opr.tbl_crt 
      where cd_crt = rg_rdp.cd_crt;
      
      if coalesce(sc_cad.get_parametro_contrato(44,vl_codigo_contrato, null, 1),'Não') = 'SIM' then -- Se é D0

          select sc_cnt.get_saldo_cartao(rg_rdp.cd_crt, 'N', 'N') into vl_valor_saldo;
          
          vl_desconto := vl_saldo_inicial + rg_rdp.vl_dep_rdp - vl_valor_saldo;
      
     
          if (rg_rdp.vl_dep_rdp - vl_desconto) > 0 then

             perform sc_cnt.bloqueio_saldo_conta_agendamento(cd_conta_cartao,9,(rg_rdp.vl_dep_rdp - vl_desconto),vl_data_agendamento);
          end if;
         
      end if;


      update sc_adp.tbl_rdp set dt_fin_prc_rdp = clock_timestamp() where cd_rdp = rg_rdp.cd_rdp;
    end loop;
    
    if( vlr_ttl_deposito > 0 ) then

        update sc_cnt.tbl_tbc_cnt 
          set vl_blq_tbc_cnt = vl_blq_tbc_cnt - vlr_ttl_deposito,
              dt_alt_usr = now(),
              cd_alt_usr = 1
        where cd_cnt = cd_conta_empresa
          and cd_tbc = 2; -- tipo de bloqueio de agendamento
    
      update sc_adp.tbl_hfe 
      set st_hfe = hfe_st_depositado,
          dt_dps_hfe = now(),
          dt_fin_prc_hfe = clock_timestamp() 
      where cd_hfe = cd_arquivo;
      
      update sc_adp.tbl_tfe
      set nr_reg_dep_tfe = qtd_ttl_depositos,
          vl_reg_dep_tfe = vlr_ttl_deposito
      where cd_hfe = cd_arquivo;    
      
      nr_lanc_deposito := null;
      perform sc_cnt.lancar_movimento(nr_lanc_empresa,nr_lanc_deposito, tp_lanc_deposito,cd_conta_empresa,'D',
                                 vlr_ttl_deposito,now()::timestamp,1::numeric,null,('Arq dep nsu '||cd_arquivo)::varchar,
                                 sst_deposito,cd_arquivo);
      
      
    end if;
                  
end;
$$;


ALTER FUNCTION sc_adp.processa_arquivo_deposito(cd_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1171 (class 1255 OID 564055)
-- Name: valida_arquivo_deposito(); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION valida_arquivo_deposito() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg_hfe record;
begin
  for rg_hfe in select hfe.cd_hfe
                from sc_adp.tbl_hfe hfe
                where hfe.st_hfe = 1 loop
                
     perform sc_adp.valida_arquivo_deposito(rg_hfe.cd_hfe, 1);
             
  end loop;              
end;
$$;


ALTER FUNCTION sc_adp.valida_arquivo_deposito() OWNER TO scan;

--
-- TOC entry 1174 (class 1255 OID 564056)
-- Name: valida_arquivo_deposito(numeric); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION valida_arquivo_deposito(cd_arquivo numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
  
begin
   
   return sc_adp.valida_arquivo_deposito(cd_arquivo, 1);

end;
$$;


ALTER FUNCTION sc_adp.valida_arquivo_deposito(cd_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1535 (class 1255 OID 861992)
-- Name: valida_arquivo_deposito(numeric, numeric); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION valida_arquivo_deposito(cd_arquivo numeric, vp_usuario numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
   ct_produto_salario constant numeric := 1;

   vl_motivo_erro_detalhe numeric;
   
   qtd_reg_dps numeric(8,0) := 0;
   vl_reg_dps numeric(10,2) := 0;

   qtd_reg_dps_trl numeric(8,0) := 0;
   vl_reg_dps_trl numeric(10,2) := 0;
   
   qtd_reg_inv numeric(8,0) := 0;
   vlr_reg_inv numeric(10,2) := 0;
   
   qtd_reg_vld numeric(8,0) := 0;
   vlr_reg_vld numeric(10,2) := 0;
   
   situacao_hfe numeric(2,0);
   
   cd_contrato numeric(10,0);
   cd_cartao sc_opr.tbl_crt.cd_crt%type;
   
   cd_filial numeric(10,0);
   cd_empresa numeric(10,0);

   /******* CONSTANTES ********/

   hfe_st_validado numeric(2,0) := 2;
   hfe_st_invalido numeric(2,0) := 3;
   hfe_st_recebido numeric(2,0) := 1;
   hfe_st_em_processamento numeric(2,0) := 6;

   hfe_cd_err_proc_qtd_trl numeric(2,0) := 1;
   hfe_cd_err_proc_vlr_trl numeric(2,0) := 9;
   hfe_cd_err_todos_invd numeric(2,0) := 2;
   hfe_cd_err_s_ctr_atv numeric(2,0) := 6;
   hfe_cd_err_cun_n_existe numeric(2,0) := 4;
   
   rdp_cd_ret_func_nao_existe numeric(2,0) := 2;

   rg_rdp record;

   vl_existe numeric;
begin
   
      
   select count(*)
     into vl_existe
   from sc_adp.tbl_hfe
   where cd_hfe = cd_arquivo
     and st_hfe = hfe_st_recebido;

   if vl_existe = 0 then
      raise exception 'Arquivo não pode ser validado. Motivo: situação diferente de RECEBIDO';
   end if;


   select count(*),sum(dep.vl_dep_rdp)
   into qtd_reg_dps,vl_reg_dps
   from sc_adp.tbl_rdp dep
   where cd_hfe = cd_arquivo;

   select nr_reg_env_tfe,vl_reg_env_tfe
   into qtd_reg_dps_trl,vl_reg_dps_trl
   from sc_adp.tbl_tfe
   where cd_hfe = cd_arquivo;

   if(qtd_reg_dps <> qtd_reg_dps_trl) then
     update sc_adp.tbl_hfe h set st_hfe = hfe_st_invalido,cd_ret_hfe=hfe_cd_err_proc_qtd_trl where h.cd_hfe = cd_arquivo;
     return hfe_cd_err_proc_qtd_trl;
   end if;

   if(vl_reg_dps <> vl_reg_dps_trl) then
     update sc_adp.tbl_hfe h set st_hfe = hfe_st_invalido,cd_ret_hfe=hfe_cd_err_proc_vlr_trl where h.cd_hfe = cd_arquivo;
     return hfe_cd_err_proc_vlr_trl;
     --raise notice 'Valor total de depósitos diferente do trailler do arquivo';
     
   end if;
   
   --VERIFICANDO CNPJ
   BEGIN
     SELECT fem.cd_fem, fem.cd_emp
     into strict cd_filial, cd_empresa
     FROM SC_CAD.tbl_fem fem 
       INNER JOIN SC_CAD.tbl_cun CUN ON cun.cd_cun = FEM.cd_cun
       INNER JOIN SC_ADP.tbl_hfe HFE ON hfe.cd_emp = FEM.cd_emp AND hfe.cd_fem = fem.cd_fem
     WHERE CUN.nr_cpf_cnpj_cun = hfe.nr_cpf_cnpj_hfe
     and hfe.cd_hfe = cd_arquivo;  
   EXCEPTION
      WHEN OTHERS THEN
        
        update sc_adp.tbl_hfe set st_hfe = hfe_st_invalido,cd_ret_hfe=hfe_cd_err_cun_n_existe where cd_hfe = cd_arquivo;
        --commit;
        return hfe_cd_err_cun_n_existe;
        --raise notice 'CNPJ Inexistente.';
      
   END;
   
   --VERIFICANDO O CONTRATO
   BEGIN
      select ctr.cd_ctr
      into strict cd_contrato
      from sc_cad.tbl_ctr ctr
        inner join sc_cad.tbl_fem_ctr fctr on ctr.cd_ctr = fctr.cd_ctr
        inner join sc_adp.tbl_hfe hfe on fctr.cd_emp = ctr.cd_emp and fctr.cd_fem = hfe.cd_fem
      where ctr.fg_atv_ctr = 'S'
        and fctr.fg_atv_fem_ctr = 'S'
        and ctr.cd_prd = 1
	and ctr.cd_emp = cd_empresa
	and fctr.cd_fem = cd_filial
        and hfe.cd_hfe = cd_arquivo;
   EXCEPTION 
     WHEN OTHERS THEN
       update sc_adp.tbl_hfe set st_hfe = hfe_st_invalido,cd_ret_hfe=hfe_cd_err_s_ctr_atv where cd_hfe = cd_arquivo;
       --commit;       
       return hfe_cd_err_s_ctr_atv;
       --raise notice 'Empresa/Filial não possuem contrato ativo.';
   END;  

   for rg_rdp in select rdp.cd_rdp,hfe.cd_emp,hfe.cd_fem,rdp.nr_mtr_rdp,rdp.vl_dep_rdp 
                 from sc_adp.tbl_rdp rdp
                    inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
                 where rdp.cd_hfe = cd_arquivo loop
                 
     if(sc_adp.existe_cartao_funcionario(rg_rdp.cd_emp,rg_rdp.cd_fem,rg_rdp.nr_mtr_rdp,ct_produto_salario) = false) then
     
       update sc_adp.tbl_rdp rdp set st_rdp = hfe_st_invalido,cd_ret_rdp=rdp_cd_ret_func_nao_existe where rdp.cd_rdp = rg_rdp.cd_rdp;
       
       qtd_reg_inv := qtd_reg_inv + 1;
       vlr_reg_inv := vlr_reg_inv + rg_rdp.vl_dep_rdp;
       
     else
       -- OBTENDO O NUMERO DO CARTAO  
       select *
       into cd_cartao, vl_motivo_erro_detalhe
       from sc_adp.get_cartao(rg_rdp.cd_rdp, ct_produto_salario);

       if cd_cartao is null then
         update sc_adp.tbl_rdp rdp set st_rdp = hfe_st_invalido,cd_ret_rdp=vl_motivo_erro_detalhe where rdp.cd_rdp = rg_rdp.cd_rdp;
       
         qtd_reg_inv := qtd_reg_inv + 1;
         vlr_reg_inv := vlr_reg_inv + rg_rdp.vl_dep_rdp;
       else
         update sc_adp.tbl_rdp rdp set st_rdp = hfe_st_validado,cd_crt=cd_cartao where rdp.cd_rdp = rg_rdp.cd_rdp;
       
         qtd_reg_vld := qtd_reg_vld + 1;
         vlr_reg_vld := vlr_reg_vld + rg_rdp.vl_dep_rdp;
       end if;
     end if;
       
   
   end loop;
   
   if( qtd_reg_vld > 0 ) then
     update sc_adp.tbl_hfe h 
        set st_hfe = hfe_st_validado,
            cd_ctr = cd_contrato,
            dt_sit_vld_hfe = clock_timestamp(),
            cd_usr_vld_hfe = vp_usuario
      where h.cd_hfe = cd_arquivo;
   else   
      update sc_adp.tbl_hfe h 
        set st_hfe = hfe_st_invalido,
            cd_ret_hfe = hfe_cd_err_todos_invd
      where h.cd_hfe = cd_arquivo;

      return hfe_cd_err_todos_invd;
   end if;
   
    update sc_adp.tbl_tfe t
       set nr_reg_vld_tfe = qtd_reg_vld,
           vl_reg_vld_tfe = vlr_reg_vld
    where t.cd_hfe = cd_arquivo;   

    return 0;      

end;
$$;


ALTER FUNCTION sc_adp.valida_arquivo_deposito(cd_arquivo numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1667 (class 1255 OID 1638643)
-- Name: valida_arquivo_deposito_produto(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_adp; Owner: postgres
--

CREATE FUNCTION valida_arquivo_deposito_produto(cd_arquivo numeric, vp_usuario numeric, vp_tipo_produto numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
   ct_produto_salario constant numeric := 1;

   vl_motivo_erro_detalhe numeric;
   
   qtd_reg_dps numeric(8,0) := 0;
   vl_reg_dps numeric(10,2) := 0;

   qtd_reg_dps_trl numeric(8,0) := 0;
   vl_reg_dps_trl numeric(10,2) := 0;
   
   qtd_reg_inv numeric(8,0) := 0;
   vlr_reg_inv numeric(10,2) := 0;
   
   qtd_reg_vld numeric(8,0) := 0;
   vlr_reg_vld numeric(10,2) := 0;
   
   situacao_hfe numeric(2,0);
   
   cd_contrato numeric(10,0);
   cd_cartao sc_opr.tbl_crt.cd_crt%type;
   
   cd_filial numeric(10,0);
   cd_empresa numeric(10,0);

   /******* CONSTANTES ********/

   hfe_st_validado numeric(2,0) := 2;
   hfe_st_invalido numeric(2,0) := 3;
   hfe_st_recebido numeric(2,0) := 1;
   hfe_st_em_processamento numeric(2,0) := 6;

   hfe_cd_err_proc_qtd_trl numeric(2,0) := 1;
   hfe_cd_err_proc_vlr_trl numeric(2,0) := 9;
   hfe_cd_err_todos_invd numeric(2,0) := 2;
   hfe_cd_err_s_ctr_atv numeric(2,0) := 6;
   hfe_cd_err_cun_n_existe numeric(2,0) := 4;
   
   rdp_cd_ret_func_nao_existe numeric(2,0) := 2;

   rg_rdp record;

   vl_existe numeric;
begin
   
      
   select count(*)
     into vl_existe
   from sc_adp.tbl_hfe
   where cd_hfe = cd_arquivo
     and st_hfe = hfe_st_recebido;

   if vl_existe = 0 then
      raise exception 'Arquivo não pode ser validado. Motivo: situação diferente de RECEBIDO';
   end if;


   select count(*),sum(dep.vl_dep_rdp)
   into qtd_reg_dps,vl_reg_dps
   from sc_adp.tbl_rdp dep
   where cd_hfe = cd_arquivo;

   select nr_reg_env_tfe,vl_reg_env_tfe
   into qtd_reg_dps_trl,vl_reg_dps_trl
   from sc_adp.tbl_tfe
   where cd_hfe = cd_arquivo;

   if(qtd_reg_dps <> qtd_reg_dps_trl) then
     update sc_adp.tbl_hfe h set st_hfe = hfe_st_invalido,cd_ret_hfe=hfe_cd_err_proc_qtd_trl where h.cd_hfe = cd_arquivo;
     return hfe_cd_err_proc_qtd_trl;
   end if;

   if(vl_reg_dps <> vl_reg_dps_trl) then
     update sc_adp.tbl_hfe h set st_hfe = hfe_st_invalido,cd_ret_hfe=hfe_cd_err_proc_vlr_trl where h.cd_hfe = cd_arquivo;
     return hfe_cd_err_proc_vlr_trl;
     --raise notice 'Valor total de depósitos diferente do trailler do arquivo';
     
   end if;
   
   --VERIFICANDO CNPJ
   BEGIN
     SELECT fem.cd_fem, fem.cd_emp
     into strict cd_filial, cd_empresa
     FROM SC_CAD.tbl_fem fem 
       INNER JOIN SC_CAD.tbl_cun CUN ON cun.cd_cun = FEM.cd_cun
       INNER JOIN SC_ADP.tbl_hfe HFE ON hfe.cd_emp = FEM.cd_emp AND hfe.cd_fem = fem.cd_fem
     WHERE CUN.nr_cpf_cnpj_cun = hfe.nr_cpf_cnpj_hfe
     and hfe.cd_hfe = cd_arquivo;  
   EXCEPTION
      WHEN OTHERS THEN
        
        update sc_adp.tbl_hfe set st_hfe = hfe_st_invalido,cd_ret_hfe=hfe_cd_err_cun_n_existe where cd_hfe = cd_arquivo;
        --commit;
        return hfe_cd_err_cun_n_existe;
        --raise notice 'CNPJ Inexistente.';
      
   END;
   
   --VERIFICANDO O CONTRATO
   BEGIN
      select ctr.cd_ctr
      into strict cd_contrato
      from sc_cad.tbl_ctr ctr
        inner join sc_cad.tbl_fem_ctr fctr on ctr.cd_ctr = fctr.cd_ctr
        inner join sc_adp.tbl_hfe hfe on fctr.cd_emp = ctr.cd_emp and fctr.cd_fem = hfe.cd_fem
      where ctr.fg_atv_ctr = 'S'
        and fctr.fg_atv_fem_ctr = 'S'
        and ctr.cd_prd = vp_tipo_produto
	and ctr.cd_emp = cd_empresa
	and fctr.cd_fem = cd_filial
        and hfe.cd_hfe = cd_arquivo;
   EXCEPTION 
     WHEN OTHERS THEN
       update sc_adp.tbl_hfe set st_hfe = hfe_st_invalido,cd_ret_hfe=hfe_cd_err_s_ctr_atv where cd_hfe = cd_arquivo;
       --commit;       
       return hfe_cd_err_s_ctr_atv;
       --raise notice 'Empresa/Filial não possuem contrato ativo.';
   END;  

   for rg_rdp in select rdp.cd_rdp,hfe.cd_emp,hfe.cd_fem,rdp.nr_mtr_rdp,rdp.vl_dep_rdp 
                 from sc_adp.tbl_rdp rdp
                    inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
                 where rdp.cd_hfe = cd_arquivo loop
                 
     if(sc_adp.existe_cartao_funcionario(rg_rdp.cd_emp,rg_rdp.cd_fem,rg_rdp.nr_mtr_rdp,vp_tipo_produto) = false) then
     
       update sc_adp.tbl_rdp rdp set st_rdp = hfe_st_invalido,cd_ret_rdp=rdp_cd_ret_func_nao_existe where rdp.cd_rdp = rg_rdp.cd_rdp;
       
       qtd_reg_inv := qtd_reg_inv + 1;
       vlr_reg_inv := vlr_reg_inv + rg_rdp.vl_dep_rdp;
       
     else
       -- OBTENDO O NUMERO DO CARTAO  
       select *
       into cd_cartao, vl_motivo_erro_detalhe
       from sc_adp.get_cartao(rg_rdp.cd_rdp, vp_tipo_produto);

       if cd_cartao is null then
         update sc_adp.tbl_rdp rdp set st_rdp = hfe_st_invalido,cd_ret_rdp=vl_motivo_erro_detalhe where rdp.cd_rdp = rg_rdp.cd_rdp;
       
         qtd_reg_inv := qtd_reg_inv + 1;
         vlr_reg_inv := vlr_reg_inv + rg_rdp.vl_dep_rdp;
       else
         update sc_adp.tbl_rdp rdp set st_rdp = hfe_st_validado,cd_crt=cd_cartao where rdp.cd_rdp = rg_rdp.cd_rdp;
       
         qtd_reg_vld := qtd_reg_vld + 1;
         vlr_reg_vld := vlr_reg_vld + rg_rdp.vl_dep_rdp;
       end if;
     end if;
       
   
   end loop;
   
   if( qtd_reg_vld > 0 ) then
     update sc_adp.tbl_hfe h 
        set st_hfe = hfe_st_validado,
            cd_ctr = cd_contrato,
            dt_sit_vld_hfe = clock_timestamp(),
            cd_usr_vld_hfe = vp_usuario
      where h.cd_hfe = cd_arquivo;
   else   
      update sc_adp.tbl_hfe h 
        set st_hfe = hfe_st_invalido,
            cd_ret_hfe = hfe_cd_err_todos_invd
      where h.cd_hfe = cd_arquivo;

      return hfe_cd_err_todos_invd;
   end if;
   
    update sc_adp.tbl_tfe t
       set nr_reg_vld_tfe = qtd_reg_vld,
           vl_reg_vld_tfe = vlr_reg_vld
    where t.cd_hfe = cd_arquivo;   

    return 0;      

end;
$$;


ALTER FUNCTION sc_adp.valida_arquivo_deposito_produto(cd_arquivo numeric, vp_usuario numeric, vp_tipo_produto numeric) OWNER TO postgres;

--
-- TOC entry 1505 (class 1255 OID 564057)
-- Name: valor_media_abastecimento_cartao(numeric); Type: FUNCTION; Schema: sc_adp; Owner: scan
--

CREATE FUNCTION valor_media_abastecimento_cartao(vp_crt numeric) RETURNS double precision
    LANGUAGE plpgsql
    AS $$declare
  vl_retorno double precision;
begin
  select round(avg(valor),-1)
         --round(count(*)/sum(1/valor),-1) 
    into vl_retorno
  from(select sum(rdp.vl_dep_rdp) as valor, to_char(hfe.dt_dps_hfe, 'mm/yyyy') as data
       from sc_adp.tbl_rdp rdp
         inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
       where rdp.st_rdp = 5 -- Depositado
         and hfe.dt_dps_hfe >= to_date('01/' || to_char(current_date,'MM/yyyy'), 'dd/MM/yyyy') + interval '-3 month' 
         and hfe.dt_dps_hfe < current_date
   and rdp.cd_crt=vp_crt
   and rdp.cd_tdp in (1, 8)
       group by to_char(hfe.dt_dps_hfe, 'mm/yyyy')) as media_deposito;

   if vl_retorno is null then
     select round(avg(valor),-1)
            --round(count(*)/sum(1/valor),-1)
       into vl_retorno
     from(select sum(rdp.vl_dep_rdp) as valor, to_char(hfe.dt_dps_hfe, 'mm/yyyy') as data
          from sc_adp.tbl_rdp rdp
            inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
          where rdp.st_rdp = 5 -- Depositado
            and hfe.dt_dps_hfe >= to_date('01/' || to_char(current_date,'MM/yyyy'), 'dd/MM/yyyy')
      and rdp.cd_crt=vp_crt
      and rdp.cd_tdp in (1, 8)
          group by to_char(hfe.dt_dps_hfe, 'mm/yyyy')) as media_deposito;
   end if;
       
   return vl_retorno;
end;$$;


ALTER FUNCTION sc_adp.valor_media_abastecimento_cartao(vp_crt numeric) OWNER TO scan;

SET search_path = sc_aeo, pg_catalog;

--
-- TOC entry 1493 (class 1255 OID 835305)
-- Name: cancelar_arquivo(numeric); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION cancelar_arquivo(vp_cod_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin
   delete from sc_aeo.tbl_eop where cd_aeop = vp_cod_arquivo;
   update sc_aeo.tbl_aeop set st_aeop = 3 where cd_aeop = vp_cod_arquivo;
end$$;


ALTER FUNCTION sc_aeo.cancelar_arquivo(vp_cod_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1498 (class 1255 OID 835426)
-- Name: comprar_ccb(numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION comprar_ccb(vp_cod_arquivo numeric, vp_conta numeric, vp_data_referencia date, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_valor_liberado  numeric;
  vl_conta_banco numeric;
  vl_fee numeric;
  vl_a_repassar_investidor numeric;
  vl_despesa_financeira numeric;

  ct_conta_cobranca_terceiros numeric := 68007;
  ct_conta_cliente_saque_extra numeric := 66155;
  ct_conta_limite_contratado numeric := 66156; 
  ct_conta_receita_rend_ccb numeric := 66157;
  ct_tipo_lancamento_compra_ccb numeric := 1375;
  ct_conta_receita_dif_rend_ccb numeric := 67967;

  
  ct_sistema_exportacao numeric := 21;
  ct_fornecedor_bracce numeric := 77;
  ct_tipo_despesa_fee numeric := 49;
  ct_tipo_lancamento_repasse_investidor numeric := 1214;
  ct_conta_investidor numeric := 43217;
  ct_conta_despesa_financeira numeric := 43218;
  ct_tipo_despesa_repasse_investidor numeric := 50;
  ct_conta_despesa_iof numeric := 20080; 

  vl_cod_lancamento numeric;
  vl_cod_lancamento_aux numeric;
  vl_situacao numeric;
  vl_limite_contratado numeric;
  vl_receita_operacional numeric;
  vl_receita_ccb	numeric;
  vl_iof numeric;
begin
   select vl_lib_aeop, vl_fee_aeop, vl_ttl_aeop, st_aeop,(vl_slc_aeop - vl_lib_aeop)
   into vl_valor_liberado, vl_fee, vl_a_repassar_investidor, vl_situacao, vl_iof
   from sc_aeo.tbl_aeop
   where cd_aeop = vp_cod_arquivo;

   if vl_situacao = 3 then
     raise exception 'NAO É POSSIVEL CONTABILIZAR UM ARQUIVO CANCELADO.';
   end if;

   /*select c.cd_cnt
   into vl_conta_banco
   from sc_fin.tbl_ccr c
   where cd_ccr = vp_conta_corrente;*/

   vl_conta_banco := vp_conta;

  
   perform sc_cnt.lancar_debito_credito(ct_conta_cobranca_terceiros,vl_conta_banco,ct_tipo_lancamento_compra_ccb,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, vl_valor_liberado, vp_data_referencia, 1, ct_sistema_exportacao, vp_cod_arquivo);
   perform sc_cnt.lancar_debito_credito(ct_conta_despesa_iof,vl_conta_banco,ct_tipo_lancamento_compra_ccb,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, vl_iof, vp_data_referencia, 1, ct_sistema_exportacao, vp_cod_arquivo);
   

   select sum(opr.vl_opr - opr.vl_jrs_opr), sum(opr.vl_jrs_opr), sum(eop.vl_prc_eop - vl_slc_eop)
   into vl_limite_contratado, vl_receita_operacional, vl_receita_ccb	 
   from sc_aeo.tbl_eop eop
     inner join sc_opr.tbl_opr opr on opr.cd_opr = eop.cd_opr
   where eop.cd_aeop = vp_cod_arquivo;

   -- Sensibilizando Limite Contratado
   perform sc_cnt.lancar_debito_credito(ct_conta_cliente_saque_extra,ct_conta_limite_contratado,ct_tipo_lancamento_compra_ccb,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, vl_limite_contratado, vp_data_referencia, 1, ct_sistema_exportacao, vp_cod_arquivo);

   -- Reconhecendo Receita de CCB
   perform sc_cnt.lancar_debito_credito(ct_conta_cliente_saque_extra,ct_conta_receita_rend_ccb,ct_tipo_lancamento_compra_ccb,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, vl_receita_ccb, vp_data_referencia, 1, ct_sistema_exportacao, vp_cod_arquivo);

   
    -- Reconhecendo DIFERENCA DE RECEITA de CCB
   if vl_receita_operacional > vl_receita_ccb then
       perform sc_cnt.lancar_debito_credito(ct_conta_cliente_saque_extra,ct_conta_receita_dif_rend_ccb,ct_tipo_lancamento_compra_ccb,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, vl_receita_operacional - vl_receita_ccb, vp_data_referencia, 1, ct_sistema_exportacao, vp_cod_arquivo);
   else
       perform sc_cnt.lancar_debito_credito(ct_conta_receita_dif_rend_ccb,ct_conta_cliente_saque_extra,ct_tipo_lancamento_compra_ccb,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, vl_receita_ccb - vl_receita_operacional, vp_data_referencia, 1, ct_sistema_exportacao, vp_cod_arquivo);
   end if;

   UPDATE SC_AEO.TBL_AEOP 
   SET DT_CMP_CCB_AEOP = vp_data_referencia,
       CD_CCR_CMP_AEOP = vp_conta
   WHERE CD_AEOP = vp_cod_arquivo;    

end$$;


ALTER FUNCTION sc_aeo.comprar_ccb(vp_cod_arquivo numeric, vp_conta numeric, vp_data_referencia date, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1502 (class 1255 OID 564058)
-- Name: comunica_investidor(); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION comunica_investidor() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_telefone_investidor numeric := 988797225;
  vl_email varchar := 'fernando@saqpag.com.br;financeiro@saqpag.com.br';
  vl_ddd numeric := 85;
  vl_cd_tms numeric := 1;
  
  vl_valor_solicitado numeric;
  
begin
   select vl_slc_aeop
   into vl_valor_solicitado
   from sc_aeo.tbl_aeop
   where dt_ref_aeop = current_date
     and cd_aeop = (select max(cd_aeop) from sc_aeo.tbl_aeop where dt_ref_aeop = current_date);

   if coalesce(vl_valor_solicitado,0) > 0 then  

	   insert into sc_msg.tbl_msg (cd_msg, cd_tms, ddd_msg, nr_msg, prm_msg, fg_atv_msg, fg_env_msg, cd_inc_usr, dt_inc_usr)
		    values (nextval('sc_msg.sq_msg'), vl_cd_tms, vl_ddd, vl_telefone_investidor::numeric, 'SR INVESTIDOR, O VALOR A SER DEPOSITADO HOJE E DE '|| replace(to_char(vl_valor_solicitado, '999990D99'), ' ', ''), 'S', 'N', 1, now());

	   perform sc_msg.enviar_mensagem(vl_cd_tms);

	   perform sc_pbl.enviar_email_saqpag(vl_email,'VALOR PARA GERACAO DE CCB - BRACCE','SR INVESTIDOR, O VALOR A SER DEPOSITADO HOJE E DE ' || trim(to_char(vl_valor_solicitado, '999990D99')),null);
  end if; 
	      
end$$;


ALTER FUNCTION sc_aeo.comunica_investidor() OWNER TO scan;

--
-- TOC entry 1583 (class 1255 OID 887126)
-- Name: contabilizar_arquivo_cessao_bracce(numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION contabilizar_arquivo_cessao_bracce(vp_cod_arquivo numeric, vp_conta numeric, vp_data_referencia date, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_valor_liberado  numeric;
  vl_conta_banco numeric;
  vl_fee numeric;
  vl_a_repassar_investidor numeric;
  vl_despesa_financeira numeric;

  ct_conta_emprestimo_bancario numeric := 67182;
  ct_conta_receita_tarifa_saque_extra numeric := 34;
  ct_tipo_lancamento_emprestimo numeric := 1411;
  ct_tp_lcn_repasse_trf_financiada numeric := 1413;
  ct_tp_lcn_reg_cobranca_terceiro numeric := 1412;
  
  ct_sistema_exportacao numeric := 21;
  ct_fornecedor_bracce numeric := 77;
  ct_tipo_despesa_fee numeric := 49;
  ct_tipo_lancamento_repasse_investidor numeric := 1214;
  ct_conta_investidor numeric := 43217;
  ct_conta_despesa_financeira numeric := 43218;
  ct_tipo_despesa_repasse_investidor numeric := 50;
  
  ct_conta_cbr_principal numeric := 116311;
  ct_conta_cbr_iof numeric := 116310;
  ct_conta_cbr_juros numeric := 116309;
  ct_conta_cbr_tarifa numeric := 116312;
  ct_conta_mandatario_gaia numeric := 116308;
  ct_conta_mandatario_adicional numeric := 161427;
  

  vl_cod_lancamento numeric;
  vl_cod_lancamento_aux numeric;
  vl_situacao numeric;
  vl_lanc_contrapartida numeric := null;
  vl_tarifa_financiada numeric;

  vl_valor_principal numeric;
  vl_valor_iof numeric;
  vl_valor_juros numeric;
  vl_valor_tarifa numeric;
  vl_valor_ccb numeric;
  
begin

   select vl_lib_aeop, vl_fee_aeop, vl_ttl_aeop, st_aeop,coalesce(vl_trf_fnc_aeop,0)
   into vl_valor_liberado, vl_fee, vl_a_repassar_investidor, vl_situacao, vl_tarifa_financiada
   from sc_aeo.tbl_aeop
   where cd_aeop = vp_cod_arquivo;

   select sum(ccb.vlr_iof_ccb),
          sum(ccb.vlr_lib_ccb - coalesce(opr.vl_trf_opr,0)),
          sum(coalesce(opr.vl_trf_opr,0)),
          sum(ccb.vlr_ccb - ccb.vlr_lib_ccb - ccb.vlr_iof_ccb),
          sum(ccb.vlr_ccb)
   into vl_valor_iof,
        vl_valor_principal,
        vl_valor_tarifa,
        vl_valor_juros,
        vl_valor_ccb       
   from sc_ccb.tbl_ccb ccb
      inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
      inner join sc_aeo.tbl_eop eop on eop.cd_opr = opr.cd_opr
   where eop.cd_aeop = vp_cod_arquivo;

   if vl_situacao = 3 then
     raise exception 'NAO É POSSIVEL CONTABILIZAR UM ARQUIVO CANCELADO.';
   end if;

   vl_conta_banco := vp_conta;

   /*
      Vitor Vasconcelos - 12/09/2016
      Nova Contabilizacao - CCB
      D - Banco (Valor Sacado do Saque Extra)
      C - Conta Transitoria ( Valor Sacado do Saque Extra )

      D - Banco (valor da tarifa Financiada)
      C - Receita Tarifa de SaqueExtra(Valor da tarida financiada)
   */ 
   
   select sc_cnt.lancar_movimento(vl_lanc_contrapartida,null,ct_tipo_lancamento_emprestimo,vp_conta,'D',vl_valor_liberado,vp_data_referencia,1,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo) into vl_lanc_contrapartida;
   perform sc_cnt.lancar_movimento(null,vl_lanc_contrapartida,ct_tipo_lancamento_emprestimo,ct_conta_emprestimo_bancario,'C',vl_valor_liberado - vl_valor_tarifa,vp_data_referencia,1,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo);
   perform sc_cnt.lancar_movimento(null,vl_lanc_contrapartida,ct_tipo_lancamento_emprestimo,ct_conta_receita_tarifa_saque_extra,'C',vl_valor_tarifa,vp_data_referencia,1,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo);
   
 
   --perform sc_cnt.lancar_debito_credito(vl_conta_banco, ct_conta_emprestimo_bancario,ct_tipo_lancamento_emprestimo,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, vl_valor_liberado - vl_valor_tarifa, vp_data_referencia, 1, ct_sistema_exportacao, vp_cod_arquivo);
   --perform sc_cnt.lancar_debito_credito(vl_conta_banco, ct_conta_receita_tarifa_saque_extra,ct_tp_lcn_repasse_trf_financiada,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, vl_valor_tarifa, vp_data_referencia, 1, ct_sistema_exportacao, vp_cod_arquivo);

   vl_lanc_contrapartida := null;

   /*
      Vitor Vasconcelos - 12/09/2016
      Nova Contabilizacao - CCB
      D - Cobr. Ordem Terc - Principal Saque Extra
      D - Cobr. Ordem Terc - IOF
      D - Cobr. Ordem Terc - Juros
      D - Cobr. Ordem Terc - Tarifa
      C - Mandatario de Cobranca - Gaia
   */
   select sc_cnt.lancar_movimento(vl_lanc_contrapartida,null,ct_tp_lcn_reg_cobranca_terceiro,ct_conta_mandatario_adicional,'C',vl_valor_ccb,vp_data_referencia,1,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo) into vl_lanc_contrapartida;
   perform sc_cnt.lancar_movimento(null,vl_lanc_contrapartida,ct_tp_lcn_reg_cobranca_terceiro,ct_conta_cbr_principal,'D',vl_valor_principal,vp_data_referencia,1,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo);
   perform sc_cnt.lancar_movimento(null,vl_lanc_contrapartida,ct_tp_lcn_reg_cobranca_terceiro,ct_conta_cbr_iof,'D',vl_valor_iof,vp_data_referencia,1,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo);
   perform sc_cnt.lancar_movimento(null,vl_lanc_contrapartida,ct_tp_lcn_reg_cobranca_terceiro,ct_conta_cbr_juros,'D',vl_valor_juros,vp_data_referencia,1,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo);
   perform sc_cnt.lancar_movimento(null,vl_lanc_contrapartida,ct_tp_lcn_reg_cobranca_terceiro,ct_conta_cbr_tarifa,'D',vl_valor_tarifa,vp_data_referencia,1,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo);
   
  
   update sc_aeo.tbl_aeop 
      set dt_ctb_aeop = now(),
          dt_dps_aeop = vp_data_referencia 
   where cd_aeop = vp_cod_arquivo;

   -- inserindo contas a pagar para o fee
   insert 
   into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp)
     values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_bracce,ct_tipo_despesa_fee,1,vl_fee,vp_data_referencia,vp_data_referencia,2,'REF A FEE BRACCE',1,now(),1,1,1,vl_fee);


end$$;


ALTER FUNCTION sc_aeo.contabilizar_arquivo_cessao_bracce(vp_cod_arquivo numeric, vp_conta numeric, vp_data_referencia date, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1496 (class 1255 OID 835424)
-- Name: contabilizar_arquivo_cessao_bracce_OLD2(numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION "contabilizar_arquivo_cessao_bracce_OLD2"(vp_cod_arquivo numeric, vp_conta numeric, vp_data_referencia date, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_valor_liberado  numeric;
  vl_conta_banco numeric;
  vl_fee numeric;
  vl_a_repassar_investidor numeric;
  vl_despesa_financeira numeric;

  ct_conta_emprestimo_bancario numeric := 67182;
  ct_tipo_lancamento_emprestimo numeric := 1003;
  ct_sistema_exportacao numeric := 21;
  ct_fornecedor_bracce numeric := 77;
  ct_tipo_despesa_fee numeric := 49;
  ct_tipo_lancamento_repasse_investidor numeric := 1214;
  ct_conta_investidor numeric := 43217;
  ct_conta_despesa_financeira numeric := 43218;
  ct_tipo_despesa_repasse_investidor numeric := 50;

  vl_cod_lancamento numeric;
  vl_cod_lancamento_aux numeric;
  vl_situacao numeric;
  
begin

   select vl_lib_aeop, vl_fee_aeop, vl_ttl_aeop, st_aeop
   into vl_valor_liberado, vl_fee, vl_a_repassar_investidor, vl_situacao
   from sc_aeo.tbl_aeop
   where cd_aeop = vp_cod_arquivo;

   if vl_situacao = 3 then
     raise exception 'NAO É POSSIVEL CONTABILIZAR UM ARQUIVO CANCELADO.';
   end if;

   /*select c.cd_cnt
   into vl_conta_banco
   from sc_fin.tbl_ccr c
   where cd_ccr = vp_conta_corrente;
   */
   vl_conta_banco := vp_conta;

  
   perform sc_cnt.lancar_debito_credito(vl_conta_banco, ct_conta_emprestimo_bancario,ct_tipo_lancamento_emprestimo,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, vl_valor_liberado, vp_data_referencia, 1, ct_sistema_exportacao, vp_cod_arquivo);
  
   update sc_aeo.tbl_aeop 
      set dt_ctb_aeop = now(),
          dt_dps_aeop = vp_data_referencia 
   where cd_aeop = vp_cod_arquivo;

   -- inserindo contas a pagar para o fee
   insert 
   into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp)
     values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_bracce,ct_tipo_despesa_fee,1,vl_fee,vp_data_referencia,vp_data_referencia,2,'REF A FEE BRACCE',1,now(),1,1,1,vl_fee);


   -- RECONHECENDO VALORES A REPASSAR PARA O INVESTIDOR E PROVISONANDO DESPESAS 
   /*vl_despesa_financeira := vl_a_repassar_investidor - vl_valor_liberado;
    
   select nextval('sc_cnt.sq_lcn')
   into vl_cod_lancamento;

   perform sc_cnt.lancar_movimento(vl_cod_lancamento,null,ct_tipo_lancamento_repasse_investidor,ct_conta_investidor,'C',vl_a_repassar_investidor, vp_data_referencia, vp_usuario, null, 'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo);

   perform sc_cnt.lancar_movimento(vl_cod_lancamento_aux,vl_cod_lancamento,ct_tipo_lancamento_repasse_investidor,ct_conta_emprestimo_bancario,'D',vl_valor_liberado, vp_data_referencia, vp_usuario, null, 'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo);

   perform sc_cnt.lancar_movimento(vl_cod_lancamento_aux,vl_cod_lancamento,ct_tipo_lancamento_repasse_investidor,ct_conta_despesa_financeira,'D',vl_despesa_financeira, vp_data_referencia, vp_usuario, null, 'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo);*/

end$$;


ALTER FUNCTION sc_aeo."contabilizar_arquivo_cessao_bracce_OLD2"(vp_cod_arquivo numeric, vp_conta numeric, vp_data_referencia date, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1179 (class 1255 OID 564059)
-- Name: contabilizar_arquivo_cessao_bracce_old(numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION contabilizar_arquivo_cessao_bracce_old(vp_cod_arquivo numeric, vp_conta_corrente numeric, vp_data_referencia date, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_valor_liberado  numeric;
  vl_conta_banco numeric;
  vl_fee numeric;
  vl_a_repassar_investidor numeric;
  vl_despesa_financeira numeric;

  ct_conta_emprestimo_bancario numeric := 40511;
  ct_tipo_lancamento_emprestimo numeric := 1003;
  ct_sistema_exportacao numeric := 21;
  ct_fornecedor_bracce numeric := 77;
  ct_tipo_despesa_fee numeric := 49;
  ct_tipo_lancamento_repasse_investidor numeric := 1214;
  ct_conta_investidor numeric := 43217;
  ct_conta_despesa_financeira numeric := 43218;
  ct_tipo_despesa_repasse_investidor numeric := 50;

  vl_cod_lancamento numeric;
  vl_cod_lancamento_aux numeric;
  vl_situacao numeric;
  
begin

   select vl_lib_aeop, vl_fee_aeop, vl_ttl_aeop, st_aeop
   into vl_valor_liberado, vl_fee, vl_a_repassar_investidor, vl_situacao
   from sc_aeo.tbl_aeop
   where cd_aeop = vp_cod_arquivo;

   if vl_situacao = 3 then
     raise exception 'NAO É POSSIVEL CONTABILIZAR UM ARQUIVO CANCELADO.';
   end if;

   select c.cd_cnt
   into vl_conta_banco
   from sc_fin.tbl_ccr c
   where cd_ccr = vp_conta_corrente;

  
   perform sc_cnt.lancar_debito_credito(vl_conta_banco, ct_conta_emprestimo_bancario,ct_tipo_lancamento_emprestimo,null,'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, vl_valor_liberado, vp_data_referencia, 1, ct_sistema_exportacao, vp_cod_arquivo);
  
   update sc_aeo.tbl_aeop 
      set dt_ctb_aeop = now(),
          dt_dps_aeop = vp_data_referencia 
   where cd_aeop = vp_cod_arquivo;

   -- inserindo contas a pagar para o fee
   insert 
   into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp)
     values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_bracce,ct_tipo_despesa_fee,1,vl_fee,vp_data_referencia,vp_data_referencia,2,'REF A FEE BRACCE',1,now(),1,1,1,vl_fee);


   -- RECONHECENDO VALORES A REPASSAR PARA O INVESTIDOR E PROVISONANDO DESPESAS 
   vl_despesa_financeira := vl_a_repassar_investidor - vl_valor_liberado;
    
   select nextval('sc_cnt.sq_lcn')
   into vl_cod_lancamento;

   perform sc_cnt.lancar_movimento(vl_cod_lancamento,null,ct_tipo_lancamento_repasse_investidor,ct_conta_investidor,'C',vl_a_repassar_investidor, vp_data_referencia, vp_usuario, null, 'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo);

   perform sc_cnt.lancar_movimento(vl_cod_lancamento_aux,vl_cod_lancamento,ct_tipo_lancamento_repasse_investidor,ct_conta_emprestimo_bancario,'D',vl_valor_liberado, vp_data_referencia, vp_usuario, null, 'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo);

   perform sc_cnt.lancar_movimento(vl_cod_lancamento_aux,vl_cod_lancamento,ct_tipo_lancamento_repasse_investidor,ct_conta_despesa_financeira,'D',vl_despesa_financeira, vp_data_referencia, vp_usuario, null, 'REF A ARQUIVO DE CESSAO NR '||vp_cod_arquivo, ct_sistema_exportacao, vp_cod_arquivo);

end$$;


ALTER FUNCTION sc_aeo.contabilizar_arquivo_cessao_bracce_old(vp_cod_arquivo numeric, vp_conta_corrente numeric, vp_data_referencia date, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1175 (class 1255 OID 564060)
-- Name: corrige_vencimento_cartao(); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION corrige_vencimento_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;
reg record;

vnc_parcela numeric;

begin


for rg in 
  select emp.nm_emp, crt.cd_crt as cartao, coalesce(crt.cd_fcr,0) as  fatura, crt.dt_prx_vnc_crt as vencimento,
         vl_pce_ctr::numeric as novo_vencimento, to_char(dt_prx_vnc_crt,'dd')::numeric as antigo_vencimento
  from sc_cad.tbl_pce_ctr pc
  inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = pc.cd_ctr
  inner join sc_opr.tbl_crt crt on crt.cd_ctr = ctr.cd_ctr
  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
  inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
where pc.cd_pce = 1
  and crt.fg_atv_crt = 'S'
  and vl_pce_ctr::numeric <> to_char(dt_prx_vnc_crt,'dd')::numeric
order by emp.nm_emp  loop

  --cancelando a fatura
  if rg.fatura <> 0 then
     perform sc_fcr.cancelar_fatura(rg.fatura,1);
  end if;

  -- alterando a data de vencimento do cartao
  update sc_opr.tbl_crt
    set dt_prx_vnc_crt = to_date(rg.novo_vencimento || '/' || to_char(rg.vencimento,'mm/yyyy'),'dd/mm/yyyy')
    where cd_crt = rg.cartao;

  -- se o vencimento novo for menor que o antigo soma um mês
  /*if rg.novo_vencimento < rg.antigo_vencimento then
  
  --  update sc_opr.tbl_crt
  --    set dt_prx_vnc_crt = dt_prx_vnc_crt +  interval '1 month'
  --    where cd_crt = rg.cartao;

  end if;*/
  
  -- atualizando a data da proxima apuracao 
  update sc_opr.tbl_crt
    set dt_prx_apr_crt = dt_prx_vnc_crt - interval '5 day'
    where cd_crt = rg.cartao;

  -- alterando as parcelas
  for reg in select cd_prc, dt_vnc_prc
               from sc_fcr.tbl_prc 
                 where cd_crt = rg.cartao and st_prc = 1 loop

       vnc_parcela := to_char(reg.dt_vnc_prc,'dd')::numeric;

       if vnc_parcela <> rg.novo_vencimento then

          update sc_fcr.tbl_prc set dt_vnc_prc = to_date(rg.novo_vencimento || '/' || to_char(reg.dt_vnc_prc,'mm/yyyy'),'dd/mm/yyyy')
            where cd_prc = reg.cd_prc;

          if rg.novo_vencimento < vnc_parcela then
  
		update sc_fcr.tbl_prc
		set dt_vnc_prc = dt_vnc_prc +  interval '1 month'
		where cd_prc = reg.cd_prc;

	  end if;  
          
       end if;
       
               
  end loop;             
                      

end loop;


end;$$;


ALTER FUNCTION sc_aeo.corrige_vencimento_cartao() OWNER TO scan;

--
-- TOC entry 1176 (class 1255 OID 564061)
-- Name: exporta_operacao(date); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION exporta_operacao(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  ct_saque_extra constant numeric := 5;
  ct_situacao_confirmado constant numeric := 2;
  
  --situacao do arquivo de exportacao de operacao
  ct_st_aeo_gerado constant numeric := 1;
  ct_st_aeo_enviado constant numeric := 2;
  ct_st_aeo_cancelado constant numeric := 3;
  
  --tipos de erro de exportacao
  ct_sucesso constant numeric := 0;
  ct_erro_nao_existe_endereco constant numeric := 1;
  ct_erro_cpf_cnpj_invalido constant numeric := 3;

  ct_caractere_separador constant char := '#';
  ct_diretorio_arq_exp_operacao constant varchar := 'DIRETORIO_ARQUIVO_EXPORTACAO_OPERACAO';

  ct_a_esquerda constant numeric := 1;
  ct_a_direita constant numeric := 2;
  ct_centralizado constant numeric := 3;
  
  ct_tipo_residencial constant numeric := 1;
  ct_tipo_celular constant numeric := 2;

  --informacoes que precisam ser levantadas
  ct_codigo_convenio constant numeric := 229; -- definido pelo codigo da empresa no sistema da multipla (aguardar retorno do Daniel da TI)
  ct_nome_convenio constant varchar := 'SAQEXTRA';
  ct_tipo_beneficio constant numeric := null; -- pode deixar em branco
  ct_nome_tabela constant varchar := ''; -- pode deixar em branco
  ct_codigo_tabela constant numeric := null; -- pode deixar em branco
  ct_tipo_pagamento constant varchar := 'TED'; -- ok
  ct_banco constant numeric := 399; -- ok
  ct_agencia constant numeric := 905; -- ok
  ct_conta_corrente constant numeric := 197561; -- ok
  ct_taxa_operacao numeric := 2.06;

  vl_linha varchar;
  vl_qtde_operacao numeric;
  vl_codigo_arquivo numeric;
  vl_retorno numeric;
  vl_local_arquivo varchar;
  vl_nome_arquivo varchar;
  vl_diretorio varchar;
  vl_ddd_telefone varchar;
  vl_cpf_cnpj_valido boolean;
  
  vl_principal_operacao numeric := 0;
  vl_total_operacao numeric := 0;
  vl_quantidade_operacao numeric := 0;
  
  vl_data_primeiro_vencimento date;
  vl_data_ultimo_vencimento date;

  vl_rg_opr sc_opr.tbl_opr%rowtype;
  vl_rg_fnc sc_cad.tbl_fnc%rowtype;
  vl_rg_cun sc_cad.tbl_cun%rowtype;
  vl_rg_cpf sc_cad.tbl_cpf%rowtype;
  vl_rg_edr sc_cad.vw_edr%rowtype;
  vl_rg_tlf sc_cad.tbl_tlf%rowtype;
begin
  --verificando se existem operacoes de saque extra confirmadas para serem exportadas
  select count(*)
  into vl_qtde_operacao
  from sc_opr.tbl_opr opr
  where opr.dt_opr >= vp_data_referencia  
    and opr.dt_opr < vp_data_referencia + interval '1 day'
    and opr.cd_top = ct_saque_extra
    and opr.st_opr = ct_situacao_confirmado
    and opr.cd_aeo is null;

  --se existir continuar gerando o arquivo, caso contrario nao faz nada
  if vl_qtde_operacao > 0 then  
    --obtendo o codigo do arquivo
    select nextval('sc_aeo.sq_aeo') into vl_codigo_arquivo;

    -- Obtendo os parametros
    select prm.vl_prm
    into vl_diretorio
    from sc_cad.tbl_prm prm
    where prm.nm_prm = ct_diretorio_arq_exp_operacao;
      
    --definindo o nome do arquivo
    vl_nome_arquivo := 'MULTIPLA.' || to_char(vp_data_referencia, 'yyyymmdd') || '.' || trim(to_char(vl_codigo_arquivo, repeat('0', 5))) || '.txt';

    --definindo onde o arquivo sera gravado
    vl_local_arquivo := vl_diretorio || '\\' || vl_nome_arquivo;
        
    --inserindo um registro na tabela de arquivo de exportacao de operacao
    insert into sc_aeo.tbl_aeo(cd_aeo, dt_grc_aeo, dt_ref_aeo, st_aeo, qt_opr_aeo, vl_prc_aeo, vl_ttl_aeo)
    values(vl_codigo_arquivo, now(), vp_data_referencia, ct_st_aeo_enviado, 0, 0, 0);
      
    for vl_rg_opr in select *
                     from sc_opr.tbl_opr opr
                     where opr.dt_opr >= vp_data_referencia
                       and opr.dt_opr < vp_data_referencia + interval '1 day'
                       and opr.cd_top = 5
                       and opr.st_opr = 2
                       and opr.cd_aeo is null
                     order by opr.dt_opr  loop


      --raise notice 'operacao %', vl_rg_opr.cd_opr;
      --inicializando a variavel que controla a ocorrencia ou nao de erros
      vl_retorno := ct_sucesso;
      
      --obtendo as informacoes do cadastro de funcionario
      select fnc.*
      into vl_rg_fnc
      from sc_opr.tbl_pls pls
           inner join sc_opr.tbl_crt crt on pls.cd_crt = crt.cd_crt
           inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
      where pls.cd_pls = vl_rg_opr.cd_pls;
      
      --obtendo as informacoes do cadastro unico
      select cun.*
      into vl_rg_cun
      from sc_cad.tbl_cun cun
      where cun.cd_cun = vl_rg_fnc.cd_cun;

      --validando o cpf ou o cnpj conforme o tipo de pessoa
      if vl_rg_cun.tp_pss_cun = 'F' then
        select sc_acc.valida_cpf(vl_rg_cun.nr_cpf_cnpj_cun)
        into vl_cpf_cnpj_valido;
      else
        select sc_acc.valida_cnpj(vl_rg_cun.nr_cpf_cnpj_cun)
        into vl_cpf_cnpj_valido;
      end if;
      
      --verificando se o cpf ou cnpj eh valido
      if vl_cpf_cnpj_valido then
        --obtendo as informacoes do cadastro unico de pessoa fisica
        select *
        into vl_rg_cpf
        from sc_cad.tbl_cpf cpf
        where cpf.cd_cun = vl_rg_fnc.cd_cun;
      
        --obtendo as informacoes de endereco
        select *
        into vl_rg_edr
        from sc_aeo.get_endereco(vl_rg_cun.cd_cun);
      
        if vl_rg_edr.cep_edr is null then
          vl_retorno := ct_erro_nao_existe_endereco;
        end if;
      else
        vl_retorno := ct_erro_cpf_cnpj_invalido;      
      end if;

      if vl_retorno = ct_sucesso then
        --obtendo a data do primeiro vencimento
	      select *
	      into vl_data_primeiro_vencimento, vl_retorno
	      from sc_aeo.get_primeiro_vencimento(vl_rg_opr.cd_opr);
	      
	      --obtendo a data do ultimo vencimento
	      select *
	      into vl_data_ultimo_vencimento, vl_retorno
	      from sc_aeo.get_ultimo_vencimento(vl_rg_opr.cd_opr);
      end if;
      
      if vl_retorno <> ct_sucesso then
        update sc_opr.tbl_opr
           set tp_err_exp_opr = vl_retorno
        where cd_opr = vl_rg_opr.cd_opr;
      else
        --separador
        vl_linha := ct_caractere_separador;

        --numero da proposta
        vl_linha := vl_linha || trim(to_char(vl_rg_opr.cd_opr, repeat('0', 9))) || ct_caractere_separador;

        --numero do contrato
        vl_linha := vl_linha || repeat(' ', 11) || ct_caractere_separador;

        --cod. do login do usuário
        vl_linha := vl_linha || repeat(' ', 6) || ct_caractere_separador;

        --login do usuário
        vl_linha := vl_linha || repeat(' ', 60) || ct_caractere_separador;

        --codigo do convenio
        vl_linha := vl_linha || sc_arq.preencher(6, ct_codigo_convenio, ' ', ct_a_esquerda) || ct_caractere_separador;

        --nome do convenio
        vl_linha := vl_linha || sc_arq.preencher(40, ct_nome_convenio, ' ', ct_a_esquerda) || ct_caractere_separador;

        --data de digitacao
        vl_linha := vl_linha || to_char(vl_rg_opr.dt_opr, 'ddmmyyyy') || ct_caractere_separador;

        --data do ultimo status
        vl_linha := vl_linha || repeat(' ', 8) || ct_caractere_separador;

        --status
        vl_linha := vl_linha || repeat(' ', 2) || ct_caractere_separador;

        --ultimo código de retorno do DATAPREV
        vl_linha := vl_linha || repeat(' ', 2) || ct_caractere_separador;

        --descricao do retorno do DATAPREV
        vl_linha := vl_linha || repeat(' ', 80) || ct_caractere_separador;

        --nome do proponente
        vl_linha := vl_linha || sc_arq.preencher(60, vl_rg_cun.nm_cun, ' ', ct_a_esquerda) || ct_caractere_separador;

        --cpf
        vl_linha := vl_linha || sc_arq.preencher(15, vl_rg_cun.nr_cpf_cnpj_cun, ' ', ct_a_esquerda) || ct_caractere_separador;

        --sexo
        vl_linha := vl_linha || vl_rg_cpf.sexo_cpf || ct_caractere_separador;
      
        --data de nascimento
        vl_linha := vl_linha || to_char(vl_rg_cpf.dt_nsc_cpf, 'ddmmyyyy') || ct_caractere_separador;
      
        --estado civil
        vl_linha := vl_linha || sc_arq.preencher(10, vl_rg_cpf.cd_est_civil_cpf, '0', ct_a_direita) || ct_caractere_separador;
      
        --identidade
        vl_linha := vl_linha || sc_arq.preencher(20, vl_rg_cpf.nr_rg_cpf, '0', ct_a_direita) || ct_caractere_separador;
      
        --orgao emissor
        -- desconsiderar o original do cadastro
        -- considerar sempre SSP pois o sistema da multipla so aceita este
        vl_linha := vl_linha || sc_arq.preencher(20, 'SSP', ' ', ct_a_esquerda) || ct_caractere_separador;
      
        --uf da identidade
        vl_linha := vl_linha || vl_rg_cpf.uf_org_ems_rg_cpf || ct_caractere_separador;
      
        --data de emissao da identidade
        vl_linha := vl_linha || to_char(vl_rg_cpf.dt_ems_rg_cpf, 'ddmmyyyy') || ct_caractere_separador;
      
        --naturalidade
        vl_linha := vl_linha || sc_arq.preencher(50, vl_rg_cpf.ds_nat_cpf, ' ', ct_a_esquerda) || ct_caractere_separador;
      
        --uf da naturalidade
        vl_linha := vl_linha || vl_rg_cpf.uf_nat_cpf || ct_caractere_separador;
      
        --nacionalidade
        vl_linha := vl_linha || sc_arq.preencher(50, vl_rg_cpf.ds_nac_cpf, ' ', ct_a_esquerda) || ct_caractere_separador;
      
        --nome do pai
        vl_linha := vl_linha || repeat(' ', 60) || ct_caractere_separador;
      
        --nome da mae
        vl_linha := vl_linha || sc_arq.preencher(60, vl_rg_cpf.nm_mae_cpf, ' ', ct_a_esquerda) || ct_caractere_separador;
        
        --cep residencial
        vl_linha := vl_linha || sc_arq.preencher(8, vl_rg_edr.cep_edr, '0', ct_a_direita) || ct_caractere_separador;
        
        --logradouro
        vl_linha := vl_linha || sc_arq.preencher(25, vl_rg_edr.logradouro, ' ', ct_a_esquerda) || ct_caractere_separador;
        
        --numero
        vl_linha := vl_linha || sc_arq.preencher(5, vl_rg_edr.nr_edr, '0', ct_a_direita) || ct_caractere_separador;
        
        --complemento
        vl_linha := vl_linha || sc_arq.preencher(15, vl_rg_edr.cpl_edr, ' ', ct_a_esquerda) || ct_caractere_separador;
        
        --bairro
        vl_linha := vl_linha || sc_arq.preencher(20, vl_rg_edr.bairro, ' ', ct_a_esquerda) || ct_caractere_separador;
        
        --cidade
        vl_linha := vl_linha || sc_arq.preencher(20, vl_rg_edr.localidade, ' ', ct_a_esquerda) || ct_caractere_separador;
        
        --uf
        vl_linha := vl_linha || sc_arq.preencher(2, vl_rg_edr.uf, ' ', ct_a_esquerda) || ct_caractere_separador;
        
        --obtendo as informacoes do telefone residencial
        select *
        into vl_rg_tlf
        from sc_aeo.get_telefone(vl_rg_cun.cd_cun, ct_tipo_residencial);
        
        --telefone residencial
        if vl_rg_tlf.nr_ddd_tlf is not null and vl_rg_tlf.nr_tlf is not null then
          vl_ddd_telefone := vl_rg_tlf.nr_ddd_tlf::text || vl_rg_tlf.nr_tlf::text;
          vl_linha := vl_linha || sc_arq.preencher(12, vl_ddd_telefone , '0', ct_a_direita) || ct_caractere_separador;
        else
          vl_linha := vl_linha || repeat('0', 12) || ct_caractere_separador;
        end if;
        
        --obtendo as informacoes do telefone celular
        select *
        into vl_rg_tlf
        from sc_aeo.get_telefone(vl_rg_cun.cd_cun, ct_tipo_celular);
        
        --telefone celular
        if vl_rg_tlf.nr_ddd_tlf is not null and vl_rg_tlf.nr_tlf is not null then
          vl_ddd_telefone := vl_rg_tlf.nr_ddd_tlf::text || vl_rg_tlf.nr_tlf::text;
          vl_linha := vl_linha || sc_arq.preencher(12, vl_ddd_telefone , '0', ct_a_direita) || ct_caractere_separador;
        else
          vl_linha := vl_linha || repeat('0', 12) || ct_caractere_separador;
        end if;
        
        --Nome ref. pessoal 1
        vl_linha := vl_linha || repeat(' ', 60) || ct_caractere_separador;
        
        --Telefone ref. pessoal 1
        vl_linha := vl_linha || repeat('0', 12) || ct_caractere_separador;
        
        --Nome ref. pessoal 2
        vl_linha := vl_linha || repeat(' ', 60) || ct_caractere_separador;
        
        --Telefone ref. pessoal 2
        vl_linha := vl_linha || repeat('0', 12) || ct_caractere_separador;
        
        --nº do beneficio/ matricula
        vl_linha := vl_linha || sc_arq.preencher(20, vl_rg_fnc.nr_idt_fnc, '0', ct_a_direita) || ct_caractere_separador;
        
        --profissao
        vl_linha := vl_linha || repeat(' ', 40) || ct_caractere_separador;
        
        --tipo beneficio
        vl_linha := vl_linha || sc_arq.preencher(5, ct_tipo_beneficio, '0', ct_a_direita) || ct_caractere_separador;
        
        --uf matricula
        vl_linha := vl_linha || 'CE' || ct_caractere_separador;
        
        --nome tabela
        vl_linha := vl_linha || sc_arq.preencher(40, ct_nome_tabela, ' ', ct_a_esquerda) || ct_caractere_separador;
        
        --codigo tabela
        vl_linha := vl_linha || sc_arq.preencher(3, ct_codigo_tabela, ' ', ct_a_esquerda) || ct_caractere_separador;
        
        --prazo
        vl_linha := vl_linha || sc_arq.preencher(5, vl_rg_opr.nr_prc_opr, '0', ct_a_direita) || ct_caractere_separador;
        
        --valor da prestacao
        vl_linha := vl_linha || sc_arq.formatar_moeda(vl_rg_opr.vl_prc_opr - (vl_rg_opr.vl_jrs_opr + vl_rg_opr.vl_trf_opr + vl_rg_opr.vl_iof_opr) , 18, 2, ',') || ct_caractere_separador;
        
        --tipo de operacao
        vl_linha := vl_linha || sc_arq.formatar_moeda(ct_taxa_operacao, 2, 2, ',')  || ct_caractere_separador;
        
        --valor bruto do contrato
        vl_linha := vl_linha || sc_arq.formatar_moeda(vl_rg_opr.vl_opr - (vl_rg_opr.vl_jrs_opr + vl_rg_opr.vl_trf_opr + vl_rg_opr.vl_iof_opr), 18, 2, ',') || ct_caractere_separador;
        
        --valor refin.
        vl_linha := vl_linha || sc_arq.formatar_moeda(0, 18, 2, ',') || ct_caractere_separador;
        
        --% refin. proposta anterior
        vl_linha := vl_linha || sc_arq.formatar_moeda(0, 3, 2, ',') || ct_caractere_separador;
        
        --valor total de compra
        vl_linha := vl_linha || sc_arq.formatar_moeda(0, 12, 2, ',') || ct_caractere_separador;
        
        --valor liquido ao cliente
        vl_linha := vl_linha || sc_arq.formatar_moeda(0, 12, 2, ',') || ct_caractere_separador;
        
        --% comissao
        vl_linha := vl_linha || sc_arq.formatar_moeda(0, 2, 2, ',') || ct_caractere_separador;
        
        --1º vencimento
        vl_linha := vl_linha || to_char(vl_data_primeiro_vencimento, 'ddmmyyyy') || ct_caractere_separador;
        
        --ultimo vencimento
        vl_linha := vl_linha || to_char(vl_data_ultimo_vencimento, 'ddmmyyyy') || ct_caractere_separador;
        
        --codigo vendedor ( -- pode ser em branco)
        vl_linha := vl_linha || repeat(' ', 5) || ct_caractere_separador;
        
        --tipo de pagamento
        vl_linha := vl_linha || sc_arq.preencher(18, ct_tipo_pagamento, ' ', ct_a_esquerda) || ct_caractere_separador;
        
        --banco
        vl_linha := vl_linha || sc_arq.preencher(3, ct_banco, '0', ct_a_direita) || ct_caractere_separador;
        
        --agencia
        vl_linha := vl_linha || sc_arq.preencher(4, ct_agencia, '0', ct_a_direita) || ct_caractere_separador;
        
        --conta
        vl_linha := vl_linha || sc_arq.preencher(12, ct_conta_corrente, '0', ct_a_direita) || ct_caractere_separador;
        
        --quantidade de dividas
        vl_linha := vl_linha || sc_arq.preencher(3, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --numero do contrato
        vl_linha := vl_linha || sc_arq.preencher(25, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --banco 1
        vl_linha := vl_linha || sc_arq.preencher(3, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --vlr divida 1
        vl_linha := vl_linha || sc_arq.formatar_moeda(0, 18, 2, ',') || ct_caractere_separador;
        
        --numero do contrato
        vl_linha := vl_linha || sc_arq.preencher(25, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --banco 2
        vl_linha := vl_linha || sc_arq.preencher(3, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --vlr divida 2
        vl_linha := vl_linha || sc_arq.formatar_moeda(0, 18, 2, ',') || ct_caractere_separador;
        
        --numero do contrato
        vl_linha := vl_linha || sc_arq.preencher(25, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --banco 3
        vl_linha := vl_linha || sc_arq.preencher(3, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --vlr divida 3
        vl_linha := vl_linha || sc_arq.formatar_moeda(0, 18, 2, ',') || ct_caractere_separador;
        
        --numero do contrato
        vl_linha := vl_linha || sc_arq.preencher(25, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --banco 4
        vl_linha := vl_linha || sc_arq.preencher(3, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --vlr divida 4
        vl_linha := vl_linha || sc_arq.formatar_moeda(0, 18, 2, ',') || ct_caractere_separador;
        
        --numero do contrato
        vl_linha := vl_linha || sc_arq.preencher(25, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --banco 5
        vl_linha := vl_linha || sc_arq.preencher(3, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --vlr divida 5
        vl_linha := vl_linha || sc_arq.formatar_moeda(0, 18, 2, ',') || ct_caractere_separador;
        
        --numero do contrato
        vl_linha := vl_linha || sc_arq.preencher(25, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --banco 6
        vl_linha := vl_linha || sc_arq.preencher(3, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --vlr divida 6
        vl_linha := vl_linha || sc_arq.formatar_moeda(0, 18, 2, ',') || ct_caractere_separador;
        
        --numero do contrato
        vl_linha := vl_linha || sc_arq.preencher(25, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --banco 7
        vl_linha := vl_linha || sc_arq.preencher(3, 0, '0', ct_a_direita) || ct_caractere_separador;
        
        --vlr divida 7
        vl_linha := vl_linha || sc_arq.formatar_moeda(0, 18, 2, ',') || ct_caractere_separador;
        
        --gravando a linha no arquivo
        perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);
        
        vl_principal_operacao := vl_principal_operacao + (vl_rg_opr.vl_opr -(vl_rg_opr.vl_jrs_opr + vl_rg_opr.vl_trf_opr + vl_rg_opr.vl_iof_opr));
        vl_total_operacao := vl_total_operacao + vl_rg_opr.vl_opr;
        vl_quantidade_operacao := vl_quantidade_operacao + 1;
        
        update sc_opr.tbl_opr
           set cd_aeo = vl_codigo_arquivo,
               tp_err_exp_opr = null
        where cd_opr = vl_rg_opr.cd_opr;
      end if; 
    end loop;
    
    -- gravando a ultima linha do arquivo em branco 
    vl_linha := '';	
    perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);

    update sc_aeo.tbl_aeo
       set qt_opr_aeo = vl_quantidade_operacao,
           vl_prc_aeo = vl_principal_operacao,
           vl_ttl_aeo = vl_total_operacao
    where cd_aeo = vl_codigo_arquivo;

    -- inserindo registro na tabela de download de arquivo
    insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_arquivo,now(),vp_data_referencia,2,1);    

  end if;
end;
$$;


ALTER FUNCTION sc_aeo.exporta_operacao(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7608 (class 0 OID 0)
-- Dependencies: 1176
-- Name: FUNCTION exporta_operacao(vp_data_referencia date); Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON FUNCTION exporta_operacao(vp_data_referencia date) IS 'rotina que exporta todas as operacoes de uma determinada data';


--
-- TOC entry 1184 (class 1255 OID 564064)
-- Name: exporta_remessa_bracce(date); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION exporta_remessa_bracce(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;

  ct_diretorio_arq_remessa_bracce constant varchar := 'DIRETORIO_ARQUIVO_REMESSA_BRACCE';

  ct_fee_bracce numeric := 0.7;

  -- contantes de controle
  ct_tipo_atributo_abre_tag constant numeric := 1;
  ct_tipo_atributo_fecha_tag constant numeric := 2;
  ct_tipo_atributo_tag constant numeric := 3;
  ct_situacao_arquivo_gerado constant numeric := 1;
  
  -- contantes do layout (verificar codigos com o banco)
  ct_codigo_modulo constant varchar := '900';
  ct_versao_arquivo constant varchar := '06';
  ct_codigo_convenio constant varchar := '400000';
  ct_tipo_operacao constant varchar := '01'; -- tipo Credito Pessoal
  ct_grupo_cliente constant varchar := '99';
  ct_tipo_beneficiario constant varchar := '4'; 
  ct_codigo_historico_lib_1 constant varchar := '501';
  ct_praca_compensacao_lib_1 constant varchar := '0045';
  ct_codigo_origem_1 constant varchar := '40';
  ct_codigo_origem_2 constant varchar := '44';
  ct_codigo_origem_3 constant varchar := '400000';
  ct_codigo_origem_4 constant varchar := '400000';
  ct_codigo_origem_5 constant varchar := '400000'; --NAO USADO
  ct_codigo_politica_despesa varchar := '1';
  ct_codigo_tipo_despesa varchar := '1';
  ct_codigo_item_politica_despesa varchar := '1';
  ct_codigo_grupo_despesa varchar := '1';
  
  
  ct_cnpj_saqpag constant varchar := '21444981000136';
  ct_razao_social_saqpag varchar := 'SOMA ADMINISTRACAO DE CARTOES S/A';
  --ct_banco_saqcard constant varchar := '399'; 
  --ct_agencia_saqcard constant varchar := '0905'; 
  --ct_dv_agencia_saqcard constant varchar := '0'; 
  --ct_conta_saqcard constant varchar := '4541'; 
  --ct_dv_conta_saqcard constant varchar := '65'; 

  ct_banco_saqcard constant varchar := '237'; 
  ct_agencia_saqcard constant varchar := '2367'; 
  ct_dv_agencia_saqcard constant varchar := '1'; 
  ct_conta_saqcard constant varchar := '111'; 
  ct_dv_conta_saqcard constant varchar := '2';   
  

  vl_linha_xml varchar := '';
  vl_local_arquivo varchar;
  vl_nome_arquivo varchar;
  vl_diretorio varchar;
  vl_codigo_arquivo numeric;
  vl_sequencial_arquivo numeric;
  vl_qtd_operacoes numeric := 0;

  vl_valor numeric;
  vl_valor_prestacao numeric;
  vl_valor_parcela numeric;  
  vl_valor_solicitado numeric;
  vl_valor_iof numeric;
  vl_valor_tarifa numeric;

  vl_valor_total_solicitado numeric := 0;
  vl_valor_total_liberado numeric := 0;
  vl_valor_total_parcela numeric := 0;

begin


  select coalesce(count(*),0)
    into vl_qtd_operacoes
    from sc_aeo.tbl_eop
  where dt_base_eop = vp_data_referencia
    and cd_aeop is null;  

  if vl_qtd_operacoes > 0 then

  -- obtendo o codigo do arquivo
  select nextval('sc_aeo.sq_aeop') into vl_codigo_arquivo;

  -- obtendo o proximo sequencial do arquivo
  select coalesce(max(seq_aeop),0) + 1
    into vl_sequencial_arquivo
  from sc_aeo.tbl_aeop
  where dt_ref_aeop = vp_data_referencia;

  -- inserindo registro na tabela de arquivo
  insert into sc_aeo.tbl_aeop (cd_aeop,seq_aeop,dt_ref_aeop,dt_grc_aeop,st_aeop,vl_slc_aeop,vl_lib_aeop,vl_ttl_aeop,qt_opr_aeop)
         values (vl_codigo_arquivo,vl_sequencial_arquivo,vp_data_referencia,now(),ct_situacao_arquivo_gerado,0,0,0,vl_qtd_operacoes);
    

  -- Obtendo os parametros
  select prm.vl_prm
  into vl_diretorio
  from sc_cad.tbl_prm prm
  where prm.nm_prm = ct_diretorio_arq_remessa_bracce;
      
  --definindo o nome do arquivo
  vl_nome_arquivo := ct_codigo_modulo || to_char(vp_data_referencia, 'ddmmyyyy') || trim(to_char(vl_sequencial_arquivo, repeat('0', 3))) || '.XML';

  --definindo onde o arquivo sera gravado
  vl_local_arquivo := vl_diretorio || '\\' || vl_nome_arquivo;

  --GARANTINDO QUE O SISTEMA NÃO IRÁ ADICIONAR LINHAS A ARQUIVOS JÁ EXISTENTES, GARANTE A CONSISTENCIA EM RELAÇÃO A REPROCESSAMENTO
  begin
    perform sc_arq.excluirarquivo(vl_local_arquivo);
  exception
    when others then
      raise notice 'ocorreu um erro ao tentar apagar o arquivo: %, descricao do erro: %', vl_local_arquivo, sqlerrm;
  end;
  
  -- inicio do padrao xml
  perform sc_arq.gravarlinha(vl_local_arquivo, '<?xml version="1.0" encoding="UTF-8"?>');

  -- ######### INICIO DE REMESSA ###########
  perform sc_aeo.set_atributo_xml('REMESSA',null,ct_tipo_atributo_abre_tag, vl_local_arquivo);

  -- ######### INICIO DE HEADER ########### 
  perform sc_aeo.set_atributo_xml('header',null,ct_tipo_atributo_abre_tag, vl_local_arquivo);

  -- TAG <cod_modulo> codigo do modulo das propostas
  perform sc_aeo.set_atributo_xml('cod_modulo',ct_codigo_modulo,ct_tipo_atributo_tag, vl_local_arquivo);

  -- TAG <arquivo> nome do arquivo xml gerado (999 – Código módulo / DD – Dia / MM – Mês / A – Ano)
  perform sc_aeo.set_atributo_xml('arquivo',vl_nome_arquivo,ct_tipo_atributo_tag, vl_local_arquivo);

  -- TAG <diretorio> diretorio onde o arquivo xml sera gerado
  --perform sc_aeo.set_atributo_xml('diretorio',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo);

  -- TAG <email> email para confirmação da captura da proposta
  perform sc_aeo.set_atributo_xml('email','financeiro@saqpag.com.br', ct_tipo_atributo_tag, vl_local_arquivo);

  -- TAG <data> data da geração do arquivo
  perform sc_aeo.set_atributo_xml('data',to_char(vp_data_referencia, 'yyyymmdd'), ct_tipo_atributo_tag, vl_local_arquivo);

  -- TAG <tpdata> tipo de data (Liberação ou Cadastro)
  perform sc_aeo.set_atributo_xml('tpdata','Liberacao', ct_tipo_atributo_tag, vl_local_arquivo);

  -- TAG <tpremessa> tipo de remessa (Emissão ou Re-emissão)
  perform sc_aeo.set_atributo_xml('tpremessa','Emissao', ct_tipo_atributo_tag, vl_local_arquivo);

  -- TAG <versao> versao do arquivo
  perform sc_aeo.set_atributo_xml('versao', ct_versao_arquivo, ct_tipo_atributo_tag, vl_local_arquivo);

  -- TAG <dth_ini> data e hora do inicio da geracao do arquivo
  perform sc_aeo.set_atributo_xml('dth_ini', to_char(clock_timestamp(), 'yyyymmdd hh24:mi'), ct_tipo_atributo_tag, vl_local_arquivo);

  -- TAG <dth_fim> data e hora da conclusao da geracao do arquivo
  perform sc_aeo.set_atributo_xml('dth_fim', to_char(clock_timestamp(), 'yyyymmdd hh24:mi'), ct_tipo_atributo_tag, vl_local_arquivo);

  -- ######### FIM DO HEADER ########### 
  perform sc_aeo.set_atributo_xml('header',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo);


  -- ######### DADOS ###########
  perform sc_aeo.set_atributo_xml('dados',null,ct_tipo_atributo_abre_tag, vl_local_arquivo); 

  
  for rg in 
    select * from sc_aeo.tbl_eop where dt_base_eop = vp_data_referencia
  loop 

    -- ######### PROPOSTA ###########
    perform sc_aeo.set_atributo_xml('proposta',null,ct_tipo_atributo_abre_tag, vl_local_arquivo); 

    -- TAG <nrprop> numero da proposta (codigo da operacao de saque extra)
    perform sc_aeo.set_atributo_xml('nrprop', rg.cd_opr::varchar, ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <nroper> numero da operacao gerado pelo sistema de destino
    perform sc_aeo.set_atributo_xml('nroper', rg.cd_opr::varchar, ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <codprd> codigo do convenio gerado para proposta
    perform sc_aeo.set_atributo_xml('codprd', ct_codigo_convenio, ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <usuario> nome do usuário para geração e captura do arquivo

    -- TAG <dtbase> data base da proposta cadastrada.
    perform sc_aeo.set_atributo_xml('dtbase', to_char(rg.dt_base_eop, 'yyyymmdd'), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <dtcad> utilizada data base da proposta como referencia
    perform sc_aeo.set_atributo_xml('dtcad', to_char(rg.dt_base_eop, 'yyyymmdd'), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <vlrsol> valor solicitado
    vl_valor_total_solicitado := vl_valor_total_solicitado + rg.vl_slc_eop;
    perform sc_aeo.set_atributo_xml('vlrsol', sc_pbl.valor_formato_ptbr(rg.vl_slc_eop,'N'), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <vlrtac> Valor da TAC da proposta. 	na versão 6 as despesas devem ser informadas na tag <DespesasProposta>
    -- TAG <seg> Código do seguro cadastrado para a proposta (A – No ato N – Não). na versão 6 as despesas devem ser informadas na tag <DespesasProposta>
    -- TAG <vlrseg> Valor do seguro cadastrado para a proposta. na versão 6 as despesas devem ser informadas na tag <DespesasProposta>

    -- TAG <vlrtaxa> valor da taxa nominal da proposta
    perform sc_aeo.set_atributo_xml('vlrtaxa', trim(to_char(rg.vl_tx_eop,'90D9999')), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <qtparc> quantidade de parcelas da proposta
    perform sc_aeo.set_atributo_xml('qtparc', trim(to_char(rg.qtd_prc_eop,'99')), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <dtvcto> data do primeiro vencimento
    perform sc_aeo.set_atributo_xml('dtvcto', to_char(rg.dt_vnc_eop, 'yyyymmdd'), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <vlrsolcalculoiof> valor solicitado para o calculo do iof
    -- Adicionado em 24/09/2015  - Solicitacao feita pela Bracce
    perform sc_aeo.set_atributo_xml('vlrsolcalculoiof', sc_pbl.valor_formato_ptbr(rg.vl_lib_eop,'N'), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <vlrioc> valor do iof calculado para a proposta
    perform sc_aeo.set_atributo_xml('vlrioc', replace(to_char(rg.iof_eop, '999990D9999'), ' ', ''), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <vlrparc> valor da parcela da proposta
    vl_valor_total_parcela := vl_valor_total_parcela + rg.vl_prc_eop;
    perform sc_aeo.set_atributo_xml('vlrparc', sc_pbl.valor_formato_ptbr(rg.vl_prc_eop,'N'), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <vlrcpmf> Soma dos valores da CPMF das liberações 1 ao 5 da proposta. 

    -- TAG <tpoper> tipo da operacao (01 – Crédito Pessoal 02 – Financiamento 03 – Refinanciamento 04 – Renegociação 05 – Privado Simulação 06 – Privado Dados Básicos 09 – Compra de dívida)
    perform sc_aeo.set_atributo_xml('tpoper', ct_tipo_operacao, ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <cgc> CPF/CNPJ do cliente referente à proposta
    perform sc_aeo.set_atributo_xml('cgc', trim(to_char(rg.nr_cpf_eop,'00000000000')), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <nomecli> nome do cliente
    perform sc_aeo.set_atributo_xml('nomecli', substr(rg.nm_eop,0,36), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <grpcli> código do grupo de clientes do respectivo cliente da proposta 

    -- TAG <codnac> código da nacionalidade cadastrada para o cliente 
    perform sc_aeo.set_atributo_xml('codnac', rg.cd_nac_eop::varchar, ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <rg> numero do rg do cliente 
    perform sc_aeo.set_atributo_xml('rg', rg.rg_eop::varchar, ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <ufrg> uf do rg do cliente 
    perform sc_aeo.set_atributo_xml('ufrg', rg.uf_rg_eop, ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <dtemi> data emissao rg do cliente 
    perform sc_aeo.set_atributo_xml('dtemi', to_char(rg.dt_ems_rg_eop,'yyyymmdd'), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <estcivil> codigo estado civil (1 – Solteiro 2 – Casado 3 – Desquitado 4 – Divorciado 5 – Viúvo 9 – Outros)
    perform sc_aeo.set_atributo_xml('estcivil', rg.cd_est_civ_eop::varchar, ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <dtnasc> data emissao rg do cliente 
    perform sc_aeo.set_atributo_xml('dtnasc', to_char(rg.dt_nsc_eop,'yyyymmdd'), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <endfis> endereço pessoa física do cliente (logradouro).
    perform sc_aeo.set_atributo_xml('endfis', rg.log_edr_eop, ct_tipo_atributo_tag, vl_local_arquivo);
   
    -- TAG <nrendfis> número do endereço pessoa física do cliente.
    perform sc_aeo.set_atributo_xml('nrendfis', rg.nr_edr_eop, ct_tipo_atributo_tag, vl_local_arquivo);
    
    -- TAG <cmptfis> complemento de endereço pessoa física do cliente.
    perform sc_aeo.set_atributo_xml('cmptfis', rg.cpl_edr_eop, ct_tipo_atributo_tag, vl_local_arquivo);
    
    -- TAG <baifis> bairro do endereço pessoa física do cliente.
    perform sc_aeo.set_atributo_xml('baifis', rg.brr_edr_eop, ct_tipo_atributo_tag, vl_local_arquivo);
    
    -- TAG <cidfis> cidade do endereço pessoa física do cliente.
    perform sc_aeo.set_atributo_xml('cidfis', rg.loc_edr_eop, ct_tipo_atributo_tag, vl_local_arquivo);
    
    -- TAG <uffis> UF do endereço de pessoa física do cliente.
    perform sc_aeo.set_atributo_xml('uffis', rg.uf_edr_eop, ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <cepfis> cep do endereco da pessoa fisica
    perform sc_aeo.set_atributo_xml('cepfis', rg.cep_eop::varchar, ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <dddfonefis> DDD do telefone do endereço pessoa física do cliente.
    -- TAG <fonefis> Telefone do endereço pessoa física do cliente.
    -- TAG <tpres> Tipo de residência do cliente. (P – Própria,A – Alugada,F – Familiares,E – Empresa,N – Financiada,H – Hotel)
    -- TAG <anoratu> Tempo (em anos) na residência atual.
    -- TAG <mesratu> Tempo (em meses) na residência atual
    -- TAG <nomeemp> Nome da empresa.
    -- TAG <profiss> Profissão do cliente.
    -- TAG <cargo> Cargo do cliente.
    -- TAG <dtadm> Data de admissão do cliente.
    -- TAG <endcom> Endereço comercial do cliente (logradouro)
    -- TAG <nrocom> Número do endereço comercial do cliente.
    -- TAG <cmpcom> Complemento do endereço comercial do cliente.
    -- TAG <baicom> Bairro do endereço comercial do cliente.
    -- TAG <cidcom> Cidade do endereço comercial do cliente.
    -- TAG <ufcom> UF do endereço comercial do cliente.
    -- TAG <cepcom> CEP do endereço comercial do cliente.
    -- TAG <fonecom> Telefone do endereço comercial do cliente.
    -- TAG <rmlcom> Ramal do telefone comercial do cliente.
    -- TAG <matrcom> Número de matrícula do cliente

    -- TAG <rendmes> renda mensal do cliente.
    perform sc_aeo.set_atributo_xml('rendmes', sc_pbl.valor_formato_ptbr(rg.rnd_msl_eop,'N'), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <codaverb> código de averbação da proposta
    -- TAG <bemfin> descrição do bem financiado.

    -- TAG <sexo> sexo do cliente (F – Feminino ou M – Masculino)
    perform sc_aeo.set_atributo_xml('sexo', rg.sexo_eop, ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <nomerf1> Nome da referência 1
    -- TAG <cmptrf1> Complemento da referência 1
    -- TAG <fonerf1> Telefone da referência 1

    -- TAG <orgemi> órgão emissor do RG.
    perform sc_aeo.set_atributo_xml('orgemi', substr(rg.org_ems_rg_eop,0,9), ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <nomepai> Filiação paterna.
    -- TAG <nomemae> Filiação Materna.
    -- TAG <cjgnome> Nome do conjugue do cliente.
    -- TAG <endrf1> Endereço da referência 1 (logradouro).
    -- TAG <ocup> Código da ocupação do cliente. (1 – Funcionário Público 2 – Aposentado)
    -- TAG <anoserv> Tempo de serviço anterior (anos).
    -- TAG <messerv> Tempo de serviço anterior (meses).
    -- TAG <bancocompcli> Código da compensação dos dados bancários do cliente. (C/C 1)
    -- TAG <banconrcli> Código do banco dos dados bancários do cliente.
    -- TAG <agencianrcli> Código da agência dos dados bancários do cliente.
    -- TAG <agenciadvcli> Código do DV da agência dos dados bancários do cliente. (O campo da conta e do DV são concatenados no mesmo campo CLCC1AGNR)
    -- TAG <agencianmcli> Nome da agência dos dados bancários do cliente.
    -- TAG <contaccnrcli> Código da conta dos dados bancários do cliente.
    -- TAG <contaccdvcli> Código do DV da conta dos dados bancários do cliente.
    -- TAG <agenciaendcli> Endereço da agência dos dados bancários do cliente. 

    -- ######### BENEFICIARIO ###########
    -- retirado o numero 1 da tag beneficiario, solicitacao do Bracce por alteracao no layout

    -- TAG <tpbene1> Tipo do beneficiário da 1º liberação da proposta
    perform sc_aeo.set_atributo_xml('tpbene', ct_tipo_beneficiario, ct_tipo_atributo_tag, vl_local_arquivo);    

    -- TAG <cpfbene1> CPF do beneficiário da 1º liberação
    perform sc_aeo.set_atributo_xml('cpfbene', ct_cnpj_saqpag, ct_tipo_atributo_tag, vl_local_arquivo);    

    -- TAG <nomebene1> Nome do beneficiário da 1º liberação
    perform sc_aeo.set_atributo_xml('nomebene', ct_razao_social_saqpag, ct_tipo_atributo_tag, vl_local_arquivo);    

    -- TAG <vlrlib1> valor da 1º liberação
    vl_valor_total_liberado := vl_valor_total_liberado + rg.vl_lib_eop;
    perform sc_aeo.set_atributo_xml('vlrlib', sc_pbl.valor_formato_ptbr(rg.vl_lib_eop,'N'), ct_tipo_atributo_tag, vl_local_arquivo);    

    -- TAG <codliq1> codigo do historico da 1º liberação (fornecido pelo banco)
    perform sc_aeo.set_atributo_xml('codliq', ct_codigo_historico_lib_1, ct_tipo_atributo_tag, vl_local_arquivo);    

    -- TAG <comp1> praça da compensação da 1º liberação (fornecido pelo banco)
    --perform sc_aeo.set_atributo_xml('comp1', ct_praca_compensacao_lib_1, ct_tipo_atributo_tag, vl_local_arquivo);    

    -- TAG <banco1> banco da 1º liberação 
    perform sc_aeo.set_atributo_xml('banco',ct_banco_saqcard , ct_tipo_atributo_tag, vl_local_arquivo);    

    -- TAG <agnr1> agencia da 1º liberação 
    perform sc_aeo.set_atributo_xml('agnr',ct_agencia_saqcard , ct_tipo_atributo_tag, vl_local_arquivo);    

    -- TAG <agnrdv1> digito agencia da 1º liberação 
    perform sc_aeo.set_atributo_xml('agnrdv1',ct_dv_agencia_saqcard , ct_tipo_atributo_tag, vl_local_arquivo);    

    -- TAG <agnm1> nome da agencia. Nao utilizado na versao 6 

    -- TAG <conta1> conta da 1º liberação 
    perform sc_aeo.set_atributo_xml('conta',ct_conta_saqcard , ct_tipo_atributo_tag, vl_local_arquivo);    

    -- TAG <contadv1> digito conta da 1º liberação 
    perform sc_aeo.set_atributo_xml('contadv',ct_dv_conta_saqcard , ct_tipo_atributo_tag, vl_local_arquivo);    

    -- ######### FIM DE BENEFICIARIO ###########

    -- TAG <codorg1> codigo da origem 1 vinculado a proposta 
    perform sc_aeo.set_atributo_xml('codorg1',ct_codigo_origem_1 , ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <codorg2> codigo da origem 2 vinculado a proposta 
    perform sc_aeo.set_atributo_xml('codorg2',ct_codigo_origem_2 , ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <codorg3> codigo da origem 3 vinculado a proposta 
    perform sc_aeo.set_atributo_xml('codorg3',ct_codigo_origem_3 , ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <codorg4> codigo da origem 4 vinculado a proposta 
    perform sc_aeo.set_atributo_xml('codorg4',ct_codigo_origem_4 , ct_tipo_atributo_tag, vl_local_arquivo);

    -- TAG <codorg5> codigo da origem 5 vinculado a proposta 
    perform sc_aeo.set_atributo_xml('codorg5',ct_codigo_origem_5 , ct_tipo_atributo_tag, vl_local_arquivo);


    if rg.trf_eop > 0 then

	    -- ######### DESPESAS DA PROPOSTA ###########

	    perform sc_aeo.set_atributo_xml('despesasproposta',null,ct_tipo_atributo_abre_tag, vl_local_arquivo);

	    perform sc_aeo.set_atributo_xml('despesa',null,ct_tipo_atributo_abre_tag, vl_local_arquivo);

	    -- TAG <coddsp> codigo da politica de despesa
	    perform sc_aeo.set_atributo_xml('coddsp',ct_codigo_politica_despesa , ct_tipo_atributo_tag, vl_local_arquivo); 

	    -- TAG <tpdsp> tipo da despesa cadastrada
	    perform sc_aeo.set_atributo_xml('tpdsp',ct_codigo_tipo_despesa , ct_tipo_atributo_tag, vl_local_arquivo); 

	    -- TAG <itemdsp> codigo do item da politica de despesa
	    perform sc_aeo.set_atributo_xml('itemdsp',ct_codigo_item_politica_despesa , ct_tipo_atributo_tag, vl_local_arquivo); 

	    -- TAG <grpdsp> codigo do grupo da despesa
	    perform sc_aeo.set_atributo_xml('grpdsp',ct_codigo_grupo_despesa , ct_tipo_atributo_tag, vl_local_arquivo); 

	    -- TAG <vlrdsp> valor da despesa
	    perform sc_aeo.set_atributo_xml('vlrdsp',sc_pbl.valor_formato_ptbr(rg.trf_eop,'N') , ct_tipo_atributo_tag, vl_local_arquivo); 

	    perform sc_aeo.set_atributo_xml('despesa',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo);
	    
	    -- ######### FIM DE DESPESAS DA PROPOSTA ###########
	    perform sc_aeo.set_atributo_xml('despesasproposta',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo); 

    end if;
   
    -- ######### FIM DE PROPOSTA ###########
    perform sc_aeo.set_atributo_xml('proposta',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo); 


  end loop;

  -- ######### FIM DO DADOS ###########
  perform sc_aeo.set_atributo_xml('dados',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo); 

  -- ######### TRAILLER ###########
  perform sc_aeo.set_atributo_xml('trailler',null,ct_tipo_atributo_abre_tag, vl_local_arquivo);

  perform sc_aeo.set_atributo_xml('totais',null,ct_tipo_atributo_abre_tag, vl_local_arquivo);

    -- TAG <propostas> total de propostas
    perform sc_aeo.set_atributo_xml('propostas', trim(to_char(vl_qtd_operacoes,'9999')), ct_tipo_atributo_tag, vl_local_arquivo);    

    -- TAG <vlr_sol> total de propostas
    perform sc_aeo.set_atributo_xml('vlr_sol', sc_pbl.valor_formato_ptbr(vl_valor_total_solicitado,'N'), ct_tipo_atributo_tag, vl_local_arquivo);    

  perform sc_aeo.set_atributo_xml('totais',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo);
    
  perform sc_aeo.set_atributo_xml('trailler',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo);

  -- ######### FIM DE TRAILLER ###########


  -- ######### FIM DE REMESSA ###########
  perform sc_aeo.set_atributo_xml('REMESSA',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo);

  -- atualizando o codigo do arquivo na tabela de operacoes exportadas
  update sc_aeo.tbl_eop set cd_aeop = vl_codigo_arquivo where dt_base_eop = vp_data_referencia;

  -- atualizando valores totais no arquivo
  update sc_aeo.tbl_aeop set 
    vl_slc_aeop = vl_valor_total_solicitado,
    vl_lib_aeop = vl_valor_total_liberado,
    vl_ttl_aeop = vl_valor_total_parcela,
    vl_fee_aeop = vl_valor_total_solicitado * ct_fee_bracce/100
  where cd_aeop = vl_codigo_arquivo;

  update sc_aeo.tbl_eop set log_edr_eop='SEM LOGRADOURO' WHERE TRIM(log_edr_eop) = '' and cd_aeop = vl_codigo_arquivo;
  update sc_aeo.tbl_eop set log_edr_eop='SEM LOGRADOURO' WHERE log_edr_eop IS NULL and cd_aeop = vl_codigo_arquivo;

  update sc_aeo.tbl_eop set brr_edr_eop='SEM BAIRRO' WHERE TRIM(brr_edr_eop) = '' and cd_aeop = vl_codigo_arquivo;
  update sc_aeo.tbl_eop set brr_edr_eop='SEM BAIRRO' WHERE brr_edr_eop IS NULL and cd_aeop = vl_codigo_arquivo;

  -- inserindo registro na tabela de download de arquivo
  insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_arquivo,now(),vp_data_referencia,8,1);     

  end if;

end;$$;


ALTER FUNCTION sc_aeo.exporta_remessa_bracce(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1177 (class 1255 OID 564067)
-- Name: gera_boleto_veacos(); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION gera_boleto_veacos() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin


  for rg in select cd_fcr from sc_fcr.tbl_fcr where dt_ems_fcr >= current_date and st_fcr = 1 and dt_ult_pgt_fcr is null loop

   perform sc_cbr.gerar_boleto(2,2,rg.cd_fcr);

  end loop;
end;$$;


ALTER FUNCTION sc_aeo.gera_boleto_veacos() OWNER TO scan;

--
-- TOC entry 1275 (class 1255 OID 1665026)
-- Name: gerar_arquivo_bracce_job(); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION gerar_arquivo_bracce_job() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin

    if sc_grl.eh_dia_util(current_date) and current_date <> TO_DATE('09-07-2019', 'dd-mm-yyyy') then

       --perform sc_aeo.popula_bracce(current_date);
       perform sc_ccb.gerar_ccb();
       perform sc_ccb.popula_dados_arquivo_bracce(current_date);
       perform sc_aeo.exporta_remessa_bracce(current_date);
       
    end if;
  
end$$;


ALTER FUNCTION sc_aeo.gerar_arquivo_bracce_job() OWNER TO scan;

SET search_path = sc_cad, pg_catalog;

--
-- TOC entry 212 (class 1259 OID 564069)
-- Name: tbl_edr; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_edr (
    cd_edr numeric(10,0) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    cep_edr numeric(8,0),
    nr_edr character varying(8) NOT NULL,
    cpl_edr character varying(30),
    fg_atv_edr character(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    tp_edr numeric(2,0) NOT NULL,
    CONSTRAINT ck_fg_atv_edr CHECK ((fg_atv_edr = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_edr OWNER TO scan;

--
-- TOC entry 7609 (class 0 OID 0)
-- Dependencies: 212
-- Name: TABLE tbl_edr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_edr IS 'TABELA DE ENDERECO';


--
-- TOC entry 213 (class 1259 OID 564073)
-- Name: tbl_eex; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_eex (
    cd_edr numeric(10,0) NOT NULL,
    nm_log_eex character varying(50) NOT NULL,
    nm_brr_eex character varying(50) NOT NULL,
    nm_loc_eex character varying(50) NOT NULL,
    uf_eex character(2) NOT NULL
);


ALTER TABLE tbl_eex OWNER TO scan;

--
-- TOC entry 7610 (class 0 OID 0)
-- Dependencies: 213
-- Name: TABLE tbl_eex; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_eex IS 'EXTENSAO DA TABELA DE ENDERECO';


SET search_path = sc_crr, pg_catalog;

--
-- TOC entry 214 (class 1259 OID 564076)
-- Name: log_bairro; Type: TABLE; Schema: sc_crr; Owner: scan
--

CREATE TABLE log_bairro (
    bai_nu_sequencial numeric(10,0) NOT NULL,
    ufe_sg character varying(4) NOT NULL,
    loc_nu_sequencial numeric(10,0) NOT NULL,
    bai_no character varying(144) NOT NULL,
    bai_no_abrev character varying(72)
);


ALTER TABLE log_bairro OWNER TO scan;

--
-- TOC entry 215 (class 1259 OID 564079)
-- Name: log_localidade; Type: TABLE; Schema: sc_crr; Owner: scan
--

CREATE TABLE log_localidade (
    loc_nu_sequencial numeric(10,0) NOT NULL,
    loc_nosub character varying(100),
    loc_no character varying(120),
    cep character varying(16),
    ufe_sg character varying(4) NOT NULL,
    loc_in_situacao numeric(10,0) NOT NULL,
    loc_in_tipo_localidade character varying(2) NOT NULL,
    loc_nu_sequencial_sub numeric(10,0),
    loc_mun_nu numeric(10,0),
    cep2 numeric(8,0)
);


ALTER TABLE log_localidade OWNER TO scan;

--
-- TOC entry 216 (class 1259 OID 564082)
-- Name: log_logradouro; Type: TABLE; Schema: sc_crr; Owner: scan
--

CREATE TABLE log_logradouro (
    log_nu_sequencial numeric(10,0) NOT NULL,
    ufe_sg character varying(4) NOT NULL,
    loc_nu_sequencial numeric(10,0) NOT NULL,
    log_no character varying(140) NOT NULL,
    log_nome character varying(250),
    bai_nu_sequencial_ini numeric(10,0),
    bai_nu_sequencial_fim numeric(10,0),
    cep character varying(16) NOT NULL,
    log_complemento character varying(200),
    log_tipo_logradouro character varying(144) NOT NULL,
    log_status_tipo_log character varying(2) NOT NULL,
    log_no_sem_acento character varying(140),
    cep2 numeric(8,0)
);


ALTER TABLE log_logradouro OWNER TO scan;

--
-- TOC entry 217 (class 1259 OID 564088)
-- Name: vw_crr; Type: VIEW; Schema: sc_crr; Owner: scan
--

CREATE VIEW vw_crr AS
SELECT lgr.cep2 AS cep, CASE WHEN (lgr.log_nome IS NOT NULL) THEN lgr.log_nome ELSE (btrim((((lgr.log_tipo_logradouro)::text || ' '::text) || (lgr.log_no_sem_acento)::text)))::character varying END AS logradouro, brr.bai_no AS bairro, loc.loc_no AS localidade, loc.ufe_sg AS uf FROM ((log_logradouro lgr JOIN log_bairro brr ON ((lgr.bai_nu_sequencial_ini = brr.bai_nu_sequencial))) JOIN log_localidade loc ON ((brr.loc_nu_sequencial = loc.loc_nu_sequencial))) UNION ALL SELECT loc.cep2 AS cep, '' AS logradouro, '' AS bairro, loc.loc_no AS localidade, loc.ufe_sg AS uf FROM log_localidade loc WHERE (loc.cep2 IS NOT NULL);


ALTER TABLE vw_crr OWNER TO scan;

SET search_path = sc_cad, pg_catalog;

--
-- TOC entry 218 (class 1259 OID 564093)
-- Name: vw_edr; Type: VIEW; Schema: sc_cad; Owner: scan
--

CREATE VIEW vw_edr AS
SELECT edr.cd_cun, edr.cd_edr, edr.cep_edr, edr.tp_edr, edr.nr_edr, edr.cpl_edr, edr.fg_atv_edr, crr.logradouro, crr.bairro, crr.localidade, crr.uf, CASE WHEN (crr.localidade IS NULL) THEN 'N'::text ELSE 'S'::text END AS cep_valido, edr.cd_inc_usr, edr.dt_inc_usr, edr.cd_alt_usr, edr.dt_alt_usr, 'NOME DO TIPO DE ENDERECO' AS nm_tipo FROM (tbl_edr edr JOIN sc_crr.vw_crr crr ON ((edr.cep_edr = crr.cep))) WHERE (NOT (EXISTS (SELECT 1 FROM tbl_eex eex WHERE (eex.cd_edr = edr.cd_edr)))) UNION ALL SELECT edr.cd_cun, edr.cd_edr, edr.cep_edr, edr.tp_edr, edr.nr_edr, edr.cpl_edr, edr.fg_atv_edr, ((eex.nm_log_eex)::text)::character varying AS logradouro, ((eex.nm_brr_eex)::text)::character varying AS bairro, ((eex.nm_loc_eex)::text)::character varying AS localidade, (((eex.uf_eex)::character varying)::bpchar)::character varying AS uf, 'N'::text AS cep_valido, edr.cd_inc_usr, edr.dt_inc_usr, edr.cd_alt_usr, edr.dt_alt_usr, 'NOME DO TIPO DE ENDERECO' AS nm_tipo FROM (tbl_edr edr JOIN tbl_eex eex ON ((edr.cd_edr = eex.cd_edr)));


ALTER TABLE vw_edr OWNER TO scan;

SET search_path = sc_aeo, pg_catalog;

--
-- TOC entry 1178 (class 1255 OID 564098)
-- Name: get_endereco(numeric); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION get_endereco(vp_codigo_cadastro_unico numeric) RETURNS sc_cad.vw_edr
    LANGUAGE plpgsql
    AS $$declare
  vl_existe numeric;
  vl_endereco sc_cad.vw_edr%rowtype;
  
  ct_tipo_residencial constant numeric := 1;
begin
  select count(*)
  into vl_existe
  from sc_cad.vw_edr edr
  where edr.cd_cun = vp_codigo_cadastro_unico
    and edr.tp_edr = ct_tipo_residencial
    and edr.fg_atv_edr = 'S';

  if vl_existe > 0 then
    select *
    into vl_endereco
    from sc_cad.vw_edr edr
    where edr.cd_cun = vp_codigo_cadastro_unico
      and edr.tp_edr = ct_tipo_residencial
      and edr.fg_atv_edr = 'S'
    order by edr.dt_inc_usr desc;
  else
    select count(*)
    into vl_existe
    from sc_cad.vw_edr edr
    where edr.cd_cun = vp_codigo_cadastro_unico
      and edr.fg_atv_edr = 'S';

    if vl_existe > 0 then
      select *
      into vl_endereco
      from sc_cad.vw_edr edr
      where edr.cd_cun = vp_codigo_cadastro_unico
        and edr.fg_atv_edr = 'S'
      order by edr.dt_inc_usr desc;
    end if;
  end if;

  return vl_endereco;
end;$$;


ALTER FUNCTION sc_aeo.get_endereco(vp_codigo_cadastro_unico numeric) OWNER TO scan;

--
-- TOC entry 7611 (class 0 OID 0)
-- Dependencies: 1178
-- Name: FUNCTION get_endereco(vp_codigo_cadastro_unico numeric); Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON FUNCTION get_endereco(vp_codigo_cadastro_unico numeric) IS 'funcao que retorna o endereco residencial ativo de um determinado cadastro unico, caso exista, e qualquer outro endereco ativo caso contrario';


--
-- TOC entry 1172 (class 1255 OID 564099)
-- Name: get_primeiro_vencimento(numeric); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION get_primeiro_vencimento(vp_codigo_operacao numeric, OUT vp_data_primeiro_vencimento date, OUT vp_validacao numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
  vl_existe numeric;

  ct_sucesso constant numeric := 0;
  ct_nao_existe_parcela constant numeric := 2;

  ct_situacao_cancelado constant numeric := 3;
begin
  vp_validacao := ct_sucesso;
  
  select count(*)
  into vl_existe
  from sc_fcr.tbl_prc prc
  where prc.cd_opr = vp_codigo_operacao
    and prc.st_prc <> ct_situacao_cancelado;

  if vl_existe > 0 then
    select min(prc.dt_vnc_prc) + interval '3 day'
    into vp_data_primeiro_vencimento
    from sc_fcr.tbl_prc prc
    where prc.cd_opr = vp_codigo_operacao
      and prc.st_prc <> ct_situacao_cancelado;
  else
    vp_validacao := ct_nao_existe_parcela;
  end if;
end;$$;


ALTER FUNCTION sc_aeo.get_primeiro_vencimento(vp_codigo_operacao numeric, OUT vp_data_primeiro_vencimento date, OUT vp_validacao numeric) OWNER TO scan;

--
-- TOC entry 7612 (class 0 OID 0)
-- Dependencies: 1172
-- Name: FUNCTION get_primeiro_vencimento(vp_codigo_operacao numeric, OUT vp_data_primeiro_vencimento date, OUT vp_validacao numeric); Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON FUNCTION get_primeiro_vencimento(vp_codigo_operacao numeric, OUT vp_data_primeiro_vencimento date, OUT vp_validacao numeric) IS 'funcao que retorna o vencimento da primeira parcela da operacao';


SET search_path = sc_cad, pg_catalog;

--
-- TOC entry 219 (class 1259 OID 564100)
-- Name: tbl_tlf; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_tlf (
    cd_tlf numeric(10,0) NOT NULL,
    nr_ddd_tlf numeric(2,0) NOT NULL,
    nr_tlf numeric(10,0) NOT NULL,
    tp_tlf numeric(2,0) NOT NULL,
    tp_org_tlf numeric(2,0) NOT NULL,
    nsu_org_tlf numeric(10,0) NOT NULL,
    fg_atv_tlf character(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    fg_prn_tlf character varying(1) DEFAULT 'N'::character varying
);


ALTER TABLE tbl_tlf OWNER TO scan;

--
-- TOC entry 7613 (class 0 OID 0)
-- Dependencies: 219
-- Name: TABLE tbl_tlf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_tlf IS 'TABELA DE TELEFONE';


SET search_path = sc_aeo, pg_catalog;

--
-- TOC entry 1173 (class 1255 OID 564103)
-- Name: get_telefone(numeric, numeric); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION get_telefone(vp_codigo_cadastro_unico numeric, vp_tipo_telefone numeric) RETURNS sc_cad.tbl_tlf
    LANGUAGE plpgsql
    AS $$declare
  vl_existe numeric;

  ct_pessoa_fisica constant numeric := 1;

  vl_telefone sc_cad.tbl_tlf%rowtype;
begin
  select count(*)
  into vl_existe
  from sc_cad.tbl_tlf tlf
  where tlf.fg_atv_tlf = 'S'
    and tlf.tp_org_tlf = ct_pessoa_fisica
    and tlf.nsu_org_tlf = vp_codigo_cadastro_unico
    and tlf.tp_tlf = vp_tipo_telefone;
  
  if vl_existe > 0 then
    select *
    into vl_telefone
    from sc_cad.tbl_tlf tlf
    where tlf.fg_atv_tlf = 'S'
      and tlf.tp_org_tlf = ct_pessoa_fisica
      and tlf.nsu_org_tlf = vp_codigo_cadastro_unico
      and tlf.tp_tlf = vp_tipo_telefone
    order by tlf.dt_inc_usr;
  end if;

  return vl_telefone;
end;$$;


ALTER FUNCTION sc_aeo.get_telefone(vp_codigo_cadastro_unico numeric, vp_tipo_telefone numeric) OWNER TO scan;

--
-- TOC entry 7614 (class 0 OID 0)
-- Dependencies: 1173
-- Name: FUNCTION get_telefone(vp_codigo_cadastro_unico numeric, vp_tipo_telefone numeric); Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON FUNCTION get_telefone(vp_codigo_cadastro_unico numeric, vp_tipo_telefone numeric) IS 'funcao que retorna um telefone ativo de um determinado tipo e cadastro unico';


--
-- TOC entry 1099 (class 1255 OID 564104)
-- Name: get_ultimo_vencimento(numeric); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION get_ultimo_vencimento(vp_codigo_operacao numeric, OUT vp_data_ultimo_vencimento date, OUT vp_validacao numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
  vl_existe numeric;

  ct_sucesso constant numeric := 0;
  ct_nao_existe_parcela constant numeric := 2;

  ct_situacao_cancelado constant numeric := 3;
begin
  vp_validacao := ct_sucesso;
  
  select count(*)
  into vl_existe
  from sc_fcr.tbl_prc prc
  where prc.cd_opr = vp_codigo_operacao
    and prc.st_prc <> ct_situacao_cancelado;

  if vl_existe > 0 then
    select max(prc.dt_vnc_prc) + interval '3 day'
    into vp_data_ultimo_vencimento
    from sc_fcr.tbl_prc prc
    where prc.cd_opr = vp_codigo_operacao
      and prc.st_prc <> ct_situacao_cancelado;
  else
    vp_validacao := ct_nao_existe_parcela;
  end if;
end;$$;


ALTER FUNCTION sc_aeo.get_ultimo_vencimento(vp_codigo_operacao numeric, OUT vp_data_ultimo_vencimento date, OUT vp_validacao numeric) OWNER TO scan;

--
-- TOC entry 7615 (class 0 OID 0)
-- Dependencies: 1099
-- Name: FUNCTION get_ultimo_vencimento(vp_codigo_operacao numeric, OUT vp_data_ultimo_vencimento date, OUT vp_validacao numeric); Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON FUNCTION get_ultimo_vencimento(vp_codigo_operacao numeric, OUT vp_data_ultimo_vencimento date, OUT vp_validacao numeric) IS 'funcao que retorna o vencimento da ultima parcela da operacao';


--
-- TOC entry 1133 (class 1255 OID 564105)
-- Name: popula_bracce(date); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION popula_bracce(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;
vl_rg_edr record;

ct_taxa_fundo constant numeric := 3.0;
ct_vl_tarifa_fundo constant numeric := 0;

ct_tipo_operacao_saque_extra constant numeric := 5;
ct_situacao_operacao_confirmada constant numeric := 2;
ct_tipo_cobranca_juros_saque_extra constant numeric := 1;

ct_cod_nacionalidade constant numeric := 0;

vl_dt_inicio timestamp := vp_data_referencia;
vl_dt_final timestamp := vp_data_referencia;

vl_data_base date;
vl_data_base_util date;
vl_data_vencimento date;
vl_valor_solicitado numeric := 0;
vl_valor_liberado numeric := 0;
-- bracce[1 – Solteiro 2 – Casado 3 – Desquitado 4 – Divorciado 5 – Viúvo 9 – Outros] saq[1 - Solteiro 2 - Casado 3 - Viuvo 4 - Divorciado]
cd_estado_civil numeric;
vl_renda_mensal numeric;
contador numeric;

vr_vl_iof numeric(13,4) := 0;
vr_vl_parcela numeric(13,2) := 0;

ct_regex varchar := '([^a-zA-Z0-9\(\)\. _@<>/:,-])';

retorno_parcela record;
i numeric :=0;

begin


   vl_dt_inicio := vl_dt_inicio;
   --vl_dt_final := vl_dt_final + interval '17 hour';


   for rg in 
   select opr.*, crt.cd_crt, cun.nm_cun, cun.nr_cpf_cnpj_cun, cpf.*, edr.*,dtv.vl_dtv,
          prc.dt_vnc_prc vencimento
     from sc_opr.tbl_opr opr
       inner join sc_fcr.tbl_prc prc on prc.cd_opr = opr.cd_opr
       inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
       inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
       inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
       inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
       inner join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
       inner join (select max(cd_edr) as endereco, cd_cun as cadastro 
                   from sc_cad.vw_edr 
                   where fg_atv_edr = 'S'
                   group by cd_cun) as edr_t on edr_t.cadastro = cun.cd_cun
       inner join sc_cad.vw_edr edr on edr_t.endereco = edr.cd_edr 
       inner join sc_opr.tbl_tvt tvt on tvt.cd_tvt = crt.cd_tvt
       inner join sc_opr.tbl_dtv dtv on dtv.cd_tvt = tvt.cd_tvt       
   where opr.cd_top = ct_tipo_operacao_saque_extra
     and opr.st_opr = ct_situacao_operacao_confirmada
     and opr.cd_aeo is null
     and not exists(select 1 from sc_aeo.tbl_eop where cd_opr = opr.cd_opr)
     and prc.dt_vnc_prc >= vp_data_referencia + interval '1 days'
     and opr.dt_opr < vp_data_referencia 
     and dtv.cd_top = 5
     and dtv.tp_cbr_dtv = 1
    -- and opr.dt_opr::date = '02/02/2016'::date 
   order by opr.cd_opr

  loop

    /*contador := 0;

    -- calculo data base e data vencimento
    vl_data_base := rg.dt_opr;
    vl_data_vencimento := rg.vencimento;
    
    if rg.dt_opr::date < vl_dt_final::date then
	vl_data_base := vl_data_base + interval '1 day';
	vl_data_vencimento := vl_data_vencimento + interval '1 day';
    end if;

    -- garantindo que a data base eh dia util
    vl_data_base_util := vl_data_base;
    if not sc_grl.eh_dia_util(vl_data_base) then
       vl_data_base_util := sc_grl.get_proximo_dia_util(vl_data_base);
    end if;

    -- somando a qtd de dias acrescidos a data base no vencimento para garantir o calculo financeiro
    contador := vl_data_base_util - vl_data_base;

    vl_data_base := vl_data_base_util;

    while contador > 0 loop

      vl_data_vencimento := vl_data_vencimento + interval '1 day';
      contador := contador - 1;

    end loop;*/

    vl_data_base := vp_data_referencia;
    vl_data_vencimento := rg.vencimento;

    select *
    into vl_rg_edr
    from sc_aeo.get_endereco(rg.cd_cun);    
    
    -- acrescentando 3 dias no vencimento a titulo de recebimento das empresas
    vl_data_vencimento := vl_data_vencimento + interval '1 day';


    -- recalculando operacao
    vl_valor_solicitado := rg.vl_opr - (rg.vl_iof_opr + rg.vl_trf_opr + rg.vl_jrs_opr);
    --sc_calc.calcula_valor_parcela(IN vp_data_base date, IN vp_data_venc_primeira date, IN vp_taxa_juros numeric, IN vp_valor_tarifa numeric, IN vp_qt_prestacoes numeric, IN vp_vl_financiado numeric, OUT vr_vl_iof numeric, OUT vr_vl_parcela numeric, OUT vr_vl_cet numeric)

    select * from sc_calc.calcula_valor_parcela(vl_data_base, vl_data_vencimento, rg.vl_dtv, ct_vl_tarifa_fundo, rg.nr_prc_opr, vl_valor_solicitado)
      into retorno_parcela;

    vr_vl_iof := retorno_parcela.vr_vl_iof;
    vr_vl_parcela := retorno_parcela.vr_vl_parcela;   

    -- calculo do valor liberado
    vl_valor_liberado := vl_valor_solicitado;

    -- novo valor solicitado com IOF baseado na taxa do fundo
    vl_valor_solicitado := vl_valor_solicitado + vr_vl_iof;

    -- converte estado civil
    cd_estado_civil := rg.cd_est_civil_cpf;
    if cd_estado_civil = 3 then 
      cd_estado_civil := 5; 
    end if;

    if cd_estado_civil not in(1,2,3,4,5,9) then
      cd_estado_civil := 9;
    end if;

    -- calculo da renda mensal
    vl_renda_mensal := coalesce(sc_adp.valor_media_abastecimento_cartao(rg.cd_crt),1000);

    insert into sc_aeo.tbl_eop (cd_eop,dt_grc_eop, cd_opr, nr_cpf_eop, nm_eop, vl_tx_eop, trf_eop, iof_eop, vl_slc_eop, vl_opr_eop, qtd_prc_eop, vl_prc_eop, vl_lib_eop, dt_opr_eop, dt_vnc_opr_eop, dt_base_eop, dt_vnc_eop, 
                                rg_eop, uf_rg_eop, org_ems_rg_eop, dt_ems_rg_eop, cd_est_civ_eop, dt_nsc_eop, cd_nac_eop, cep_eop, log_edr_eop, 
                                nr_edr_eop, cpl_edr_eop, brr_edr_eop, loc_edr_eop, uf_edr_eop, rnd_msl_eop, sexo_eop) 
                     values (nextval('sc_aeo.sq_eop'), now(), rg.cd_opr, rg.nr_cpf_cnpj_cun, sc_pbl.sem_acento(rg.nm_cun), rg.vl_dtv, ct_vl_tarifa_fundo, vr_vl_iof, vl_valor_solicitado, vr_vl_parcela, rg.nr_prc_opr, vr_vl_parcela, vl_valor_liberado, rg.dt_opr, rg.vencimento, vl_data_base, vl_data_vencimento,
                             rg.nr_rg_cpf, rg.uf_org_ems_rg_cpf, regexp_replace(sc_pbl.sem_acento(rg.nm_org_ems_rg_cpf),ct_regex,'','g'), rg.dt_ems_rg_cpf, cd_estado_civil, rg.dt_nsc_cpf, ct_cod_nacionalidade, vl_rg_edr.cep_edr, regexp_replace(sc_pbl.sem_acento(vl_rg_edr.logradouro),ct_regex,'','g'),
                             vl_rg_edr.nr_edr, regexp_replace(sc_pbl.sem_acento(vl_rg_edr.cpl_edr),ct_regex,'','g'), regexp_replace(sc_pbl.sem_acento(vl_rg_edr.bairro),ct_regex,'','g'), regexp_replace(sc_pbl.sem_acento(vl_rg_edr.localidade),ct_regex,'','g'), vl_rg_edr.uf, vl_renda_mensal, rg.sexo_cpf);
    raise notice 'interacao %',i;
    i := i+1;                        

  end loop;

  
end$$;


ALTER FUNCTION sc_aeo.popula_bracce(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1108 (class 1255 OID 1666458)
-- Name: regerar_arquivo_bracce(numeric); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION regerar_arquivo_bracce(vp_codigo_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;

  ct_diretorio_arq_remessa_bracce constant varchar := 'DIRETORIO_ARQUIVO_REMESSA_BRACCE';

  ct_fee_bracce numeric := 0.7;

  -- contantes de controle
  ct_tipo_atributo_abre_tag constant numeric := 1;
  ct_tipo_atributo_fecha_tag constant numeric := 2;
  ct_tipo_atributo_tag constant numeric := 3;
  ct_situacao_arquivo_gerado constant numeric := 1;
  
  -- contantes do layout (verificar codigos com o banco)
  ct_codigo_modulo constant varchar := '900';
  ct_versao_arquivo constant varchar := '06';
  ct_codigo_convenio constant varchar := '400000';
  ct_tipo_operacao constant varchar := '01'; -- tipo Credito Pessoal
  ct_grupo_cliente constant varchar := '99';
  ct_tipo_beneficiario constant varchar := '4'; 
  ct_codigo_historico_lib_1 constant varchar := '501';
  ct_praca_compensacao_lib_1 constant varchar := '0045';
  ct_codigo_origem_1 constant varchar := '40';
  ct_codigo_origem_2 constant varchar := '44';
  ct_codigo_origem_3 constant varchar := '400000';
  ct_codigo_origem_4 constant varchar := '400000';
  ct_codigo_origem_5 constant varchar := '400000'; --NAO USADO
  ct_codigo_politica_despesa varchar := '1';
  ct_codigo_tipo_despesa varchar := '1';
  ct_codigo_item_politica_despesa varchar := '1';
  ct_codigo_grupo_despesa varchar := '1';
  
  
  ct_cnpj_saqpag constant varchar := '21444981000136';
  ct_razao_social_saqpag varchar := 'SOMA ADMINISTRACAO DE CARTOES S/A';
  --ct_banco_saqcard constant varchar := '399'; 
  --ct_agencia_saqcard constant varchar := '0905'; 
  --ct_dv_agencia_saqcard constant varchar := '0'; 
  --ct_conta_saqcard constant varchar := '4541'; 
  --ct_dv_conta_saqcard constant varchar := '65'; 

  ct_banco_saqcard constant varchar := '237'; 
  ct_agencia_saqcard constant varchar := '2367'; 
  ct_dv_agencia_saqcard constant varchar := '1'; 
  ct_conta_saqcard constant varchar := '111'; 
  ct_dv_conta_saqcard constant varchar := '2';   
  

  vl_linha_xml varchar := '';
  vl_local_arquivo varchar;
  vl_nome_arquivo varchar;
  vl_diretorio varchar;
  vl_codigo_arquivo numeric;
  vl_sequencial_arquivo numeric;
  vl_qtd_operacoes numeric := 0;

  vl_valor numeric;
  vl_valor_prestacao numeric;
  vl_valor_parcela numeric;  
  vl_valor_solicitado numeric;
  vl_valor_iof numeric;
  vl_valor_tarifa numeric;

  vl_valor_total_solicitado numeric := 0;
  vl_valor_total_liberado numeric := 0;
  vl_valor_total_parcela numeric := 0;

  vp_data_referencia date;

begin


  select coalesce(count(*),0), dt_base_eop, seq_aeop
    into vl_qtd_operacoes, vp_data_referencia, vl_sequencial_arquivo
    from sc_aeo.tbl_aeop
  where cd_aeop = vp_codigo_arquivo;  

  if vl_qtd_operacoes > 0 then

	  -- Obtendo os parametros
	  select prm.vl_prm
	  into vl_diretorio
	  from sc_cad.tbl_prm prm
	  where prm.nm_prm = ct_diretorio_arq_remessa_bracce;
	  raise notice 'diretorio do arquivo: %',  vl_diretorio;
	      
	  --definindo o nome do arquivo
	  vl_nome_arquivo := ct_codigo_modulo || to_char(vp_data_referencia, 'ddmmyyyy') || trim(to_char(vl_sequencial_arquivo, repeat('0', 3))) || '.XML';
          raise notice 'nome do arquivo: %',  vl_nome_arquivo;
          
	  --definindo onde o arquivo sera gravado
	  vl_local_arquivo := vl_diretorio || '\\' || vl_nome_arquivo;

          --excluindo o arquivo caso o mesmo exista
          begin
	    perform sc_arq.excluirarquivo(vl_local_arquivo);
	  exception
	    when others then
	      raise notice 'ocorreu um erro ao tentar apagar o arquivo: %, descricao do erro: %', vl_local_arquivo, sqlerrm;
	  end;
	  
	  -- inicio do padrao xml
	  perform sc_arq.gravarlinha(vl_local_arquivo, '<?xml version="1.0" encoding="UTF-8"?>');

	  -- ######### INICIO DE REMESSA ###########
	  perform sc_aeo.set_atributo_xml('REMESSA',null,ct_tipo_atributo_abre_tag, vl_local_arquivo);

	  -- ######### INICIO DE HEADER ########### 
	  perform sc_aeo.set_atributo_xml('header',null,ct_tipo_atributo_abre_tag, vl_local_arquivo);

	  -- TAG <cod_modulo> codigo do modulo das propostas
	  perform sc_aeo.set_atributo_xml('cod_modulo',ct_codigo_modulo,ct_tipo_atributo_tag, vl_local_arquivo);

	  -- TAG <arquivo> nome do arquivo xml gerado (999 – Código módulo / DD – Dia / MM – Mês / A – Ano)
	  perform sc_aeo.set_atributo_xml('arquivo',vl_nome_arquivo,ct_tipo_atributo_tag, vl_local_arquivo);

	  -- TAG <diretorio> diretorio onde o arquivo xml sera gerado
	  --perform sc_aeo.set_atributo_xml('diretorio',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo);

	  -- TAG <email> email para confirmação da captura da proposta
	  perform sc_aeo.set_atributo_xml('email','financeiro@saqpag.com.br', ct_tipo_atributo_tag, vl_local_arquivo);

	  -- TAG <data> data da geração do arquivo
	  perform sc_aeo.set_atributo_xml('data',to_char(vp_data_referencia, 'yyyymmdd'), ct_tipo_atributo_tag, vl_local_arquivo);

	  -- TAG <tpdata> tipo de data (Liberação ou Cadastro)
	  perform sc_aeo.set_atributo_xml('tpdata','Liberacao', ct_tipo_atributo_tag, vl_local_arquivo);

	  -- TAG <tpremessa> tipo de remessa (Emissão ou Re-emissão)
	  perform sc_aeo.set_atributo_xml('tpremessa','Emissao', ct_tipo_atributo_tag, vl_local_arquivo);

	  -- TAG <versao> versao do arquivo
	  perform sc_aeo.set_atributo_xml('versao', ct_versao_arquivo, ct_tipo_atributo_tag, vl_local_arquivo);

	  -- TAG <dth_ini> data e hora do inicio da geracao do arquivo
	  perform sc_aeo.set_atributo_xml('dth_ini', to_char(clock_timestamp(), 'yyyymmdd hh24:mi'), ct_tipo_atributo_tag, vl_local_arquivo);

	  -- TAG <dth_fim> data e hora da conclusao da geracao do arquivo
	  perform sc_aeo.set_atributo_xml('dth_fim', to_char(clock_timestamp(), 'yyyymmdd hh24:mi'), ct_tipo_atributo_tag, vl_local_arquivo);

	  -- ######### FIM DO HEADER ########### 
	  perform sc_aeo.set_atributo_xml('header',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo);


	  -- ######### DADOS ###########
	  perform sc_aeo.set_atributo_xml('dados',null,ct_tipo_atributo_abre_tag, vl_local_arquivo); 

	  
	  for rg in 
	    select * from sc_aeo.tbl_eop where cd_aeop = vp_codigo_arquivo
	  loop 

	    -- ######### PROPOSTA ###########
	    perform sc_aeo.set_atributo_xml('proposta',null,ct_tipo_atributo_abre_tag, vl_local_arquivo); 

	    -- TAG <nrprop> numero da proposta (codigo da operacao de saque extra)
	    perform sc_aeo.set_atributo_xml('nrprop', rg.cd_opr::varchar, ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <nroper> numero da operacao gerado pelo sistema de destino
	    perform sc_aeo.set_atributo_xml('nroper', rg.cd_opr::varchar, ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <codprd> codigo do convenio gerado para proposta
	    perform sc_aeo.set_atributo_xml('codprd', ct_codigo_convenio, ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <usuario> nome do usuário para geração e captura do arquivo

	    -- TAG <dtbase> data base da proposta cadastrada.
	    perform sc_aeo.set_atributo_xml('dtbase', to_char(rg.dt_base_eop, 'yyyymmdd'), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <dtcad> utilizada data base da proposta como referencia
	    perform sc_aeo.set_atributo_xml('dtcad', to_char(rg.dt_base_eop, 'yyyymmdd'), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <vlrsol> valor solicitado
	    vl_valor_total_solicitado := vl_valor_total_solicitado + rg.vl_slc_eop;
	    perform sc_aeo.set_atributo_xml('vlrsol', sc_pbl.valor_formato_ptbr(rg.vl_slc_eop,'N'), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <vlrtac> Valor da TAC da proposta. 	na versão 6 as despesas devem ser informadas na tag <DespesasProposta>
	    -- TAG <seg> Código do seguro cadastrado para a proposta (A – No ato N – Não). na versão 6 as despesas devem ser informadas na tag <DespesasProposta>
	    -- TAG <vlrseg> Valor do seguro cadastrado para a proposta. na versão 6 as despesas devem ser informadas na tag <DespesasProposta>

	    -- TAG <vlrtaxa> valor da taxa nominal da proposta
	    perform sc_aeo.set_atributo_xml('vlrtaxa', trim(to_char(rg.vl_tx_eop,'90D9999')), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <qtparc> quantidade de parcelas da proposta
	    perform sc_aeo.set_atributo_xml('qtparc', trim(to_char(rg.qtd_prc_eop,'99')), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <dtvcto> data do primeiro vencimento
	    perform sc_aeo.set_atributo_xml('dtvcto', to_char(rg.dt_vnc_eop, 'yyyymmdd'), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <vlrsolcalculoiof> valor solicitado para o calculo do iof
	    -- Adicionado em 24/09/2015  - Solicitacao feita pela Bracce
	    perform sc_aeo.set_atributo_xml('vlrsolcalculoiof', sc_pbl.valor_formato_ptbr(rg.vl_lib_eop,'N'), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <vlrioc> valor do iof calculado para a proposta
	    perform sc_aeo.set_atributo_xml('vlrioc', replace(to_char(rg.iof_eop, '999990D9999'), ' ', ''), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <vlrparc> valor da parcela da proposta
	    vl_valor_total_parcela := vl_valor_total_parcela + rg.vl_prc_eop;
	    perform sc_aeo.set_atributo_xml('vlrparc', sc_pbl.valor_formato_ptbr(rg.vl_prc_eop,'N'), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <vlrcpmf> Soma dos valores da CPMF das liberações 1 ao 5 da proposta. 

	    -- TAG <tpoper> tipo da operacao (01 – Crédito Pessoal 02 – Financiamento 03 – Refinanciamento 04 – Renegociação 05 – Privado Simulação 06 – Privado Dados Básicos 09 – Compra de dívida)
	    perform sc_aeo.set_atributo_xml('tpoper', ct_tipo_operacao, ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <cgc> CPF/CNPJ do cliente referente à proposta
	    perform sc_aeo.set_atributo_xml('cgc', trim(to_char(rg.nr_cpf_eop,'00000000000')), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <nomecli> nome do cliente
	    perform sc_aeo.set_atributo_xml('nomecli', substr(rg.nm_eop,0,36), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <grpcli> código do grupo de clientes do respectivo cliente da proposta 

	    -- TAG <codnac> código da nacionalidade cadastrada para o cliente 
	    perform sc_aeo.set_atributo_xml('codnac', rg.cd_nac_eop::varchar, ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <rg> numero do rg do cliente 
	    perform sc_aeo.set_atributo_xml('rg', rg.rg_eop::varchar, ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <ufrg> uf do rg do cliente 
	    perform sc_aeo.set_atributo_xml('ufrg', rg.uf_rg_eop, ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <dtemi> data emissao rg do cliente 
	    perform sc_aeo.set_atributo_xml('dtemi', to_char(rg.dt_ems_rg_eop,'yyyymmdd'), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <estcivil> codigo estado civil (1 – Solteiro 2 – Casado 3 – Desquitado 4 – Divorciado 5 – Viúvo 9 – Outros)
	    perform sc_aeo.set_atributo_xml('estcivil', rg.cd_est_civ_eop::varchar, ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <dtnasc> data emissao rg do cliente 
	    perform sc_aeo.set_atributo_xml('dtnasc', to_char(rg.dt_nsc_eop,'yyyymmdd'), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <endfis> endereço pessoa física do cliente (logradouro).
	    perform sc_aeo.set_atributo_xml('endfis', rg.log_edr_eop, ct_tipo_atributo_tag, vl_local_arquivo);
	   
	    -- TAG <nrendfis> número do endereço pessoa física do cliente.
	    perform sc_aeo.set_atributo_xml('nrendfis', rg.nr_edr_eop, ct_tipo_atributo_tag, vl_local_arquivo);
	    
	    -- TAG <cmptfis> complemento de endereço pessoa física do cliente.
	    perform sc_aeo.set_atributo_xml('cmptfis', rg.cpl_edr_eop, ct_tipo_atributo_tag, vl_local_arquivo);
	    
	    -- TAG <baifis> bairro do endereço pessoa física do cliente.
	    perform sc_aeo.set_atributo_xml('baifis', rg.brr_edr_eop, ct_tipo_atributo_tag, vl_local_arquivo);
	    
	    -- TAG <cidfis> cidade do endereço pessoa física do cliente.
	    perform sc_aeo.set_atributo_xml('cidfis', rg.loc_edr_eop, ct_tipo_atributo_tag, vl_local_arquivo);
	    
	    -- TAG <uffis> UF do endereço de pessoa física do cliente.
	    perform sc_aeo.set_atributo_xml('uffis', rg.uf_edr_eop, ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <cepfis> cep do endereco da pessoa fisica
	    perform sc_aeo.set_atributo_xml('cepfis', rg.cep_eop::varchar, ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <dddfonefis> DDD do telefone do endereço pessoa física do cliente.
	    -- TAG <fonefis> Telefone do endereço pessoa física do cliente.
	    -- TAG <tpres> Tipo de residência do cliente. (P – Própria,A – Alugada,F – Familiares,E – Empresa,N – Financiada,H – Hotel)
	    -- TAG <anoratu> Tempo (em anos) na residência atual.
	    -- TAG <mesratu> Tempo (em meses) na residência atual
	    -- TAG <nomeemp> Nome da empresa.
	    -- TAG <profiss> Profissão do cliente.
	    -- TAG <cargo> Cargo do cliente.
	    -- TAG <dtadm> Data de admissão do cliente.
	    -- TAG <endcom> Endereço comercial do cliente (logradouro)
	    -- TAG <nrocom> Número do endereço comercial do cliente.
	    -- TAG <cmpcom> Complemento do endereço comercial do cliente.
	    -- TAG <baicom> Bairro do endereço comercial do cliente.
	    -- TAG <cidcom> Cidade do endereço comercial do cliente.
	    -- TAG <ufcom> UF do endereço comercial do cliente.
	    -- TAG <cepcom> CEP do endereço comercial do cliente.
	    -- TAG <fonecom> Telefone do endereço comercial do cliente.
	    -- TAG <rmlcom> Ramal do telefone comercial do cliente.
	    -- TAG <matrcom> Número de matrícula do cliente

	    -- TAG <rendmes> renda mensal do cliente.
	    perform sc_aeo.set_atributo_xml('rendmes', sc_pbl.valor_formato_ptbr(rg.rnd_msl_eop,'N'), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <codaverb> código de averbação da proposta
	    -- TAG <bemfin> descrição do bem financiado.

	    -- TAG <sexo> sexo do cliente (F – Feminino ou M – Masculino)
	    perform sc_aeo.set_atributo_xml('sexo', rg.sexo_eop, ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <nomerf1> Nome da referência 1
	    -- TAG <cmptrf1> Complemento da referência 1
	    -- TAG <fonerf1> Telefone da referência 1

	    -- TAG <orgemi> órgão emissor do RG.
	    perform sc_aeo.set_atributo_xml('orgemi', substr(rg.org_ems_rg_eop,0,9), ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <nomepai> Filiação paterna.
	    -- TAG <nomemae> Filiação Materna.
	    -- TAG <cjgnome> Nome do conjugue do cliente.
	    -- TAG <endrf1> Endereço da referência 1 (logradouro).
	    -- TAG <ocup> Código da ocupação do cliente. (1 – Funcionário Público 2 – Aposentado)
	    -- TAG <anoserv> Tempo de serviço anterior (anos).
	    -- TAG <messerv> Tempo de serviço anterior (meses).
	    -- TAG <bancocompcli> Código da compensação dos dados bancários do cliente. (C/C 1)
	    -- TAG <banconrcli> Código do banco dos dados bancários do cliente.
	    -- TAG <agencianrcli> Código da agência dos dados bancários do cliente.
	    -- TAG <agenciadvcli> Código do DV da agência dos dados bancários do cliente. (O campo da conta e do DV são concatenados no mesmo campo CLCC1AGNR)
	    -- TAG <agencianmcli> Nome da agência dos dados bancários do cliente.
	    -- TAG <contaccnrcli> Código da conta dos dados bancários do cliente.
	    -- TAG <contaccdvcli> Código do DV da conta dos dados bancários do cliente.
	    -- TAG <agenciaendcli> Endereço da agência dos dados bancários do cliente. 

	    -- ######### BENEFICIARIO ###########
	    -- retirado o numero 1 da tag beneficiario, solicitacao do Bracce por alteracao no layout

	    -- TAG <tpbene1> Tipo do beneficiário da 1º liberação da proposta
	    perform sc_aeo.set_atributo_xml('tpbene', ct_tipo_beneficiario, ct_tipo_atributo_tag, vl_local_arquivo);    

	    -- TAG <cpfbene1> CPF do beneficiário da 1º liberação
	    perform sc_aeo.set_atributo_xml('cpfbene', ct_cnpj_saqpag, ct_tipo_atributo_tag, vl_local_arquivo);    

	    -- TAG <nomebene1> Nome do beneficiário da 1º liberação
	    perform sc_aeo.set_atributo_xml('nomebene', ct_razao_social_saqpag, ct_tipo_atributo_tag, vl_local_arquivo);    

	    -- TAG <vlrlib1> valor da 1º liberação
	    vl_valor_total_liberado := vl_valor_total_liberado + rg.vl_lib_eop;
	    perform sc_aeo.set_atributo_xml('vlrlib', sc_pbl.valor_formato_ptbr(rg.vl_lib_eop,'N'), ct_tipo_atributo_tag, vl_local_arquivo);    

	    -- TAG <codliq1> codigo do historico da 1º liberação (fornecido pelo banco)
	    perform sc_aeo.set_atributo_xml('codliq', ct_codigo_historico_lib_1, ct_tipo_atributo_tag, vl_local_arquivo);    

	    -- TAG <comp1> praça da compensação da 1º liberação (fornecido pelo banco)
	    --perform sc_aeo.set_atributo_xml('comp1', ct_praca_compensacao_lib_1, ct_tipo_atributo_tag, vl_local_arquivo);    

	    -- TAG <banco1> banco da 1º liberação 
	    perform sc_aeo.set_atributo_xml('banco',ct_banco_saqcard , ct_tipo_atributo_tag, vl_local_arquivo);    

	    -- TAG <agnr1> agencia da 1º liberação 
	    perform sc_aeo.set_atributo_xml('agnr',ct_agencia_saqcard , ct_tipo_atributo_tag, vl_local_arquivo);    

	    -- TAG <agnrdv1> digito agencia da 1º liberação 
	    perform sc_aeo.set_atributo_xml('agnrdv1',ct_dv_agencia_saqcard , ct_tipo_atributo_tag, vl_local_arquivo);    

	    -- TAG <agnm1> nome da agencia. Nao utilizado na versao 6 

	    -- TAG <conta1> conta da 1º liberação 
	    perform sc_aeo.set_atributo_xml('conta',ct_conta_saqcard , ct_tipo_atributo_tag, vl_local_arquivo);    

	    -- TAG <contadv1> digito conta da 1º liberação 
	    perform sc_aeo.set_atributo_xml('contadv',ct_dv_conta_saqcard , ct_tipo_atributo_tag, vl_local_arquivo);    

	    -- ######### FIM DE BENEFICIARIO ###########

	    -- TAG <codorg1> codigo da origem 1 vinculado a proposta 
	    perform sc_aeo.set_atributo_xml('codorg1',ct_codigo_origem_1 , ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <codorg2> codigo da origem 2 vinculado a proposta 
	    perform sc_aeo.set_atributo_xml('codorg2',ct_codigo_origem_2 , ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <codorg3> codigo da origem 3 vinculado a proposta 
	    perform sc_aeo.set_atributo_xml('codorg3',ct_codigo_origem_3 , ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <codorg4> codigo da origem 4 vinculado a proposta 
	    perform sc_aeo.set_atributo_xml('codorg4',ct_codigo_origem_4 , ct_tipo_atributo_tag, vl_local_arquivo);

	    -- TAG <codorg5> codigo da origem 5 vinculado a proposta 
	    perform sc_aeo.set_atributo_xml('codorg5',ct_codigo_origem_5 , ct_tipo_atributo_tag, vl_local_arquivo);


	    if rg.trf_eop > 0 then

		    -- ######### DESPESAS DA PROPOSTA ###########

		    perform sc_aeo.set_atributo_xml('despesasproposta',null,ct_tipo_atributo_abre_tag, vl_local_arquivo);

		    perform sc_aeo.set_atributo_xml('despesa',null,ct_tipo_atributo_abre_tag, vl_local_arquivo);

		    -- TAG <coddsp> codigo da politica de despesa
		    perform sc_aeo.set_atributo_xml('coddsp',ct_codigo_politica_despesa , ct_tipo_atributo_tag, vl_local_arquivo); 

		    -- TAG <tpdsp> tipo da despesa cadastrada
		    perform sc_aeo.set_atributo_xml('tpdsp',ct_codigo_tipo_despesa , ct_tipo_atributo_tag, vl_local_arquivo); 

		    -- TAG <itemdsp> codigo do item da politica de despesa
		    perform sc_aeo.set_atributo_xml('itemdsp',ct_codigo_item_politica_despesa , ct_tipo_atributo_tag, vl_local_arquivo); 

		    -- TAG <grpdsp> codigo do grupo da despesa
		    perform sc_aeo.set_atributo_xml('grpdsp',ct_codigo_grupo_despesa , ct_tipo_atributo_tag, vl_local_arquivo); 

		    -- TAG <vlrdsp> valor da despesa
		    perform sc_aeo.set_atributo_xml('vlrdsp',sc_pbl.valor_formato_ptbr(rg.trf_eop,'N') , ct_tipo_atributo_tag, vl_local_arquivo); 

		    perform sc_aeo.set_atributo_xml('despesa',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo);
		    
		    -- ######### FIM DE DESPESAS DA PROPOSTA ###########
		    perform sc_aeo.set_atributo_xml('despesasproposta',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo); 

	    end if;
	   
	    -- ######### FIM DE PROPOSTA ###########
	    perform sc_aeo.set_atributo_xml('proposta',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo); 


	  end loop;

	  -- ######### FIM DO DADOS ###########
	  perform sc_aeo.set_atributo_xml('dados',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo); 

	  -- ######### TRAILLER ###########
	  perform sc_aeo.set_atributo_xml('trailler',null,ct_tipo_atributo_abre_tag, vl_local_arquivo);

	  perform sc_aeo.set_atributo_xml('totais',null,ct_tipo_atributo_abre_tag, vl_local_arquivo);

	    -- TAG <propostas> total de propostas
	    perform sc_aeo.set_atributo_xml('propostas', trim(to_char(vl_qtd_operacoes,'9999')), ct_tipo_atributo_tag, vl_local_arquivo);    

	    -- TAG <vlr_sol> total de propostas
	    perform sc_aeo.set_atributo_xml('vlr_sol', sc_pbl.valor_formato_ptbr(vl_valor_total_solicitado,'N'), ct_tipo_atributo_tag, vl_local_arquivo);    

	  perform sc_aeo.set_atributo_xml('totais',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo);
	    
	  perform sc_aeo.set_atributo_xml('trailler',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo);

	  -- ######### FIM DE TRAILLER ###########


	  -- ######### FIM DE REMESSA ###########
	  perform sc_aeo.set_atributo_xml('REMESSA',null,ct_tipo_atributo_fecha_tag, vl_local_arquivo);   

  end if;

end;$$;


ALTER FUNCTION sc_aeo.regerar_arquivo_bracce(vp_codigo_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1106 (class 1255 OID 564108)
-- Name: repassar_investidor(); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION repassar_investidor() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_a_repassar numeric;
  vl_conta_bancaria_investidor numeric;

  ct_fornecedor_investidor numeric := 81;
  ct_tipo_despesa_repasse_investidor numeric := 50;
  ct_conta_banco numeric := 459;
  ct_conta_bancaria_investidor numeric := 3268; 

begin

   select sum(vl_prc_eop)
   into vl_a_repassar
   from sc_aeo.tbl_eop e
     inner join sc_aeo.tbl_aeop a on a.cd_aeop = e.cd_aeop
   where e.dt_vnc_eop <= current_date
     and e.dt_rps_eop is null
     and a.cd_ivt = 1;

     
   if coalesce(vl_a_repassar,0) > 0 then

   
	   insert 
	   into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp,cd_aut_usr,dt_aut_usr,cd_cnt,cd_cbf)
	     values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_investidor,ct_tipo_despesa_repasse_investidor,2,vl_a_repassar,current_date,current_date,3,'REF A REPASSE INVESTIDOR',1,now(),1,1,1,vl_a_repassar,1,now(),ct_conta_banco,ct_conta_bancaria_investidor);

	   update sc_aeo.tbl_eop 
	      set dt_rps_eop = now() 
	   where dt_vnc_eop <= current_date 
	     and dt_rps_eop is null;
   end if;  
     
end$$;


ALTER FUNCTION sc_aeo.repassar_investidor() OWNER TO scan;

--
-- TOC entry 1119 (class 1255 OID 564109)
-- Name: set_atributo_xml(character varying, character varying, numeric, character varying); Type: FUNCTION; Schema: sc_aeo; Owner: scan
--

CREATE FUNCTION set_atributo_xml(vp_nome character varying, vp_valor character varying, vp_tipo numeric, vp_arquivo character varying DEFAULT NULL::character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

vl_retorno varchar := '';

ct_tipo_atributo_abre_tag constant numeric := 1;
ct_tipo_atributo_fecha_tag constant numeric := 2;
ct_tipo_atributo_tag constant numeric := 3;

begin

  if vp_tipo in (ct_tipo_atributo_abre_tag,ct_tipo_atributo_tag) then
    vl_retorno := vl_retorno || '<' || lower(vp_nome) || '>';
  end if;

  if vp_tipo in (ct_tipo_atributo_tag) and not vp_valor is null then
    vl_retorno := vl_retorno || vp_valor;
  end if;

  if vp_tipo in (ct_tipo_atributo_fecha_tag,ct_tipo_atributo_tag) then
    vl_retorno := vl_retorno || '</' || lower(vp_nome) || '>';
  end if;

  if not vp_arquivo is null then
    perform sc_arq.gravarlinha(vp_arquivo, vl_retorno);
  end if;
  
  return vl_retorno;

end;$$;


ALTER FUNCTION sc_aeo.set_atributo_xml(vp_nome character varying, vp_valor character varying, vp_tipo numeric, vp_arquivo character varying) OWNER TO scan;

SET search_path = sc_analise, pg_catalog;

--
-- TOC entry 1806 (class 1255 OID 1667145)
-- Name: atualiza_cartoes(character varying); Type: FUNCTION; Schema: sc_analise; Owner: scan
--

CREATE FUNCTION atualiza_cartoes(vp_mes_referencia character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_data_inicial date;
  vl_data_final date;
  
  vl_mes integer;
  vl_ano integer;
  
  vl_mes_anterior integer;
  vl_ano_anterior integer;
  
  vl_qtde_mes_deposito integer;
  vl_qtde_reativacao integer;
  vl_ativo character;
  vl_data_ultimo_deposito timestamp without time zone;

  vl_qtde_deposito integer;
  vl_valor_deposito double precision;

  vl_rg record;

  CT_SITUACAO_DEPOSITADO constant integer := 5;
  CT_QTDE_DIAS_INATIVACAO constant integer := 35;
begin
  vl_data_inicial := to_date('01/' || vp_mes_referencia, 'dd/mm/yyyy');
  vl_data_final := (vl_data_inicial + interval '1 month')::date;

  vl_mes_anterior := trim(to_char(vl_data_inicial - interval '1 day', 'mm'))::integer;
  vl_ano_anterior := trim(to_char(vl_data_inicial - interval '1 day', 'yyyy'))::integer;

  for vl_rg in select cartao, qtde_mes_ativacao, qtde_reativacao, qtde_mes_deposito, ativo, data_ultimo_deposito
               from sc_analise.tbl_cartoes_mes
               where mes = vl_mes_anterior
                 and ano = vl_ano_anterior loop
               
    vl_mes := trim(to_char(vl_data_inicial, 'mm'))::integer;
    vl_ano := trim(to_char(vl_data_inicial, 'yyyy'))::integer;

    select count(*) as qtde, coalesce(sum(rdp.vl_dep_rdp), 0.0) as valor, max(hfe.dt_dps_hfe) as data_ultimo_deposito
      into vl_qtde_deposito, vl_valor_deposito, vl_data_ultimo_deposito
    from sc_opr.tbl_crt crt
         inner join sc_adp.tbl_rdp rdp on crt.cd_crt = rdp.cd_crt
         inner join sc_adp.tbl_hfe hfe on rdp.cd_hfe = hfe.cd_hfe
    where crt.dt_pri_dps_crt < vl_data_inicial
      and hfe.dt_dps_hfe >= vl_data_inicial
      and hfe.dt_dps_hfe < vl_data_final
      and rdp.st_rdp = CT_SITUACAO_DEPOSITADO
      and hfe.st_hfe = CT_SITUACAO_DEPOSITADO
      and crt.cd_crt = vl_rg.cartao;

    vl_ativo := vl_rg.ativo;
    vl_qtde_mes_deposito := vl_rg.qtde_mes_deposito;
    vl_qtde_reativacao := vl_rg.qtde_reativacao;
 
    if vl_qtde_deposito = 0 then
      vl_data_ultimo_deposito := vl_rg.data_ultimo_deposito;     
      if vl_data_final - vl_data_ultimo_deposito::date > CT_QTDE_DIAS_INATIVACAO then
        vl_ativo := 'N';
      end if;
    else
      vl_qtde_mes_deposito := vl_rg.qtde_mes_deposito + 1;
      if vl_ativo = 'N' then
        vl_ativo := 'S';
        vl_qtde_reativacao := vl_qtde_reativacao + 1;
      end if;
    end if;
    
    insert into sc_analise.tbl_cartoes_mes(cartao, mes, ano, qtde_mes_ativacao, qtde_reativacao, qtde_mes_deposito, qtde_deposito, valor_deposito, ativo, data_ultimo_deposito)
    values(vl_rg.cartao, vl_mes, vl_ano, vl_rg.qtde_mes_ativacao + 1, vl_qtde_reativacao, vl_qtde_mes_deposito, vl_qtde_deposito, vl_valor_deposito, vl_ativo, vl_data_ultimo_deposito);
  end loop;
end;$$;


ALTER FUNCTION sc_analise.atualiza_cartoes(vp_mes_referencia character varying) OWNER TO scan;

--
-- TOC entry 7616 (class 0 OID 0)
-- Dependencies: 1806
-- Name: FUNCTION atualiza_cartoes(vp_mes_referencia character varying); Type: COMMENT; Schema: sc_analise; Owner: scan
--

COMMENT ON FUNCTION atualiza_cartoes(vp_mes_referencia character varying) IS 'rotina que atualiza as informacoes dos cartoes que ja tiveram o primeiro deposito';


--
-- TOC entry 1802 (class 1255 OID 1667141)
-- Name: inclui_novos_cartoes(character varying); Type: FUNCTION; Schema: sc_analise; Owner: scan
--

CREATE FUNCTION inclui_novos_cartoes(vp_mes_referencia character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_data_inicial date;
  vl_data_final date;
  vl_mes integer;
  vl_ano integer;

  vl_rg record;

  CT_SITUACAO_DEPOSITADO constant integer := 5;
begin
  vl_data_inicial := to_date('01/' || vp_mes_referencia, 'dd/mm/yyyy');
  vl_data_final := (vl_data_inicial + interval '1 month')::date;

  for vl_rg in select crt.cd_crt, count(*) as qtde, sum(rdp.vl_dep_rdp) as valor, max(hfe.dt_dps_hfe) as data_ultimo_deposito
               from sc_opr.tbl_crt crt
                    inner join sc_adp.tbl_rdp rdp on crt.cd_crt = rdp.cd_crt
                    inner join sc_adp.tbl_hfe hfe on rdp.cd_hfe = hfe.cd_hfe
               where crt.dt_pri_dps_crt >= vl_data_inicial
                 and crt.dt_pri_dps_crt < vl_data_final
                 and hfe.dt_dps_hfe >= vl_data_inicial
                 and hfe.dt_dps_hfe < vl_data_final
                 and rdp.st_rdp = CT_SITUACAO_DEPOSITADO
                 and hfe.st_hfe = CT_SITUACAO_DEPOSITADO
               group by crt.cd_crt loop
               
    vl_mes := trim(to_char(vl_data_inicial, 'mm'))::integer;
    vl_ano := trim(to_char(vl_data_inicial, 'yyyy'))::integer;
    
    delete from sc_analise.tbl_cartoes_mes 
    where cartao = vl_rg.cd_crt 
      and mes = vl_mes 
      and ano = vl_ano;

    insert into sc_analise.tbl_cartoes_mes(cartao, mes, ano, qtde_mes_ativacao, qtde_reativacao, qtde_mes_deposito, qtde_deposito, valor_deposito, ativo, data_ultimo_deposito)
    values(vl_rg.cd_crt, vl_mes, vl_ano, 1, 0, 1, vl_rg.qtde, vl_rg.valor, 'S', vl_rg.data_ultimo_deposito);
  end loop;
end;$$;


ALTER FUNCTION sc_analise.inclui_novos_cartoes(vp_mes_referencia character varying) OWNER TO scan;

--
-- TOC entry 7617 (class 0 OID 0)
-- Dependencies: 1802
-- Name: FUNCTION inclui_novos_cartoes(vp_mes_referencia character varying); Type: COMMENT; Schema: sc_analise; Owner: scan
--

COMMENT ON FUNCTION inclui_novos_cartoes(vp_mes_referencia character varying) IS 'rotina que insere os cartoes que tiveram o primeiro deposito na data passada como parâmetro';


--
-- TOC entry 1804 (class 1255 OID 1667146)
-- Name: processa_mes(character varying); Type: FUNCTION; Schema: sc_analise; Owner: scan
--

CREATE FUNCTION processa_mes(vp_mes_referencia character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin
  perform sc_analise.inclui_novos_cartoes(vp_mes_referencia);
  perform sc_analise.atualiza_cartoes(vp_mes_referencia);
end;$$;


ALTER FUNCTION sc_analise.processa_mes(vp_mes_referencia character varying) OWNER TO scan;

--
-- TOC entry 7618 (class 0 OID 0)
-- Dependencies: 1804
-- Name: FUNCTION processa_mes(vp_mes_referencia character varying); Type: COMMENT; Schema: sc_analise; Owner: scan
--

COMMENT ON FUNCTION processa_mes(vp_mes_referencia character varying) IS 'rotina que gera os registros dos cartões que tiveram o primeiro deposito no mês passado como parâmetro, bem como atualizar os cartões que tiveram deposito nos meses anteriores';


--
-- TOC entry 1808 (class 1255 OID 1667148)
-- Name: processa_periodo(character varying, character varying); Type: FUNCTION; Schema: sc_analise; Owner: scan
--

CREATE FUNCTION processa_periodo(vp_mes_ref_inicial character varying, vp_mes_ref_final character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_data_inicial date;
  vl_data_final date;
begin
  vl_data_inicial := to_date('01/' || vp_mes_ref_inicial, 'dd/mm/yyyy');
  vl_data_final := to_date('01/' || vp_mes_ref_final, 'dd/mm/yyyy');

  while vl_data_inicial <= vl_data_final loop
    perform sc_analise.processa_mes(to_char(vl_data_inicial, 'mm/yyyy'));
    vl_data_inicial := vl_data_inicial + interval '1 month';
  end loop;
end;$$;


ALTER FUNCTION sc_analise.processa_periodo(vp_mes_ref_inicial character varying, vp_mes_ref_final character varying) OWNER TO scan;

--
-- TOC entry 7619 (class 0 OID 0)
-- Dependencies: 1808
-- Name: FUNCTION processa_periodo(vp_mes_ref_inicial character varying, vp_mes_ref_final character varying); Type: COMMENT; Schema: sc_analise; Owner: scan
--

COMMENT ON FUNCTION processa_periodo(vp_mes_ref_inicial character varying, vp_mes_ref_final character varying) IS 'rotina que gera processa todos os meses compreendidos no período informado';


SET search_path = sc_arq, pg_catalog;

--
-- TOC entry 1633 (class 1255 OID 1632745)
-- Name: criardiretorio(character varying); Type: FUNCTION; Schema: sc_arq; Owner: scan
--

CREATE FUNCTION criardiretorio(character varying) RETURNS void
    LANGUAGE javau
    AS $$br.com.aptare.a2pg.Arquivo.criarDiretorio$$;


ALTER FUNCTION sc_arq.criardiretorio(character varying) OWNER TO scan;

--
-- TOC entry 1120 (class 1255 OID 564110)
-- Name: excluirarquivo(character varying); Type: FUNCTION; Schema: sc_arq; Owner: scan
--

CREATE FUNCTION excluirarquivo(character varying) RETURNS void
    LANGUAGE javau
    AS $$br.com.aptare.a2pg.Arquivo.excluirArquivo$$;


ALTER FUNCTION sc_arq.excluirarquivo(character varying) OWNER TO scan;

--
-- TOC entry 1121 (class 1255 OID 564111)
-- Name: formatar_moeda(integer, numeric); Type: FUNCTION; Schema: sc_arq; Owner: scan
--

CREATE FUNCTION formatar_moeda(vp_tamanho integer, vp_valor numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

    AUX text;
    AUX_VALOR varchar;
    NUMERO NUMERIC(15,2);
begin

    IF VP_VALOR IS NULL THEN
      NUMERO := 0;
    ELSE
      NUMERO := VP_VALOR * 100;
    END IF;
	
    AUX_VALOR := TRUNC(NUMERO)::text;
    AUX := sc_arq.preencher(vp_tamanho, AUX_VALOR, '0', 2);
	
    RETURN AUX;

end$$;


ALTER FUNCTION sc_arq.formatar_moeda(vp_tamanho integer, vp_valor numeric) OWNER TO scan;

--
-- TOC entry 1128 (class 1255 OID 564112)
-- Name: formatar_moeda(numeric, integer, integer, character varying); Type: FUNCTION; Schema: sc_arq; Owner: scan
--

CREATE FUNCTION formatar_moeda(vp_valor numeric, vp_parte_inteira integer, vp_parte_decimal integer, vp_separador character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

    AUX text;
    AUX_VALOR varchar;
    NUMERO NUMERIC(15,2);
begin
    IF VP_VALOR IS NULL THEN
      NUMERO := 0;
    ELSE
      NUMERO := VP_VALOR * power(10, vp_parte_decimal);
    END IF;
	
    AUX_VALOR := TRUNC(NUMERO)::text;
    AUX := sc_arq.preencher(vp_parte_inteira + vp_parte_decimal, AUX_VALOR, '0', 2);

    AUX := SUBSTR(AUX, 1, vp_parte_inteira) || vp_separador || SUBSTR(AUX, vp_parte_inteira + 1);
    
    RETURN AUX;

end$$;


ALTER FUNCTION sc_arq.formatar_moeda(vp_valor numeric, vp_parte_inteira integer, vp_parte_decimal integer, vp_separador character varying) OWNER TO scan;

--
-- TOC entry 1129 (class 1255 OID 564113)
-- Name: formatar_moeda(numeric, integer, integer, character varying, character varying); Type: FUNCTION; Schema: sc_arq; Owner: scan
--

CREATE FUNCTION formatar_moeda(vp_valor numeric, vp_parte_inteira integer, vp_parte_decimal integer, vp_separador character varying, vp_caracter_preecher character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

    AUX text;
    AUX_VALOR varchar;
    NUMERO NUMERIC(15,2);
begin
    IF VP_VALOR IS NULL THEN
      NUMERO := 0;
    ELSE
      NUMERO := VP_VALOR * power(10, vp_parte_decimal);
    END IF;
	
    AUX_VALOR := TRUNC(NUMERO)::text;
    AUX := sc_arq.preencher(vp_parte_inteira + vp_parte_decimal, AUX_VALOR, vp_caracter_preecher, 2);

    AUX := SUBSTR(AUX, 1, vp_parte_inteira) || vp_separador || SUBSTR(AUX, vp_parte_inteira + 1);
    
    RETURN AUX;

end$$;


ALTER FUNCTION sc_arq.formatar_moeda(vp_valor numeric, vp_parte_inteira integer, vp_parte_decimal integer, vp_separador character varying, vp_caracter_preecher character varying) OWNER TO scan;

--
-- TOC entry 1130 (class 1255 OID 564114)
-- Name: gravarlinha(character varying, character varying); Type: FUNCTION; Schema: sc_arq; Owner: scan
--

CREATE FUNCTION gravarlinha(character varying, character varying) RETURNS void
    LANGUAGE javau
    AS $$br.com.aptare.a2pg.Arquivo.gravarLinha$$;


ALTER FUNCTION sc_arq.gravarlinha(character varying, character varying) OWNER TO scan;

--
-- TOC entry 1730 (class 1255 OID 564115)
-- Name: preencher(integer, numeric, character varying, numeric); Type: FUNCTION; Schema: sc_arq; Owner: scan
--

CREATE FUNCTION preencher(vp_tamanho integer, vp_valor numeric, vp_character character varying, vp_alinhamento numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

    AUX text;
    NUMERO_BRANCOS NUMERIC(10,0);
begin


    IF VP_VALOR IS NULL THEN
      AUX := VP_CHARACTER;
    ELSE
      AUX := VP_VALOR;
    END IF;
    CASE vp_alinhamento
      WHEN 1 THEN
        AUX := RPAD(AUX::text,vp_tamanho::integer,vp_character::text);
      WHEN 2 THEN
        AUX := LPAD(AUX::text,vp_tamanho::integer,vp_character::text);
      WHEN 3 THEN
        NUMERO_BRANCOS := vp_tamanho - LENGTH(vp_valor);
        IF NUMERO_BRANCOS > 0 THEN
          AUX := sc_arq.REPETIR(VP_CHARACTER, TRUNC(NUMERO_BRANCOS/2)) || VP_VALOR ||
                 sc_arq.REPETIR(VP_CHARACTER, NUMERO_BRANCOS - TRUNC(NUMERO_BRANCOS/2));
        ELSE
          AUX := SUBSTR(VP_VALOR, 1, VP_TAMANHO);
        END IF;
    END CASE;
    
    RETURN AUX;

end$$;


ALTER FUNCTION sc_arq.preencher(vp_tamanho integer, vp_valor numeric, vp_character character varying, vp_alinhamento numeric) OWNER TO scan;

--
-- TOC entry 1143 (class 1255 OID 564116)
-- Name: preencher(integer, character varying, character varying, numeric); Type: FUNCTION; Schema: sc_arq; Owner: scan
--

CREATE FUNCTION preencher(vp_tamanho integer, vp_valor character varying, vp_character character varying, vp_alinhamento numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

    AUX text;
    NUMERO_BRANCOS NUMERIC(10,0);
begin


    IF VP_VALOR IS NULL THEN
      AUX := VP_CHARACTER;
    ELSE
      AUX := VP_VALOR;
    END IF;
    CASE vp_alinhamento
      WHEN 1 THEN
        AUX := RPAD(AUX::text,vp_tamanho::integer,vp_character::text);
      WHEN 2 THEN
        AUX := LPAD(AUX::text,vp_tamanho::integer,vp_character::text);
      WHEN 3 THEN
        NUMERO_BRANCOS := vp_tamanho - LENGTH(vp_valor);
        IF NUMERO_BRANCOS > 0 THEN
          AUX := sc_arq.REPETIR(VP_CHARACTER, TRUNC(NUMERO_BRANCOS/2)) || VP_VALOR ||
                 sc_arq.REPETIR(VP_CHARACTER, NUMERO_BRANCOS - TRUNC(NUMERO_BRANCOS/2));
        ELSE
          AUX := SUBSTR(VP_VALOR, 1, VP_TAMANHO);
        END IF;
    END CASE;
    
    RETURN AUX;

end$$;


ALTER FUNCTION sc_arq.preencher(vp_tamanho integer, vp_valor character varying, vp_character character varying, vp_alinhamento numeric) OWNER TO scan;

--
-- TOC entry 1137 (class 1255 OID 564117)
-- Name: repetir(character varying, numeric); Type: FUNCTION; Schema: sc_arq; Owner: scan
--

CREATE FUNCTION repetir(vp_valor character varying, vp_tamanho numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
begin
  return repeat(vp_valor,vp_tamanho::integer);
  end$$;


ALTER FUNCTION sc_arq.repetir(vp_valor character varying, vp_tamanho numeric) OWNER TO scan;

SET search_path = sc_atb, pg_catalog;

--
-- TOC entry 1857 (class 1255 OID 1657040)
-- Name: atualiza_qtde_ted_abonadas(date); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION atualiza_qtde_ted_abonadas(vp_data_inicial_transferencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;

  CT_SITUACAO_CANCELADO constant integer := 3;
  CT_SITUACAO_REJEITADO constant integer := 6;
begin
  for vl_rg in select crt.cd_crt, sum(case when tba.cd_tba is null then 0 else 1 end) as qtde_correta, crt.qtd_abn_trf_crt as qtde_atual
               from sc_opr.tbl_crt crt
                    inner join sc_opr.tbl_cnt_crt cnt_crt on crt.cd_crt = cnt_crt.cd_crt
                    left join sc_atb.tbl_tba tba on cnt_crt.cd_cnt = tba.cd_dbt_cnt and tba.dt_inc_usr >= vp_data_inicial_transferencia
               where (tba.dt_inc_usr is null or tba.dt_inc_usr >= vp_data_inicial_transferencia)
                 and (tba.st_tba is null or tba.st_tba not in (CT_SITUACAO_CANCELADO, CT_SITUACAO_REJEITADO)) --Não podem estar com as situações: CANCELADO ou REJEITADO
               group by crt.cd_crt, crt.qtd_abn_trf_crt
               having sum(case when tba.cd_tba is null then 0 else 1 end) <> crt.qtd_abn_trf_crt
               limit 1000 loop
               
    raise notice 'atualizando o cartao: %, quantidade atual: %, quantidade correta: %', vl_rg.cd_crt, vl_rg.qtde_atual, vl_rg.qtde_correta;
    update sc_opr.tbl_crt set qtd_abn_trf_crt = vl_rg.qtde_correta where cd_crt = vl_rg.cd_crt;
  end loop;
end;$$;


ALTER FUNCTION sc_atb.atualiza_qtde_ted_abonadas(vp_data_inicial_transferencia date) OWNER TO scan;

--
-- TOC entry 1530 (class 1255 OID 564118)
-- Name: cancela_transferencia(numeric, character varying, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION cancela_transferencia(vp_codigo_detalhe_transferencia numeric, vp_motivo_cancelamento character varying, vp_codigo_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  
  ct_st_enviado constant numeric := 4;
  ct_st_depositado constant numeric := 5;
  
  ct_st_dtb_rejeitado constant numeric := 4;
  
  vl_codigo_usuario numeric;
    
  vl_rg record;
begin

  --definindo o usuario de cancelamento
  if vp_codigo_usuario is not null then
    vl_codigo_usuario := vp_codigo_usuario; 
  else
    select vl_prm
      into vl_codigo_usuario
    from sc_cad.tbl_prm prm
    where nm_prm = 'USUARIO_ARQUIVO_RETORNO_TRANSFERENCIA';
  end if;


  -- cancelando as transferencias 
  for vl_rg in select cd_tba
	     from sc_atb.tbl_tba
	     where cd_dtb = vp_codigo_detalhe_transferencia
	       and st_tba in (ct_st_enviado,ct_st_depositado) loop


      perform sc_atb.cancela_transferencia_bancaria(vl_rg.cd_tba, vp_motivo_cancelamento, vl_codigo_usuario);	       
  
  end loop;
  
  -- atualizando o detalhe do arquivo de transferencia
  update sc_atb.tbl_dtb
       set st_dtb = ct_st_dtb_rejeitado
  where cd_dtb = vp_codigo_detalhe_transferencia;
end;$$;


ALTER FUNCTION sc_atb.cancela_transferencia(vp_codigo_detalhe_transferencia numeric, vp_motivo_cancelamento character varying, vp_codigo_usuario numeric) OWNER TO scan;

--
-- TOC entry 7620 (class 0 OID 0)
-- Dependencies: 1530
-- Name: FUNCTION cancela_transferencia(vp_codigo_detalhe_transferencia numeric, vp_motivo_cancelamento character varying, vp_codigo_usuario numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION cancela_transferencia(vp_codigo_detalhe_transferencia numeric, vp_motivo_cancelamento character varying, vp_codigo_usuario numeric) IS 'rotina que cancela todas as transferencias vinculadas a um detalhe do arquivo de transferencia';


--
-- TOC entry 1545 (class 1255 OID 868181)
-- Name: cancela_transferencia_bancaria(numeric, character varying, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION cancela_transferencia_bancaria(vp_codigo numeric, vp_motivo_cancelamento character varying, vp_codigo_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  ct_st_rejeitado constant numeric := 6;
  ct_st_gerado constant numeric := 1;
  ct_st_cancelado constant numeric := 3;
  ct_st_enviado constant numeric := 4;
  ct_st_depositado constant numeric := 5;
  ct_codigo_sistema constant numeric := 11; -- sitema de transferencia

  vl_codigo_conta_debito numeric;
  vl_codigo_conta_credito numeric;
  vl_valor numeric;
  vl_situacao numeric;
  vl_situacao_final numeric;
  vl_tarifa numeric;
  vl_contrato numeric;
  vl_filial numeric;
  vl_cartao numeric;

  vl_banco numeric;
  vl_agencia numeric;
  vl_conta numeric;
  vl_dig_conta varchar;
  
  vl_tipo_lancamento_transferencia numeric;
  vl_tipo_lancamento_est_transferencia numeric;
  vl_conta_tarifa_transferencia numeric;
  vl_tipo_pagamento_tarifa numeric;
  vl_quantidade_abono_contrato numeric;
  vl_quantidade_abono_cartao numeric;
  
begin

   -- retornando a situacao da transferencia e a conta de credito
   select st_tba, cd_dbt_cnt, vl_trf_tba, vl_tba, cd_bnc, nr_agc_tba, nr_cba_tba, nr_dgt_cba_tba
     into vl_situacao, vl_codigo_conta_credito, vl_tarifa, vl_valor, vl_banco, vl_agencia, vl_conta, vl_dig_conta
   from sc_atb.tbl_tba
   where cd_tba = vp_codigo;  

   if vl_situacao = ct_st_gerado then

     select vl_prm
       into vl_codigo_conta_debito
     from sc_cad.tbl_prm prm
     where nm_prm = 'CONTA_TRANSFERENCIA';

    vl_situacao_final := ct_st_cancelado;
 
   end if;

   if vl_situacao in (ct_st_enviado, ct_st_depositado) then

     select ccr.cd_cnt
       into vl_codigo_conta_debito
     from sc_fin.tbl_ccr ccr
       inner join sc_atb.tbl_tba tba on ccr.cd_ccr = tba.cd_ccr
     where tba.cd_tba = vp_codigo;

     vl_situacao_final := ct_st_rejeitado;
  
   end if;

   -- obtendo o tipo de lancamento de transferencia
   select vl_prm
     into vl_tipo_lancamento_transferencia
   from sc_cad.tbl_prm prm
   where nm_prm = 'TIPO_LANCAMENTO_TRANSFERENCIA';

   --obtendo o tipo de lancamento de estorno de transferencia
   select cd_est_tlc
     into vl_tipo_lancamento_est_transferencia
   from sc_cnt.tbl_tlc
   where cd_tlc = vl_tipo_lancamento_transferencia;
  
   -- obtendo a conta de tarifa de transferencia
   vl_conta_tarifa_transferencia := 468;

   -- caso seja uma transferencia de cartao obter contrato e filial
   select crt.cd_ctr, fnc.cd_fem, coalesce(crt.qtd_abn_trf_crt,0), crt.cd_crt
     into vl_contrato, vl_filial, vl_quantidade_abono_cartao, vl_cartao
   from sc_opr.tbl_cnt_crt cc
     inner join sc_opr.tbl_crt crt on crt.cd_crt = cc.cd_crt
     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
   where cc.cd_cnt = vl_codigo_conta_credito;

   vl_contrato := coalesce(vl_contrato,0);
	  
   -- inserir lancamento de estorno de transferencia

   vp_motivo_cancelamento := vp_motivo_cancelamento || ' \n(BC: ' || vl_banco || ' AG: ' || vl_agencia || ' CC: ' || vl_conta || '-' || vl_dig_conta || ')';
   
   perform sc_cnt.lancar_debito_credito(vl_codigo_conta_debito, vl_codigo_conta_credito, vl_tipo_lancamento_est_transferencia,
                                         null, vp_motivo_cancelamento, vl_valor, now()::timestamp without time zone,
                                         vp_codigo_usuario, ct_codigo_sistema, vp_codigo);

    -- inserir lancamento de estorno da tarifa
    if vl_contrato > 0 then

      vl_quantidade_abono_contrato := sc_cad.get_parametro_contrato(30,vl_contrato,vl_filial)::numeric;

      if vl_situacao in (ct_st_gerado, ct_st_enviado) and vl_quantidade_abono_contrato > 0 and vl_quantidade_abono_cartao > 0 then
	    
           update sc_opr.tbl_crt 
	   set qtd_abn_trf_crt = qtd_abn_trf_crt - 1 
	   where cd_crt = vl_cartao;
      
      end if;

      vl_tipo_pagamento_tarifa := sc_cad.get_parametro_contrato(11,vl_contrato,vl_filial,3)::numeric;

      if vl_tipo_pagamento_tarifa = 1 then -- pago pela empresa

         if vl_situacao in (ct_st_gerado, ct_st_enviado) then

           update sc_atb.tbl_etb set fg_cbr_etb = 'N' where cd_tba = vp_codigo;

         end if;
      
      else  --pago pelo funcionario

         if vl_tarifa > 0 and vl_situacao in (ct_st_gerado, ct_st_enviado) then
             perform sc_cnt.lancar_debito_credito(vl_conta_tarifa_transferencia, vl_codigo_conta_credito, vl_tipo_lancamento_est_transferencia,
                                           null, vp_motivo_cancelamento, vl_tarifa, now()::timestamp without time zone,
                                           vp_codigo_usuario, ct_codigo_sistema, vp_codigo);
         end if;
                                           
      end if;
      
    end if;
   
    -- atualizando a situacao da transferencia
    update sc_atb.tbl_tba 
       set st_tba = vl_situacao_final,
           dt_rjc_tba = now(),
           ds_mtv_rjc_tba = vp_motivo_cancelamento
    where cd_tba = vp_codigo;
  
  
end;$$;


ALTER FUNCTION sc_atb.cancela_transferencia_bancaria(vp_codigo numeric, vp_motivo_cancelamento character varying, vp_codigo_usuario numeric) OWNER TO scan;

--
-- TOC entry 7621 (class 0 OID 0)
-- Dependencies: 1545
-- Name: FUNCTION cancela_transferencia_bancaria(vp_codigo numeric, vp_motivo_cancelamento character varying, vp_codigo_usuario numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION cancela_transferencia_bancaria(vp_codigo numeric, vp_motivo_cancelamento character varying, vp_codigo_usuario numeric) IS 'rotina que uma transferencia bancaria';


--
-- TOC entry 1145 (class 1255 OID 564119)
-- Name: confirma_transferencia(numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION confirma_transferencia(vp_codigo_detalhe_transferencia numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  ct_st_depositado constant numeric := 5;
  ct_st_enviado constant numeric := 4;

  ct_st_dtb_depositado constant numeric := 3;
begin
  update sc_atb.tbl_tba 
     set st_tba = ct_st_depositado,
         dt_dps_tba = now()
  where cd_dtb = vp_codigo_detalhe_transferencia
    and st_tba = ct_st_enviado;

  update sc_atb.tbl_dtb
     set st_dtb = ct_st_dtb_depositado
  where cd_dtb = vp_codigo_detalhe_transferencia;
end;$$;


ALTER FUNCTION sc_atb.confirma_transferencia(vp_codigo_detalhe_transferencia numeric) OWNER TO scan;

--
-- TOC entry 7622 (class 0 OID 0)
-- Dependencies: 1145
-- Name: FUNCTION confirma_transferencia(vp_codigo_detalhe_transferencia numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION confirma_transferencia(vp_codigo_detalhe_transferencia numeric) IS 'rotina que confirma todas as transferencia vinculadas a um determinado detalhe do arquivo de transferencia';


--
-- TOC entry 1146 (class 1255 OID 564120)
-- Name: estorno_transferencia(); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION estorno_transferencia() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg_lcn record;

begin
  for rg_lcn in select cnt.nm_cnt, lcn.*
                from sc_cnt.tbl_lcn lcn
                  inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = lcn.cd_cnt
		  inner join (
			      select max(lcn.cd_lcn) as lancamento, cnt.nm_cnt as nome
			      from sc_adp.tbl_rdp rdp
			        inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = rdp.cd_crt
				inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
				inner join sc_cnt.tbl_lcn lcn on lcn.cd_cnt = cnt.cd_cnt
			      where rdp.cd_hfe = 13545
				and lcn.dt_inc_usr::date = current_date
				and lcn.cd_tlc = 93
			      group by cnt.nm_cnt) as lll on lll.lancamento = lcn.cd_lcn loop

    perform sc_cnt.lancar_debito_credito(5751, rg_lcn.cd_cnt, 92, null, 'ESTORNO DE TRANSFERENCIA', rg_lcn.vl_lcn, current_timestamp::timestamp without time zone, 3, rg_lcn.cd_sst, rg_lcn.nsu_lcn);
    
  end loop;
end;$$;


ALTER FUNCTION sc_atb.estorno_transferencia() OWNER TO scan;

--
-- TOC entry 220 (class 1259 OID 564121)
-- Name: tbl_dtb; Type: TABLE; Schema: sc_atb; Owner: scan
--

CREATE TABLE tbl_dtb (
    cd_dtb numeric(20,0) NOT NULL,
    cd_atb numeric(10,0) NOT NULL,
    cd_bnc numeric(5,0) NOT NULL,
    nr_agc_dtb numeric(20,0) NOT NULL,
    nr_dgt_agc_dtb character varying(1) NOT NULL,
    nr_cba_dtb numeric(20,0) NOT NULL,
    nr_dgt_cba_dtb character varying(2) NOT NULL,
    tp_cba_dtb numeric(2,0) NOT NULL,
    nr_cpf_cnpj_dtb numeric(14,0) NOT NULL,
    tp_pss_dtb character(1) NOT NULL,
    nm_dtb character varying(100) NOT NULL,
    st_dtb numeric(2,0) NOT NULL,
    vl_dtb numeric(13,2) NOT NULL,
    CONSTRAINT ck_tp_pss_dtb CHECK ((tp_pss_dtb = ANY (ARRAY['F'::bpchar, 'J'::bpchar])))
);


ALTER TABLE tbl_dtb OWNER TO scan;

--
-- TOC entry 7623 (class 0 OID 0)
-- Dependencies: 220
-- Name: TABLE tbl_dtb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON TABLE tbl_dtb IS 'tabela de detalhe do arquivo de transferencia bancaria';


--
-- TOC entry 7624 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.cd_dtb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.cd_dtb IS 'codigo';


--
-- TOC entry 7625 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.cd_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.cd_atb IS 'arquivo';


--
-- TOC entry 7626 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.cd_bnc; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.cd_bnc IS 'banco';


--
-- TOC entry 7627 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.nr_agc_dtb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.nr_agc_dtb IS 'numero da agencia';


--
-- TOC entry 7628 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.nr_dgt_agc_dtb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.nr_dgt_agc_dtb IS 'numero do digito da agencia';


--
-- TOC entry 7629 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.nr_cba_dtb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.nr_cba_dtb IS 'numero da conta bancaria';


--
-- TOC entry 7630 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.nr_dgt_cba_dtb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.nr_dgt_cba_dtb IS 'numero do digito da conta bancaria';


--
-- TOC entry 7631 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.tp_cba_dtb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.tp_cba_dtb IS 'tipo de conta bancaria (ver tabela de dominio)';


--
-- TOC entry 7632 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.nr_cpf_cnpj_dtb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.nr_cpf_cnpj_dtb IS 'numero do cpf/cnpj do titular da conta';


--
-- TOC entry 7633 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.tp_pss_dtb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.tp_pss_dtb IS 'tipo de pessoa do titular da conta bancaria';


--
-- TOC entry 7634 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.nm_dtb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.nm_dtb IS 'nome do titular da conta bancaria';


--
-- TOC entry 7635 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.st_dtb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.st_dtb IS 'situacao (ver tabela de dominio)';


--
-- TOC entry 7636 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN tbl_dtb.vl_dtb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_dtb.vl_dtb IS 'valor';


--
-- TOC entry 1183 (class 1255 OID 564125)
-- Name: gera_detalhe_a_arquivo_hsbc(tbl_dtb, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION gera_detalhe_a_arquivo_hsbc(vp_detalhe_transferencia tbl_dtb, vp_numero_lote numeric, vp_sequencia_registro numeric, vp_tipo_transferencia numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$declare
  vl_linha varchar;
  vl_aux VarCHar;

  vl_conta_corrente varchar;

  --constantes
  ct_ted constant numeric := 1;
  ct_doc constant numeric := 2;
  ct_tipo_conta_facil_caixa numeric := 3;
  
begin
  --campo 01: banco
  vl_linha := '399';
  
  --campo 02: lote
  vl_linha := vl_linha || trim(to_char(vp_numero_lote, repeat('0', 4)));

  --campo 03: tipo de registro
  vl_linha := vl_linha || '3';
  
  --campo 04: numero sequencial do registro dentro do lote
  vl_linha := vl_linha || trim(to_char(vp_sequencia_registro, repeat('0', 5)));
  
  --campo 05: codigo de segmento do registro
  vl_linha := vl_linha || 'A';

  --campo 06: tipo de movimento (5 - inclusao com bloqueio)
  vl_linha := vl_linha || '0';
    
  --campo 07: código de instrucao por motivo (55 - inclusao com bloqueio)
  vl_linha := vl_linha || '00';

  --campo 08: Codigo da camara de compensacao
  if vp_tipo_transferencia = ct_ted then
    vl_linha := vl_linha || '018';
  else
    vl_linha := vl_linha || '700';
  end if;

  --campo 09: codigo do banco favorecido
  vl_linha := vl_linha || trim(to_char(vp_detalhe_transferencia.cd_bnc, repeat('0', 3)));
  
  --campo 10: codigo da agencia favorecido
  vl_linha := vl_linha || trim(to_char(vp_detalhe_transferencia.nr_agc_dtb, repeat('0', 5)));

  --campo 11: Filler
  vl_linha := vl_linha || repeat(' ', 1);
  
  --campo 12: numero da conta corrente

  -- se cliente possui conta facil caixa
  if vp_detalhe_transferencia.tp_cba_dtb = ct_tipo_conta_facil_caixa then
    vl_conta_corrente := '23' || vp_detalhe_transferencia.nr_cba_dtb;
  else
    vl_conta_corrente := vp_detalhe_transferencia.nr_cba_dtb;
  end if;
  
  vl_linha := vl_linha || trim(to_char(vl_conta_corrente::numeric, repeat('0', 13 - length(vp_detalhe_transferencia.nr_dgt_cba_dtb))));
  
  --campo 13: digito verificador da conta corrente
  vl_linha := vl_linha || upper(vp_detalhe_transferencia.nr_dgt_cba_dtb);

  --campo 14: filler
  vl_linha := vl_linha || repeat(' ', 1);

  --campo 15: Nome do favorecido
  if length(vp_detalhe_transferencia.nm_dtb) >= 30 then
    vl_linha := vl_linha || substr(vp_detalhe_transferencia.nm_dtb, 1, 30);
  else
    vl_linha := vl_linha || vp_detalhe_transferencia.nm_dtb || repeat(' ', 30 - length(vp_detalhe_transferencia.nm_dtb));
  end if;

  --campo 16: numero do documento atribuido
  vl_linha := vl_linha || trim(to_char(vp_detalhe_transferencia.cd_dtb, repeat('0', 16)));

  --campo 17: Filler
  vl_linha := vl_linha || repeat(' ', 4);
  
  --campo 18: data do lanCamento do Credito
  vl_linha := vl_linha || to_char(current_date, 'DDMMYYYY');
  
  --campo 19: tipo de moeda
  vl_linha := vl_linha || 'R$ ';

  --campo 20: Filler
  vl_linha := vl_linha || repeat(' ', 17);
  
  --campo 21: Valor do lanCamento
  vl_aux := trim(to_char(vp_detalhe_transferencia.vl_dtb, repeat('0', 11) || 'D' || repeat('0', 2)));
  vl_aux := replace(replace(vl_aux, ',', ''), '.', '');
  vl_linha := vl_linha || vl_aux;

  --campo 22: ComproVante de pagamento - emissao indiVidual
  vl_linha := vl_linha || 'S';
  
  --campo 23: pagador efetiVo
  vl_linha := vl_linha || repeat(' ', 30);
  
  --campo 24: Filler
  vl_linha := vl_linha || repeat(' ', 12);

  --campo 25: outras informaCoes
  vl_linha := vl_linha || repeat(' ', 40);

  --campo 26: Filler
  vl_linha := vl_linha || repeat(' ', 12);
  
  --campo 27: aViso ao faVoreCido
  vl_linha := vl_linha || '0';

  --campo 28: filler
  vl_linha := vl_linha || repeat(' ', 10);

  return vl_linha;
end;$_$;


ALTER FUNCTION sc_atb.gera_detalhe_a_arquivo_hsbc(vp_detalhe_transferencia tbl_dtb, vp_numero_lote numeric, vp_sequencia_registro numeric, vp_tipo_transferencia numeric) OWNER TO scan;

--
-- TOC entry 7637 (class 0 OID 0)
-- Dependencies: 1183
-- Name: FUNCTION gera_detalhe_a_arquivo_hsbc(vp_detalhe_transferencia tbl_dtb, vp_numero_lote numeric, vp_sequencia_registro numeric, vp_tipo_transferencia numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION gera_detalhe_a_arquivo_hsbc(vp_detalhe_transferencia tbl_dtb, vp_numero_lote numeric, vp_sequencia_registro numeric, vp_tipo_transferencia numeric) IS 'rotina responsavel por gerar a linha de detalhe de segmento "A" do lote do arquivo de transferencia do HSBC';


--
-- TOC entry 1844 (class 1255 OID 1635250)
-- Name: gera_detalhe_arquivo_bradesco(numeric, character varying, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION gera_detalhe_arquivo_bradesco(vp_codigo_arquivo numeric, vp_nome_arquivo character varying, vp_codigo_conta_corrente numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_linha varchar;

  vl_tipo_transferencia numeric;

  vl_qtde_registros_arquivo numeric;
    
  ct_tipo_transf_ted constant numeric := 1;
  ct_tipo_transf_doc constant numeric := 2;

  ct_situacao_autorizado constant numeric := 2;
  ct_situacao_enviado constant numeric := 4;
  ct_banco_bradesco numeric := 237;

  vl_qtd_transferencia numeric;
  vl_qtd_ted numeric;
  vl_qtd_doc numeric;

  vl_mod_pagamento numeric;

  ct_valor_min_ted numeric := 0;

  vl_cpf_cnpj varchar;
  vl_complemento_pagamento varchar;

  vl_rg_dtb record;

  ct_cod_bradesco numeric := 237;

  vl_digito_agencia varchar;

  ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
  ALINHAMENTO_A_DIREITA numeric(2,0) := 1;  
  
begin

        vl_qtde_registros_arquivo := 1;
        vl_qtd_transferencia := 0;
        vl_qtd_ted := 0;
        vl_qtd_doc := 0;

	for vl_rg_dtb in select tba.cd_dtb as codigo, tba.cd_bnc, tba.nr_agc_tba, tba.nr_dgt_agc_tba, 
				tba.nr_cba_tba, tba.nr_dgt_cba_tba, tba.tp_cba_tba, tba.nr_cpf_cnpj_tba, tba.tp_pss_tba, tba.nm_tba, 
				2 as situacao, ccr.cd_cnt_ccr, sum(tba.vl_tba) as valor
			 from sc_atb.tbl_tba tba
			   inner join sc_fin.tbl_ccr ccr on ccr.cd_ccr = tba.cd_ccr
				 inner join sc_atb.tbl_dtb dtb on dtb.cd_dtb = tba.cd_dtb
			 where dtb.cd_atb = vp_codigo_arquivo
			   and tba.cd_ccr = vp_codigo_conta_corrente
			 group by tba.cd_dtb, tba.cd_bnc, tba.nr_agc_tba, tba.nr_dgt_agc_tba, tba.nr_cba_tba, tba.nr_dgt_cba_tba, 
				  tba.nr_cpf_cnpj_tba, tba.nm_tba, tba.tp_pss_tba, tba.tp_cba_tba, ccr.cd_cnt_ccr loop

		vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 1;

		if vl_rg_dtb.cd_bnc = ct_banco_bradesco then
		
		   vl_qtd_transferencia := vl_qtd_transferencia + 1;
		   vl_mod_pagamento := 5;
		   
		else

		   if vl_rg_dtb.valor >= ct_valor_min_ted then
		      vl_mod_pagamento := 8;
		      vl_qtd_ted := vl_qtd_ted + 1;
		   else
		      vl_mod_pagamento := 3;
		      vl_qtd_doc := vl_qtd_doc + 1;
		   end if;
		   
		end if;

		vl_cpf_cnpj := sc_atb.montar_cpf_cnpj(vl_rg_dtb.tp_pss_tba,vl_rg_dtb.nr_cpf_cnpj_tba);

		if vl_mod_pagamento = 1 or vl_mod_pagamento = 5 then

                   vl_complemento_pagamento := sc_arq.repetir(' ',40);
                   
		elsif vl_mod_pagamento = 3 or vl_mod_pagamento = 8 then

		   vl_complemento_pagamento := 'C';
		   vl_complemento_pagamento := vl_complemento_pagamento || sc_arq.repetir('0',6);
		   vl_complemento_pagamento := vl_complemento_pagamento || '07';
		   vl_complemento_pagamento := vl_complemento_pagamento || '01';
		   vl_complemento_pagamento := vl_complemento_pagamento || sc_arq.repetir(' ',29);
		   
		end if; 

                -- calculando digito agencia caso banco for bradesco
                vl_digito_agencia := vl_rg_dtb.nr_dgt_agc_tba;

                if vl_rg_dtb.cd_bnc = ct_cod_bradesco then
                  vl_digito_agencia := sc_pbl.modulo11(vl_rg_dtb.nr_agc_tba::numeric)::varchar;
                end if;
                -- fim calculando digito agencia caso banco for bradesco

		update sc_atb.tbl_tba 
		set st_tba = ct_situacao_enviado,
		 dt_env_tba = now(),
		 cd_dtb = vl_rg_dtb.codigo
		where st_tba = ct_situacao_autorizado
		and cd_ccr = vp_codigo_conta_corrente
		and cd_bnc = vl_rg_dtb.cd_bnc
		and nr_agc_tba = vl_rg_dtb.nr_agc_tba
		and nr_dgt_agc_tba = vl_rg_dtb.nr_dgt_agc_tba
		and nr_cba_tba = vl_rg_dtb.nr_cba_tba
		and nr_dgt_cba_tba = vl_rg_dtb.nr_dgt_cba_tba
		and tp_cba_tba = vl_rg_dtb.tp_cba_tba
		and nr_cpf_cnpj_tba = vl_rg_dtb.nr_cpf_cnpj_tba
		and tp_pss_tba = vl_rg_dtb.tp_pss_tba
		and nm_tba = vl_rg_dtb.nm_tba;

		vl_linha := '1';

		if vl_rg_dtb.tp_pss_tba = 'F' then
		    vl_linha := vl_linha || '1';
		else
		    vl_linha := vl_linha || '2';
		end if;

		vl_linha := vl_linha || sc_arq.preencher(15,vl_cpf_cnpj,'0',ALINHAMENTO_A_ESQUERDA);--CNPJ

		vl_linha := vl_linha || sc_arq.preencher(30,sc_pbl.sem_acento(trim(vl_rg_dtb.nm_tba)),' ',ALINHAMENTO_A_DIREITA);--NOME

		vl_linha := vl_linha || sc_arq.preencher(40,'',' ',ALINHAMENTO_A_DIREITA);--ENDERECO

		vl_linha := vl_linha || sc_arq.preencher(8,'0','0',ALINHAMENTO_A_ESQUERDA);--CEP

		vl_linha := vl_linha || sc_arq.preencher(3,vl_rg_dtb.cd_bnc,'0',ALINHAMENTO_A_ESQUERDA);--BANCO

		vl_linha := vl_linha || sc_arq.preencher(5,vl_rg_dtb.nr_agc_tba,'0',ALINHAMENTO_A_ESQUERDA); -- AGENCIA

		vl_linha := vl_linha || sc_arq.preencher(1,vl_digito_agencia,' ',ALINHAMENTO_A_DIREITA); -- DIGITO AGENCIA

		vl_linha := vl_linha || sc_arq.preencher(13,vl_rg_dtb.nr_cba_tba,'0',ALINHAMENTO_A_ESQUERDA); -- CONTA

		vl_linha := vl_linha || sc_arq.preencher(2,vl_rg_dtb.nr_dgt_cba_tba,' ',ALINHAMENTO_A_DIREITA); -- DIGITO CONTA

		vl_linha := vl_linha || sc_arq.preencher(16,vl_rg_dtb.codigo,' ',ALINHAMENTO_A_DIREITA); -- NUMERO DO PAGAMENTO

		vl_linha := vl_linha || sc_arq.preencher(3,'0','0',ALINHAMENTO_A_ESQUERDA); -- CARTEIRA

		vl_linha := vl_linha || sc_arq.preencher(12,'0','0',ALINHAMENTO_A_ESQUERDA); -- NOSSO NUMERO

		vl_linha := vl_linha || sc_arq.preencher(15,'0',' ',ALINHAMENTO_A_DIREITA); -- SEU NUMERO

		vl_linha := vl_linha || to_char(current_date,'yyyymmdd'); -- DATA DE VENCIMENTO

		vl_linha := vl_linha || to_char(current_date,'yyyymmdd'); -- DATA DE EMISSAO DO DOCUMENTO

		vl_linha := vl_linha || sc_arq.repetir('0',8); -- DATA LIMITE PARA DESCONTO

		vl_linha := vl_linha || '0';

		vl_linha := vl_linha || sc_arq.repetir('0',4); -- FATOR DE VENCIMENTO

		vl_linha := vl_linha || sc_arq.formatar_moeda(10,vl_rg_dtb.valor); -- VALOR DO DOCUMENTO

		vl_linha := vl_linha || sc_arq.formatar_moeda(15,vl_rg_dtb.valor); -- VALOR DO PAGAMENTO

		vl_linha := vl_linha || sc_arq.repetir('0',15); -- VALOR DO DESCONTO

		vl_linha := vl_linha || sc_arq.repetir('0',15); -- VALOR DO ACRESCIMO

		vl_linha := vl_linha || '05'; -- TIPO DO DOCUMENTO
		
		vl_linha := vl_linha || sc_arq.repetir('0',10); -- NUMERO NOTA FISCAL
		
		vl_linha := vl_linha || sc_arq.repetir(' ',2); -- SERIE DOCUMENTO

		vl_linha := vl_linha || sc_arq.preencher(2,vl_mod_pagamento,'0',ALINHAMENTO_A_ESQUERDA); -- MODALIDADE PAGAMENTO

		vl_linha := vl_linha || to_char(current_date,'yyyymmdd'); -- DATA EFETIVACAO PAGAMENTO

		vl_linha := vl_linha || sc_arq.repetir(' ',3); -- MOEDA

		vl_linha := vl_linha || '01';

		vl_linha := vl_linha || sc_arq.repetir(' ',2);
		
		vl_linha := vl_linha || sc_arq.repetir(' ',2);

		vl_linha := vl_linha || sc_arq.repetir(' ',2);

		vl_linha := vl_linha || sc_arq.repetir(' ',2);

		vl_linha := vl_linha || sc_arq.repetir(' ',2);

		vl_linha := vl_linha || '0';

		vl_linha := vl_linha || '00';

		vl_linha := vl_linha || sc_arq.repetir(' ',4);

		vl_linha := vl_linha || sc_arq.repetir(' ',15);

		vl_linha := vl_linha || sc_arq.repetir(' ',15);

		vl_linha := vl_linha || sc_arq.repetir(' ',6);

		vl_linha := vl_linha || sc_arq.repetir(' ',40);

		vl_linha := vl_linha || ' ';

		vl_linha := vl_linha || ' ';

		vl_linha := vl_linha || sc_arq.preencher(40,vl_complemento_pagamento,' ',ALINHAMENTO_A_DIREITA); 
		
		vl_linha := vl_linha || '00';
		
		vl_linha := vl_linha || sc_arq.repetir(' ',35);
		
		vl_linha := vl_linha || sc_arq.repetir(' ',22);

		vl_linha := vl_linha || sc_arq.repetir('0',5);

		vl_linha := vl_linha || ' ';

                -- ALTERACAO TEMPORARIA.
                -- TODO: FAZER A FORMA CORRETA E JA TRAZER O DADO CORRETO PARA O CASO DE CONTA FACIL
		if vl_rg_dtb.tp_cba_tba = 3 then
		   vl_linha := vl_linha || '1';
		else   
		   vl_linha := vl_linha || vl_rg_dtb.tp_cba_tba;
		end if;

		vl_linha := vl_linha || sc_arq.preencher(7,vl_rg_dtb.cd_cnt_ccr,'0',ALINHAMENTO_A_ESQUERDA); 
		
		vl_linha := vl_linha || sc_arq.repetir(' ',8);

		vl_linha := vl_linha || sc_arq.preencher(6,vl_qtde_registros_arquivo,'0',ALINHAMENTO_A_ESQUERDA); 

		perform sc_arq.gravarlinha(vp_nome_arquivo,vl_linha);

	end loop; 
                      
end;$$;


ALTER FUNCTION sc_atb.gera_detalhe_arquivo_bradesco(vp_codigo_arquivo numeric, vp_nome_arquivo character varying, vp_codigo_conta_corrente numeric) OWNER TO scan;

--
-- TOC entry 1185 (class 1255 OID 564126)
-- Name: gera_detalhe_b_arquivo_hsbc(tbl_dtb, numeric, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION gera_detalhe_b_arquivo_hsbc(vp_detalhe_transferencia tbl_dtb, vp_numero_lote numeric, vp_sequencia_registro numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
  vl_linha varchar;
  Vl_aux VarCHar;

  --constantes
  ct_ted constant numeric := 1;
  ct_doc constant numeric := 2;
begin
  --campo 01: banco
  vl_linha := '399';
  
  --campo 02: lote
  vl_linha := vl_linha || trim(to_char(vp_numero_lote, repeat('0', 4)));

  --campo 03: tipo de registro
  vl_linha := vl_linha || '3';
  
  --campo 04: numero sequencial do registro dentro do lote
  vl_linha := vl_linha || trim(to_char(vp_sequencia_registro, repeat('0', 5)));
  
  --campo 05: codigo de segmento do registro
  vl_linha := vl_linha || 'B';

  --campo 06: Filler
  vl_linha := vl_linha || repeat(' ', 3);
    
  --campo 07: tipo de inscricao da empresa
  if vp_detalhe_transferencia.tp_pss_dtb = 'F' then
    vl_linha := vl_linha || '1';
  else
    vl_linha := vl_linha || '2';
  end if;

  --campo 08: numero de inscricao da empresa
  vl_linha := vl_linha || trim(to_char(vp_detalhe_transferencia.nr_cpf_cnpj_dtb, repeat('0', 14)));

  --campo 09: logradouro
  vl_linha := vl_linha || repeat(' ', 30);

  --campo 10: numero
  vl_linha := vl_linha || repeat(' ', 5);
  
  --campo 11: complemento
  vl_linha := vl_linha || repeat(' ', 15);

  --campo 12: bairro
  vl_linha := vl_linha || repeat(' ', 15);
  
  --campo 13: cidade
  vl_linha := vl_linha || repeat(' ', 20);

  --campo 14: cep
  vl_linha := vl_linha || repeat('0', 5);

  --campo 15: complemento do cep
  vl_linha := vl_linha || repeat('0', 3);

  --campo 16: sigla do estado
  vl_linha := vl_linha || repeat(' ', 2);

  --campo 17: Filler
  vl_linha := vl_linha || repeat(' ', 113);
 
  return vl_linha;
end;$$;


ALTER FUNCTION sc_atb.gera_detalhe_b_arquivo_hsbc(vp_detalhe_transferencia tbl_dtb, vp_numero_lote numeric, vp_sequencia_registro numeric) OWNER TO scan;

--
-- TOC entry 7638 (class 0 OID 0)
-- Dependencies: 1185
-- Name: FUNCTION gera_detalhe_b_arquivo_hsbc(vp_detalhe_transferencia tbl_dtb, vp_numero_lote numeric, vp_sequencia_registro numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION gera_detalhe_b_arquivo_hsbc(vp_detalhe_transferencia tbl_dtb, vp_numero_lote numeric, vp_sequencia_registro numeric) IS 'rotina responsavel por gerar a linha de detalhe de segmento "B" do lote do arquivo de transferencia do HSBC';


--
-- TOC entry 221 (class 1259 OID 564127)
-- Name: tbl_atb; Type: TABLE; Schema: sc_atb; Owner: scan
--

CREATE TABLE tbl_atb (
    cd_atb numeric(10,0) NOT NULL,
    cd_ccr numeric(5,0) NOT NULL,
    dt_grc_atb timestamp without time zone NOT NULL,
    dt_env_atb timestamp without time zone,
    nr_lte_atb numeric(5,0) NOT NULL,
    nr_ctr_atb numeric(20,0) NOT NULL,
    nr_seq_atb numeric(20,0) NOT NULL,
    vrs_lyt_atb numeric(5,0) NOT NULL,
    nr_reg_atb numeric(7,0) DEFAULT 0 NOT NULL,
    nr_ted_atb numeric(7,0) DEFAULT 0 NOT NULL,
    nr_doc_atb numeric(7,0) DEFAULT 0 NOT NULL,
    nt_trf_atb numeric(7,0) DEFAULT 0 NOT NULL,
    vl_atb numeric(13,2) DEFAULT 0 NOT NULL,
    st_atb numeric(2,0) DEFAULT 1 NOT NULL
);


ALTER TABLE tbl_atb OWNER TO scan;

--
-- TOC entry 7639 (class 0 OID 0)
-- Dependencies: 221
-- Name: TABLE tbl_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON TABLE tbl_atb IS 'tabela de arquivo de transferencia bancaria';


--
-- TOC entry 7640 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.cd_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.cd_atb IS 'codigo';


--
-- TOC entry 7641 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.cd_ccr; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.cd_ccr IS 'conta corrente';


--
-- TOC entry 7642 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.dt_grc_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.dt_grc_atb IS 'data de geracao';


--
-- TOC entry 7643 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.dt_env_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.dt_env_atb IS 'data de envio';


--
-- TOC entry 7644 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.nr_lte_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.nr_lte_atb IS 'numero do lote';


--
-- TOC entry 7645 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.nr_ctr_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.nr_ctr_atb IS 'numero do contrato';


--
-- TOC entry 7646 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.nr_seq_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.nr_seq_atb IS 'numero de sequencia';


--
-- TOC entry 7647 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.vrs_lyt_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.vrs_lyt_atb IS 'versao do layout';


--
-- TOC entry 7648 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.nr_reg_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.nr_reg_atb IS 'numero de registros';


--
-- TOC entry 7649 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.nr_ted_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.nr_ted_atb IS 'numero de ted';


--
-- TOC entry 7650 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.nr_doc_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.nr_doc_atb IS 'numero de doc';


--
-- TOC entry 7651 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.nt_trf_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.nt_trf_atb IS 'numero de transferencias';


--
-- TOC entry 7652 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.vl_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.vl_atb IS 'valor total do arquivo';


--
-- TOC entry 7653 (class 0 OID 0)
-- Dependencies: 221
-- Name: COLUMN tbl_atb.st_atb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_atb.st_atb IS 'situacao do arquivo (ver tabela de dominio)';


SET search_path = sc_fin, pg_catalog;

--
-- TOC entry 222 (class 1259 OID 564136)
-- Name: tbl_ccr; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_ccr (
    cd_ccr numeric(3,0) NOT NULL,
    cd_cnt numeric(10,0) NOT NULL,
    cd_bnc numeric(5,0) NOT NULL,
    cd_agn_ccr numeric(5,0) NOT NULL,
    cd_cnt_ccr numeric(9,0) NOT NULL,
    nr_dgt_vrf_cnt_ccr character varying(2),
    nr_dgt_vrf_agn_ccr character varying(1),
    fg_atv_ccr character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    tp_pss_ccr character(1),
    nr_cpf_cnpj_ccr numeric(14,0),
    nr_ctr_ccr numeric(10,0),
    nm_emp_ccr character varying(30),
    nm_bnc_ccr character varying(30),
    cnt_ctb_ccr character varying(40),
    cd_cun numeric(10,0),
    fg_sis_emp_ccr character(1) DEFAULT 'N'::bpchar,
    fg_rrc_ccr character(1) DEFAULT 'S'::bpchar NOT NULL
);


ALTER TABLE tbl_ccr OWNER TO scan;

--
-- TOC entry 7654 (class 0 OID 0)
-- Dependencies: 222
-- Name: COLUMN tbl_ccr.tp_pss_ccr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_ccr.tp_pss_ccr IS 'tipo de pessoa do titular da conta corrente';


--
-- TOC entry 7655 (class 0 OID 0)
-- Dependencies: 222
-- Name: COLUMN tbl_ccr.nr_cpf_cnpj_ccr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_ccr.nr_cpf_cnpj_ccr IS 'numero de cpf/cnpj do titular da conta corrente';


--
-- TOC entry 7656 (class 0 OID 0)
-- Dependencies: 222
-- Name: COLUMN tbl_ccr.nr_ctr_ccr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_ccr.nr_ctr_ccr IS 'numero do contrato de transferencia de valores por arquivo';


--
-- TOC entry 7657 (class 0 OID 0)
-- Dependencies: 222
-- Name: COLUMN tbl_ccr.nm_emp_ccr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_ccr.nm_emp_ccr IS 'nome da empresa enviado no arquivo de transferencia bancaria';


--
-- TOC entry 7658 (class 0 OID 0)
-- Dependencies: 222
-- Name: COLUMN tbl_ccr.nm_bnc_ccr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_ccr.nm_bnc_ccr IS 'nome do banco enviado no arquivo de transferencia bancaria';


--
-- TOC entry 7659 (class 0 OID 0)
-- Dependencies: 222
-- Name: COLUMN tbl_ccr.cnt_ctb_ccr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_ccr.cnt_ctb_ccr IS 'conta contabil, utilizado no momento de exportacao das informacoes contabeis';


SET search_path = sc_atb, pg_catalog;

--
-- TOC entry 1188 (class 1255 OID 564141)
-- Name: gera_header_arquivo_bradesco(sc_fin.tbl_ccr, tbl_atb, character varying); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION gera_header_arquivo_bradesco(vp_conta_corrente sc_fin.tbl_ccr, vp_arquivo_transferencia tbl_atb, vp_razao_social character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
  vl_linha varchar;
  ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
  ALINHAMENTO_A_DIREITA numeric(2,0) := 1;  

  ct_banco_bradesco numeric := 237;
begin

  vl_linha := '0';
  
  vl_linha := vl_linha || sc_arq.preencher(8,vp_conta_corrente.nr_ctr_ccr,'0',ALINHAMENTO_A_ESQUERDA); -- VERIFICAR

  vl_linha := vl_linha || '2';

  vl_linha := vl_linha || sc_arq.preencher(15,vp_conta_corrente.nr_cpf_cnpj_ccr,'0',ALINHAMENTO_A_ESQUERDA);

  vl_linha := vl_linha || sc_arq.preencher(40,vp_razao_social,' ',ALINHAMENTO_A_DIREITA);

  vl_linha := vl_linha || '20';

  vl_linha := vl_linha || '1';

  vl_linha := vl_linha || sc_arq.preencher(5,vp_arquivo_transferencia.nr_seq_atb,'0',ALINHAMENTO_A_ESQUERDA);
  
  vl_linha := vl_linha || sc_arq.repetir('0',5);

  vl_linha := vl_linha || to_char(now(),'yyyymmdd');

  vl_linha := vl_linha || to_char(now(),'hh24miss');

  vl_linha := vl_linha || sc_arq.repetir(' ',5);

  vl_linha := vl_linha || sc_arq.repetir(' ',3);

  vl_linha := vl_linha || sc_arq.repetir(' ',5);

  vl_linha := vl_linha || sc_arq.repetir('0',1);

  vl_linha := vl_linha || sc_arq.repetir(' ',74);

  vl_linha := vl_linha || sc_arq.repetir(' ',80);

  vl_linha := vl_linha || sc_arq.repetir(' ',217);

  vl_linha := vl_linha || sc_arq.repetir(' ',9);

  vl_linha := vl_linha || sc_arq.repetir(' ',8);

  vl_linha := vl_linha || '000001';
  
  return vl_linha;
end;$$;


ALTER FUNCTION sc_atb.gera_header_arquivo_bradesco(vp_conta_corrente sc_fin.tbl_ccr, vp_arquivo_transferencia tbl_atb, vp_razao_social character varying) OWNER TO scan;

--
-- TOC entry 7660 (class 0 OID 0)
-- Dependencies: 1188
-- Name: FUNCTION gera_header_arquivo_bradesco(vp_conta_corrente sc_fin.tbl_ccr, vp_arquivo_transferencia tbl_atb, vp_razao_social character varying); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION gera_header_arquivo_bradesco(vp_conta_corrente sc_fin.tbl_ccr, vp_arquivo_transferencia tbl_atb, vp_razao_social character varying) IS 'rotina responsavel por gerar a linha de header do arquivo de transferencia do BRADESCO';


--
-- TOC entry 1189 (class 1255 OID 564142)
-- Name: gera_header_arquivo_hsbc(sc_fin.tbl_ccr, tbl_atb); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION gera_header_arquivo_hsbc(vp_conta_corrente sc_fin.tbl_ccr, vp_arquivo_transferencia tbl_atb) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
  vl_linha varchar;
begin
  --campo 01: banco
  vl_linha := '399';
  
  --campo 02: lote
  vl_linha := vl_linha || '0000';

  --campo 03: tipo de registro
  vl_linha := vl_linha || '0';
  
  --campo 04: filler
  vl_linha := vl_linha || repeat(' ', 9);
  
  --campo 05: tipo de inscricao da empresa
  if vp_conta_corrente.tp_pss_ccr = 'F' then
    vl_linha := vl_linha || '1';
  else
    vl_linha := vl_linha || '2';
  end if;

  --campo 06: numero de inscricao da empresa
  vl_linha := vl_linha || trim(to_char(vp_conta_corrente.nr_cpf_cnpj_ccr, repeat('0', 14)));
  
  --campo 07: numero do contrato
  vl_linha := vl_linha || trim(to_char(vp_conta_corrente.nr_ctr_ccr, repeat('0', 6)));

  --campo 08: Filler
  vl_linha := vl_linha || repeat(' ', 14);

  --campo 09: agencia da conta
  vl_linha := vl_linha || trim(to_char(vp_conta_corrente.cd_agn_ccr, repeat('0', 5)));
  
  --campo 10: Filler
  vl_linha := vl_linha || repeat(' ', 1);

  --campo 11: numero conta corrente
  vl_linha := vl_linha || trim(to_char(vp_conta_corrente.cd_cnt_ccr, repeat('0', 12)));

  --campo 12: digito verificador da conta corrente
  vl_linha := vl_linha || vp_conta_corrente.nr_dgt_vrf_cnt_ccr;

  --campo 13: filler
  vl_linha := vl_linha || repeat(' ', 2 - length(vp_conta_corrente.nr_dgt_vrf_cnt_ccr));

  --campo 14: nome da empresa
  vl_linha := vl_linha || vp_conta_corrente.nm_emp_ccr || repeat(' ', 30 - length(vp_conta_corrente.nm_emp_ccr));

  --campo 15: nome do banco
  vl_linha := vl_linha || vp_conta_corrente.nm_bnc_ccr || repeat(' ', 30 - length(vp_conta_corrente.nm_bnc_ccr));
  
  --campo 16: Filler
  vl_linha := vl_linha || repeat(' ', 10);

  --campo 17: código do arquivo de remessa
  vl_linha := vl_linha || '1';

  --campo 18: data da geracao do arquivo
  vl_linha := vl_linha || to_char(vp_arquivo_transferencia.dt_grc_atb, 'DDMMYYYY');

  --campo 19: hora de geracao do arquivo
  vl_linha := vl_linha || to_char(vp_arquivo_transferencia.dt_grc_atb, 'HH24MISS');

  --campo 20: sequencia do arquivo
  vl_linha := vl_linha || trim(to_char(vp_arquivo_transferencia.nr_seq_atb, repeat('0', 6)));

  --campo 21: versao do layout do arquivo
  vl_linha := vl_linha || trim(to_char(vp_arquivo_transferencia.vrs_lyt_atb, repeat('0', 3)));

  --campo 22: densidade de gravacao do arquivo
  vl_linha := vl_linha || '01600';

  --campo 23: sigla do aplicativo
  vl_linha := vl_linha || 'CPG';

  --campo 24: identifica ano 2000
  vl_linha := vl_linha || 'Y2K';

  --campo 25: Controle CPG - Para uso interno
  vl_linha := vl_linha || repeat(' ', 3);

  --campo 26: Filler
  vl_linha := vl_linha || repeat(' ', 11);
  
  --campo 27: Filler
  vl_linha := vl_linha || repeat(' ', 49);

  return vl_linha;
end;$$;


ALTER FUNCTION sc_atb.gera_header_arquivo_hsbc(vp_conta_corrente sc_fin.tbl_ccr, vp_arquivo_transferencia tbl_atb) OWNER TO scan;

--
-- TOC entry 7661 (class 0 OID 0)
-- Dependencies: 1189
-- Name: FUNCTION gera_header_arquivo_hsbc(vp_conta_corrente sc_fin.tbl_ccr, vp_arquivo_transferencia tbl_atb); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION gera_header_arquivo_hsbc(vp_conta_corrente sc_fin.tbl_ccr, vp_arquivo_transferencia tbl_atb) IS 'rotina responsavel por gerar a linha de header do arquivo de transferencia do HSBC';


--
-- TOC entry 1191 (class 1255 OID 564143)
-- Name: gera_header_lote_arquivo_hsbc(sc_fin.tbl_ccr, numeric, character); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION gera_header_lote_arquivo_hsbc(vp_conta_corrente sc_fin.tbl_ccr, vp_numero_lote numeric, vp_flag_transferencia character) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
  vl_linha varchar;
begin
  --campo 01: banco
  vl_linha := '399';
  
  --campo 02: lote
  vl_linha := vl_linha || trim(to_char(vp_numero_lote, repeat('0', 4)));

  --campo 03: tipo de registro
  vl_linha := vl_linha || '1';
  
  --campo 04: tipo de operacao
  vl_linha := vl_linha || 'C';
  
  --campo 05: tipo de servico (20 - pagamento de fornecedor)
  vl_linha := vl_linha || '20';

  --campo 06: forma de lancamento
  if vp_flag_transferencia = 'S' then
    vl_linha := vl_linha || '01';
  else
    vl_linha := vl_linha || '03';
  end if;
  
  --campo 07: numero da versao do layout do arquivo
  vl_linha := vl_linha || '020';

  --campo 08: Filler
  vl_linha := vl_linha || repeat(' ', 1);

  --campo 09: tipo de insricao da empresa
  if vp_conta_corrente.tp_pss_ccr = 'F' then
    vl_linha := vl_linha || '1';
  else
    vl_linha := vl_linha || '2';
  end if;

  --campo 10: numero de inscricao da empresa
  vl_linha := vl_linha || trim(to_char(vp_conta_corrente.nr_cpf_cnpj_ccr, repeat('0', 14)));
  
  --campo 11: numero do contrato
  vl_linha := vl_linha || trim(to_char(vp_conta_corrente.nr_ctr_ccr, repeat('0', 6)));

  --campo 12: Filler
  vl_linha := vl_linha || repeat(' ', 14);

  --campo 13: agencia da conta
  vl_linha := vl_linha || trim(to_char(vp_conta_corrente.cd_agn_ccr, repeat('0', 5)));
  
  --campo 14: Filler
  vl_linha := vl_linha || repeat(' ', 1);

  --campo 15: numero conta corrente
  vl_linha := vl_linha || trim(to_char(vp_conta_corrente.cd_cnt_ccr, repeat('0', 12)));

  --campo 16: digito verificador da conta corrente
  vl_linha := vl_linha || vp_conta_corrente.nr_dgt_vrf_cnt_ccr;

  --campo 17: filler
  vl_linha := vl_linha || repeat(' ', 2 - length(vp_conta_corrente.nr_dgt_vrf_cnt_ccr));

  --campo 18: nome da empresa
  vl_linha := vl_linha || vp_conta_corrente.nm_emp_ccr || repeat(' ', 30 - length(vp_conta_corrente.nm_emp_ccr));
  
  --campo 19: Mensagem Marketing
  vl_linha := vl_linha || repeat(' ', 40);

  --campo 20: logradouro
  vl_linha := vl_linha || repeat(' ', 30);

  --campo 21: numero
  vl_linha := vl_linha || repeat(' ', 5);
  
  --campo 22: complemento
  vl_linha := vl_linha || repeat(' ', 15);
  
  --campo 23: cidade
  vl_linha := vl_linha || repeat(' ', 20);

  --campo 24: cep
  vl_linha := vl_linha || repeat('0', 5);

  --campo 25: complemento do cep
  vl_linha := vl_linha || repeat('0', 3);

  --campo 26: sigla do estado
  vl_linha := vl_linha || repeat(' ', 2);
  
  --campo 27: comprovante de pagto - emissao em lote
  vl_linha := vl_linha || 'N';

  --campo 28: filler
  vl_linha := vl_linha || repeat(' ', 17);

  return vl_linha;
end;$$;


ALTER FUNCTION sc_atb.gera_header_lote_arquivo_hsbc(vp_conta_corrente sc_fin.tbl_ccr, vp_numero_lote numeric, vp_flag_transferencia character) OWNER TO scan;

--
-- TOC entry 7662 (class 0 OID 0)
-- Dependencies: 1191
-- Name: FUNCTION gera_header_lote_arquivo_hsbc(vp_conta_corrente sc_fin.tbl_ccr, vp_numero_lote numeric, vp_flag_transferencia character); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION gera_header_lote_arquivo_hsbc(vp_conta_corrente sc_fin.tbl_ccr, vp_numero_lote numeric, vp_flag_transferencia character) IS 'rotina responsavel por gerar a linha de header do lote do arquivo de transferencia do HSBC';


--
-- TOC entry 1192 (class 1255 OID 564144)
-- Name: gera_trailler_arquivo_bradesco(character varying, numeric, double precision); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION gera_trailler_arquivo_bradesco(vp_nome_arquivo character varying, vp_qtde_registro numeric, vp_total_pagamento double precision) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_linha varchar;
  vl_aux varchar;


  ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
  ALINHAMENTO_A_DIREITA numeric(2,0) := 1;    
begin

  vl_linha := '9';

  vl_linha := vl_linha || sc_arq.preencher(6,(vp_qtde_registro+1),'0',ALINHAMENTO_A_ESQUERDA); 
  
  vl_linha := vl_linha || sc_arq.formatar_moeda(17, vp_total_pagamento::numeric);

  vl_linha := vl_linha || sc_arq.repetir(' ', 470);
 
  vl_linha := vl_linha || sc_arq.preencher(6,(vp_qtde_registro+1),'0',ALINHAMENTO_A_ESQUERDA);  
  
  perform sc_arq.gravarlinha(vp_nome_arquivo,vl_linha); 
  
end;$$;


ALTER FUNCTION sc_atb.gera_trailler_arquivo_bradesco(vp_nome_arquivo character varying, vp_qtde_registro numeric, vp_total_pagamento double precision) OWNER TO scan;

--
-- TOC entry 7663 (class 0 OID 0)
-- Dependencies: 1192
-- Name: FUNCTION gera_trailler_arquivo_bradesco(vp_nome_arquivo character varying, vp_qtde_registro numeric, vp_total_pagamento double precision); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION gera_trailler_arquivo_bradesco(vp_nome_arquivo character varying, vp_qtde_registro numeric, vp_total_pagamento double precision) IS 'rotina responsavel por gerar a linha de trailler do arquivo de transferencia do BRADESCO';


--
-- TOC entry 1193 (class 1255 OID 564145)
-- Name: gera_trailler_arquivo_hsbc(numeric, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION gera_trailler_arquivo_hsbc(vp_qtde_lote numeric, vp_qtde_registro numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
  vl_linha varchar;
  vl_aux varchar;
begin
  --campo 01: banco
  vl_linha := '399';
  
  --campo 02: lote
  vl_linha := vl_linha || repeat('9', 4);

  --campo 03: tipo de registro
  vl_linha := vl_linha || '9';

  --campo 04: Filler
  vl_linha := vl_linha || repeat(' ', 9);
  
  --campo 05: quantidade de lotes
  vl_linha := vl_linha || trim(to_char(vp_qtde_lote, repeat('0', 6)));

  --campo 06: quantidade de registros
  vl_linha := vl_linha || trim(to_char(vp_qtde_registro, repeat('0', 6)));
  
  --campo 07: Filler
  vl_linha := vl_linha || repeat(' ', 211);
 
  return vl_linha;
end;$$;


ALTER FUNCTION sc_atb.gera_trailler_arquivo_hsbc(vp_qtde_lote numeric, vp_qtde_registro numeric) OWNER TO scan;

--
-- TOC entry 7664 (class 0 OID 0)
-- Dependencies: 1193
-- Name: FUNCTION gera_trailler_arquivo_hsbc(vp_qtde_lote numeric, vp_qtde_registro numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION gera_trailler_arquivo_hsbc(vp_qtde_lote numeric, vp_qtde_registro numeric) IS 'rotina responsavel por gerar a linha de trailler do arquivo de transferencia do HSBC';


--
-- TOC entry 1194 (class 1255 OID 564146)
-- Name: gera_trailler_lote_arquivo_hsbc(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION gera_trailler_lote_arquivo_hsbc(vp_numero_lote numeric, vp_qtde_registro numeric, vp_soma_registro numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
  vl_linha varchar;
  vl_aux varchar;
begin
  --campo 01: banco
  vl_linha := '399';
  
  --campo 02: lote
  vl_linha := vl_linha || trim(to_char(vp_numero_lote, repeat('0', 4)));

  --campo 03: tipo de registro
  vl_linha := vl_linha || '5';

  --campo 04: Filler
  vl_linha := vl_linha || repeat(' ', 9);
  
  --campo 05: quantidade de registros
  vl_linha := vl_linha || trim(to_char(vp_qtde_registro, repeat('0', 6)));

  --campo 06: Filler
  vl_linha := vl_linha || repeat(' ', 3);
  
  --campo 07: somatorio dos valores de credito
  vl_aux := trim(to_char(vp_soma_registro, repeat('0', 13) || 'D' || repeat('0', 2)));
  vl_aux := replace(replace(vl_aux, ',', ''), '.', '');
  vl_linha := vl_linha || vl_aux;

  --campo 08: Filler
  vl_linha := vl_linha || repeat(' ', 199);
 
  return vl_linha;
end;$$;


ALTER FUNCTION sc_atb.gera_trailler_lote_arquivo_hsbc(vp_numero_lote numeric, vp_qtde_registro numeric, vp_soma_registro numeric) OWNER TO scan;

--
-- TOC entry 7665 (class 0 OID 0)
-- Dependencies: 1194
-- Name: FUNCTION gera_trailler_lote_arquivo_hsbc(vp_numero_lote numeric, vp_qtde_registro numeric, vp_soma_registro numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION gera_trailler_lote_arquivo_hsbc(vp_numero_lote numeric, vp_qtde_registro numeric, vp_soma_registro numeric) IS 'rotina responsavel por gerar a linha de trailler do lote do arquivo de transferencia do HSBC';


--
-- TOC entry 1155 (class 1255 OID 564147)
-- Name: gerar_arquivo_transferencia(numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION gerar_arquivo_transferencia(vp_codigo_conta_corrente numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg_ccr sc_fin.tbl_ccr%rowtype;
  ct_banco_hsbc constant numeric := 399;  
  ct_banco_bracce constant numeric := 65;  
  ct_banco_bradesco constant numeric := 237;  
begin

    --obtendo os dados da tabela de conta corrente
    select * 
    into vl_rg_ccr
    from sc_fin.tbl_ccr 
    where cd_ccr = vp_codigo_conta_corrente
      and nr_ctr_ccr is not null;
    
    --verificando se o codigo do banco e HSBC
    if vl_rg_ccr.cd_bnc = ct_banco_hsbc then
       perform sc_atb.gerar_arquivo_transferencia_hsbc(vp_codigo_conta_corrente);
    elsif vl_rg_ccr.cd_bnc = ct_banco_bracce then   
       perform sc_atb.gerar_arquivo_transferencia_bracce(vp_codigo_conta_corrente);
    elsif vl_rg_ccr.cd_bnc = ct_banco_bradesco then   
       perform sc_atb.gerar_arquivo_transferencia_bradesco(vp_codigo_conta_corrente);
    end if;
end;$$;


ALTER FUNCTION sc_atb.gerar_arquivo_transferencia(vp_codigo_conta_corrente numeric) OWNER TO scan;

--
-- TOC entry 7666 (class 0 OID 0)
-- Dependencies: 1155
-- Name: FUNCTION gerar_arquivo_transferencia(vp_codigo_conta_corrente numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION gerar_arquivo_transferencia(vp_codigo_conta_corrente numeric) IS 'rotina responsavel por obter todoas as transferencias bancarias autorizadas (SC_ATB.TBL_TBA) e gerar um arquivo de realização de transferencia ao banco definido pelo atributo conta corrente (CD_CCR)';


--
-- TOC entry 1156 (class 1255 OID 564148)
-- Name: gerar_arquivo_transferencia_bracce(numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION gerar_arquivo_transferencia_bracce(vp_codigo_conta_corrente numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg_ccr sc_fin.tbl_ccr%rowtype;
  vl_rg_atb sc_atb.tbl_atb%rowtype;
  vl_rg_dtb sc_atb.tbl_dtb%rowtype;
  
  vl_qtde_transferencia numeric;
  vl_qtde_registros_arquivo numeric := 0;
  vl_codigo_arquivo numeric;
  vl_sequencia_arquivo numeric;
  
  vl_numero_lote numeric := 0;
  vl_sequencia_lote numeric := 0;
  vl_soma_lote numeric;

  vl_diretorio varchar;
  vl_nome_arquivo varchar;
  vl_nome_download_arquivo varchar;
  vl_linha varchar;

  vl_conta_transferencia numeric;
  vl_conta_corrente numeric;
  vl_tipo_lancamento_transferencia numeric;
  vl_valor_total_transferencia double precision;

  vl_qnt_ted numeric;
  vl_qnt_doc numeric;
  vl_total_arquivo numeric(13,2);

  --constantes
  ct_banco_bracce constant numeric := 65;

  ct_situacao_autorizado constant numeric := 2;
  ct_situacao_enviado constant numeric := 4;

  ct_st_atb_gerado constant numeric := 1;
  ct_st_atb_enviado constant numeric := 2;
  ct_situacao_cancelado constant numeric := 4;
  ct_versao_layout constant numeric := 1;

  ct_sistema_transferencia numeric := 22;

  ct_diretorio_arq_transferencia constant varchar := 'DIRETORIO_ARQUIVO_TRANSFERENCIA_BRACCE';
begin
  --verificando se existem transferencia bancarias autorizadas para serem enviadas a conta corrente passada como parametro
  select count(*)
  into vl_qtde_transferencia
  from sc_atb.tbl_tba tba
  where tba.st_tba = ct_situacao_autorizado
    and tba.cd_ccr = vp_codigo_conta_corrente;

  --se existir continuar gerando o arquivo, caso contrario nao faz nada
  if vl_qtde_transferencia > 0 then
    --obtendo os dados da tabela de conta corrente
    select * 
    into vl_rg_ccr
    from sc_fin.tbl_ccr 
    where cd_ccr = vp_codigo_conta_corrente
      and nr_ctr_ccr is not null;
    
    --verificando se o codigo do banco e HSBC
    if vl_rg_ccr.cd_bnc = ct_banco_bracce then
      -- Obtendo os parametros
      select prm.vl_prm
      into vl_diretorio
      from sc_cad.tbl_prm prm
      where prm.nm_prm = ct_diretorio_arq_transferencia;
  
      --obtendo o codigo do arquivo
      select nextval('sc_atb.sq_atb') into vl_codigo_arquivo;

      --definindo o nome do arquivo
      vl_nome_download_arquivo := 'BRACCE' || trim(to_char(vl_codigo_arquivo, repeat('0', 4))) || '.csv';
      vl_nome_arquivo := vl_diretorio || '\\' || vl_nome_download_arquivo;

      --obtendo a sequencia atual do arquivo
      select COALESCE(max(nr_seq_atb), 0) + 1
      into vl_sequencia_arquivo
      from sc_atb.tbl_atb
      where st_atb <> ct_situacao_cancelado;
        
      --inserindo um registro na tabela de arquivo de transferencia bancaria
      select sum(case when tba.vl_tba >= 5000 then 1 else 0 end), sum(case when tba.vl_tba < 5000 then 1 else 0 end), sum(tba.vl_tba)
        into vl_qnt_ted, vl_qnt_doc, vl_total_arquivo
      from sc_atb.tbl_tba tba
      where tba.st_tba = ct_situacao_autorizado
        and tba.cd_ccr = vp_codigo_conta_corrente;

      insert into sc_atb.tbl_atb(cd_atb, cd_ccr, dt_grc_atb, nr_lte_atb, nr_ctr_atb, nr_seq_atb, vrs_lyt_atb, st_atb, nr_ted_atb, nr_doc_atb, vl_atb)
      values(vl_codigo_arquivo, vp_codigo_conta_corrente, now(), 0, vl_rg_ccr.nr_ctr_ccr, vl_sequencia_arquivo, ct_versao_layout, ct_st_atb_enviado, vl_qnt_ted, vl_qnt_doc, vl_total_arquivo);

      -- inserir lancamento na conta do banco
      select prm.vl_prm
        into vl_conta_transferencia
      from sc_cad.tbl_prm prm
      where prm.nm_prm = 'CONTA_TRANSFERENCIA';

      select ccr.cd_cnt
        into vl_conta_corrente
      from sc_fin.tbl_ccr ccr
      where cd_ccr = vp_codigo_conta_corrente;

      select sum(tba.vl_tba)
        into vl_valor_total_transferencia
      from sc_atb.tbl_tba tba
      where tba.st_tba = 2
        and tba.cd_ccr = vp_codigo_conta_corrente;

      select vl_prm
        into vl_tipo_lancamento_transferencia
      from sc_cad.tbl_prm prm
      where nm_prm = 'TIPO_LANCAMENTO_TRANSFERENCIA';

      perform sc_cnt.lancar_debito_credito(vl_conta_transferencia,vl_conta_corrente,vl_tipo_lancamento_transferencia,null::varchar,
                                           ('TRANSFERENCIA PARA CONTA DO BRACCE, NSU: ' || vl_codigo_arquivo)::varchar,
                                           vl_valor_total_transferencia,current_timestamp::timestamp without time zone,1::numeric,ct_sistema_transferencia,vl_codigo_arquivo);

      --obtendo os dados do arquivo que acabou de ser incluido
      select *
      into vl_rg_atb
      from sc_atb.tbl_atb
      where cd_atb = vl_codigo_arquivo;
        
      --gerando o header do arquivo de transferencia do banco HSBC
      vl_linha := '"Data de Vencimento";"Banco do Favorecido";"Agencia do Favorecido";"Conta do Favorecido";"Nome do Favorecido";"CNPJ/CPF";"Valor";"ISPB do Cliente";"Codigo do Produto";"Tipo de Pessoa"';
      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
      vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 1;
      
        vl_sequencia_lote := 0;
        vl_soma_lote := 0;
        for vl_rg_dtb in select nextval('sc_atb.sq_dtb'), vl_codigo_arquivo, cd_bnc, nr_agc_tba, nr_dgt_agc_tba, 
                                nr_cba_tba, nr_dgt_cba_tba, tp_cba_tba, nr_cpf_cnpj_tba, tp_pss_tba, nm_tba,  
                                2 as situacao, sum(vl_tba) as valor, cd_tba
                         from sc_atb.tbl_tba 
                         where st_tba = ct_situacao_autorizado
                           and cd_ccr = vp_codigo_conta_corrente
                         group by cd_bnc, nr_agc_tba, nr_dgt_agc_tba, nr_cba_tba, nr_dgt_cba_tba, 
                                  nr_cpf_cnpj_tba, nm_tba, tp_pss_tba, tp_cba_tba loop

            insert into sc_atb.tbl_dtb(cd_dtb, cd_atb, cd_bnc, nr_agc_dtb, nr_dgt_agc_dtb, nr_cba_dtb, nr_dgt_cba_dtb, tp_cba_dtb, nr_cpf_cnpj_dtb, tp_pss_dtb, nm_dtb, st_dtb, vl_dtb)
              values(vl_rg_dtb.cd_dtb, vl_rg_dtb.cd_atb, vl_rg_dtb.cd_bnc, vl_rg_dtb.nr_agc_dtb, vl_rg_dtb.nr_dgt_agc_dtb, vl_rg_dtb.nr_cba_dtb, vl_rg_dtb.nr_dgt_cba_dtb,
                     vl_rg_dtb.tp_cba_dtb, vl_rg_dtb.nr_cpf_cnpj_dtb, vl_rg_dtb.tp_pss_dtb, vl_rg_dtb.nm_dtb, vl_rg_dtb.st_dtb, vl_rg_dtb.vl_dtb);    
                                                    
            vl_linha := ''; 
            vl_linha := vl_linha ||'"'|| to_char(current_date,'dd/mm/yyyy') ||'"'|| ';';
            vl_linha := vl_linha ||'"'|| vl_rg_dtb.cd_bnc  ||'"'|| ';';
            vl_linha := vl_linha ||'"'|| vl_rg_dtb.nr_agc_dtb  ||'"'|| ';';
            vl_linha := vl_linha ||'"'|| vl_rg_dtb.nr_cba_dtb  || vl_rg_dtb.nr_dgt_cba_dtb ||'"'|| ';';
	    vl_linha := vl_linha ||'"'|| vl_rg_dtb.nm_dtb  ||'"'|| ';';
	    vl_linha := vl_linha ||'"'|| vl_rg_dtb.nr_cpf_cnpj_dtb  ||'"'|| ';';
	    vl_linha := vl_linha ||'"'|| vl_rg_dtb.vl_dtb  ||'"'|| ';';
	    vl_linha := vl_linha ||'"'|| 60701190  ||'"'|| ';'; -- ISPB
	    vl_linha := vl_linha ||'"'|| 0328  ||'"'|| ';'; -- Codigo do Produto
	    vl_linha := vl_linha ||'"'|| vl_rg_dtb.tp_pss_dtb  ||'"'|| ';';
            
                                  
            perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
            vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 1;
            vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 2;

		update sc_atb.tbl_tba 
		set st_tba = ct_situacao_enviado,
		    dt_env_tba = now(),
		    cd_dtb = vl_rg_dtb.cd_dtb
		where cd_tba =  vl_rg_dtb.cd_tba;           
        end loop;


      -- inserindo registro na tabela de download de arquivo
      insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_download_arquivo,now(),now(),9,1);    
    end if;
  end if;
end;$$;


ALTER FUNCTION sc_atb.gerar_arquivo_transferencia_bracce(vp_codigo_conta_corrente numeric) OWNER TO scan;

--
-- TOC entry 7667 (class 0 OID 0)
-- Dependencies: 1156
-- Name: FUNCTION gerar_arquivo_transferencia_bracce(vp_codigo_conta_corrente numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION gerar_arquivo_transferencia_bracce(vp_codigo_conta_corrente numeric) IS 'rotina responsavel por obter todoas as transferencias bancarias autorizadas (SC_ATB.TBL_TBA) e gerar um arquivo de realização de transferencia ao banco definido pelo atributo conta corrente (CD_CCR)';


--
-- TOC entry 1162 (class 1255 OID 564151)
-- Name: gerar_arquivo_transferencia_bradesco(numeric); Type: FUNCTION; Schema: sc_atb; Owner: postgres
--

CREATE FUNCTION gerar_arquivo_transferencia_bradesco(vp_codigo_conta_corrente numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg_ccr sc_fin.tbl_ccr%rowtype;
  vl_rg_atb sc_atb.tbl_atb%rowtype;
  vl_rg_dtb sc_atb.tbl_dtb%rowtype;
  
  vl_qtde_transferencia numeric;
  vl_qtde_registros_arquivo numeric := 0;
  vl_codigo_arquivo numeric;
  vl_sequencia_arquivo numeric;
  
  vl_numero_lote numeric := 0;
  vl_sequencia_lote numeric := 0;
  vl_soma_lote numeric;

  vl_diretorio varchar;
  vl_nome_arquivo varchar;
  vl_nome_download_arquivo varchar;
  vl_linha varchar;

  vl_conta_transferencia numeric;
  vl_conta_corrente numeric;
  vl_tipo_lancamento_transferencia numeric;
  vl_valor_total_transferencia double precision;

  vl_qnt_ted numeric;
  vl_qnt_doc numeric;
  vl_qnt_transferencia numeric;
  vl_total_arquivo numeric(13,2);
  vl_minimo_ted numeric;

  vl_razao_social varchar;

  --constantes
  ct_banco_bradesco constant numeric := 237;  

  ct_situacao_autorizado constant numeric := 2;
  ct_situacao_enviado constant numeric := 4;

  ct_st_atb_gerado constant numeric := 1;
  ct_st_atb_enviado constant numeric := 2;
  ct_situacao_cancelado constant numeric := 4;
  ct_versao_layout constant numeric := 20;

  ct_sistema_transferencia numeric := 22;

  ct_tipo_download_pagfor numeric := 10;

  ct_diretorio_arq_transferencia constant varchar := 'DIRETORIO_ARQUIVO_TRANSFERENCIA_BRADESCO';
  ct_valor_minimo_ted varchar := 'VL_MINIMO_TED';
begin
  --verificando se existem transferencia bancarias autorizadas para serem enviadas a conta corrente passada como parametro
  select count(*)
  into vl_qtde_transferencia
  from sc_atb.tbl_tba tba
  where tba.st_tba = ct_situacao_autorizado
    and tba.cd_ccr = vp_codigo_conta_corrente;

  --se existir continuar gerando o arquivo, caso contrario nao faz nada
  if vl_qtde_transferencia > 0 then
    --obtendo os dados da tabela de conta corrente
    select ccr.*
    into vl_rg_ccr
    from sc_fin.tbl_ccr ccr
      inner join sc_cad.tbl_cun cun on cun.cd_cun = ccr.cd_cun
    where cd_ccr = vp_codigo_conta_corrente
      and nr_ctr_ccr is not null;

    select nm_cun
    into vl_razao_social
    from sc_cad.tbl_cun
    where cd_cun = vl_rg_ccr.cd_cun;  
    
    --verificando se o codigo do banco e BRADESCO
    if vl_rg_ccr.cd_bnc = ct_banco_bradesco then
      -- Obtendo os parametros
      select prm.vl_prm
      into vl_diretorio
      from sc_cad.tbl_prm prm
      where prm.nm_prm = ct_diretorio_arq_transferencia;

      select prm.vl_prm::numeric
      into vl_minimo_ted
      from sc_cad.tbl_prm prm
      where prm.nm_prm = ct_valor_minimo_ted;
  
      --obtendo o codigo do arquivo
      select nextval('sc_atb.sq_atb') into vl_codigo_arquivo;

      --obtendo a sequencia atual do arquivo
      select COALESCE(max(nr_seq_atb), 0) + 1
      into vl_sequencia_arquivo
      from sc_atb.tbl_atb
      where st_atb <> ct_situacao_cancelado
        and cd_ccr = vp_codigo_conta_corrente;

      --definindo o nome do arquivo
      vl_nome_download_arquivo := 'PG' || to_char(current_date, 'ddmm') || vl_sequencia_arquivo || '.rem';
      vl_nome_arquivo := vl_diretorio || '\\' || vl_nome_download_arquivo;

      --excluindo arquivo caso exista
      perform sc_arq.excluirarquivo(vl_nome_arquivo);
        
      --inserindo um registro na tabela de arquivo de transferencia bancaria
      select sum(case when tba.vl_tba >= vl_minimo_ted then 1 else 0 end), 
             sum(case when tba.vl_tba < vl_minimo_ted then 1 else 0 end), 
             sum(tba.vl_tba)
        into vl_qnt_ted, 
             vl_qnt_doc, 
             vl_total_arquivo
      from sc_atb.tbl_tba tba
      where tba.st_tba = ct_situacao_autorizado
        and tba.cd_ccr = vp_codigo_conta_corrente;

      insert into sc_atb.tbl_atb(cd_atb, cd_ccr, dt_grc_atb, nr_lte_atb, nr_ctr_atb, nr_seq_atb, vrs_lyt_atb, st_atb, nr_ted_atb, nr_doc_atb, vl_atb)
      values(vl_codigo_arquivo, vp_codigo_conta_corrente, now(), 0, vl_rg_ccr.nr_ctr_ccr, vl_sequencia_arquivo, ct_versao_layout, ct_st_atb_enviado, vl_qnt_ted, vl_qnt_doc, vl_total_arquivo);

      -- inserir lancamento na conta do banco
      select prm.vl_prm
        into vl_conta_transferencia
      from sc_cad.tbl_prm prm
      where prm.nm_prm = 'CONTA_TRANSFERENCIA';

      select ccr.cd_cnt
        into vl_conta_corrente
      from sc_fin.tbl_ccr ccr
      where cd_ccr = vp_codigo_conta_corrente;

      select sum(tba.vl_tba)
        into vl_valor_total_transferencia
      from sc_atb.tbl_tba tba
      where tba.st_tba = 2
        and tba.cd_ccr = vp_codigo_conta_corrente;

      select vl_prm
        into vl_tipo_lancamento_transferencia
      from sc_cad.tbl_prm prm
      where nm_prm = 'TIPO_LANCAMENTO_TRANSFERENCIA';

      perform sc_cnt.lancar_debito_credito(vl_conta_transferencia,vl_conta_corrente,vl_tipo_lancamento_transferencia,null::varchar,
                                           ('TRANSFERENCIA PARA CONTA DO BRADESCO, NSU: ' || vl_codigo_arquivo)::varchar,
                                           vl_valor_total_transferencia,current_timestamp::timestamp without time zone,1::numeric,ct_sistema_transferencia,vl_codigo_arquivo);

      --obtendo os dados do arquivo que acabou de ser incluido
      select *
      into vl_rg_atb
      from sc_atb.tbl_atb
      where cd_atb = vl_codigo_arquivo;
        
      vl_linha := sc_atb.gera_header_arquivo_bradesco(vl_rg_ccr, vl_rg_atb, vl_razao_social);
      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
      vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 1;

      perform sc_atb.processa_detalhe_arquivo_bradesco(vl_codigo_arquivo, vl_nome_arquivo, vl_rg_ccr.cd_ccr);

      select count(*)
      into vl_qtde_transferencia
      from sc_atb.tbl_dtb
      where cd_atb = vl_codigo_arquivo;

      --gerando o trailler do arquivo de transferencia do banco BRADESCO
      perform sc_atb.gera_trailler_arquivo_bradesco(vl_nome_arquivo, vl_qtde_transferencia + 1, vl_valor_total_transferencia);

      -- inserindo registro na tabela de download de arquivo
      insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_download_arquivo,now(),now(),ct_tipo_download_pagfor,1);    
    end if;
  end if;
end;$$;


ALTER FUNCTION sc_atb.gerar_arquivo_transferencia_bradesco(vp_codigo_conta_corrente numeric) OWNER TO postgres;

--
-- TOC entry 7668 (class 0 OID 0)
-- Dependencies: 1162
-- Name: FUNCTION gerar_arquivo_transferencia_bradesco(vp_codigo_conta_corrente numeric); Type: COMMENT; Schema: sc_atb; Owner: postgres
--

COMMENT ON FUNCTION gerar_arquivo_transferencia_bradesco(vp_codigo_conta_corrente numeric) IS 'rotina responsavel por obter todoas as transferencias bancarias autorizadas (SC_ATB.TBL_TBA) e gerar um arquivo de realização de transferencia ao banco definido pelo atributo conta corrente (CD_CCR)';


--
-- TOC entry 1846 (class 1255 OID 1635249)
-- Name: gerar_arquivo_transferencia_bradesco2(numeric, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION gerar_arquivo_transferencia_bradesco2(vp_codigo_conta_corrente numeric, vp_codigo_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg_ccr sc_fin.tbl_ccr%rowtype;
  vl_rg_atb sc_atb.tbl_atb%rowtype;
  vl_rg_dtb sc_atb.tbl_dtb%rowtype;
  
  vl_qtde_transferencia numeric;
  vl_qtde_registros_arquivo numeric := 0;
  vl_codigo_arquivo numeric;
  vl_sequencia_arquivo numeric;
  
  vl_numero_lote numeric := 0;
  vl_sequencia_lote numeric := 0;
  vl_soma_lote numeric;

  vl_diretorio varchar;
  vl_nome_arquivo varchar;
  vl_nome_download_arquivo varchar;
  vl_linha varchar;

  vl_conta_transferencia numeric;
  vl_conta_corrente numeric;
  vl_tipo_lancamento_transferencia numeric;
  vl_valor_total_transferencia double precision;

  vl_qnt_ted numeric;
  vl_qnt_doc numeric;
  vl_qnt_transferencia numeric;
  vl_total_arquivo numeric(13,2);
  vl_minimo_ted numeric;

  vl_razao_social varchar;

  --constantes
  ct_banco_bradesco constant numeric := 237;  

  ct_situacao_autorizado constant numeric := 2;
  ct_situacao_enviado constant numeric := 4;

  ct_st_atb_gerado constant numeric := 1;
  ct_st_atb_enviado constant numeric := 2;
  ct_situacao_cancelado constant numeric := 4;
  ct_versao_layout constant numeric := 20;

  ct_sistema_transferencia numeric := 22;

  ct_tipo_download_pagfor numeric := 10;

  ct_diretorio_arq_transferencia constant varchar := 'DIRETORIO_ARQUIVO_TRANSFERENCIA_BRADESCO';
  ct_valor_minimo_ted varchar := 'VL_MINIMO_TED';
begin
  --verificando se existem transferencia bancarias autorizadas para serem enviadas a conta corrente passada como parametro		
	select count(*)
	  into vl_qtde_transferencia
  from sc_atb.tbl_dtb dtb
	where dtb.cd_atb = vp_codigo_arquivo;

  --se existir continuar gerando o arquivo, caso contrario nao faz nada
  if vl_qtde_transferencia > 0 then
    --obtendo os dados da tabela de conta corrente
    select ccr.*
    into vl_rg_ccr
    from sc_fin.tbl_ccr ccr
      inner join sc_cad.tbl_cun cun on cun.cd_cun = ccr.cd_cun
    where cd_ccr = vp_codigo_conta_corrente
      and nr_ctr_ccr is not null;

    select nm_cun
    into vl_razao_social
    from sc_cad.tbl_cun
    where cd_cun = vl_rg_ccr.cd_cun;  
    
    --verificando se o codigo do banco e BRADESCO
    if vl_rg_ccr.cd_bnc = ct_banco_bradesco then
      -- Obtendo os parametros
      select prm.vl_prm
      into vl_diretorio
      from sc_cad.tbl_prm prm
      where prm.nm_prm = ct_diretorio_arq_transferencia;

			--obtendo a sequencia atual do arquivo
      select COALESCE(max(nr_seq_atb), 0)
      into vl_sequencia_arquivo
      from sc_atb.tbl_atb
      where st_atb <> ct_situacao_cancelado
        and cd_ccr = vp_codigo_conta_corrente;

      --definindo o nome do arquivo
      vl_nome_download_arquivo := 'PG' || to_char(current_date, 'ddmm') || vl_sequencia_arquivo || '.rem';
      vl_nome_arquivo := vl_diretorio || '\\' || vl_nome_download_arquivo;

      --excluindo arquivo caso exista
      perform sc_arq.excluirarquivo(vl_nome_arquivo);        
			
      select sum(tba.vl_tba)
        into vl_valor_total_transferencia
      from sc_atb.tbl_tba tba
			inner join sc_atb.tbl_dtb dtb on dtb.cd_dtb = tba.cd_dtb
      where dtb.cd_atb = vp_codigo_arquivo
        and tba.cd_ccr = vp_codigo_conta_corrente;

			--obtendo os dados do arquivo que acabou de ser incluido
      select *
      into vl_rg_atb
      from sc_atb.tbl_atb
      where cd_atb = vp_codigo_arquivo;
        
      vl_linha := sc_atb.gera_header_arquivo_bradesco(vl_rg_ccr, vl_rg_atb, vl_razao_social);
      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
      vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 1;

      perform sc_atb.gera_detalhe_arquivo_bradesco(vp_codigo_arquivo, vl_nome_arquivo, vl_rg_ccr.cd_ccr);
			
			select count(*)
      into vl_qtde_transferencia
      from sc_atb.tbl_dtb
      where cd_atb = vp_codigo_arquivo;

      --gerando o trailler do arquivo de transferencia do banco BRADESCO
      perform sc_atb.gera_trailler_arquivo_bradesco(vl_nome_arquivo, vl_qtde_transferencia + 1, vl_valor_total_transferencia);

      -- inserindo registro na tabela de download de arquivo
      insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_download_arquivo,now(),now(),ct_tipo_download_pagfor,1);    
    end if;
  end if;
end;$$;


ALTER FUNCTION sc_atb.gerar_arquivo_transferencia_bradesco2(vp_codigo_conta_corrente numeric, vp_codigo_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1157 (class 1255 OID 564153)
-- Name: gerar_arquivo_transferencia_hsbc(numeric); Type: FUNCTION; Schema: sc_atb; Owner: postgres
--

CREATE FUNCTION gerar_arquivo_transferencia_hsbc(vp_codigo_conta_corrente numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg_ccr sc_fin.tbl_ccr%rowtype;
  vl_rg_atb sc_atb.tbl_atb%rowtype;
  vl_rg_dtb sc_atb.tbl_dtb%rowtype;
  
  vl_qtde_transferencia numeric;
  vl_qtde_registros_arquivo numeric := 0;
  vl_codigo_arquivo numeric;
  vl_sequencia_arquivo numeric;
  
  vl_numero_lote numeric := 0;
  vl_sequencia_lote numeric := 0;
  vl_soma_lote numeric;

  vl_diretorio varchar;
  vl_nome_arquivo varchar;
  vl_nome_download_arquivo varchar;
  vl_linha varchar;

  vl_conta_transferencia numeric;
  vl_conta_corrente numeric;
  vl_tipo_lancamento_transferencia numeric;
  vl_valor_total_transferencia double precision;

  vl_qnt_ted numeric;
  vl_qnt_doc numeric;
  vl_total_arquivo numeric(13,2);

  --constantes
  ct_banco_hsbc constant numeric := 399;

  ct_situacao_autorizado constant numeric := 2;
  ct_situacao_enviado constant numeric := 4;

  ct_st_atb_gerado constant numeric := 1;
  ct_st_atb_enviado constant numeric := 2;
  ct_situacao_cancelado constant numeric := 4;
  ct_versao_layout constant numeric := 20;

  ct_sistema_transferencia numeric := 22;

  ct_diretorio_arq_transferencia constant varchar := 'DIRETORIO_ARQUIVO_TRANSFERENCIA_HSBC';
begin
  --verificando se existem transferencia bancarias autorizadas para serem enviadas a conta corrente passada como parametro
  select count(*)
  into vl_qtde_transferencia
  from sc_atb.tbl_tba tba
  where tba.st_tba = ct_situacao_autorizado
    and tba.cd_ccr = vp_codigo_conta_corrente;

  --se existir continuar gerando o arquivo, caso contrario nao faz nada
  if vl_qtde_transferencia > 0 then
    --obtendo os dados da tabela de conta corrente
    select * 
    into vl_rg_ccr
    from sc_fin.tbl_ccr 
    where cd_ccr = vp_codigo_conta_corrente
      and nr_ctr_ccr is not null;
    
    --verificando se o codigo do banco e HSBC
    if vl_rg_ccr.cd_bnc = ct_banco_hsbc then
      -- Obtendo os parametros
      select prm.vl_prm
      into vl_diretorio
      from sc_cad.tbl_prm prm
      where prm.nm_prm = ct_diretorio_arq_transferencia;
  
      --obtendo o codigo do arquivo
      select nextval('sc_atb.sq_atb') into vl_codigo_arquivo;

      --definindo o nome do arquivo
      vl_nome_download_arquivo := 'HSBC' || trim(to_char(vl_codigo_arquivo, repeat('0', 4))) || '.txt';
      vl_nome_arquivo := vl_diretorio || '\\' || vl_nome_download_arquivo;

      --obtendo a sequencia atual do arquivo
      select COALESCE(max(nr_seq_atb), 0) + 1
      into vl_sequencia_arquivo
      from sc_atb.tbl_atb
      where st_atb <> ct_situacao_cancelado;
        
      --inserindo um registro na tabela de arquivo de transferencia bancaria
      select sum(case when tba.vl_tba >= 5000 then 1 else 0 end), sum(case when tba.vl_tba < 5000 then 1 else 0 end), sum(tba.vl_tba)
        into vl_qnt_ted, vl_qnt_doc, vl_total_arquivo
      from sc_atb.tbl_tba tba
      where tba.st_tba = ct_situacao_autorizado
        and tba.cd_ccr = vp_codigo_conta_corrente;

      insert into sc_atb.tbl_atb(cd_atb, cd_ccr, dt_grc_atb, nr_lte_atb, nr_ctr_atb, nr_seq_atb, vrs_lyt_atb, st_atb, nr_ted_atb, nr_doc_atb, vl_atb)
      values(vl_codigo_arquivo, vp_codigo_conta_corrente, now(), 0, vl_rg_ccr.nr_ctr_ccr, vl_sequencia_arquivo, ct_versao_layout, ct_st_atb_enviado, vl_qnt_ted, vl_qnt_doc, vl_total_arquivo);

      -- inserir lancamento na conta do banco
      select prm.vl_prm
        into vl_conta_transferencia
      from sc_cad.tbl_prm prm
      where prm.nm_prm = 'CONTA_TRANSFERENCIA';

      select ccr.cd_cnt
        into vl_conta_corrente
      from sc_fin.tbl_ccr ccr
      where cd_ccr = vp_codigo_conta_corrente;

      select sum(tba.vl_tba)
        into vl_valor_total_transferencia
      from sc_atb.tbl_tba tba
      where tba.st_tba = 2
        and tba.cd_ccr = vp_codigo_conta_corrente;

      select vl_prm
        into vl_tipo_lancamento_transferencia
      from sc_cad.tbl_prm prm
      where nm_prm = 'TIPO_LANCAMENTO_TRANSFERENCIA';

      perform sc_cnt.lancar_debito_credito(vl_conta_transferencia,vl_conta_corrente,vl_tipo_lancamento_transferencia,null::varchar,
                                           ('TRANSFERENCIA PARA CONTA DO HSBC, NSU: ' || vl_codigo_arquivo)::varchar,
                                           vl_valor_total_transferencia,current_timestamp::timestamp without time zone,1::numeric,ct_sistema_transferencia,vl_codigo_arquivo);

      --obtendo os dados do arquivo que acabou de ser incluido
      select *
      into vl_rg_atb
      from sc_atb.tbl_atb
      where cd_atb = vl_codigo_arquivo;
        
      --gerando o header do arquivo de transferencia do banco HSBC
      vl_linha := sc_atb.gera_header_arquivo_hsbc(vl_rg_ccr, vl_rg_atb);
      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
      vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 1;

      --gerando lote de transferencia - inicio *****************************
      --verificando se existem transferencia bancarias autorizadas do tipo "transferencia"
      select count(*)
      into vl_qtde_transferencia
      from sc_atb.tbl_tba tba
      where tba.st_tba = 2
	and tba.cd_ccr = vp_codigo_conta_corrente
	and tba.cd_bnc = ct_banco_hsbc;

      if vl_qtde_transferencia > 0 then
        --gerando o header do lote do arquivo de transferencia do banco HSBC (do tipo "transferencia")
        vl_numero_lote := vl_numero_lote + 1;
        vl_linha := sc_atb.gera_header_lote_arquivo_hsbc(vl_rg_ccr, vl_numero_lote, 'S');
        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 1;

        --obtendo todas as transferencias que devem ser inclusas no arquivo
        vl_sequencia_lote := 0;
        vl_soma_lote := 0;
        for vl_rg_dtb in select nextval('sc_atb.sq_dtb'), vl_codigo_arquivo, cd_bnc, nr_agc_tba, nr_dgt_agc_tba, 
                                nr_cba_tba, nr_dgt_cba_tba, tp_cba_tba, nr_cpf_cnpj_tba, tp_pss_tba, nm_tba,  
                                2 as situacao, sum(vl_tba) as valor
                         from sc_atb.tbl_tba 
                         where st_tba = ct_situacao_autorizado
                           and cd_ccr = vp_codigo_conta_corrente
                           and cd_bnc = ct_banco_hsbc
                         group by cd_bnc, nr_agc_tba, nr_dgt_agc_tba, nr_cba_tba, nr_dgt_cba_tba, 
                                  nr_cpf_cnpj_tba, nm_tba, tp_pss_tba, tp_cba_tba loop
          perform sc_atb.processa_detalhe_arquivo(vl_rg_dtb, vl_nome_arquivo, vp_codigo_conta_corrente, vl_sequencia_lote, vl_numero_lote);
          vl_sequencia_lote := vl_sequencia_lote + 2;
          vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 2;
          vl_soma_lote := vl_soma_lote + vl_rg_dtb.vl_dtb;
        end loop;
        --gerando o trailler do lote do arquivo de transferencia do banco HSBC
        vl_linha := sc_atb.gera_trailler_lote_arquivo_hsbc(vl_numero_lote, vl_sequencia_lote + 2, vl_soma_lote);
        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 1;
      end if;
      --gerando lote de transferencia - final ********************************

      --gerando lote de doc/ted - inicio *****************************
      --verificando se existem transferencia bancarias autorizadas do tipo "transferencia"
      select count(*)
      into vl_qtde_transferencia
      from sc_atb.tbl_tba tba
      where tba.st_tba = 2
	and tba.cd_ccr = vp_codigo_conta_corrente
	and tba.cd_bnc <> ct_banco_hsbc;

      if vl_qtde_transferencia > 0 then
        --gerando o header do lote do arquivo de transferencia do banco HSBC (do tipo "transferencia")
        vl_numero_lote := vl_numero_lote + 1;
        vl_linha := sc_atb.gera_header_lote_arquivo_hsbc(vl_rg_ccr, vl_numero_lote, 'N');
        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 1;

        --obtendo todas as transferencias que devem ser inclusas no arquivo
        vl_sequencia_lote := 0;
        vl_soma_lote := 0;
        for vl_rg_dtb in select nextval('sc_atb.sq_dtb'), vl_codigo_arquivo, cd_bnc, nr_agc_tba, nr_dgt_agc_tba, 
                                nr_cba_tba, nr_dgt_cba_tba, tp_cba_tba, nr_cpf_cnpj_tba, tp_pss_tba, nm_tba,  
                                2 as situacao, sum(vl_tba) as valor
                         from sc_atb.tbl_tba 
                         where st_tba = ct_situacao_autorizado
                           and cd_ccr = vp_codigo_conta_corrente
                           and cd_bnc <> ct_banco_hsbc
                         group by cd_bnc, nr_agc_tba, nr_dgt_agc_tba, nr_cba_tba, nr_dgt_cba_tba, 
                                  nr_cpf_cnpj_tba, nm_tba, tp_pss_tba, tp_cba_tba loop
          perform sc_atb.processa_detalhe_arquivo(vl_rg_dtb, vl_nome_arquivo, vp_codigo_conta_corrente, vl_sequencia_lote, vl_numero_lote);
          vl_sequencia_lote := vl_sequencia_lote + 2;
          vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 2;
          vl_soma_lote := vl_soma_lote + vl_rg_dtb.vl_dtb;
        end loop;
        --gerando o trailler do lote do arquivo de transferencia do banco HSBC
        vl_linha := sc_atb.gera_trailler_lote_arquivo_hsbc(vl_numero_lote, vl_sequencia_lote + 2, vl_soma_lote);
        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 1;
      end if;
      --gerando lote de doc/ted - final ********************************
        
      --gerando o trailler do arquivo de transferencia do banco HSBC
      vl_linha := sc_atb.gera_trailler_arquivo_hsbc(vl_qtde_registros_arquivo - 1, vl_qtde_registros_arquivo + 1);
      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

      -- inserindo registro na tabela de download de arquivo
      insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_download_arquivo,now(),now(),1,1);    
    end if;
  end if;
end;$$;


ALTER FUNCTION sc_atb.gerar_arquivo_transferencia_hsbc(vp_codigo_conta_corrente numeric) OWNER TO postgres;

--
-- TOC entry 7669 (class 0 OID 0)
-- Dependencies: 1157
-- Name: FUNCTION gerar_arquivo_transferencia_hsbc(vp_codigo_conta_corrente numeric); Type: COMMENT; Schema: sc_atb; Owner: postgres
--

COMMENT ON FUNCTION gerar_arquivo_transferencia_hsbc(vp_codigo_conta_corrente numeric) IS 'rotina responsavel por obter todoas as transferencias bancarias autorizadas (SC_ATB.TBL_TBA) e gerar um arquivo de realização de transferencia ao banco definido pelo atributo conta corrente (CD_CCR)';


--
-- TOC entry 1756 (class 1255 OID 564155)
-- Name: inserir_transferencia(numeric, numeric, numeric, character varying, numeric, character varying, numeric, numeric, numeric, character varying, double precision, numeric, numeric, timestamp with time zone, numeric, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION inserir_transferencia(vp_codigo numeric, vp_banco numeric, vp_agencia numeric, vp_digito_agencia character varying, vp_conta numeric, vp_digito_conta character varying, vp_funcionario numeric, vp_nsu numeric, vp_conta_debito numeric, vp_motivo_cadastro character varying, vp_valor double precision, vp_tipo_conta numeric, vp_usuario_inclusao numeric, vp_data_inclusao timestamp with time zone, vp_cadastro_unico numeric DEFAULT NULL::numeric, vp_conta_corrente numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

vl_nome varchar;
vl_cpf_cnpj numeric;
vl_tipo_pessoa varchar;
vl_filial numeric;

vl_codigo numeric;
vl_conta_tarifa_transferencia numeric = 468;
vl_conta_transferencia numeric;
vl_tipo_lancamento_transferencia numeric;
vl_conta_corrente numeric;
vl_sistema numeric := 11; -- sistema de transferencia
vl_codigo_conta_corrente numeric;
vl_tipo_cobranca_pce_ctr numeric := 2; -- cobrar do funcionario
vl_cd_ctr numeric;

vl_valor_tarifa double precision;
vl_valor_tarifa_str varchar;

vl_quantidade_abono_contrato numeric;
vl_quantidade_abono_cartao numeric;

vl_existe_transferencia_gerada numeric;
vl_cartao numeric;

begin

  vl_codigo := vp_codigo;
  vl_valor_tarifa := 0;
  
  if vl_codigo is null or vl_codigo = 0 then
    select nextval('sc_atb.sq_tba') into vl_codigo;
  end if;

  	  -- tipo de lancamento de transferencia
	  select vl_prm
	    into vl_tipo_lancamento_transferencia
	  from sc_cad.tbl_prm prm
	  where nm_prm = 'TIPO_LANCAMENTO_TRANSFERENCIA';

	  -- conta de tarifa de transferencia
	  /*select vl_prm
	    into vl_conta_tarifa_transferencia
	  from sc_cad.tbl_prm prm
	  where nm_prm = 'CONTA_RECEITA';*/

	  -- conta de transferencia
	  select vl_prm
	    into vl_conta_transferencia
	  from sc_cad.tbl_prm prm
	  where nm_prm = 'CONTA_TRANSFERENCIA';

  if vp_funcionario is not null and vp_funcionario > 0 then
	   -- dados do funcionário
	  select cun.nm_cun, cun.nr_cpf_cnpj_cun, cun.tp_pss_cun, crt.cd_ctr, fnc.cd_fem, coalesce(crt.qtd_abn_trf_crt,0), crt.cd_crt
	    into vl_nome, vl_cpf_cnpj, vl_tipo_pessoa, vl_cd_ctr, vl_filial, vl_quantidade_abono_cartao, vl_cartao
	  from sc_cad.tbl_fnc fnc
	    inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
	    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	   inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
          where fnc.cd_fnc = vp_funcionario
             and cnt_crt.fg_pdr_cnt_crt = 'S';

	  -- valor da tarifa de transferencia
          vl_valor_tarifa_str := sc_cad.get_parametro_contrato_cartao(11, vl_cartao);
          vl_tipo_cobranca_pce_ctr := sc_cad.get_parametro_contrato_cartao(11,vl_cartao,3)::numeric;
          vl_quantidade_abono_contrato := sc_cad.get_parametro_contrato_cartao(30, vl_cartao)::numeric;

          vl_quantidade_abono_contrato := coalesce(vl_quantidade_abono_contrato,0);

          if vl_valor_tarifa_str is null then
            raise exception 'Não existe parametro de transferência para o contrato cadastrado.';
          end if;

          vl_valor_tarifa = replace(replace(vl_valor_tarifa_str, '.', ''), ',', '.');

	  -- verificar se existe alguma transferencia gerada, caso exista nao cobrar a tarifa
	  select count(*)
	    into vl_existe_transferencia_gerada
	  from sc_atb.tbl_tba tba
	  where tba.st_tba = 1 -- gerada
	    and tba.nr_cpf_cnpj_tba = vl_cpf_cnpj
	    and tba.cd_bnc = vp_banco
	    and tba.nr_agc_tba = vp_agencia
	    and tba.nr_dgt_agc_tba = vp_digito_agencia
	    and tba.nr_cba_tba = vp_conta
	    and tba.nr_dgt_cba_tba = vp_digito_conta;

	  if vl_existe_transferencia_gerada > 0 then
	    vl_valor_tarifa = 0;
	  end if;
  else
    -- dados do cadastro unico
    select cun.nm_cun, cun.nr_cpf_cnpj_cun, cun.tp_pss_cun
	  into vl_nome, vl_cpf_cnpj, vl_tipo_pessoa
    from sc_cad.tbl_cun cun 
    where cun.cd_cun = vp_cadastro_unico;
  end if;

  -- valor conta banco de transferencia
  if vp_conta_corrente is null or vp_conta_corrente <= 0 then
	  select vl_prm
	    into vl_conta_corrente
	  from sc_cad.tbl_prm prm
	  where nm_prm = 'CONTA_BANCO_TRANSFERENCIA';
  else
    vl_conta_corrente := vp_conta_corrente;
  end if;

  select ccr.cd_cnt
    into vl_codigo_conta_corrente
  from sc_fin.tbl_ccr ccr
  where ccr.cd_ccr = vl_conta_corrente;

    -- Abono de Transferencia
    -- Vitor Vasconcelos
    -- 21/10/2015

    if vl_valor_tarifa > 0 then

	    if vl_quantidade_abono_contrato > 0 then
	    
	      if vl_quantidade_abono_cartao < vl_quantidade_abono_contrato then
	      
		   update sc_opr.tbl_crt 
		   set qtd_abn_trf_crt = coalesce(qtd_abn_trf_crt,0) + 1 
		   where cd_crt = vl_cartao;

		   vl_valor_tarifa := 0;
	      end if;
	      
	    end if;
    end if;    
	    -- Fim Abono Transferencia

    
  -- inserir transferencia
  insert into sc_atb.tbl_tba(cd_tba, cd_ccr, cd_bnc, nr_agc_tba, nr_dgt_agc_tba, nr_cba_tba, nr_dgt_cba_tba, nr_cpf_cnpj_tba,
            		     nm_tba, tp_pss_tba, cd_sst, nr_nsu_org_tba, cd_dbt_cnt, cd_crd_cnt, ds_mtv_cad_tba,
  			     vl_tba, vl_trf_tba, tp_cba_tba, cd_inc_usr, dt_inc_usr)
    values (vl_codigo, vl_conta_corrente, vp_banco, vp_agencia, vp_digito_agencia, vp_conta, vp_digito_conta, vl_cpf_cnpj,
            vl_nome, vl_tipo_pessoa, vl_sistema, vp_nsu, vp_conta_debito, vl_codigo_conta_corrente, vp_motivo_cadastro,
  	    vp_valor, vl_valor_tarifa, vp_tipo_conta, vp_usuario_inclusao, vp_data_inclusao);
  		  
  -- inserir lancamento de transferencia
  vp_motivo_cadastro := vp_motivo_cadastro || '\n(BC: ' || vp_banco || ' AG: ' || vp_agencia || ' CC: ' || vp_conta || '-' || vp_digito_conta || ')';
  
  perform sc_cnt.lancar_debito_credito(vp_conta_debito, vl_conta_transferencia, vl_tipo_lancamento_transferencia,
                                       null, vp_motivo_cadastro, vp_valor, current_timestamp::timestamp without time zone,
                                       vp_usuario_inclusao, vl_sistema, vl_codigo);

  if vl_valor_tarifa > 0 then

    -- verificar se cobra da empresa ou do funcionario
    if vl_tipo_cobranca_pce_ctr = 1 then -- empresa

      -- inserir tarifa na empresa
      insert into sc_atb.tbl_etb (cd_etb, cd_tba, cd_ctr, vl_trf_etb, cd_fnc, fg_cbr_etb)
        values (nextval('sc_atb.sq_etb'), vl_codigo, vl_cd_ctr, vl_valor_tarifa, vp_funcionario, 'S');

    else
      -- inserir lancamento de tarifa
      perform sc_cnt.lancar_debito_credito(vp_conta_debito, vl_conta_tarifa_transferencia, vl_tipo_lancamento_transferencia,
                                           null, vp_motivo_cadastro, vl_valor_tarifa, current_timestamp::timestamp without time zone,
                                           vp_usuario_inclusao, vl_sistema, vl_codigo);
   end if;
  end if;

end;$$;


ALTER FUNCTION sc_atb.inserir_transferencia(vp_codigo numeric, vp_banco numeric, vp_agencia numeric, vp_digito_agencia character varying, vp_conta numeric, vp_digito_conta character varying, vp_funcionario numeric, vp_nsu numeric, vp_conta_debito numeric, vp_motivo_cadastro character varying, vp_valor double precision, vp_tipo_conta numeric, vp_usuario_inclusao numeric, vp_data_inclusao timestamp with time zone, vp_cadastro_unico numeric, vp_conta_corrente numeric) OWNER TO scan;

--
-- TOC entry 1833 (class 1255 OID 1634121)
-- Name: inserir_transferencia_generica(numeric, numeric, numeric, character varying, numeric, character varying, numeric, numeric, character varying, double precision, numeric, numeric, timestamp with time zone, character varying, numeric, character varying); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION inserir_transferencia_generica(vp_codigo numeric, vp_banco numeric, vp_agencia numeric, vp_digito_agencia character varying, vp_conta numeric, vp_digito_conta character varying, vp_nsu numeric, vp_conta_debito numeric, vp_motivo_cadastro character varying, vp_valor double precision, vp_tipo_conta numeric, vp_usuario_inclusao numeric, vp_data_inclusao timestamp with time zone, vp_nome_transferencia character varying, vp_cpf_cnpj numeric, vp_tipo_pessoa character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

vl_codigo numeric;
vl_conta_tarifa_transferencia numeric = 468;
vl_conta_transferencia numeric;
vl_tipo_lancamento_transferencia numeric;
vl_conta_corrente numeric;
vl_sistema numeric := 11; -- sistema de transferencia
vl_codigo_conta_corrente numeric;

begin

  vl_codigo := vp_codigo;
  
  if vl_codigo is null or vl_codigo = 0 then
    select nextval('sc_atb.sq_tba') into vl_codigo;
  end if;

  -- tipo de lancamento de transferencia
  select vl_prm
    into vl_tipo_lancamento_transferencia
  from sc_cad.tbl_prm prm
  where nm_prm = 'TIPO_LANCAMENTO_TRANSFERENCIA';

  -- conta de tarifa de transferencia
  /*select vl_prm
    into vl_conta_tarifa_transferencia
  from sc_cad.tbl_prm prm
  where nm_prm = 'CONTA_RECEITA';*/

  -- conta de transferencia
  select vl_prm
    into vl_conta_transferencia
  from sc_cad.tbl_prm prm
  where nm_prm = 'CONTA_TRANSFERENCIA';

  -- valor conta banco de transferencia
  select vl_prm
    into vl_conta_corrente
  from sc_cad.tbl_prm prm
  where nm_prm = 'CONTA_BANCO_TRANSFERENCIA';

  select ccr.cd_cnt
    into vl_codigo_conta_corrente
  from sc_fin.tbl_ccr ccr
  where ccr.cd_ccr = vl_conta_corrente;
    
  -- inserir transferencia
  insert into sc_atb.tbl_tba(cd_tba, cd_ccr, cd_bnc, nr_agc_tba, nr_dgt_agc_tba, nr_cba_tba, nr_dgt_cba_tba, nr_cpf_cnpj_tba,
            	nm_tba, tp_pss_tba, cd_sst, nr_nsu_org_tba, cd_dbt_cnt, cd_crd_cnt, ds_mtv_cad_tba,
  			    vl_tba, vl_trf_tba, tp_cba_tba, cd_inc_usr, dt_inc_usr)
    values (vl_codigo, vl_conta_corrente, vp_banco, vp_agencia, vp_digito_agencia, vp_conta, vp_digito_conta, vp_cpf_cnpj,
            vp_nome_transferencia, vp_tipo_pessoa, vl_sistema, vp_nsu, vp_conta_debito, vl_codigo_conta_corrente, vp_motivo_cadastro,
  	    vp_valor, 0.0, vp_tipo_conta, vp_usuario_inclusao, vp_data_inclusao);
  		  
  -- inserir lancamento de transferencia
  vp_motivo_cadastro := vp_motivo_cadastro || '(BC: ' || vp_banco || ' AG: ' || vp_agencia || ' CC: ' || vp_conta || '-' || vp_digito_conta || ')';
  
  perform sc_cnt.lancar_debito_credito(vp_conta_debito, vl_conta_transferencia, vl_tipo_lancamento_transferencia,
                                       null, vp_motivo_cadastro, vp_valor, current_timestamp::timestamp without time zone,
                                       vp_usuario_inclusao, vl_sistema, vl_codigo);
                                       
end;$$;


ALTER FUNCTION sc_atb.inserir_transferencia_generica(vp_codigo numeric, vp_banco numeric, vp_agencia numeric, vp_digito_agencia character varying, vp_conta numeric, vp_digito_conta character varying, vp_nsu numeric, vp_conta_debito numeric, vp_motivo_cadastro character varying, vp_valor double precision, vp_tipo_conta numeric, vp_usuario_inclusao numeric, vp_data_inclusao timestamp with time zone, vp_nome_transferencia character varying, vp_cpf_cnpj numeric, vp_tipo_pessoa character varying) OWNER TO scan;

--
-- TOC entry 1195 (class 1255 OID 564158)
-- Name: montar_cpf_cnpj(character varying, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION montar_cpf_cnpj(vp_tipo_pessoa character varying, vp_cpf_cnpj numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
   vl_cpf_cnpj_aux varchar;
   vl_cpf_cnpj_rej varchar;

   ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
   ALINHAMENTO_A_DIREITA numeric(2,0) := 1; 
   
begin

   if vp_tipo_pessoa = 'J' then

      vl_cpf_cnpj_aux := sc_arq.preencher(14,vp_cpf_cnpj,'0',ALINHAMENTO_A_ESQUERDA);
      vl_cpf_cnpj_rej := sc_arq.preencher(9,substr(vl_cpf_cnpj_aux,1,8),'0',ALINHAMENTO_A_ESQUERDA);
      vl_cpf_cnpj_rej := vl_cpf_cnpj_rej || sc_arq.preencher(4,substr(vl_cpf_cnpj_aux,9,4),'0',ALINHAMENTO_A_ESQUERDA);
      vl_cpf_cnpj_rej := vl_cpf_cnpj_rej || sc_arq.preencher(2,substr(vl_cpf_cnpj_aux,13,2),'0',ALINHAMENTO_A_ESQUERDA);
      
   elsif vp_tipo_pessoa = 'F' then

      vl_cpf_cnpj_aux := sc_arq.preencher(11,vp_cpf_cnpj,'0',ALINHAMENTO_A_ESQUERDA);
      vl_cpf_cnpj_rej := sc_arq.preencher(9,substr(vl_cpf_cnpj_aux,1,9),'0',ALINHAMENTO_A_ESQUERDA);
      vl_cpf_cnpj_rej := vl_cpf_cnpj_rej || sc_arq.repetir('0',4);
      vl_cpf_cnpj_rej := vl_cpf_cnpj_rej || sc_arq.preencher(2,substr(vl_cpf_cnpj_aux,10,2),'0',ALINHAMENTO_A_ESQUERDA);
   
   end if;  

   return vl_cpf_cnpj_rej;
   
end$$;


ALTER FUNCTION sc_atb.montar_cpf_cnpj(vp_tipo_pessoa character varying, vp_cpf_cnpj numeric) OWNER TO scan;

--
-- TOC entry 1196 (class 1255 OID 564159)
-- Name: processa_arquivo_retorno(); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION processa_arquivo_retorno() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg sc_atb.tbl_art%rowtype;

  ct_st_recebido constant numeric := 1;
begin
  for vl_rg in select *
               from sc_atb.tbl_art
               where st_art = ct_st_recebido loop
    perform sc_atb.processa_arquivo_retorno(vl_rg);
  end loop;
end;$$;


ALTER FUNCTION sc_atb.processa_arquivo_retorno() OWNER TO scan;

--
-- TOC entry 7670 (class 0 OID 0)
-- Dependencies: 1196
-- Name: FUNCTION processa_arquivo_retorno(); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION processa_arquivo_retorno() IS 'rotina que processa todos os arquivos de retorno de transferencia bancaria com a situacao recebido';


--
-- TOC entry 1199 (class 1255 OID 564166)
-- Name: processa_arquivo_retorno(numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION processa_arquivo_retorno(vp_codigo_arquivo_retorno numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  ct_st_recebido constant numeric := 1;

  vl_existe numeric;
  vl_rg sc_atb.tbl_art%rowtype;
begin
  select count(*)
  into vl_existe
  from sc_atb.tbl_art
  where st_art = ct_st_recebido
    and cd_art = vp_codigo_arquivo_retorno;

  if vl_existe = 1 then
    select *
    into vl_rg
    from sc_atb.tbl_art
    where st_art = ct_st_recebido
      and cd_art = vp_codigo_arquivo_retorno;

    perform sc_atb.processa_arquivo_retorno(vl_rg);
  end if;
end;$$;


ALTER FUNCTION sc_atb.processa_arquivo_retorno(vp_codigo_arquivo_retorno numeric) OWNER TO scan;

--
-- TOC entry 7671 (class 0 OID 0)
-- Dependencies: 1199
-- Name: FUNCTION processa_arquivo_retorno(vp_codigo_arquivo_retorno numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION processa_arquivo_retorno(vp_codigo_arquivo_retorno numeric) IS 'rotina que processa um determinado arquivo de retorno de transferencia bancaria';


--
-- TOC entry 223 (class 1259 OID 564160)
-- Name: tbl_art; Type: TABLE; Schema: sc_atb; Owner: scan
--

CREATE TABLE tbl_art (
    cd_art numeric(10,0) NOT NULL,
    st_art numeric(2,0) DEFAULT 1 NOT NULL,
    dt_rcb_art timestamp without time zone NOT NULL,
    cd_rcb_usr numeric(10,0),
    cd_bnc numeric(5,0) NOT NULL,
    tp_pss_art numeric(1,0) NOT NULL,
    cpf_cnpj_art numeric(14,0) NOT NULL,
    nr_ctr_art numeric(6,0) NOT NULL,
    cd_agc_art numeric(5,0) NOT NULL,
    cd_ccr_art numeric(12,0) NOT NULL,
    nr_seq_art numeric(6,0),
    cd_mtv_inv_art numeric(2,0),
    tp_art numeric(2,0) NOT NULL,
    dt_prc_art timestamp with time zone,
    dt_grc_art timestamp without time zone NOT NULL,
    CONSTRAINT ck_tp_pss_art CHECK ((tp_pss_art = ANY (ARRAY[(1)::numeric, (2)::numeric])))
);


ALTER TABLE tbl_art OWNER TO scan;

--
-- TOC entry 7672 (class 0 OID 0)
-- Dependencies: 223
-- Name: TABLE tbl_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON TABLE tbl_art IS 'tabela de arquivo de retorno de transferência';


--
-- TOC entry 7673 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.cd_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.cd_art IS 'código';


--
-- TOC entry 7674 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.st_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.st_art IS 'situacao (ver tabela de dominio)';


--
-- TOC entry 7675 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.dt_rcb_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.dt_rcb_art IS 'data de recebimento';


--
-- TOC entry 7676 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.cd_rcb_usr; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.cd_rcb_usr IS 'usuario de recebimento';


--
-- TOC entry 7677 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.cd_bnc; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.cd_bnc IS 'banco';


--
-- TOC entry 7678 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.tp_pss_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.tp_pss_art IS 'tipo de pessoa';


--
-- TOC entry 7679 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.cpf_cnpj_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.cpf_cnpj_art IS 'cpf/cnpj do titular da conta de origem';


--
-- TOC entry 7680 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.nr_ctr_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.nr_ctr_art IS 'numero do contrato de transferencia';


--
-- TOC entry 7681 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.cd_agc_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.cd_agc_art IS 'agencia da conta de origem';


--
-- TOC entry 7682 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.cd_ccr_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.cd_ccr_art IS 'conta corrente de origem';


--
-- TOC entry 7683 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.nr_seq_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.nr_seq_art IS 'numero sequencial do arquivo';


--
-- TOC entry 7684 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.cd_mtv_inv_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.cd_mtv_inv_art IS 'codigo do motivo de invalidacao (ver tabela de dominio)';


--
-- TOC entry 7685 (class 0 OID 0)
-- Dependencies: 223
-- Name: COLUMN tbl_art.tp_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_art.tp_art IS 'tipo do arquivo (ver tabela de dominio)';


--
-- TOC entry 1198 (class 1255 OID 564165)
-- Name: processa_arquivo_retorno(tbl_art); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION processa_arquivo_retorno(vp_arquivo_retorno tbl_art) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_existe numeric;
  vl_validacao numeric;
  vl_codigo_arquivo_transferencia numeric;
  vl_situacao_arquivo_transferencia numeric;
  vl_rg sc_atb.tbl_drt%rowtype;

  --situacoes do arquivo de remessa de transferencia
  ct_st_gerado constant numeric := 1;
  ct_st_enviado constant numeric := 2;
  ct_st_processado_retorno numeric := 3;
  ct_st_cancelado constant numeric := 4;
  
  --situacoes do arquivo de retorno de transferencia
  ct_st_processado constant numeric := 2;
  ct_st_invalidado constant numeric := 4;

  --situacoes do detalhe do arquivo de retorno de transferencia
  ct_st_recebido constant numeric := 1;
  
  ct_sucesso constant numeric := 0;
  ct_arquivo_nao_encontrado constant numeric := 1;
  ct_arquivo_ja_processado constant numeric := 2;
  ct_varios_arquivos constant numeric := 3;
  ct_arquivo_nao_enviado constant numeric := 4;

  ct_st_confirmacao constant numeric := 2;
  ct_st_confirmacao_bradesco constant numeric := 3;

  ct_banco_hsbc constant numeric := 399;
  ct_banco_bradesco constant numeric := 237;
  
begin
  if vp_arquivo_retorno.cd_bnc not in( ct_banco_hsbc, ct_banco_bradesco) then
    select count(*)
    into vl_existe
    from sc_atb.tbl_atb atb
         inner join sc_fin.tbl_ccr ccr on atb.cd_ccr = ccr.cd_ccr
    where atb.nr_seq_atb = vp_arquivo_retorno.nr_seq_art
      and atb.st_atb <> ct_st_cancelado
      and ccr.cd_bnc = vp_arquivo_retorno.cd_bnc
      and ccr.nr_ctr_ccr = vp_arquivo_retorno.nr_ctr_art;

    vl_validacao := ct_sucesso;
    if vl_existe = 0 then
      vl_validacao := ct_arquivo_nao_encontrado;
    end if;

    if vl_existe > 1 then
      vl_validacao := ct_varios_arquivos;
    end if;

    select atb.cd_atb, atb.st_atb
    into vl_codigo_arquivo_transferencia, vl_situacao_arquivo_transferencia
    from sc_atb.tbl_atb atb
         inner join sc_fin.tbl_ccr ccr on atb.cd_ccr = ccr.cd_ccr
    where atb.nr_seq_atb = vp_arquivo_retorno.nr_seq_art
      and atb.st_atb <> ct_st_cancelado
      and ccr.cd_bnc = vp_arquivo_retorno.cd_bnc
      and ccr.nr_ctr_ccr = vp_arquivo_retorno.nr_ctr_art;

    if vl_situacao_arquivo_transferencia = ct_st_processado_retorno then
      vl_validacao := ct_arquivo_ja_processado;
    end if;

    if vl_situacao_arquivo_transferencia = ct_st_gerado then
      vl_validacao := ct_arquivo_nao_enviado;
    end if;
  
    if vl_validacao <> ct_sucesso then
      update sc_atb.tbl_art
         set st_art = ct_st_invalidado,
             cd_mtv_inv_art = vl_validacao,
             dt_prc_art = now()
      where cd_art = vp_arquivo_retorno.cd_art;

      return;
    end if;
  end if;
  
  for vl_rg in select *
               from sc_atb.tbl_drt drt
               where drt.cd_art = vp_arquivo_retorno.cd_art
                 and drt.st_drt = ct_st_recebido loop
    perform sc_atb.processa_detalhe_arquivo_retorno(vl_rg, vp_arquivo_retorno.tp_art, vl_codigo_arquivo_transferencia);
  end loop;

  update sc_atb.tbl_art
     set st_art = ct_st_processado,
         dt_prc_art = now()
  where cd_art = vp_arquivo_retorno.cd_art;


end;$$;


ALTER FUNCTION sc_atb.processa_arquivo_retorno(vp_arquivo_retorno tbl_art) OWNER TO scan;

--
-- TOC entry 7686 (class 0 OID 0)
-- Dependencies: 1198
-- Name: FUNCTION processa_arquivo_retorno(vp_arquivo_retorno tbl_art); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION processa_arquivo_retorno(vp_arquivo_retorno tbl_art) IS 'rotina que processa um arquivo de retorno de transferencia bancaria';


--
-- TOC entry 1186 (class 1255 OID 564167)
-- Name: processa_detalhe_arquivo(tbl_dtb, character varying, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION processa_detalhe_arquivo(vp_detalhe_arquivo tbl_dtb, vp_nome_arquivo character varying, vp_codigo_conta_corrente numeric, vp_sequencia_lote numeric, vp_numero_lote numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_linha varchar;

  vl_tipo_transferencia numeric;
  vl_sequencia_lote numeric;
    
  ct_tipo_transf_ted constant numeric := 1;
  ct_tipo_transf_doc constant numeric := 2;

  ct_situacao_autorizado constant numeric := 2;
  ct_situacao_enviado constant numeric := 4;
  ct_banco_hsbc constant numeric := 399;
begin
  --inserindo o registro de detalhe
  insert into sc_atb.tbl_dtb(cd_dtb, cd_atb, cd_bnc, nr_agc_dtb, nr_dgt_agc_dtb, nr_cba_dtb, nr_dgt_cba_dtb, 
                             tp_cba_dtb, nr_cpf_cnpj_dtb, tp_pss_dtb, nm_dtb, st_dtb, vl_dtb)
  values(vp_detalhe_arquivo.cd_dtb, vp_detalhe_arquivo.cd_atb, vp_detalhe_arquivo.cd_bnc, vp_detalhe_arquivo.nr_agc_dtb, vp_detalhe_arquivo.nr_dgt_agc_dtb, vp_detalhe_arquivo.nr_cba_dtb, vp_detalhe_arquivo.nr_dgt_cba_dtb,
         vp_detalhe_arquivo.tp_cba_dtb, vp_detalhe_arquivo.nr_cpf_cnpj_dtb, vp_detalhe_arquivo.tp_pss_dtb, vp_detalhe_arquivo.nm_dtb, vp_detalhe_arquivo.st_dtb, vp_detalhe_arquivo.vl_dtb);

  --marcando as transferencias como enviadas
  update sc_atb.tbl_tba 
     set st_tba = ct_situacao_enviado,
         dt_env_tba = now(),
         cd_dtb = vp_detalhe_arquivo.cd_dtb
  where st_tba = ct_situacao_autorizado
    and cd_ccr = vp_codigo_conta_corrente
    and cd_bnc = vp_detalhe_arquivo.cd_bnc
    and nr_agc_tba = vp_detalhe_arquivo.nr_agc_dtb
    and nr_dgt_agc_tba = vp_detalhe_arquivo.nr_dgt_agc_dtb
    and nr_cba_tba = vp_detalhe_arquivo.nr_cba_dtb
    and nr_dgt_cba_tba = vp_detalhe_arquivo.nr_dgt_cba_dtb
    and tp_cba_tba = vp_detalhe_arquivo.tp_cba_dtb
    and nr_cpf_cnpj_tba = vp_detalhe_arquivo.nr_cpf_cnpj_dtb
    and tp_pss_tba = vp_detalhe_arquivo.tp_pss_dtb
    and nm_tba = vp_detalhe_arquivo.nm_dtb;
                      
   --gerando o detalhe do tipo A do arquivode transferencia do banco HSBC
   if vp_detalhe_arquivo.vl_dtb >= 1000 then
     vl_tipo_transferencia := ct_tipo_transf_ted;
   else
     vl_tipo_transferencia := ct_tipo_transf_doc;
   end if;
   vl_sequencia_lote := vp_sequencia_lote + 1;
   vl_linha := sc_atb.gera_detalhe_a_arquivo_hsbc(vp_detalhe_arquivo, vp_numero_lote, vl_sequencia_lote, vl_tipo_transferencia);
   perform sc_arq.gravarlinha(vp_nome_arquivo,vl_linha);
          
   --gerando o detalhe do tipo B do arquivode transferencia do banco HSBC
   vl_sequencia_lote := vl_sequencia_lote + 1;
   vl_linha := sc_atb.gera_detalhe_b_arquivo_hsbc(vp_detalhe_arquivo, vp_numero_lote, vl_sequencia_lote);
   perform sc_arq.gravarlinha(vp_nome_arquivo,vl_linha);
end;$$;


ALTER FUNCTION sc_atb.processa_detalhe_arquivo(vp_detalhe_arquivo tbl_dtb, vp_nome_arquivo character varying, vp_codigo_conta_corrente numeric, vp_sequencia_lote numeric, vp_numero_lote numeric) OWNER TO scan;

--
-- TOC entry 7687 (class 0 OID 0)
-- Dependencies: 1186
-- Name: FUNCTION processa_detalhe_arquivo(vp_detalhe_arquivo tbl_dtb, vp_nome_arquivo character varying, vp_codigo_conta_corrente numeric, vp_sequencia_lote numeric, vp_numero_lote numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION processa_detalhe_arquivo(vp_detalhe_arquivo tbl_dtb, vp_nome_arquivo character varying, vp_codigo_conta_corrente numeric, vp_sequencia_lote numeric, vp_numero_lote numeric) IS 'rotina responsavel por gerar as linhas de detalhe dentro do arquivo de transferencia e realizar todas as alteracoes de banco de dados necessarias';


--
-- TOC entry 1190 (class 1255 OID 564168)
-- Name: processa_detalhe_arquivo_bradesco(numeric, character varying, numeric); Type: FUNCTION; Schema: sc_atb; Owner: postgres
--

CREATE FUNCTION processa_detalhe_arquivo_bradesco(vp_codigo_arquivo numeric, vp_nome_arquivo character varying, vp_codigo_conta_corrente numeric, OUT vp_qtd_ted numeric, OUT vp_qtd_doc numeric, OUT vp_qtd_transferencia numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
  vl_linha varchar;

  vl_tipo_transferencia numeric;

  vl_qtde_registros_arquivo numeric;
    
  ct_tipo_transf_ted constant numeric := 1;
  ct_tipo_transf_doc constant numeric := 2;

  ct_situacao_autorizado constant numeric := 2;
  ct_situacao_enviado constant numeric := 4;
  ct_banco_bradesco numeric := 237;

  vl_qtd_transferencia numeric;
  vl_qtd_ted numeric;
  vl_qtd_doc numeric;

  vl_mod_pagamento numeric;

  ct_valor_min_ted numeric := 0;

  vl_cpf_cnpj varchar;
  vl_complemento_pagamento varchar;

  vl_rg_dtb record;

  ct_cod_bradesco numeric := 237;

  vl_digito_agencia varchar;

  ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
  ALINHAMENTO_A_DIREITA numeric(2,0) := 1;  
  
begin

        vl_qtde_registros_arquivo := 1;
        vl_qtd_transferencia := 0;
        vl_qtd_ted := 0;
        vl_qtd_doc := 0;

	for vl_rg_dtb in select nextval('sc_atb.sq_dtb') codigo, tba.cd_bnc, tba.nr_agc_tba, tba.nr_dgt_agc_tba, 
				tba.nr_cba_tba, tba.nr_dgt_cba_tba, tba.tp_cba_tba, tba.nr_cpf_cnpj_tba, tba.tp_pss_tba, tba.nm_tba, 
				2 as situacao, ccr.cd_cnt_ccr, sum(tba.vl_tba) as valor
			 from sc_atb.tbl_tba tba
			   inner join sc_fin.tbl_ccr ccr on ccr.cd_ccr = tba.cd_ccr
			 where tba.st_tba = ct_situacao_autorizado
			   and tba.cd_ccr = vp_codigo_conta_corrente
			 group by tba.cd_bnc, tba.nr_agc_tba, tba.nr_dgt_agc_tba, tba.nr_cba_tba, tba.nr_dgt_cba_tba, 
				  tba.nr_cpf_cnpj_tba, tba.nm_tba, tba.tp_pss_tba, tba.tp_cba_tba, ccr.cd_cnt_ccr loop

		vl_qtde_registros_arquivo := vl_qtde_registros_arquivo + 1;

		if vl_rg_dtb.cd_bnc = ct_banco_bradesco then
		
		   vl_qtd_transferencia := vl_qtd_transferencia + 1;
		   vl_mod_pagamento := 5;
		   
		else

		   if vl_rg_dtb.valor >= ct_valor_min_ted then
		      vl_mod_pagamento := 8;
		      vl_qtd_ted := vl_qtd_ted + 1;
		   else
		      vl_mod_pagamento := 3;
		      vl_qtd_doc := vl_qtd_doc + 1;
		   end if;
		   
		end if;

		vl_cpf_cnpj := sc_atb.montar_cpf_cnpj(vl_rg_dtb.tp_pss_tba,vl_rg_dtb.nr_cpf_cnpj_tba);

		if vl_mod_pagamento = 1 or vl_mod_pagamento = 5 then

                   vl_complemento_pagamento := sc_arq.repetir(' ',40);
                   
		elsif vl_mod_pagamento = 3 or vl_mod_pagamento = 8 then

		   vl_complemento_pagamento := 'C';
		   vl_complemento_pagamento := vl_complemento_pagamento || sc_arq.repetir('0',6);
		   vl_complemento_pagamento := vl_complemento_pagamento || '07';
		   vl_complemento_pagamento := vl_complemento_pagamento || '01';
		   vl_complemento_pagamento := vl_complemento_pagamento || sc_arq.repetir(' ',29);
		   
		end if; 

                -- calculando digito agencia caso banco for bradesco
                vl_digito_agencia := vl_rg_dtb.nr_dgt_agc_tba;

                if vl_rg_dtb.cd_bnc = ct_cod_bradesco then
                  vl_digito_agencia := sc_pbl.modulo11(vl_rg_dtb.nr_agc_tba::numeric)::varchar;
                end if;
                -- fim calculando digito agencia caso banco for bradesco

		insert into sc_atb.tbl_dtb(cd_dtb, cd_atb, cd_bnc, nr_agc_dtb, nr_dgt_agc_dtb, nr_cba_dtb, nr_dgt_cba_dtb, 
				     tp_cba_dtb, nr_cpf_cnpj_dtb, tp_pss_dtb, nm_dtb, st_dtb, vl_dtb)
		values(vl_rg_dtb.codigo, vp_codigo_arquivo, vl_rg_dtb.cd_bnc, vl_rg_dtb.nr_agc_tba, vl_digito_agencia::varchar, vl_rg_dtb.nr_cba_tba, vl_rg_dtb.nr_dgt_cba_tba,
		 vl_rg_dtb.tp_cba_tba, vl_rg_dtb.nr_cpf_cnpj_tba, vl_rg_dtb.tp_pss_tba, substring(trim(vl_rg_dtb.nm_tba),1,30), vl_rg_dtb.situacao, vl_rg_dtb.valor);

		update sc_atb.tbl_tba 
		set st_tba = ct_situacao_enviado,
		 dt_env_tba = now(),
		 cd_dtb = vl_rg_dtb.codigo
		where st_tba = ct_situacao_autorizado
		and cd_ccr = vp_codigo_conta_corrente
		and cd_bnc = vl_rg_dtb.cd_bnc
		and nr_agc_tba = vl_rg_dtb.nr_agc_tba
		and nr_dgt_agc_tba = vl_rg_dtb.nr_dgt_agc_tba
		and nr_cba_tba = vl_rg_dtb.nr_cba_tba
		and nr_dgt_cba_tba = vl_rg_dtb.nr_dgt_cba_tba
		and tp_cba_tba = vl_rg_dtb.tp_cba_tba
		and nr_cpf_cnpj_tba = vl_rg_dtb.nr_cpf_cnpj_tba
		and tp_pss_tba = vl_rg_dtb.tp_pss_tba
		and nm_tba = vl_rg_dtb.nm_tba;

		vl_linha := '1';

		if vl_rg_dtb.tp_pss_tba = 'F' then
		    vl_linha := vl_linha || '1';
		else
		    vl_linha := vl_linha || '2';
		end if;

		vl_linha := vl_linha || sc_arq.preencher(15,vl_cpf_cnpj,'0',ALINHAMENTO_A_ESQUERDA);--CNPJ

		vl_linha := vl_linha || sc_arq.preencher(30,sc_pbl.sem_acento(trim(vl_rg_dtb.nm_tba)),' ',ALINHAMENTO_A_DIREITA);--NOME

		vl_linha := vl_linha || sc_arq.preencher(40,'',' ',ALINHAMENTO_A_DIREITA);--ENDERECO

		vl_linha := vl_linha || sc_arq.preencher(8,'0','0',ALINHAMENTO_A_ESQUERDA);--CEP

		vl_linha := vl_linha || sc_arq.preencher(3,vl_rg_dtb.cd_bnc,'0',ALINHAMENTO_A_ESQUERDA);--BANCO

		vl_linha := vl_linha || sc_arq.preencher(5,vl_rg_dtb.nr_agc_tba,'0',ALINHAMENTO_A_ESQUERDA); -- AGENCIA

		vl_linha := vl_linha || sc_arq.preencher(1,vl_digito_agencia,' ',ALINHAMENTO_A_DIREITA); -- DIGITO AGENCIA

		vl_linha := vl_linha || sc_arq.preencher(13,vl_rg_dtb.nr_cba_tba,'0',ALINHAMENTO_A_ESQUERDA); -- CONTA

		vl_linha := vl_linha || sc_arq.preencher(2,vl_rg_dtb.nr_dgt_cba_tba,' ',ALINHAMENTO_A_DIREITA); -- DIGITO CONTA

		vl_linha := vl_linha || sc_arq.preencher(16,vl_rg_dtb.codigo,' ',ALINHAMENTO_A_DIREITA); -- NUMERO DO PAGAMENTO

		vl_linha := vl_linha || sc_arq.preencher(3,'0','0',ALINHAMENTO_A_ESQUERDA); -- CARTEIRA

		vl_linha := vl_linha || sc_arq.preencher(12,'0','0',ALINHAMENTO_A_ESQUERDA); -- NOSSO NUMERO

		vl_linha := vl_linha || sc_arq.preencher(15,'0',' ',ALINHAMENTO_A_DIREITA); -- SEU NUMERO

		vl_linha := vl_linha || to_char(current_date,'yyyymmdd'); -- DATA DE VENCIMENTO

		vl_linha := vl_linha || to_char(current_date,'yyyymmdd'); -- DATA DE EMISSAO DO DOCUMENTO

		vl_linha := vl_linha || sc_arq.repetir('0',8); -- DATA LIMITE PARA DESCONTO

		vl_linha := vl_linha || '0';

		vl_linha := vl_linha || sc_arq.repetir('0',4); -- FATOR DE VENCIMENTO

		vl_linha := vl_linha || sc_arq.formatar_moeda(10,vl_rg_dtb.valor); -- VALOR DO DOCUMENTO

		vl_linha := vl_linha || sc_arq.formatar_moeda(15,vl_rg_dtb.valor); -- VALOR DO PAGAMENTO

		vl_linha := vl_linha || sc_arq.repetir('0',15); -- VALOR DO DESCONTO

		vl_linha := vl_linha || sc_arq.repetir('0',15); -- VALOR DO ACRESCIMO

		vl_linha := vl_linha || '05'; -- TIPO DO DOCUMENTO
		
		vl_linha := vl_linha || sc_arq.repetir('0',10); -- NUMERO NOTA FISCAL
		
		vl_linha := vl_linha || sc_arq.repetir(' ',2); -- SERIE DOCUMENTO

		vl_linha := vl_linha || sc_arq.preencher(2,vl_mod_pagamento,'0',ALINHAMENTO_A_ESQUERDA); -- MODALIDADE PAGAMENTO

		vl_linha := vl_linha || to_char(current_date,'yyyymmdd'); -- DATA EFETIVACAO PAGAMENTO

		vl_linha := vl_linha || sc_arq.repetir(' ',3); -- MOEDA

		vl_linha := vl_linha || '01';

		vl_linha := vl_linha || sc_arq.repetir(' ',2);
		
		vl_linha := vl_linha || sc_arq.repetir(' ',2);

		vl_linha := vl_linha || sc_arq.repetir(' ',2);

		vl_linha := vl_linha || sc_arq.repetir(' ',2);

		vl_linha := vl_linha || sc_arq.repetir(' ',2);

		vl_linha := vl_linha || '0';

		vl_linha := vl_linha || '00';

		vl_linha := vl_linha || sc_arq.repetir(' ',4);

		vl_linha := vl_linha || sc_arq.repetir(' ',15);

		vl_linha := vl_linha || sc_arq.repetir(' ',15);

		vl_linha := vl_linha || sc_arq.repetir(' ',6);

		vl_linha := vl_linha || sc_arq.repetir(' ',40);

		vl_linha := vl_linha || ' ';

		vl_linha := vl_linha || ' ';

		vl_linha := vl_linha || sc_arq.preencher(40,vl_complemento_pagamento,' ',ALINHAMENTO_A_DIREITA); 
		
		vl_linha := vl_linha || '00';
		
		vl_linha := vl_linha || sc_arq.repetir(' ',35);
		
		vl_linha := vl_linha || sc_arq.repetir(' ',22);

		vl_linha := vl_linha || sc_arq.repetir('0',5);

		vl_linha := vl_linha || ' ';

                -- ALTERACAO TEMPORARIA.
                -- TODO: FAZER A FORMA CORRETA E JA TRAZER O DADO CORRETO PARA O CASO DE CONTA FACIL
		if vl_rg_dtb.tp_cba_tba = 3 then
		   vl_linha := vl_linha || '1';
		else   
		   vl_linha := vl_linha || vl_rg_dtb.tp_cba_tba;
		end if;

		vl_linha := vl_linha || sc_arq.preencher(7,vl_rg_dtb.cd_cnt_ccr,'0',ALINHAMENTO_A_ESQUERDA); 
		
		vl_linha := vl_linha || sc_arq.repetir(' ',8);

		vl_linha := vl_linha || sc_arq.preencher(6,vl_qtde_registros_arquivo,'0',ALINHAMENTO_A_ESQUERDA); 

		perform sc_arq.gravarlinha(vp_nome_arquivo,vl_linha);

	end loop; 

	vp_qtd_transferencia := vl_qtd_transferencia;
        vp_qtd_ted := vl_qtd_ted;
        vp_qtd_doc := vl_qtd_doc;
                      
end;$$;


ALTER FUNCTION sc_atb.processa_detalhe_arquivo_bradesco(vp_codigo_arquivo numeric, vp_nome_arquivo character varying, vp_codigo_conta_corrente numeric, OUT vp_qtd_ted numeric, OUT vp_qtd_doc numeric, OUT vp_qtd_transferencia numeric) OWNER TO postgres;

--
-- TOC entry 224 (class 1259 OID 564170)
-- Name: tbl_drt; Type: TABLE; Schema: sc_atb; Owner: scan
--

CREATE TABLE tbl_drt (
    cd_drt numeric(20,0) NOT NULL,
    cd_art numeric(10,0) NOT NULL,
    cd_hlt numeric(10,0),
    st_drt numeric(2,0) DEFAULT 1 NOT NULL,
    nr_seq_drt numeric(5,0),
    tp_mvm_drt numeric(2,0) NOT NULL,
    cd_cmr_cmp_drt numeric(3,0),
    cd_bnc numeric(5,0) NOT NULL,
    cd_agc_drt numeric(5,0) NOT NULL,
    cd_ccr_drt numeric(15,0) NOT NULL,
    dgt_ccr_drt character varying(2) NOT NULL,
    nm_drt character varying(30) NOT NULL,
    nr_doc_drt numeric(16,0) NOT NULL,
    dt_lcn_drt timestamp without time zone NOT NULL,
    vl_drt numeric(11,2) NOT NULL,
    cd_ort character varying(2) NOT NULL,
    cd_mtv_inv_drt numeric(2,0)
);


ALTER TABLE tbl_drt OWNER TO scan;

--
-- TOC entry 7688 (class 0 OID 0)
-- Dependencies: 224
-- Name: TABLE tbl_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON TABLE tbl_drt IS 'tabela de detalhe do arquivo de retorno de transferencia';


--
-- TOC entry 7689 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.cd_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.cd_drt IS 'codigo';


--
-- TOC entry 7690 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.cd_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.cd_art IS 'codigo do arquivo';


--
-- TOC entry 7691 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.cd_hlt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.cd_hlt IS 'codigo do header de lote';


--
-- TOC entry 7692 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.st_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.st_drt IS 'situacao (ver tabela de dominio)';


--
-- TOC entry 7693 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.nr_seq_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.nr_seq_drt IS 'numero de sequencia do registro no lote';


--
-- TOC entry 7694 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.tp_mvm_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.tp_mvm_drt IS 'tipo de movimento (ver tabela de dominio)';


--
-- TOC entry 7695 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.cd_cmr_cmp_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.cd_cmr_cmp_drt IS 'codigo da camara de compensacao (ver tabela de dominio)';


--
-- TOC entry 7696 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.cd_bnc; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.cd_bnc IS 'banco de destino';


--
-- TOC entry 7697 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.cd_agc_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.cd_agc_drt IS 'codigo da agencia de destino';


--
-- TOC entry 7698 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.cd_ccr_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.cd_ccr_drt IS 'codigo da conta corrente de destino';


--
-- TOC entry 7699 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.dgt_ccr_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.dgt_ccr_drt IS 'digito da conta corrente de destino';


--
-- TOC entry 7700 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.nm_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.nm_drt IS 'nome do titular da conta de destino';


--
-- TOC entry 7701 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.nr_doc_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.nr_doc_drt IS 'numero do documento atribuido (preenchido com o campo: cd_dtb no arquivo de remessa)';


--
-- TOC entry 7702 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.dt_lcn_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.dt_lcn_drt IS 'data do lancamento';


--
-- TOC entry 7703 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.vl_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.vl_drt IS 'valor para credito';


--
-- TOC entry 7704 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.cd_ort; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.cd_ort IS 'codigo da ocorrencia de retorno';


--
-- TOC entry 7705 (class 0 OID 0)
-- Dependencies: 224
-- Name: COLUMN tbl_drt.cd_mtv_inv_drt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_drt.cd_mtv_inv_drt IS 'codigo do motivo da invalidacao (ver tabela de dominio)';


--
-- TOC entry 1187 (class 1255 OID 564174)
-- Name: processa_detalhe_arquivo_retorno(tbl_drt, numeric, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION processa_detalhe_arquivo_retorno(vp_detalhe_arquivo tbl_drt, vp_tipo_arquivo numeric, vp_codigo_arquivo_transferencia numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  ct_tipo_consistencia constant numeric := 1;
  ct_tipo_confirmacao constant numeric := 2;

  ct_st_validado constant numeric := 2;
  ct_st_invalidado constant numeric := 3;
  
  ct_sucesso constant numeric := 0;

  ct_banco_bradesco numeric := 237;
  ct_banco_hsbc numeric := 399;

  vl_descricao_ocorrencia varchar;
  vl_retorno_validacao numeric;
  vl_banco numeric;
begin

  
  
  --validando o registro de detalhe do arquivo de retorno de transferencia
  select sc_atb.valida_detalhe_arquivo_retorno(vp_detalhe_arquivo, vp_codigo_arquivo_transferencia)
  into vl_retorno_validacao;

  if vl_retorno_validacao = ct_sucesso then

    select cd_bnc
    into vl_banco
    from sc_atb.tbl_art
    where cd_art = vp_detalhe_arquivo.cd_art;
    
    --obtendo a descricao da ocorrencia de retorno de transferencia
    select ds_rdz_ort
    into vl_descricao_ocorrencia
    from sc_atb.tbl_ort
    where cd_ort = vp_detalhe_arquivo.cd_ort;
  
    /*if vp_tipo_arquivo = ct_tipo_consistencia then
      if vp_detalhe_arquivo.cd_ort <> 'BD' then
        perform sc_atb.cancela_transferencia(vp_detalhe_arquivo.nr_doc_drt,vl_descricao_ocorrencia,null);
      end if;
    else 
      if vp_tipo_arquivo = ct_tipo_confirmacao then
        if vp_detalhe_arquivo.cd_ort = '00' then
          perform sc_atb.confirma_transferencia(vp_detalhe_arquivo.nr_doc_drt);
        else
          perform sc_atb.cancela_transferencia(vp_detalhe_arquivo.nr_doc_drt,vl_descricao_ocorrencia,null);  
        end if;
      end if;
    end if;*/

    if (vp_detalhe_arquivo.cd_ort = '00' and vl_banco = ct_banco_hsbc) or
       (vp_detalhe_arquivo.cd_ort = 'HF' and vl_banco = ct_banco_bradesco) or
       (vp_detalhe_arquivo.cd_ort = 'BW' and vl_banco = ct_banco_bradesco) then
       
       perform sc_atb.confirma_transferencia(vp_detalhe_arquivo.nr_doc_drt);
       
    elsif (vp_detalhe_arquivo.cd_ort <> 'BD' and vl_banco = ct_banco_hsbc) or
          (vp_detalhe_arquivo.cd_ort not in('HA','BD','JL','LA') and vl_banco = ct_banco_bradesco) then

       perform sc_atb.cancela_transferencia(vp_detalhe_arquivo.nr_doc_drt,vl_descricao_ocorrencia,null);    
            
    end if;	 

    

    update sc_atb.tbl_drt
       set st_drt = ct_st_validado
    where cd_drt = vp_detalhe_arquivo.cd_drt;
  else
    update sc_atb.tbl_drt
       set st_drt = ct_st_invalidado,
           cd_mtv_inv_drt = vl_retorno_validacao
    where cd_drt = vp_detalhe_arquivo.cd_drt;
  end if;
end;$$;


ALTER FUNCTION sc_atb.processa_detalhe_arquivo_retorno(vp_detalhe_arquivo tbl_drt, vp_tipo_arquivo numeric, vp_codigo_arquivo_transferencia numeric) OWNER TO scan;

--
-- TOC entry 7706 (class 0 OID 0)
-- Dependencies: 1187
-- Name: FUNCTION processa_detalhe_arquivo_retorno(vp_detalhe_arquivo tbl_drt, vp_tipo_arquivo numeric, vp_codigo_arquivo_transferencia numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION processa_detalhe_arquivo_retorno(vp_detalhe_arquivo tbl_drt, vp_tipo_arquivo numeric, vp_codigo_arquivo_transferencia numeric) IS 'rotina que processa um determinado registro de detalhe do arquivo';


--
-- TOC entry 1525 (class 1255 OID 1648833)
-- Name: realizar_transferencias_rejeitadas_por_horario(); Type: FUNCTION; Schema: sc_atb; Owner: postgres
--

CREATE FUNCTION realizar_transferencias_rejeitadas_por_horario() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg_transferencia record;
  vl_cd_fnc numeric;
  vl_cd_crt numeric;
  vl_saldo_conta_funcionario numeric;
  
  ct_situacao_rejeitado constant numeric := 6;
begin

   FOR rg_transferencia in 
     SELECT * 
	  FROM sc_atb.tbl_tba tba
     WHERE tba.dt_env_tba >= '2018-12-24'
	  AND tba.dt_env_tba < '2018-12-25'
	  AND tba.st_tba = ct_situacao_rejeitado
	  AND tba.ds_mtv_rjc_tba LIKE '%Data da efetivação anterior a do processamento%'
	  AND tba.tp_pss_tba = 'F'
	  AND tba.cd_inc_usr <> 716
	LOOP
	  vl_saldo_conta_funcionario := sc_cnt.saldo_conta_liquido_bloqueio(rg_transferencia.cd_dbt_cnt, Array[9],'S');
	  
	  IF vl_saldo_conta_funcionario >= rg_transferencia.vl_tba + coalesce(rg_transferencia.vl_trf_tba, 0) THEN
	  
  	  	SELECT crt.cd_crt, fnc.cd_fnc
	   	  INTO vl_cd_crt, vl_cd_fnc
	  	FROM sc_cad.tbl_fnc fnc
		  INNER JOIN sc_opr.tbl_crt crt ON crt.cd_fnc = fnc.cd_fnc
		  INNER JOIN sc_opr.tbl_cnt_crt cnt_crt ON cnt_crt.cd_crt = crt.cd_crt
		WHERE cnt_crt.cd_cnt = rg_transferencia.cd_dbt_cnt
		  AND cnt_crt.fg_pdr_cnt_crt = 'S';
	  
	    perform sc_atb.transferencia_bancaria(rg_transferencia.cd_bnc, rg_transferencia.nr_agc_tba, rg_transferencia.nr_dgt_agc_tba, rg_transferencia.nr_cba_tba, rg_transferencia.nr_dgt_cba_tba, rg_transferencia.tp_cba_tba, rg_transferencia.vl_tba, vl_cd_fnc, 'TRANSFERENCIA AUTOMATICA', 716, now(), vl_cd_crt);
	  END IF;
	END LOOP;
end;
$$;


ALTER FUNCTION sc_atb.realizar_transferencias_rejeitadas_por_horario() OWNER TO postgres;

--
-- TOC entry 1763 (class 1255 OID 1648514)
-- Name: transferencia_bancaria(numeric, numeric, character varying, numeric, character varying, numeric, double precision, numeric, character varying, numeric, timestamp with time zone, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION transferencia_bancaria(vp_banco numeric, vp_agencia numeric, vp_digito_agencia character varying, vp_conta numeric, vp_digito_conta character varying, vp_tipo_conta numeric, vp_valor double precision, vp_funcionario numeric, vp_motivo_cadastro character varying, vp_usuario_inclusao numeric, vp_data_inclusao timestamp with time zone, vp_cartao numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_nsu numeric;
  vl_conta_debito numeric;
  vl_contrato numeric;
  vl_filial numeric;
  vl_tipo_pagamento_tarifa numeric;
  vl_conta_credito numeric;
  vl_valor_tarifa_str varchar;
  vl_valor_tarifa double precision;
  vl_existe_transferencia_gerada numeric;
  vl_cpf_cnpj numeric;
  vl_cartao numeric;
  
  vl_valor_saldo_conta numeric(13,2);
  vl_valor_restante numeric(13,2);
  vl_saldo_conta_funcionario numeric(13,2);
  vl_quantidade_abono_contrato numeric;
  vl_quantidade_abono_cartao numeric;
  rg_cnt record;
-------------------------

begin

  select cnt_crt.cd_cnt
    into vl_conta_debito
  from sc_cad.tbl_fnc fnc
    inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
    inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
  where fnc.cd_fnc = vp_funcionario
    and cnt_crt.fg_pdr_cnt_crt = 'S';

  -- Vitor Vasconcelos
  -- 23/08/2018
   --vl_saldo_conta_funcionario := sc_cnt.saldo_conta(vl_conta_debito, 'S','S');

   vl_saldo_conta_funcionario := sc_cnt.saldo_conta_liquido_bloqueio(vl_conta_debito, Array[9],'S');
 
  -- valor da tarifa de transferencia

  begin


    select crt.cd_ctr, cun.nr_cpf_cnpj_cun, fnc.cd_fem, coalesce(crt.qtd_abn_trf_crt,0), crt.cd_crt
      into vl_contrato, vl_cpf_cnpj, vl_filial, vl_quantidade_abono_cartao, vl_cartao
    from sc_cad.tbl_fnc fnc
      inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
      inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
      inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
    where fnc.cd_fnc = vp_funcionario
      and cnt_crt.fg_pdr_cnt_crt = 'S';

    vl_valor_tarifa_str := sc_cad.get_parametro_contrato_cartao(11, vl_cartao);
    vl_tipo_pagamento_tarifa := sc_cad.get_parametro_contrato_cartao(11,vl_cartao,3)::numeric;
    vl_quantidade_abono_contrato := sc_cad.get_parametro_contrato_cartao(30, vl_cartao)::numeric;


    if vl_tipo_pagamento_tarifa = 1 then
      vl_valor_tarifa_str := '0';
    end if;
      
  exception when others then
    vl_valor_tarifa_str := '0';
  end;

  if vl_valor_tarifa_str is null then
    vl_valor_tarifa_str := '0';
  end if;

  vl_valor_tarifa = replace(replace(vl_valor_tarifa_str, '.', ''), ',', '.');

  -- verificar se existe alguma transferencia gerada, caso exista nao cobrar a tarifa
  select count(*)
    into vl_existe_transferencia_gerada
  from sc_atb.tbl_tba tba
  where tba.st_tba = 1 -- gerada
    and tba.nr_cpf_cnpj_tba = vl_cpf_cnpj
    and tba.cd_bnc = vp_banco
    and tba.nr_agc_tba = vp_agencia
    and tba.nr_dgt_agc_tba = vp_digito_agencia
    and tba.nr_cba_tba = vp_conta
    and tba.nr_dgt_cba_tba = vp_digito_conta;

  if vl_existe_transferencia_gerada > 0 then
    vl_valor_tarifa = 0;
  end if;

  -- Vitor Vasconcelos
  -- 20/10/2015
  -- Abono Tarifa
  if vl_quantidade_abono_contrato > 0 then
  
     if vl_quantidade_abono_cartao < vl_quantidade_abono_contrato then
         vl_valor_tarifa = 0;
     end if;
     
  end if;
  --

  if vl_saldo_conta_funcionario::numeric(13,2) >= (vp_valor + vl_valor_tarifa)::numeric(13,2) then

    vl_valor_restante := vp_valor;
    for rg_cnt in select cnt_crt.cd_cnt as conta
		  from sc_cad.tbl_fnc fnc
		    inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
		    inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
		  where fnc.cd_fnc = vp_funcionario
		    and crt.cd_ctr = vl_contrato
                  order by cnt_crt.prp_cnt_crt loop

        vl_valor_saldo_conta := sc_cnt.saldo_conta_liquido_bloqueio(rg_cnt.conta, Array[9],'S');--sc_cnt.saldo_conta(rg_cnt.conta, 'S','S'); 

        select count(*)
          into vl_existe_transferencia_gerada
        from sc_atb.tbl_tba tba
        where tba.st_tba = 1 -- gerada
          and tba.nr_cpf_cnpj_tba = vl_cpf_cnpj
          and tba.cd_bnc = vp_banco
          and tba.nr_agc_tba = vp_agencia
          and tba.nr_dgt_agc_tba = vp_digito_agencia
          and tba.nr_cba_tba = vp_conta
          and tba.nr_dgt_cba_tba = vp_digito_conta;

        if vl_existe_transferencia_gerada > 0 then
          vl_valor_tarifa = 0;
        end if;

      if vl_valor_restante > 0 then
        if vl_valor_saldo_conta >= vl_valor_restante then
          select nextval('sc_atb.sq_tba') into vl_nsu;

          perform sc_atb.inserir_transferencia(vl_nsu, vp_banco, vp_agencia, vp_digito_agencia, vp_conta, vp_digito_conta, vp_funcionario,
                                               vl_nsu, rg_cnt.conta, vp_motivo_cadastro, vl_valor_restante, vp_tipo_conta,
                                               vp_usuario_inclusao, vp_data_inclusao);
          exit;
 
        else
 
          perform sc_atb.inserir_transferencia(vl_nsu, vp_banco, vp_agencia, vp_digito_agencia, vp_conta, vp_digito_conta, vp_funcionario,
                                               vl_nsu, rg_cnt.conta, vp_motivo_cadastro, rg_cnt.valor, vp_tipo_conta,
                                               vp_usuario_inclusao, vp_data_inclusao);

          vl_valor_restante = vl_valor_restante - vl_valor_saldo_conta;
        end if;
      else
        exit;
      end if;

    end loop;
   
  --else
   -- RAISE EXCEPTION 'Saldo insuficiente para realizar a transferência';  
  end if;
end;$$;


ALTER FUNCTION sc_atb.transferencia_bancaria(vp_banco numeric, vp_agencia numeric, vp_digito_agencia character varying, vp_conta numeric, vp_digito_conta character varying, vp_tipo_conta numeric, vp_valor double precision, vp_funcionario numeric, vp_motivo_cadastro character varying, vp_usuario_inclusao numeric, vp_data_inclusao timestamp with time zone, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1743 (class 1255 OID 564175)
-- Name: transferencia_bancaria_OLD(numeric, numeric, character varying, numeric, character varying, numeric, double precision, numeric, character varying, numeric, timestamp with time zone); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION "transferencia_bancaria_OLD"(vp_banco numeric, vp_agencia numeric, vp_digito_agencia character varying, vp_conta numeric, vp_digito_conta character varying, vp_tipo_conta numeric, vp_valor double precision, vp_funcionario numeric, vp_motivo_cadastro character varying, vp_usuario_inclusao numeric, vp_data_inclusao timestamp with time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_nsu numeric;
  vl_conta_debito numeric;
  vl_contrato numeric;
  vl_filial numeric;
  vl_tipo_pagamento_tarifa numeric;
  vl_conta_credito numeric;
  vl_valor_tarifa_str varchar;
  vl_valor_tarifa double precision;
  vl_existe_transferencia_gerada numeric;
  vl_cpf_cnpj numeric;
  vl_cartao numeric;
  
  vl_valor_saldo_conta numeric(13,2);
  vl_valor_restante numeric(13,2);
  vl_saldo_conta_funcionario numeric(13,2);
  vl_quantidade_abono_contrato numeric;
  vl_quantidade_abono_cartao numeric;
  rg_cnt record;
-------------------------

begin

  select cnt_crt.cd_cnt
    into vl_conta_debito
  from sc_cad.tbl_fnc fnc
    inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
    inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
  where fnc.cd_fnc = vp_funcionario;

  -- Vitor Vasconcelos
  -- 23/08/2018
   --vl_saldo_conta_funcionario := sc_cnt.saldo_conta(vl_conta_debito, 'S','S');

   vl_saldo_conta_funcionario := sc_cnt.saldo_conta_liquido_bloqueio(vl_conta_debito, Array[9],'S');
 
  -- valor da tarifa de transferencia

  begin


    select crt.cd_ctr, cun.nr_cpf_cnpj_cun, fnc.cd_fem, coalesce(crt.qtd_abn_trf_crt,0), crt.cd_crt
      into vl_contrato, vl_cpf_cnpj, vl_filial, vl_quantidade_abono_cartao, vl_cartao
    from sc_cad.tbl_fnc fnc
      inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
      inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
    where fnc.cd_fnc = vp_funcionario;

    vl_valor_tarifa_str := sc_cad.get_parametro_contrato_cartao(11, vl_cartao);
    vl_tipo_pagamento_tarifa := sc_cad.get_parametro_contrato_cartao(11,vl_cartao,3)::numeric;
    vl_quantidade_abono_contrato := sc_cad.get_parametro_contrato_cartao(30, vl_cartao)::numeric;


    if vl_tipo_pagamento_tarifa = 1 then
      vl_valor_tarifa_str := '0';
    end if;
      
  exception when others then
    vl_valor_tarifa_str := '0';
  end;

  if vl_valor_tarifa_str is null then
    vl_valor_tarifa_str := '0';
  end if;

  vl_valor_tarifa = replace(replace(vl_valor_tarifa_str, '.', ''), ',', '.');

  -- verificar se existe alguma transferencia gerada, caso exista nao cobrar a tarifa
  select count(*)
    into vl_existe_transferencia_gerada
  from sc_atb.tbl_tba tba
  where tba.st_tba = 1 -- gerada
    and tba.nr_cpf_cnpj_tba = vl_cpf_cnpj
    and tba.cd_bnc = vp_banco
    and tba.nr_agc_tba = vp_agencia
    and tba.nr_dgt_agc_tba = vp_digito_agencia
    and tba.nr_cba_tba = vp_conta
    and tba.nr_dgt_cba_tba = vp_digito_conta;

  if vl_existe_transferencia_gerada > 0 then
    vl_valor_tarifa = 0;
  end if;

  -- Vitor Vasconcelos
  -- 20/10/2015
  -- Abono Tarifa
  if vl_quantidade_abono_contrato > 0 then
  
     if vl_quantidade_abono_cartao < vl_quantidade_abono_contrato then
         vl_valor_tarifa = 0;
     end if;
     
  end if;
  --

  if vl_saldo_conta_funcionario >= (vp_valor + vl_valor_tarifa)::numeric then

    vl_valor_restante := vp_valor;
    for rg_cnt in select cnt_crt.cd_cnt as conta
		  from sc_cad.tbl_fnc fnc
		    inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
		    inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
		  where fnc.cd_fnc = vp_funcionario
                  order by cnt_crt.prp_cnt_crt loop

        vl_valor_saldo_conta := sc_cnt.saldo_conta_liquido_bloqueio(rg_cnt.conta, Array[9],'S');--sc_cnt.saldo_conta(rg_cnt.conta, 'S','S'); 

        select count(*)
          into vl_existe_transferencia_gerada
        from sc_atb.tbl_tba tba
        where tba.st_tba = 1 -- gerada
          and tba.nr_cpf_cnpj_tba = vl_cpf_cnpj
          and tba.cd_bnc = vp_banco
          and tba.nr_agc_tba = vp_agencia
          and tba.nr_dgt_agc_tba = vp_digito_agencia
          and tba.nr_cba_tba = vp_conta
          and tba.nr_dgt_cba_tba = vp_digito_conta;

        if vl_existe_transferencia_gerada > 0 then
          vl_valor_tarifa = 0;
        end if;

      if vl_valor_restante > 0 then
        if vl_valor_saldo_conta >= vl_valor_restante then
          select nextval('sc_atb.sq_tba') into vl_nsu;

          perform sc_atb.inserir_transferencia(vl_nsu, vp_banco, vp_agencia, vp_digito_agencia, vp_conta, vp_digito_conta, vp_funcionario,
                                               vl_nsu, rg_cnt.conta, vp_motivo_cadastro, vl_valor_restante, vp_tipo_conta,
                                               vp_usuario_inclusao, vp_data_inclusao);
          exit;
 
        else
 
          perform sc_atb.inserir_transferencia(vl_nsu, vp_banco, vp_agencia, vp_digito_agencia, vp_conta, vp_digito_conta, vp_funcionario,
                                               vl_nsu, rg_cnt.conta, vp_motivo_cadastro, rg_cnt.valor, vp_tipo_conta,
                                               vp_usuario_inclusao, vp_data_inclusao);

          vl_valor_restante = vl_valor_restante - vl_valor_saldo_conta;
        end if;
      else
        exit;
      end if;

    end loop;
  end if;
end;$$;


ALTER FUNCTION sc_atb."transferencia_bancaria_OLD"(vp_banco numeric, vp_agencia numeric, vp_digito_agencia character varying, vp_conta numeric, vp_digito_conta character varying, vp_tipo_conta numeric, vp_valor double precision, vp_funcionario numeric, vp_motivo_cadastro character varying, vp_usuario_inclusao numeric, vp_data_inclusao timestamp with time zone) OWNER TO scan;

--
-- TOC entry 1824 (class 1255 OID 1668912)
-- Name: transferencia_bancaria_empresa_filial(integer, integer); Type: FUNCTION; Schema: sc_atb; Owner: postgres
--

CREATE FUNCTION transferencia_bancaria_empresa_filial(vp_empresa integer, vp_filial integer) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;

  CT_VALOR_MINIMO constant numeric := 10.0;
begin
  for vl_rg in select cbf.cd_bnc, cbf.nr_agc_cbf, cbf.nr_dgt_agc_cbf, cbf.nr_cba_cbf, cbf.nr_dgt_cba_cbf, cbf.tp_cba_cbf,
                      fnc.cd_fnc, cnt.vl_sld_cnt as saldo
		from sc_opr.tbl_crt crt
		     inner join sc_opr.tbl_cnt_crt cnt_crt on crt.cd_crt = cnt_crt.cd_crt
		     inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
		     inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
		     inner join sc_cad.tbl_cun cun on fnc.cd_cun = cun.cd_cun
		     inner join sc_cad.tbl_cbf cbf on cun.cd_cun = cbf.cd_cun and cbf.fg_atv_cbf = 'S' and cbf.pc_dps_cbf = 100.0
		where fnc.cd_emp = vp_empresa 
		  and fnc.cd_fem = vp_filial
		  and cnt.vl_sld_cnt > CT_VALOR_MINIMO
		order by saldo desc loop
    perform sc_atb.transferencia_bancaria(vl_rg.cd_bnc, vl_rg.nr_agc_cbf, vl_rg.nr_dgt_agc_cbf, vl_rg.nr_cba_cbf, vl_rg.nr_dgt_cba_cbf, vl_rg.tp_cba_cbf, vl_rg.saldo, vl_rg.cd_fnc, 'TRANSFERENCIA AUTOMATICA'::varchar, 1, now()::timestamp with time zone);
  end loop;
end;$$;


ALTER FUNCTION sc_atb.transferencia_bancaria_empresa_filial(vp_empresa integer, vp_filial integer) OWNER TO postgres;

--
-- TOC entry 7707 (class 0 OID 0)
-- Dependencies: 1824
-- Name: FUNCTION transferencia_bancaria_empresa_filial(vp_empresa integer, vp_filial integer); Type: COMMENT; Schema: sc_atb; Owner: postgres
--

COMMENT ON FUNCTION transferencia_bancaria_empresa_filial(vp_empresa integer, vp_filial integer) IS 'rotina que realiza a transferencia bancaria de todos os cartões de uma empresa e filial que possuirem saldo';


--
-- TOC entry 1501 (class 1255 OID 564176)
-- Name: valida_detalhe_arquivo_retorno(tbl_drt, numeric); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION valida_detalhe_arquivo_retorno(vp_detalhe_arquivo tbl_drt, vp_codigo_arquivo_transferencia numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  ct_sucesso constant numeric := 0;
  ct_documento_nao_encontrado constant numeric := 1;
  ct_valor_documento_divergente constant numeric := 2;
  ct_nome_titular_divergente constant numeric := 3;
  ct_existe_muitos_documentos constant numeric := 4;

  ct_st_enviado constant numeric := 2;
  ct_st_depositado constant numeric := 3;

  vl_existe numeric;
  vl_valor_transferencia numeric;
  vl_nome_titular varchar;
begin
	if vp_codigo_arquivo_transferencia is not null then
    select count(*)
    into vl_existe
    from sc_atb.tbl_dtb
    where cd_dtb = vp_detalhe_arquivo.nr_doc_drt
      and st_dtb in (ct_st_enviado,ct_st_depositado)
      and cd_atb = vp_codigo_arquivo_transferencia;
  else
    select count(*)
    into vl_existe
    from sc_atb.tbl_dtb
    where cd_dtb = vp_detalhe_arquivo.nr_doc_drt
      and st_dtb in (ct_st_enviado,ct_st_depositado);
  end if;

  if vl_existe = 0 then
    return ct_documento_nao_encontrado;
  end if;
  
  if vl_existe > 1 then
    return ct_existe_muitos_documentos;
  end if;
  
  if vp_codigo_arquivo_transferencia is not null then
    select vl_dtb, trim(nm_dtb)
    into vl_valor_transferencia, vl_nome_titular
    from sc_atb.tbl_dtb
    where cd_dtb = vp_detalhe_arquivo.nr_doc_drt
      and st_dtb in (ct_st_enviado,ct_st_depositado)
      and cd_atb = vp_codigo_arquivo_transferencia;
  else
    select vl_dtb, trim(nm_dtb)
    into vl_valor_transferencia, vl_nome_titular
    from sc_atb.tbl_dtb
    where cd_dtb = vp_detalhe_arquivo.nr_doc_drt
      and st_dtb in (ct_st_enviado,ct_st_depositado);
  end if;

  if vl_valor_transferencia <> vp_detalhe_arquivo.vl_drt then
    return ct_valor_documento_divergente;
  end if;

  if length(vl_nome_titular) > 30 then
    vl_nome_titular := trim(substr(vl_nome_titular, 1, 30));
  end if;
    
  if sc_pbl.sem_acento(trim(vp_detalhe_arquivo.nm_drt)) <> sc_pbl.sem_acento(vl_nome_titular) then
    return ct_nome_titular_divergente;
  end if;

  return ct_sucesso;
end;$$;


ALTER FUNCTION sc_atb.valida_detalhe_arquivo_retorno(vp_detalhe_arquivo tbl_drt, vp_codigo_arquivo_transferencia numeric) OWNER TO scan;

--
-- TOC entry 7708 (class 0 OID 0)
-- Dependencies: 1501
-- Name: FUNCTION valida_detalhe_arquivo_retorno(vp_detalhe_arquivo tbl_drt, vp_codigo_arquivo_transferencia numeric); Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON FUNCTION valida_detalhe_arquivo_retorno(vp_detalhe_arquivo tbl_drt, vp_codigo_arquivo_transferencia numeric) IS 'rotina que realiza algumas validacoes nos informacoes contindas no detalhe do arquivo de retorno de transferencia bancaria';


--
-- TOC entry 1200 (class 1255 OID 564177)
-- Name: zerar_tarifa_abonadas(); Type: FUNCTION; Schema: sc_atb; Owner: scan
--

CREATE FUNCTION zerar_tarifa_abonadas() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin

   if(to_char(current_date,'dd') = '01') then
      update sc_opr.tbl_crt set qtd_abn_trf_crt = 0 where coalesce(qtd_abn_trf_crt,0) <> 0;
   end if;
end$$;


ALTER FUNCTION sc_atb.zerar_tarifa_abonadas() OWNER TO scan;

SET search_path = sc_cad, pg_catalog;

--
-- TOC entry 1540 (class 1255 OID 866953)
-- Name: atualiza_data_vencimento_cartao(numeric, date); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION atualiza_data_vencimento_cartao(vp_contrato numeric, vp_data_referencia date DEFAULT ('now'::text)::date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;
vl_dt_prx_vencim date;
vl_dt_prx_corte date;
vl_dia_prx_vencim varchar := '';
vl_qt_dias_corte numeric;
vl_qtde numeric;
vl_motivo varchar;
begin
  
  -- capturando a dia do vencimento estabelecimento no contrato
  select vl_pce_ctr
    into vl_dia_prx_vencim
  from sc_cad.tbl_pce_ctr pce
  where pce.cd_ctr = vp_contrato
    and pce.cd_pce = 1;

  -- verificando se existe algum funcionario ativo com a data de vencimento diferente da data de vencimento do contrato
  select count(*)
    into vl_qtde
  from sc_opr.tbl_crt crt
     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
   where crt.cd_ctr = vp_contrato
     --and crt.fg_atv_crt = 'S'
     and fnc.st_fnc not in (2) -- demitido
     and to_char(crt.dt_prx_vnc_crt, 'dd') <> vl_dia_prx_vencim;

  if vl_qtde > 0 then

    -- capturando a quantidade de dias de corte
    select vl_prm::numeric
      into vl_qt_dias_corte
    from sc_cad.tbl_prm 
    where nm_prm = 'QT_DT_DIAS_CORTE_CRT_ATIVO';
    
    -- capturando a nova data de vencimento e apuracao dos cartões
    select *
      into vl_dt_prx_vencim, vl_dt_prx_corte
    from sc_acc.get_data_vencimento_apuracao(vp_data_referencia, vl_dia_prx_vencim::numeric, vl_qt_dias_corte);

    -- iterando sobre os cartões para atualizar e gravar ocorrencia
    for rg in select crt.cd_crt as cartao, to_char(crt.dt_prx_vnc_crt, 'dd') as dia_anterior
              from sc_opr.tbl_crt crt
                inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	      where crt.cd_ctr = vp_contrato
		--and crt.fg_atv_crt = 'S'
		and fnc.st_fnc not in (2) -- demitido
		and to_char(crt.dt_prx_vnc_crt, 'dd') <> vl_dia_prx_vencim
	      order by cartao
    loop
      
      -- atualizando o cartao
      update sc_opr.tbl_crt 
        set dt_prx_apr_crt = vl_dt_prx_corte, 
            dt_prx_vnc_crt = vl_dt_prx_vencim
      where cd_crt = rg.cartao;

      -- atualizando as parcelas a faturar, caso tenha
      update sc_fcr.tbl_prc
         set dt_vnc_prc = vl_dt_prx_vencim
      where cd_crt = rg.cartao
        and st_prc = 1;

      -- gravando ocorrencia de alteração de vencimento
      vl_motivo := 'ALTERACAO DO DIA DE VENCIMENTO DO CARTAO, DE ' || rg.dia_anterior || ' PARA ' || vl_dia_prx_vencim || '.';
      insert into sc_opr.tbl_ocr values (nextval('sc_opr.sq_ocr'), 14, rg.cartao, null, vl_motivo, 'S', 1, now());
      
    end loop;
  else
    RAISE EXCEPTION 'NÃO EXISTEM CARTÕES COM VENCIMENTOS DIVERGENTES DO CONTRATO';
  end if;
    

end;$$;


ALTER FUNCTION sc_cad.atualiza_data_vencimento_cartao(vp_contrato numeric, vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1201 (class 1255 OID 564178)
-- Name: atualiza_fatura_anterior(); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION atualiza_fatura_anterior() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;
reg record;

vl_proxima_fatura numeric;

begin

  for rg in 
    select cd_crt
    from sc_fcr.tbl_fcr
    group by cd_crt
    having count(*) > 1 loop

       vl_proxima_fatura := 0;

       for reg in
         select *  
          from sc_fcr.tbl_fcr where cd_crt = rg.cd_crt order by dt_vnc_fcr loop


          if vl_proxima_fatura > 0 then
            update sc_fcr.tbl_fcr set cd_ant_fcr = vl_proxima_fatura
            where cd_fcr = reg.cd_fcr;
          end if;
          
          vl_proxima_fatura = reg.cd_fcr;
      
         end loop;
    
  end loop;  

end;$$;


ALTER FUNCTION sc_cad.atualiza_fatura_anterior() OWNER TO scan;

--
-- TOC entry 1541 (class 1255 OID 859337)
-- Name: atualiza_parametros_contrato(); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION atualiza_parametros_contrato() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 


begin

  -- atualiza os contratos nos cartoes
  update sc_opr.tbl_crt crt
    set cd_ctr = ctr.cd_ctr
  from sc_cad.tbl_fnc fnc  
    inner join sc_cad.tbl_fem_ctr fem on fem.cd_fem = fnc.cd_fem and fem.fg_atv_fem_ctr = 'S'
    inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = fem.cd_ctr and ctr.cd_emp = fnc.cd_emp
  where crt.fg_atv_crt = 'S'
    and ctr.cd_prd = 1
    and crt.cd_prd = 1
    and crt.cd_fnc = fnc.cd_fnc
    and crt.cd_ctr <> ctr.cd_ctr;

  -- atualiza a tabela de tarifa nos cartoes  
  perform sc_cad.atualiza_parametros_contrato_tabela_tarifa();
  
  -- atualiza o dia de vencimentos nos cartoes
  perform sc_cad.atualiza_parametros_contrato_vencimento_cartao();

end;$$;


ALTER FUNCTION sc_cad.atualiza_parametros_contrato() OWNER TO scan;

--
-- TOC entry 1534 (class 1255 OID 859338)
-- Name: atualiza_parametros_contrato_tabela_tarifa(); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION atualiza_parametros_contrato_tabela_tarifa() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

  CT_PARAMETRO_TABELA_TARIFA constant numeric := 33;

begin

  update sc_opr.tbl_crt crt 
   set cd_tvt = sc_cad.get_parametro_contrato(CT_PARAMETRO_TABELA_TARIFA, crt.cd_ctr, fnc.cd_fem)::numeric
  from sc_cad.tbl_fnc fnc
  where crt.fg_atv_crt = 'S'
    and fnc.cd_fnc = crt.cd_fnc
    and cd_tvt <> sc_cad.get_parametro_contrato(CT_PARAMETRO_TABELA_TARIFA, crt.cd_ctr, fnc.cd_fem)::numeric;

end;$$;


ALTER FUNCTION sc_cad.atualiza_parametros_contrato_tabela_tarifa() OWNER TO scan;

--
-- TOC entry 1748 (class 1255 OID 859339)
-- Name: atualiza_parametros_contrato_vencimento_cartao(); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION atualiza_parametros_contrato_vencimento_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

  CT_PARAMETRO_DIA_VENCIMENTO_CARTAO constant numeric := 1;
   
  rg record;
  vl_qt_dias_corte numeric;
  vl_dt_prx_vencim date;
  vl_dt_prx_corte date;
  vl_motivo varchar;
  

begin

  -- retornando o parametro de qtd de dias de corte
  select vl_prm
    into vl_qt_dias_corte
  from sc_cad.tbl_prm 
  where nm_prm = 'QT_DT_DIAS_CORTE_CRT_ATIVO';

  for rg in 
    /*select crt.cd_crt, crt.cd_ctr, fnc.cd_fem, crt.dt_prx_vnc_crt 
    from sc_opr.tbl_crt crt
      inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    where crt.fg_atv_crt = 'S'
      and to_char(crt.dt_prx_vnc_crt,'dd') <> trim((to_char(sc_cad.get_parametro_contrato(1, crt.cd_ctr, fnc.cd_fem)::numeric,'00')))
      and sc_cad.get_parametro_contrato(1, crt.cd_ctr, fnc.cd_fem)::numeric > 0*/

    select crt.cd_crt, crt.cd_ctr, fnc.cd_fem, crt.dt_prx_vnc_crt 
    from sc_opr.tbl_crt crt
     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    where crt.fg_atv_crt = 'S'
      and to_char(crt.dt_prx_vnc_crt,'dd') <> 
      case when to_char(crt.dt_prx_vnc_crt,'mm') = '02' and trim((to_char(sc_cad.get_parametro_contrato(1, crt.cd_ctr, fnc.cd_fem)::numeric,'00'))) = '30' 
        then '28' 
        else trim((to_char(sc_cad.get_parametro_contrato(1, crt.cd_ctr, fnc.cd_fem)::numeric,'00'))) 
      end
    and sc_cad.get_parametro_contrato(1, crt.cd_ctr, fnc.cd_fem)::numeric > 0  
  loop    

       -- retornando nova data de vencimento e apuracao  
       select *
       into vl_dt_prx_vencim, vl_dt_prx_corte
       from sc_acc.get_data_vencimento_apuracao(sc_cad.get_parametro_contrato(1, rg.cd_ctr, rg.cd_fem)::numeric, vl_qt_dias_corte); 


       -- atualizando o cartao
       update sc_opr.tbl_crt 
       set dt_prx_vnc_crt = vl_dt_prx_vencim, 
           dt_prx_apr_crt = vl_dt_prx_corte
       where cd_crt = rg.cd_crt;

       -- atualizando parcelas a vencer
       update sc_fcr.tbl_prc
         set dt_vnc_prc = vl_dt_prx_vencim
      where cd_crt = rg.cd_crt
        and st_prc = 1;

       -- gravando ocorrencia de alteração de vencimento
      vl_motivo := 'ALTERACAO DO DIA DE VENCIMENTO DO CARTAO, DE ' || rg.dt_prx_vnc_crt || ' PARA ' || vl_dt_prx_vencim || '.';
      insert into sc_opr.tbl_ocr values (nextval('sc_opr.sq_ocr'), 14, rg.cd_crt, null, vl_motivo, 'S', 1, now());

  end loop;

end;$$;


ALTER FUNCTION sc_cad.atualiza_parametros_contrato_vencimento_cartao() OWNER TO scan;

--
-- TOC entry 1851 (class 1255 OID 926782)
-- Name: atualizar_pacotes_contrato_empresa(numeric); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION atualizar_pacotes_contrato_empresa(vp_cd_pcs numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg_ctr record;
  rg_dps record;

begin

  for rg_dps in select *
                from sc_cad.tbl_dps
                where cd_pcs = vp_cd_pcs
                  and fg_atv_dps = 'S' loop

    for rg_ctr in select *
                  from sc_cad.tbl_ctr ctr
                  where ctr.cd_pcs = vp_cd_pcs loop
                  
      update sc_cad.tbl_pce_ctr set
        vl_pce_ctr = rg_dps.vl_pce_dps,
        tp_vlr_pce_ctr = rg_dps.tp_vlr_pce_dps,
        tp_pgt_pce_ctr = rg_dps.tp_pgt_pce_dps,
        dt_alt_usr = now(),
        cd_alt_usr = 1
      where cd_ctr = rg_ctr.cd_ctr
        and cd_pce = rg_dps.cd_pce;
      
    end loop;

  end loop;
  
end;$$;


ALTER FUNCTION sc_cad.atualizar_pacotes_contrato_empresa(vp_cd_pcs numeric) OWNER TO scan;

--
-- TOC entry 7709 (class 0 OID 0)
-- Dependencies: 1851
-- Name: FUNCTION atualizar_pacotes_contrato_empresa(vp_cd_pcs numeric); Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON FUNCTION atualizar_pacotes_contrato_empresa(vp_cd_pcs numeric) IS 'ESSA ROTINA ATUALIZA TODOS OS PARAMETROS DE EMPRESA QUANDO E ALTERADO O PARAMETRO';


--
-- TOC entry 1202 (class 1255 OID 564179)
-- Name: contabiliza_transferencia_manual(); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION contabiliza_transferencia_manual() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

valor_total numeric(13,2) := 0;
nr_lancamento_total numeric;

begin

  select nextval('sc_cnt.sq_lcn') into nr_lancamento_total;
    
  for rg in 
     select sum(vl_tba) as valor 
        from sc_atb.tbl_tba 
     where st_tba in (8) 
       and dt_env_tba >= current_date
     group by nr_cpf_cnpj_tba, nr_agc_tba, nr_cba_tba loop
   
    --perform sc_cnt.lancar_debito_credito(5751, 14184, 93, null, 'ref transferencias manuais outra titularidade', rg.valor, current_timestamp::timestamp without time zone, 1, 11, null);

    perform sc_cnt.lancar_movimento(null, nr_lancamento_total, 93, 5751, 'D', rg.valor, current_timestamp::timestamp without time zone, 1, null, 'ref transferencias manuais outra titularidade', 11, nr_lancamento_total);

    valor_total := valor_total + rg.valor;

  end loop;

  perform sc_cnt.lancar_movimento(nr_lancamento_total, null, 93, 14184, 'C', valor_total, current_timestamp::timestamp without time zone, 1, null, 'ref transferencias manuais outra titularidade', 11, null);

  update sc_atb.tbl_tba set st_tba = 9 where st_tba = 8 and dt_env_tba >= current_date; 

end;
$$;


ALTER FUNCTION sc_cad.contabiliza_transferencia_manual() OWNER TO scan;

--
-- TOC entry 1203 (class 1255 OID 564180)
-- Name: estorna_saldo_contato(); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION estorna_saldo_contato() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;
valor_estornado numeric := 0;

begin

  for rg in 
     select cnt.cd_cnt, cnt.vl_sld_cnt
	from sc_cnt.tbl_cnt cnt
    inner join sc_opr.tbl_cnt_crt cc on cc.cd_cnt = cnt.cd_cnt
    inner join sc_opr.tbl_crt crt on crt.cd_crt = cc.cd_crt
    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
	where fnc.cd_emp = 65
	  and cnt.vl_sld_cnt > 0
 loop
   
    perform sc_cnt.lancar_movimento(null,null, 155, rg.cd_cnt, 'D', rg.vl_sld_cnt, now()::timestamp, 1, null, 'REF SOLICITACAO DA EMPRESA CONTATO', 4, 9999);

    valor_estornado := valor_estornado + rg.vl_sld_cnt;

  end loop;

  perform sc_cnt.lancar_movimento(null,null, 155, 10186, 'C', valor_estornado, now()::timestamp, 1, null, 'REF SOLICITACAO DA EMPRESA CONTATO', 4, 9999);
  
end;
$$;


ALTER FUNCTION sc_cad.estorna_saldo_contato() OWNER TO scan;

--
-- TOC entry 1204 (class 1255 OID 564181)
-- Name: estornar_tarifa_transferencia(); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION estornar_tarifa_transferencia() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
vl_rg record;
begin

/**
  for vl_rg in select distinct tba.*
            from sc_adp.tbl_hfe hfe
              inner join sc_adp.tbl_rdp rdp on rdp.cd_hfe = hfe.cd_hfe
              inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
              inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
              inner join sc_atb.tbl_tba tba on tba.cd_dbt_cnt = cnt_crt.cd_cnt
            where hfe.cd_hfe in (1196, 1197, 1200, 1201, 1202, 1204, 1205, 1259, 1260, 1263, 1199)
              and tba.st_tba = 1 
              and vl_trf_tba > 0 loop
*/
  for vl_rg in select * from sc_cnt.tbl_cnt where vl_sld_cnt = -8 loop
    perform sc_cnt.lancar_debito_credito(5660, vl_rg.cd_cnt, 92,
                                           null, 'NAO COBRAR TARIFA - TECHNIC', 8, now()::timestamp without time zone,
                                           1, 11, null);

    --update sc_atb.tbl_tba set vl_trf_tba = 0 where cd_tba = vl_rg.cd_tba;
  end loop;
  
end;$$;


ALTER FUNCTION sc_cad.estornar_tarifa_transferencia() OWNER TO scan;

--
-- TOC entry 1569 (class 1255 OID 564182)
-- Name: gera_albertino(numeric, numeric); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION gera_albertino(quantidade_cartoes numeric, filial numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

cont numeric;
matricula character varying(14);
vl_codigo_plastico numeric;
vl_cartao numeric;

begin

  select coalesce(max(nr_idt_fnc::numeric),0) + 1
    into cont
  from sc_cad.tbl_fnc
    where cd_emp = 265
      and cd_fem = filial;

  
  --if filial = 4 and cont = 1 then
  -- cont := 18001;
  --end if;

  while quantidade_cartoes > 0 loop

     matricula:= cont::varchar; 
     insert into sc_cad.tbl_fnc (cd_fnc,cd_emp,cd_fem,nr_idt_fnc,st_fnc,cd_cun,cd_inc_usr,cd_alt_usr,dt_inc_usr, dt_alt_usr) 
                         values (nextval('sc_cad.sq_fnc'),265,filial,matricula,1,52404,2,null,now(),null);    
     select * 
       into vl_cartao, vl_codigo_plastico
     from sc_cad.inclui_cartao(currval('sc_cad.sq_fnc'), 1, 2);    

     --inserindo na tabela de solicitacao de personalizacao de plastico
     insert into sc_ssp.tbl_ssp(cd_ssp,cd_pls,tp_ssp,st_ssp,cd_mpl,msg_crt_ssp,dt_prv_grc_ssp,
        dt_grc_ssp,dt_inc_usr)
      values(nextval('sc_ssp.sq_ssp'),vl_codigo_plastico,1,9,1,null,(now() + interval '1 day')::date,NULL,now());

     update sc_opr.tbl_pls set fg_emt_pls = 'S',nm_pls = 'TAURUS SERVICOS' where cd_pls = vl_codigo_plastico  and fg_emt_pls = 'N';

     cont := cont + 1;
     quantidade_cartoes := quantidade_cartoes - 1;
  end loop;


end;$$;


ALTER FUNCTION sc_cad.gera_albertino(quantidade_cartoes numeric, filial numeric) OWNER TO scan;

--
-- TOC entry 1657 (class 1255 OID 946204)
-- Name: get_pacote_servico_cartao(numeric); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION get_pacote_servico_cartao(vp_cartao numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_codigo_pacote numeric;
begin

	    SELECT CASE WHEN CRT.CD_PCS IS NOT NULL 
		   THEN CRT.CD_PCS 
		   ELSE CASE WHEN 1=1 --" // NAO TIRAR ESSE CASE - UM DIA VOCE VERA ESSE CODIGO E VAI ACHAR QUE NAO TEM NADA A VER COIIIDADO SEU ESPERTO!!! 
		   THEN (SELECT CPF.CD_PCS FROM SC_CAD.TBL_CTR_PCS CPF WHERE CPF.CD_CTR = CTR.CD_CTR AND CPF.FG_ATV_CTR_PCS = 'S' AND CPF.FG_PRD_CTR_PCS = 'S') 
		   ELSE (SELECT PFE.CD_PCS_FNC_PFE FROM SC_CAD.TBL_PFE PFE WHERE PFE.CD_PCS_EMP_PFE = CTR.CD_PCS AND PFE.FG_ATV_PFE = 'S' AND PFE.FG_PRD_PFE = 'S') END END 

               into vl_codigo_pacote            
               FROM SC_OPR.TBL_CRT CRT 
               LEFT JOIN SC_CAD.TBL_PCS PCS ON CRT.CD_PCS = PCS.CD_PCS AND PCS.TP_PCS = 2
               LEFT JOIN SC_CAD.TBL_CTR CTR ON CTR.CD_CTR = CRT.CD_CTR 
            WHERE CRT.CD_CRT = vp_cartao;

           return     vl_codigo_pacote;
end$$;


ALTER FUNCTION sc_cad.get_pacote_servico_cartao(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1527 (class 1255 OID 859074)
-- Name: get_parametro_contrato(numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION get_parametro_contrato(vp_parametro numeric, vp_contrato numeric, vp_filial numeric, vp_registro numeric DEFAULT 1) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

vl_retorno_1 varchar;
vl_retorno_2 varchar;
vl_retorno_3 numeric;

ct_registro_valor constant numeric := 1;
ct_registro_tipo_valor constant numeric := 2;
ct_registro_tipo_pagamento constant numeric := 3;

vl_existe numeric;

begin

  -- verificando se existe parametro ativo para a filial

  if vp_filial is not null then

    select  vl_pce_fem_ctr, tp_vlr_pce_fem_ctr, tp_pgt_pce_fem_ctr
      into vl_retorno_1, vl_retorno_2, vl_retorno_3 
    from sc_cad.tbl_pce_fem_ctr p
      inner join sc_cad.tbl_fem_ctr f on f.cd_fem_ctr = p.cd_fem_ctr  
    where p.cd_pce = vp_parametro
      and f.cd_ctr = vp_contrato
      and f.cd_fem = vp_filial
      and p.fg_atv_pce_fem_ctr = 'S';

  end if;

  -- caso nao exista na filial retorna o do contrato
  if vl_retorno_1 is null then

    select vl_pce_ctr, tp_vlr_pce_ctr, tp_pgt_pce_ctr
      into vl_retorno_1, vl_retorno_2, vl_retorno_3 
    from sc_cad.tbl_pce_ctr p
    where p.cd_pce = vp_parametro
      and p.cd_ctr = vp_contrato;

  end if;

  if vl_retorno_1 is null then
    return null;
  end if;

  if vp_registro = ct_registro_valor then
    return vl_retorno_1;
  elsif vp_registro = ct_registro_tipo_valor then
    return vl_retorno_2;
  elsif vp_registro = ct_registro_tipo_pagamento then
    if vl_retorno_1 is not null and vl_retorno_3 is null then
      select count(*)
        into vl_existe
      from sc_cad.tbl_pce
      where cd_pce = vp_parametro
      and fg_fnc_pce = 'S';

      if vl_existe > 0 then
        vl_retorno_3 := 2;
      else
        vl_retorno_3 := 1;
      end if;
    end if;

    return vl_retorno_3::varchar;
  end if;   

end;$$;


ALTER FUNCTION sc_cad.get_parametro_contrato(vp_parametro numeric, vp_contrato numeric, vp_filial numeric, vp_registro numeric) OWNER TO scan;

--
-- TOC entry 1624 (class 1255 OID 862234)
-- Name: get_parametro_contrato_cartao(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION get_parametro_contrato_cartao(vp_parametro numeric, vp_cartao numeric, vp_registro numeric DEFAULT 1) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

vl_filial numeric;
vl_contrato numeric;
vl_retorno varchar;
vl_retorno2 varchar;
vl_retorno3 varchar;

begin
  
  --retornando o parametro do cartao
  select vl_pce_crt, tp_vlr_pce_crt, tp_pgt_pce_crt
   into vl_retorno, vl_retorno2, vl_retorno3
  from sc_cad.tbl_pce_crt
  where cd_crt = vp_cartao
   and cd_pce = vp_parametro
   AND fg_atv_pce_crt = 'S';

  -- caso nao exista retornando a filial do cartao ou do contrato
  if vl_retorno is null then

    select crt.cd_ctr, fnc.cd_fem
      into vl_contrato, vl_filial
    from sc_opr.tbl_crt crt
      inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    where crt.cd_crt = vp_cartao;

    vl_retorno := sc_cad.get_parametro_contrato(vp_parametro, vl_contrato, vl_filial, vp_registro);

  ELSE

    if vp_registro = 2 then
      vl_retorno = vl_retorno2;
    end if;

    if vp_registro = 3 then
      vl_retorno = vl_retorno3;
    end if;
  
  end if; 


  return vl_retorno;
 

end;$$;


ALTER FUNCTION sc_cad.get_parametro_contrato_cartao(vp_parametro numeric, vp_cartao numeric, vp_registro numeric) OWNER TO scan;

--
-- TOC entry 1544 (class 1255 OID 868183)
-- Name: get_parametro_contrato_filial(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION get_parametro_contrato_filial(vp_parametro numeric, vp_contrato numeric, vp_filial numeric, OUT vr_valor character varying, OUT vr_tipo_pagamento numeric, OUT vr_tipo_valor character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$declare

vl_existe numeric;

begin

  -- verificando se existe parametro ativo para a filial

  if vp_filial is not null then

    select  vl_pce_fem_ctr, tp_vlr_pce_fem_ctr, tp_pgt_pce_fem_ctr
      into vr_valor, vr_tipo_valor, vr_tipo_pagamento
    from sc_cad.tbl_pce_fem_ctr p
      inner join sc_cad.tbl_fem_ctr f on f.cd_fem_ctr = p.cd_fem_ctr  
    where p.cd_pce = vp_parametro
      and f.cd_ctr = vp_contrato
      and f.cd_fem = vp_filial
      and p.fg_atv_pce_fem_ctr = 'S';

  end if;

  -- caso nao exista na filial retorna o do contrato
  if vr_valor is null then

    select vl_pce_ctr, tp_vlr_pce_ctr, tp_pgt_pce_ctr
      into vr_valor, vr_tipo_valor, vr_tipo_pagamento
    from sc_cad.tbl_pce_ctr p
    where p.cd_pce = vp_parametro
      and p.cd_ctr = vp_contrato;

  end if;

  if vr_valor is not null and vr_tipo_pagamento is null then
     select count(*)
      into vl_existe
      from sc_cad.tbl_pce
      where cd_pce = vp_parametro
        and fg_fnc_pce = 'S';

     if vl_existe > 0 then
       vr_tipo_pagamento := 2;
     else
       vr_tipo_pagamento := 1;
     end if;
  end if;
  


end;$$;


ALTER FUNCTION sc_cad.get_parametro_contrato_filial(vp_parametro numeric, vp_contrato numeric, vp_filial numeric, OUT vr_valor character varying, OUT vr_tipo_pagamento numeric, OUT vr_tipo_valor character varying) OWNER TO scan;

--
-- TOC entry 1163 (class 1255 OID 1633574)
-- Name: get_telefone(numeric); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION get_telefone(vp_codigo_cadastro_unico numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
begin
end$$;


ALTER FUNCTION sc_cad.get_telefone(vp_codigo_cadastro_unico numeric) OWNER TO scan;

--
-- TOC entry 1392 (class 1255 OID 1633575)
-- Name: get_telefones(numeric); Type: FUNCTION; Schema: sc_cad; Owner: postgres
--

CREATE FUNCTION get_telefones(vp_codigo_cadastro_unico numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
   rg record;
   vl_telefones varchar = '';
begin

   for rg in select distinct nr_ddd_tlf,nr_tlf
	     from sc_cad.tbl_tlf tlf
             where tlf.fg_atv_tlf = 'S'
	       and tlf.tp_org_tlf = 1
	       and tlf.nsu_org_tlf = vp_codigo_cadastro_unico
	       and tlf.fg_prn_tlf = 'S' loop

       vl_telefones := vl_telefones ||'#'|| rg.nr_ddd_tlf||rg.nr_tlf;     	       

   end loop;	       

    return vl_telefones;

end$$;


ALTER FUNCTION sc_cad.get_telefones(vp_codigo_cadastro_unico numeric) OWNER TO postgres;

--
-- TOC entry 1207 (class 1255 OID 564183)
-- Name: inclui_cartao(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION inclui_cartao(vp_codigo_funcionario numeric, vp_codigo_produto numeric, vp_codigo_usuario numeric, OUT vp_codigo_cartao numeric, OUT vp_codigo_plastico numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
  vl_dados_filial sc_acc.tbl_hfe%rowtype;
  vl_dados_cartao sc_acc.tbl_rct%rowtype;

  vl_codigo_cun numeric;
begin
  select cun.nm_cun, fnc.cd_emp, fnc.cd_fem, vp_codigo_produto, 
         cun.cd_cun
  into vl_dados_cartao.nm_rct, vl_dados_filial.cd_emp, vl_dados_filial.cd_fem, vl_dados_filial.cd_prd,
         vl_codigo_cun
  from sc_cad.tbl_cun cun
       inner join sc_cad.tbl_fnc fnc on cun.cd_cun = fnc.cd_cun
  where fnc.cd_fnc = vp_codigo_funcionario;

  select *
  into vp_codigo_cartao, vp_codigo_plastico
  from sc_acc.inclui_cartao(vl_dados_filial, vl_dados_cartao, vl_codigo_cun, vp_codigo_usuario, vp_codigo_funcionario);

end;$$;


ALTER FUNCTION sc_cad.inclui_cartao(vp_codigo_funcionario numeric, vp_codigo_produto numeric, vp_codigo_usuario numeric, OUT vp_codigo_cartao numeric, OUT vp_codigo_plastico numeric) OWNER TO scan;

--
-- TOC entry 7710 (class 0 OID 0)
-- Dependencies: 1207
-- Name: FUNCTION inclui_cartao(vp_codigo_funcionario numeric, vp_codigo_produto numeric, vp_codigo_usuario numeric, OUT vp_codigo_cartao numeric, OUT vp_codigo_plastico numeric); Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON FUNCTION inclui_cartao(vp_codigo_funcionario numeric, vp_codigo_produto numeric, vp_codigo_usuario numeric, OUT vp_codigo_cartao numeric, OUT vp_codigo_plastico numeric) IS 'rotina utiliza pela aplicacao java para gerar o registro de cartao, conta e plastico';


--
-- TOC entry 1208 (class 1255 OID 564184)
-- Name: retira_saldo_technic(); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION retira_saldo_technic() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;

begin

for rg in 
select cnt.*
from sc_opr.tbl_cnt_crt crt
  inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = crt.cd_cnt
where cd_crt in (
69372120741726,
69372120079312,
69372114229314,
69372138601494,
69372138986075,
69372133595936,
69372157283751,
69372124383689,
69372182753557,
69372115872273,
69372143358329,
69372132443940,
69372132651436,
69372148223445,
69372196451012,
69372189445018,
69372182500728,
69372145077620) loop

   perform sc_cnt.lancar_debito_credito(rg.cd_cnt, 6949, 18, null, 'VALORES PAGOS EM DINHEIRO POIS FUNCIONARIO NAO TINHA CONTA', rg.vl_sld_cnt, now()::timestamp without time zone, 1, 2, rg.cd_cnt);

end loop;

end;$$;


ALTER FUNCTION sc_cad.retira_saldo_technic() OWNER TO scan;

--
-- TOC entry 1209 (class 1255 OID 564185)
-- Name: setar_conta_grupo_empresarial(); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION setar_conta_grupo_empresarial() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg_gem sc_cad.tbl_gem%rowtype;
begin
  for vl_rg_gem in select * from sc_cad.tbl_gem loop
    insert into sc_cnt.tbl_cnt(cd_cnt, nm_cnt, vl_sld_cnt, fg_ntr_cnt, dt_inc_usr, cd_inc_usr)
    values(nextval('sc_cnt.sq_cnt'), 'GEM PG ' || vl_rg_gem.nm_gem || ' ' || vl_rg_gem.cd_gem, 0, 'C', now(), 1);

    update sc_cad.tbl_gem set cd_cnt = currval('sc_cnt.sq_cnt') where cd_gem = vl_rg_gem.cd_gem;
  end loop;
end;$$;


ALTER FUNCTION sc_cad.setar_conta_grupo_empresarial() OWNER TO scan;

--
-- TOC entry 7711 (class 0 OID 0)
-- Dependencies: 1209
-- Name: FUNCTION setar_conta_grupo_empresarial(); Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON FUNCTION setar_conta_grupo_empresarial() IS 'funcao criada especificamente para criar as contas de recebimento de recuso dos grupo empresariais ja existentes, quando o campo codigo da conta foi adicionado a tabela de grupo empresarial';


--
-- TOC entry 1210 (class 1255 OID 564186)
-- Name: transfere_erro_saldo_banco(); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION transfere_erro_saldo_banco() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin
  for rg in 
     select * from (
select crt.cd_fnc, tba.nm_tba, tba.cd_bnc, tba.nr_agc_tba,tba.nr_dgt_agc_tba, tba.nr_cba_tba, tba.nr_dgt_cba_tba, tba.tp_cba_tba,cnt.vl_sld_cnt as saldo, replace(pc.vl_pce_ctr,',','')::numeric / 100 as tarifa, sum(tba.vl_tba) as valor
  from sc_atb.tbl_tba tba
    inner join sc_cnt.tbl_cnt cnt on tba.cd_dbt_cnt = cnt.cd_cnt
    inner join sc_opr.tbl_cnt_crt cc on cc.cd_cnt = cnt.cd_cnt
    inner join sc_opr.tbl_crt crt on crt.cd_crt = cc.cd_crt
    inner join sc_cad.tbl_pce_ctr pc on pc.cd_ctr = crt.cd_ctr
    where tba.dt_env_tba::date = '31/08/2012'
      and tba.dt_aut_usr::date = '31/08/2012'
      and tba.st_tba = 6
      and pc.cd_pce = 11
 group by crt.cd_fnc,tba.nm_tba, tba.cd_bnc, tba.nr_agc_tba,tba.nr_dgt_agc_tba, tba.nr_cba_tba, tba.nr_dgt_cba_tba, tba.tp_cba_tba,cnt.vl_sld_cnt , pc.vl_pce_ctr ) as tbl
 where tbl.saldo >= tbl.tarifa + tbl.valor

            loop

    perform sc_atb.transferencia_bancaria(rg.cd_bnc, rg.nr_agc_tba, rg.nr_dgt_agc_tba, rg.nr_cba_tba, rg.nr_dgt_cba_tba, rg.tp_cba_tba, rg.valor, rg.cd_fnc, 'TRANSFERENCIA AUTOMATICA', 1, now()::timestamp with time zone);
            
  end loop;

end;$$;


ALTER FUNCTION sc_cad.transfere_erro_saldo_banco() OWNER TO scan;

--
-- TOC entry 1205 (class 1255 OID 564187)
-- Name: transfere_technic(); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION transfere_technic() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin
  for rg in --select distinct cnt.*, cbf.*, fnc.cd_fnc
            --from sc_adp.tbl_hfe hfe
            --  inner join sc_adp.tbl_rdp rdp on rdp.cd_hfe = hfe.cd_hfe
            --  inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
            --  inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
            --  inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
            --  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
            -- inner join sc_cad.tbl_cbf cbf on cbf.cd_cun = fnc.cd_cun
            --where hfe.cd_hfe in (1196, 1197, 1200, 1201, 1202, 1204, 1205, 1259, 1260, 1263, 1199)
            --  and cnt.vl_sld_cnt > 0
            --  and cbf.cd_cbf in (select min(cd_cbf) from sc_cad.tbl_cbf cbf2 where cbf2.cd_cun = cbf.cd_cun)

	    /**
            select distinct cnt.*, cbf.*, fnc.cd_fnc
            from sc_adp.tbl_hfe hfe
              inner join sc_adp.tbl_rdp rdp on rdp.cd_hfe = hfe.cd_hfe
              inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
              inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
              inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
              inner join sc_cad.tbl_cbf cbf on cbf.cd_cun = fnc.cd_cun and cbf.pc_dps_cbf = 100
            where hfe.cd_hfe in (1776,1778)
              and cnt.vl_sld_cnt > 0
              and cbf.cd_cbf in (select min(cd_cbf) from sc_cad.tbl_cbf cbf2 where cbf2.cd_cun = cbf.cd_cun)
             */
             /**
           select cnt.*, cbf.*, fnc.cd_fnc 
           from sc_opr.tbl_cnt_crt cnt_crt
             inner join sc_opr.tbl_crt crt on crt.cd_crt = cnt_crt.cd_crt
             inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
             inner join sc_cad.tbl_cbf cbf on cbf.cd_cun = fnc.cd_cun
             inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
           where cnt_crt.cd_crt in (69372184327677, 69372194436110, 69372157315634) 
             and cnt.vl_sld_cnt > 0
             and cbf.tp_cba_cbf = 3*/
           select cnt.*, cbf.*, fnc.cd_fnc 
           from sc_adp.tbl_rdp rdp
             inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
	     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	     inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	     inner join sc_cad.tbl_cbf cbf on cbf.cd_cun = fnc.cd_cun
	     inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
             inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
           where rdp.cd_hfe = 14601
             and cnt.cd_cnt not in (54013)
             and cnt.vl_sld_cnt > 2.5


             
            loop

    perform sc_atb.transferencia_bancaria(rg.cd_bnc, rg.nr_agc_cbf, rg.nr_dgt_agc_cbf, rg.nr_cba_cbf, rg.nr_dgt_cba_cbf, rg.tp_cba_cbf, rg.vl_sld_cnt, rg.cd_fnc, 'TRANSFERENCIA AUTOMATICA', 1, now()::timestamp with time zone);
            
  end loop;

end;$$;


ALTER FUNCTION sc_cad.transfere_technic() OWNER TO scan;

--
-- TOC entry 1212 (class 1255 OID 564188)
-- Name: transferir_funcionario(numeric, numeric, numeric, numeric, character varying, numeric); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION transferir_funcionario(vp_empresa_old numeric, vp_filial_old numeric, vp_empresa_new numeric, vp_filial_new numeric, vp_matricula character varying, vp_cpf numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

rg record;


vl_qtde numeric := 0;
vl_funcionario  numeric := 0;
vl_cpf 		numeric := 0;
vl_cad_unico	numeric := 0;
vl_grupo_empresarial_old  numeric := 0;
vl_grupo_empresarial_new  numeric := 0;
vl_contrato_old  numeric := 0;
vl_contrato_new  numeric := 0;
vl_cartao 	 numeric := 0;

begin

  --0. verificando se existe a empresa e filial informada para transferir o funcionario
  select count(*)
    into vl_qtde
  from sc_cad.tbl_emp 
  where cd_emp = vp_empresa_new;

  if vl_qtde = 0 then
    --raise exception 'NÃO EXISTE NENHUMA EMPRESA COM ESSE CODIGO INFORMADO.';
    return 1;
  end if;

  select count(*)
    into vl_qtde
  from sc_cad.tbl_fem 
  where cd_emp = vp_empresa_new
    and cd_fem = vp_filial_new;

  if vl_qtde = 0 then
    --raise exception 'NÃO EXISTE NENHUMA FILIAL COM ESSE CODIGO INFORMADO VINCULADO A ESTA EMPRESA.';
    return 2;
  end if;

  if vp_empresa_old = vp_empresa_new and vp_filial_old = vp_filial_new then
      --raise exception 'PARA TRANSFERIR É NECESSARIO A NOVA EMPRESA E FILIAL SEREM DIFERENTES DA EMPRESA E FILIAL ANTERIOR.';
      return 7;
  end if;
      
  --1. verificando se o funcionario enviado esta ATIVO na empresa e filial informado
  select count(*)
    into vl_qtde
  from sc_cad.tbl_fnc fnc
  where cd_emp = vp_empresa_old
    and cd_fem = vp_filial_old
    and nr_idt_fnc = vp_matricula
    and st_fnc in (1, 3, 4, 5);

  if vl_qtde = 0 then
    --raise exception 'NÃO EXISTE NENHUM FUNCIONARIO ATIVO VINCULADO A ESTA EMPRESA E FILIAL COM A MATRICULA INFORMADA.';
    return 3;
  else
    select cd_fnc, cd_cun
      into vl_funcionario, vl_cad_unico
    from sc_cad.tbl_fnc fnc
    where cd_emp = vp_empresa_old
      and cd_fem = vp_filial_old
      and nr_idt_fnc = vp_matricula
      and st_fnc in (1, 3, 4, 5);

    select nr_cpf_cnpj_cun
      into vl_cpf
    from sc_cad.tbl_cun
    where cd_cun = vl_cad_unico;

    if vl_cpf <> vp_cpf then
      --raise exception 'NÃO É POSSÍVEL TRANSFERIR O FUNCIONARIO POIS O CPF INFORMADO NAO CONFERE COM O CPF VINCULADO AO FUNCIONARIO DA MATRICULA INFORMADA.';
      return 4;
    end if; 
  end if;
    
  --2. se for alterar a empresa, devera verificar se estar no mesmo grupo empresarial
  if vp_empresa_old <> vp_empresa_new then

    select cd_gem 
      into vl_grupo_empresarial_old 
    from sc_cad.tbl_emp 
    where cd_emp = vp_empresa_old;

    select cd_gem 
      into vl_grupo_empresarial_new 
    from sc_cad.tbl_emp 
    where cd_emp = vp_empresa_new;


    if vl_grupo_empresarial_old <> vl_grupo_empresarial_new then
      --raise exception 'NÃO É POSSÍVEL TRANSFERIR O FUNCIONÁRIO PARA ESTA NOVA EMPRESA DEVIDO A MESMA NÃO PERTENCER AO MESMO GRUPO EMPRESARIAL DA EMPRESA ANTERIOR.';
      return 5;
    end if;    
  end if;

  --3. alterar empresa e/ou filial do funcionario, caso nao tenha nenhum funcionario nesta empresa e filial com a matricula informada
  select count(*)
    into vl_qtde
  from sc_cad.tbl_fnc fnc
  where cd_emp = vp_empresa_new
    and cd_fem = vp_filial_new
    and nr_idt_fnc = vp_matricula;

  if vl_qtde > 0 then
    --raise exception 'JÁ EXISTE UM FUNCIONARIO VINCULADO A ESTA MATRICULA NESSA EMPRESA E FILIAL INFORMADA.';
    return 6;
  end if;
  
  update sc_cad.tbl_fnc 
    set cd_emp = vp_empresa_new,
        cd_fem = vp_filial_new
  where cd_emp = vp_empresa_old
    and cd_fem = vp_filial_old
    and nr_idt_fnc = vp_matricula;    
   
  --4. gravar auditoria de alteracao de empresa e filial
    INSERT INTO sc_cad.tbl_haef(cd_haef, cd_fnc, cd_emp_ant_haef, cd_fem_ant_haef, cd_emp_atl_haef, 
            cd_fem_atl_haef, obs_haef, cd_inc_usr, dt_inc_usr)
        VALUES (nextval('sc_cad.sq_haef'), vl_funcionario, vp_empresa_old, vp_filial_old, vp_empresa_new, 
                vp_filial_new, 'TRANSFERENCIA FUNCIONARIO SOLICITADO PELA EMPRESA', 1, now());
  
  --5. verificando se o contrato da nova empresa e filial é o mesmo do contrato do empresa e filial anterior, caso contrario, deverá ser alterado no cartao do funcionario
  select cd_ctr
    into vl_contrato_old
  from sc_cad.tbl_fem_ctr
  where cd_emp = vp_empresa_old
    and cd_fem = vp_filial_old
    and fg_atv_fem_ctr = 'S';

  select cd_ctr
    into vl_contrato_new
  from sc_cad.tbl_fem_ctr
  where cd_emp = vp_empresa_new
    and cd_fem = vp_filial_new
    and fg_atv_fem_ctr = 'S';

  if vl_contrato_old <> vl_contrato_new then
     select cd_crt 
       into vl_cartao
     from sc_opr.tbl_crt
     where cd_fnc = vl_funcionario;

     update sc_opr.tbl_crt set cd_ctr = vl_contrato_new where cd_crt = vl_cartao;
  end if; 

  return 0;
end;$$;


ALTER FUNCTION sc_cad.transferir_funcionario(vp_empresa_old numeric, vp_filial_old numeric, vp_empresa_new numeric, vp_filial_new numeric, vp_matricula character varying, vp_cpf numeric) OWNER TO scan;

--
-- TOC entry 1518 (class 1255 OID 564189)
-- Name: valida_saque_extra(numeric); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION valida_saque_extra(vp_plastico numeric) RETURNS character
    LANGUAGE plpgsql
    AS $$declare

  -- variavel auxiliar
  vl_cd_cun numeric;
  vl_cd_crt numeric;

  -- variavel de controle de atualizacao de dados
  vl_data_nascimento date;
  vl_numero_rg numeric;
  vl_pagamento_minimo sc_fcr.tbl_fcr.vl_mnm_fcr%type;

  vl_nome_mae sc_cad.tbl_cpf.nm_mae_cpf%type;
  vl_data_emissao_rg date;
  vl_orgao_emissor_rg sc_cad.tbl_cpf.nm_org_ems_rg_cpf%type;
  vl_naturalidade sc_cad.tbl_cpf.ds_nat_cpf%type;
  vl_nacionalidade sc_cad.tbl_cpf.ds_nac_cpf%type;
  vl_estado_civil numeric;
  vl_possui_endereco numeric;
  vl_possui_telefone numeric;
    
  -- variavel de controle financeiro
  vl_limite_saque_extra	double precision;

  -- variavel de retorno
  vl_retorno character := 'S';
  
begin

  -- consultando o codigo do cartao
  select pls.cd_crt
   into vl_cd_crt
  from sc_opr.tbl_pls pls
  where pls.cd_pls = vp_plastico;

  if vl_cd_crt is null then
    vl_retorno := 'N';
  end if;

  -- consultando se posssui limite de saque extra
  begin

    select vl_cnc_lmt
      into vl_limite_saque_extra
    from sc_opr.tbl_lmt
    where cd_crt = vl_cd_crt
      and cd_tlt = 1; -- tipo de limite saque extra

  exception 
    when others then
      vl_limite_saque_extra := 0; 
  end;  

    
  -- consultando os dados obrigatorios

  if vl_limite_saque_extra > 0 then

     begin

       select
         cpf.cd_cun,
         cpf.dt_nsc_cpf, 
         cpf.nr_rg_cpf, 
	 cpf.nm_mae_cpf, 
	 cpf.dt_ems_rg_cpf, 
	 cpf.nm_org_ems_rg_cpf, 
	 cpf.ds_nat_cpf, 
	 cpf.ds_nac_cpf, 
	 cpf.cd_est_civil_cpf
       into 
         vl_cd_cun,
       	 vl_data_nascimento,
	 vl_numero_rg,
	 vl_nome_mae,
	 vl_data_emissao_rg,
	 vl_orgao_emissor_rg,
	 vl_naturalidade,
	 vl_nacionalidade,
	 vl_estado_civil
       from sc_cad.tbl_cpf cpf
         inner join sc_cad.tbl_fnc fnc on fnc.cd_cun = cpf.cd_cun
         inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
       where crt.cd_crt = vl_cd_crt;
     exception
       when others then
       vl_retorno := 'N';
     end;

     if vl_retorno <> 'N' then
       if vl_data_nascimento is null or
	  vl_numero_rg is null or
	  vl_nome_mae is null or
	  --vl_data_emissao_rg is null or
	  --vl_orgao_emissor_rg is null or
	  vl_naturalidade is null or
	  vl_nacionalidade is null or
	  vl_estado_civil is null
	then

          vl_retorno := 'N';

	end if;  

	if vl_retorno <> 'N' then

          begin  
	    select count(*)
	     into vl_possui_endereco
	    from sc_cad.tbl_edr 
	    where cd_cun = vl_cd_cun
	      and fg_atv_edr = 'S';   
	  exception
	    when others then
	      vl_possui_endereco := 0;
	  end;

	  -- comentado para teste de aumento de saque extra	
	  /*begin  
	    select count(*)
	     into vl_possui_telefone
	    from sc_cad.tbl_tlf 
	    where nsu_org_tlf = vl_cd_cun
	      and tp_org_tlf = 1
	      and fg_atv_tlf = 'S'; -- tipo de origem pessoa fisica  
	  exception
	    when others then
	      vl_possui_telefone := 0;
	  end;	 
	  */

	  vl_possui_telefone := 1;

          if vl_possui_endereco <= 0 or vl_possui_telefone <= 0 then
            vl_retorno := 'N';
          end if;
	      
	end if;		
	
     end if;
    
  end if;
  

  return vl_retorno;

end;$$;


ALTER FUNCTION sc_cad.valida_saque_extra(vp_plastico numeric) OWNER TO scan;

--
-- TOC entry 1213 (class 1255 OID 564190)
-- Name: via_cartao_lockstar(); Type: FUNCTION; Schema: sc_cad; Owner: scan
--

CREATE FUNCTION via_cartao_lockstar() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin

  for rg in
   select * from sc_ssp.tbl_ssp where cd_fep = 579 loop

  insert into sc_opr.tbl_opr (cd_opr,cd_top,cd_pls,cd_atm,dt_opr,vl_opr,vl_jrs_opr,vl_trf_opr,nr_prc_opr,vl_prc_opr,vl_iof_opr,nr_nsu_org_opr,st_opr,st_saq_opr,dt_prc_opr,cd_pai_opr,tp_err_exp_opr,cd_aeo)
     values (nextval('sc_opr.sq_opr'),10,rg.cd_pls,null,current_timestamp,4.50,0,0,1,4.50,0,rg.cd_ssp,2,null,null,null,null,null);


  end loop;
end;$$;


ALTER FUNCTION sc_cad.via_cartao_lockstar() OWNER TO scan;

SET search_path = sc_calc, pg_catalog;

--
-- TOC entry 1341 (class 1255 OID 564191)
-- Name: calcula_cet(numeric, numeric, numeric, date, date, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_calc; Owner: scan
--

CREATE FUNCTION calcula_cet(vp_tx_anual numeric, vp_iof_aliquota numeric, vp_iof_parametro numeric, vp_dt_contrato date, vp_dt_vencimento date, vp_vlr_contrato numeric, vp_qt_prestacoes numeric, vp_vlr_prestacao numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$Declare
  
      vl_valor_cet                    numeric(12,8) := 0;
      vl_retorno_cet                  numeric(12,8) := 0;
      vl_soma                         numeric(15,6) := 0;
      vl_aux_dif                      numeric(13,2) := 0;
      vl_data_vencimento              date;
      vl_tentativas                   numeric(10) := 0;
      vl_sair                         boolean := false;
      vl_cont                         numeric(5) := 0;
      vl_fator_dias                   numeric(13,2) := 0;
  begin

       vl_soma := vp_tx_anual + vp_iof_aliquota + vp_iof_parametro;

       vl_valor_cet := round(vl_soma,2) / 100;

       vl_soma := 0;
       vl_aux_dif := abs(vl_soma - vp_vlr_contrato);

       while vl_aux_dif > 0.00001 loop

          vl_soma := 0;
          vl_data_vencimento := vp_dt_vencimento;
          vl_cont := vp_qt_prestacoes;
          vl_sair := false;

          -- iterando sobre as prestacoes - inicio
          while not vl_sair loop

             vl_fator_dias := (vl_data_vencimento - vp_dt_contrato)::numeric / 365;
             vl_soma := vl_soma + (vp_vlr_prestacao / power(1 + vl_valor_cet, vl_fator_dias));

             vl_data_vencimento := sc_grl.adicionar_mes(vl_data_vencimento, 1);

             vl_cont := vl_cont - 1;
             if vl_cont = 0 then
                vl_sair := true;
             end if;
          end loop;
          -- iterando sobre as prestacoes - fim

          vl_aux_dif := vl_soma - vp_vlr_contrato;
          if round(vl_aux_dif, 2) = 0 then
             exit;
          end if;

          if vl_aux_dif > 0 then
             vl_valor_cet := round(vl_valor_cet + 0.00001, 6);
          else
             vl_valor_cet := round(vl_valor_cet - 0.0000001, 8);
          end if;

          vl_tentativas := vl_tentativas + 1;

          if vl_tentativas > 1000 then
             exit;
          end if;
       end loop;

       vl_retorno_cet := vl_valor_cet * 100;

       return vl_retorno_cet;
  end;
$$;


ALTER FUNCTION sc_calc.calcula_cet(vp_tx_anual numeric, vp_iof_aliquota numeric, vp_iof_parametro numeric, vp_dt_contrato date, vp_dt_vencimento date, vp_vlr_contrato numeric, vp_qt_prestacoes numeric, vp_vlr_prestacao numeric) OWNER TO scan;

--
-- TOC entry 1218 (class 1255 OID 564192)
-- Name: calcula_iof(date, date, numeric, numeric, numeric, numeric, boolean, numeric, numeric); Type: FUNCTION; Schema: sc_calc; Owner: scan
--

CREATE FUNCTION calcula_iof(vp_dt_referencia date, vp_dt_vencimento date, vp_vlr_taxa numeric, vp_vlr_financiado numeric, vp_vlr_iof_parametro numeric, vp_vlr_iof_aliquota numeric, vp_iof_financiado boolean, vp_vlr_prestacao numeric, vp_qt_prestacoes numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$DECLARE
    vl_vlr_iof_dia              numeric(15,4) := 0;
    vl_qtd_dias                 numeric := 0;
    vl_qtd_dias_aux             numeric := 0;
    vl_vlr_soma_iof             numeric(15,4) := 0;
    vl_vlr_iof                  numeric(15,4) := 0;
    vl_vlr_prestacao_periodo    numeric(15,4) := 0;
    vl_dt_vencimento            date;
    vl_sair                     boolean := false;
    cont                        numeric := vp_qt_prestacoes;
    vl_qt_meses                 numeric;
  BEGIN

    vl_vlr_iof_dia := vp_vlr_iof_parametro / 365;
    vl_dt_vencimento := vp_dt_vencimento;

    vl_qt_meses := 1;
    while not vl_sair loop

      vl_qtd_dias := vl_dt_vencimento - vp_dt_referencia;
      vl_dt_vencimento := sc_grl.adicionar_mes(vp_dt_vencimento, vl_qt_meses);
      vl_vlr_prestacao_periodo := vp_vlr_prestacao / (power((vp_vlr_taxa / 100.0 + 1),(vl_qtd_dias / 30.0)));

      -- inicio - calcula iof da prestac?o
      if vl_qtd_dias > 365 then
        vl_qtd_dias_aux := 365;
      else
        vl_qtd_dias_aux := vl_qtd_dias;
      end if;

      vl_vlr_soma_iof := vl_vlr_soma_iof + ((vl_qtd_dias_aux / 30) * vl_vlr_prestacao_periodo * (vl_vlr_iof_dia / 100.0) * 30.0);
      -- fim - calcula iof da prestac?o

      cont := cont - 1;
      if cont = 0 then
         vl_sair := true;
      end if;
      vl_qt_meses := vl_qt_meses + 1;
    end loop;

    if vp_vlr_iof_aliquota > 0 then
      vl_vlr_iof := vl_vlr_soma_iof + vp_vlr_financiado * vp_vlr_iof_aliquota / 100.0;
    end if;

    if vp_iof_financiado then
      vl_vlr_iof := (vl_vlr_iof / (1 - (vl_vlr_iof / vp_vlr_financiado)));
    end if;

    return vl_vlr_iof;
  END;$$;


ALTER FUNCTION sc_calc.calcula_iof(vp_dt_referencia date, vp_dt_vencimento date, vp_vlr_taxa numeric, vp_vlr_financiado numeric, vp_vlr_iof_parametro numeric, vp_vlr_iof_aliquota numeric, vp_iof_financiado boolean, vp_vlr_prestacao numeric, vp_qt_prestacoes numeric) OWNER TO scan;

--
-- TOC entry 1623 (class 1255 OID 564193)
-- Name: calcula_valor_parcela(date, date, numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_calc; Owner: scan
--

CREATE FUNCTION calcula_valor_parcela(vp_data_base date, vp_data_venc_primeira date, vp_taxa_juros numeric, vp_valor_tarifa numeric, vp_qt_prestacoes numeric, vp_vl_financiado numeric, OUT vr_vl_iof numeric, OUT vr_vl_parcela numeric, OUT vr_vl_cet numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$DECLARE

      vl_valor_parcela       numeric (13,2) := 0;
      vl_valor_prestacao     numeric (13,2) := 0;
      vl_valor_iof           numeric (13,4) := 0;
      vl_financiado_iof	     numeric (13,2) := 0;
      vl_taxa_anual          numeric;

      vl_iof_aliquota        numeric (13,2) := 0;
      vl_iof_complementar    numeric (13,2):= 0;

      ct_iof_aliquota        constant varchar := 'ALIQUOTA_IOF_PESSOA_FISICA';
      ct_iof_complementar    constant varchar := 'ALIQUOTA IOF COMPLEMENTAR';
    BEGIN

     -- buscando os valores do iof
     select vl_prm::numeric
      into vl_iof_aliquota
     from sc_cad.tbl_prm
      where nm_prm =  ct_iof_aliquota;

      select vl_prm::numeric
      into vl_iof_complementar
     from sc_cad.tbl_prm
      where nm_prm =  ct_iof_complementar;


     vl_financiado_iof := vp_vl_financiado + vp_valor_tarifa;
     --vl_financiado_iof := vp_vl_financiado;

     vl_valor_prestacao := sc_calc.calcula_valor_prestacao (vp_data_base, vp_data_venc_primeira, vp_taxa_juros, vp_qt_prestacoes, vl_financiado_iof);
     vl_valor_iof := sc_calc.calcula_iof(vp_data_base, vp_data_venc_primeira, vp_taxa_juros, vl_financiado_iof, vl_iof_aliquota, vl_iof_complementar, true, vl_valor_prestacao, vp_qt_prestacoes);
     --vl_financiado_iof := vp_vl_financiado + vl_valor_iof + vp_valor_tarifa;
     vl_financiado_iof := vl_financiado_iof + vl_valor_iof;
     
     vl_valor_prestacao := sc_calc.calcula_valor_prestacao (vp_data_base, vp_data_venc_primeira, vp_taxa_juros, vp_qt_prestacoes, vl_financiado_iof);

     vl_valor_parcela :=  vl_valor_prestacao;

     vr_vl_iof := vl_valor_iof;
     vr_vl_parcela := vl_valor_parcela;
     vl_taxa_anual := sc_calc.calcular_taxa_anual(vp_taxa_juros);
     vr_vl_cet := sc_calc.calcula_cet(vl_taxa_anual, vl_iof_aliquota, vl_iof_complementar, vp_data_base, vp_data_venc_primeira, vl_financiado_iof, vp_qt_prestacoes, vl_valor_parcela);

    END;$$;


ALTER FUNCTION sc_calc.calcula_valor_parcela(vp_data_base date, vp_data_venc_primeira date, vp_taxa_juros numeric, vp_valor_tarifa numeric, vp_qt_prestacoes numeric, vp_vl_financiado numeric, OUT vr_vl_iof numeric, OUT vr_vl_parcela numeric, OUT vr_vl_cet numeric) OWNER TO scan;

--
-- TOC entry 1622 (class 1255 OID 928245)
-- Name: calcula_valor_parcela_teste(date, date, numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_calc; Owner: scan
--

CREATE FUNCTION calcula_valor_parcela_teste(vp_data_base date, vp_data_venc_primeira date, vp_taxa_juros numeric, vp_valor_tarifa numeric, vp_qt_prestacoes numeric, vp_vl_financiado numeric, OUT vr_vl_iof numeric, OUT vr_vl_parcela numeric, OUT vr_vl_cet numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$DECLARE

      vl_valor_parcela       numeric (13,2) := 0;
      vl_valor_prestacao     numeric (13,2) := 0;
      vl_valor_iof           numeric (13,4) := 0;
      vl_financiado_iof	     numeric (13,2) := 0;
      vl_taxa_anual          numeric;

      vl_iof_aliquota        numeric (13,2) := 0;
      vl_iof_complementar    numeric (13,2):= 0;

      ct_iof_aliquota        constant varchar := 'ALIQUOTA_IOF_PESSOA_FISICA';
      ct_iof_complementar    constant varchar := 'ALIQUOTA IOF COMPLEMENTAR';
    BEGIN

     -- buscando os valores do iof
     select vl_prm::numeric
      into vl_iof_aliquota
     from sc_cad.tbl_prm
      where nm_prm =  ct_iof_aliquota;

      select vl_prm::numeric
      into vl_iof_complementar
     from sc_cad.tbl_prm
      where nm_prm =  ct_iof_complementar;


     vl_financiado_iof := vp_vl_financiado + vp_valor_tarifa;
     --vl_financiado_iof := vp_vl_financiado;

     vl_valor_prestacao := sc_calc.calcula_valor_prestacao (vp_data_base, vp_data_venc_primeira, vp_taxa_juros, vp_qt_prestacoes, vl_financiado_iof);
     vl_valor_iof := sc_calc.calcula_iof(vp_data_base, vp_data_venc_primeira, vp_taxa_juros, vl_financiado_iof, vl_iof_aliquota, vl_iof_complementar, true, vl_valor_prestacao, vp_qt_prestacoes);
     --vl_financiado_iof := vp_vl_financiado + vl_valor_iof + vp_valor_tarifa;
     vl_financiado_iof := vl_financiado_iof + vl_valor_iof;
     
     vl_valor_prestacao := sc_calc.calcula_valor_prestacao (vp_data_base, vp_data_venc_primeira, vp_taxa_juros, vp_qt_prestacoes, vl_financiado_iof);

     vl_valor_parcela :=  vl_valor_prestacao;

     vr_vl_iof := vl_valor_iof;
     vr_vl_parcela := vl_valor_parcela;
     vl_taxa_anual := sc_calc.calcular_taxa_anual(vp_taxa_juros);
     vr_vl_cet := sc_calc.calcula_cet(vl_taxa_anual, vl_iof_aliquota, vl_iof_complementar, vp_data_base, vp_data_venc_primeira, vl_financiado_iof, vp_qt_prestacoes, vl_valor_parcela);

    END;$$;


ALTER FUNCTION sc_calc.calcula_valor_parcela_teste(vp_data_base date, vp_data_venc_primeira date, vp_taxa_juros numeric, vp_valor_tarifa numeric, vp_qt_prestacoes numeric, vp_vl_financiado numeric, OUT vr_vl_iof numeric, OUT vr_vl_parcela numeric, OUT vr_vl_cet numeric) OWNER TO scan;

--
-- TOC entry 1219 (class 1255 OID 564194)
-- Name: calcula_valor_prestacao(date, date, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_calc; Owner: scan
--

CREATE FUNCTION calcula_valor_prestacao(vp_data_base date, vp_data_venc_primeira date, vp_taxa_juros numeric, vp_qt_prestacoes numeric, vp_vl_financiado numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$DECLARE

      vl_valor_prestacao     numeric(13,2) := 0;
      vl_soma                numeric(30,16) := 0;
      vl_sair                boolean := false;
      cont                   numeric := 0;
      vl_diferencia_dias     numeric := 0;
      vl_data_vencimento     date;
      vl_dia                 numeric := 0;
      vl_qt_meses            numeric;

    BEGIN

      -- calculando o fator da prestacao - inicio
      cont := vp_qt_prestacoes;
      vl_data_vencimento := vp_data_venc_primeira;
      vl_dia := to_char(vl_data_vencimento, 'dd');

      vl_qt_meses := 1;
      while not vl_sair loop

        vl_diferencia_dias := (vl_data_vencimento - vp_data_base)::numeric;
        vl_data_vencimento := sc_grl.adicionar_mes(vp_data_venc_primeira, vl_qt_meses);

        vl_soma := vl_soma + ( 1 / (power((vp_taxa_juros / 100 + 1), vl_diferencia_dias / 30)));

        cont := cont - 1;
        vl_qt_meses := vl_qt_meses + 1;
        if cont = 0 then
           vl_sair := true;
        end if;
      end loop;
      -- calculando o fator da prestacao - fim

      -- divindindo o valor financiado pelo resultado
      vl_valor_prestacao := vp_vl_financiado / vl_soma;

      return vl_valor_prestacao;
    END;$$;


ALTER FUNCTION sc_calc.calcula_valor_prestacao(vp_data_base date, vp_data_venc_primeira date, vp_taxa_juros numeric, vp_qt_prestacoes numeric, vp_vl_financiado numeric) OWNER TO scan;

--
-- TOC entry 1220 (class 1255 OID 564195)
-- Name: calcular_taxa_anual(numeric); Type: FUNCTION; Schema: sc_calc; Owner: scan
--

CREATE FUNCTION calcular_taxa_anual(vp_taxa_mensal numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$DECLARE
    vl_taxa_anual numeric(12, 8);
  begin
    vl_taxa_anual := round(power(1 + (vp_taxa_mensal / 100), 12) - 1, 10) * 100;

    return vl_taxa_anual;
  end;$$;


ALTER FUNCTION sc_calc.calcular_taxa_anual(vp_taxa_mensal numeric) OWNER TO scan;

SET search_path = sc_cap, pg_catalog;

--
-- TOC entry 1642 (class 1255 OID 564196)
-- Name: cancelar_despesa(numeric, character varying, numeric); Type: FUNCTION; Schema: sc_cap; Owner: postgres
--

CREATE FUNCTION cancelar_despesa(vp_cod_despesa numeric, vp_observacao character varying, vp_codigo_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   VL_SITUACAO_AUTORIZADA     sc_cap.tbl_dsp.st_dsp%type  :=  2;
   VL_SITUACAO_CONFIRMADA     sc_cap.tbl_dsp.st_dsp%type  :=  3;
   VL_SITUACAO_CANCELADA      sc_cap.tbl_dsp.st_dsp%type  :=  4;

   VL_SISTEMA_DESPESA         sc_cnt.tbl_sst.cd_sst%type  := 18;

   VL_CONTA_COFINS_A_RECOLHER sc_cnt.tbl_cnt.cd_cnt%type  := 39;
   VL_CONTA_CSLL_A_RECOLHER   sc_cnt.tbl_cnt.cd_cnt%type  := 41;
   VL_CONTA_INSS_A_RECOLHER   sc_cnt.tbl_cnt.cd_cnt%type  := 43;
   VL_CONTA_ISS_A_RECOLHER    sc_cnt.tbl_cnt.cd_cnt%type  := 42;
   VL_CONTA_PIS_A_RECOLHER    sc_cnt.tbl_cnt.cd_cnt%type  := 38;
   VL_CONTA_IR_A_RECOLHER     sc_cnt.tbl_cnt.cd_cnt%type  := 40;
   VL_CONTA_DESCONTO          sc_cnt.tbl_cnt.cd_cnt%type  := 20079;
   

   vl_conta_despesa numeric;
   vl_conta_liquidacao numeric;
   vl_conta_fornecedor numeric;
   vl_situacao_despesa numeric;
   vl_conta_debito_despesa numeric;
   vl_codigo_lancamento_estorno numeric;
   vl_despesa numeric;
   vl_liquido_despesa numeric;
   vl_pis numeric;
   vl_cofins numeric;
   vl_ir numeric;
   vl_inss numeric;
   vl_csll numeric;
   vl_iss numeric;
   vl_desconto numeric;
   vl_numero_lancamento numeric;
   vl_numero_lancamento_aux numeric;   
   vl_flag_provisao character;
   vl_data_autorizacao date;
   vl_data_confirmacao date;
   vl_data_referencia date;
   
begin

    select tdp.cd_cnt,
           dsp.cd_cnt,
           frn.cd_cnt,
           dsp.cd_cnt_dbt_dsp,
           dsp.st_dsp,
           tlc.cd_est_tlc,
           dt_aut_usr,
           dt_cnf_usr,
           dt_ref_dsp,
           vl_dsp,
           vl_pis_dsp,
           vl_cofins_dsp,
           vl_ir_dsp,
           vl_inss_dsp,
           vl_csll_dsp,
           vl_iss_dsp,
           vl_dsc_dsp,
           fg_prv_dsp
    into vl_conta_despesa,
         vl_conta_liquidacao,
         vl_conta_fornecedor,
         vl_conta_debito_despesa,
         vl_situacao_despesa,
         vl_codigo_lancamento_estorno,
         vl_data_autorizacao,
         vl_data_confirmacao,
         vl_data_referencia,
         vl_despesa,
         vl_pis,
         vl_cofins,
         vl_ir,
         vl_inss,
         vl_csll,
         vl_iss,
         vl_desconto,
         vl_flag_provisao
    from sc_cap.tbl_dsp dsp
      left join sc_cap.tbl_frn frn on frn.cd_frn = dsp.cd_frn
      inner join sc_cap.tbl_tdp tdp on tdp.cd_tdp = dsp.cd_tdp
      inner join sc_cnt.tbl_tlc tlc on tlc.cd_tlc = tdp.cd_tlc
    where cd_dsp = vp_cod_despesa;

    -- Desfaz autorização
    if (vl_situacao_despesa = VL_SITUACAO_AUTORIZADA OR vl_situacao_despesa = VL_SITUACAO_CONFIRMADA) then

       vl_liquido_despesa := vl_despesa - coalesce(vl_pis,0) - coalesce(vl_cofins,0) - coalesce(vl_ir,0) - coalesce(vl_inss,0) - coalesce(vl_csll,0) - coalesce(vl_iss,0) - coalesce(vl_desconto,0);

       if vl_situacao_despesa = VL_SITUACAO_CONFIRMADA then
           perform sc_cnt.lancar_debito_credito(vl_conta_liquidacao,coalesce(vl_conta_fornecedor,vl_conta_debito_despesa),vl_codigo_lancamento_estorno,null,vp_observacao,vl_liquido_despesa,vl_data_confirmacao,vp_codigo_usuario,VL_SISTEMA_DESPESA,vp_cod_despesa);

	    update sc_cap.tbl_dsp
	    set st_dsp = VL_SITUACAO_AUTORIZADA,
		cd_cnc_usr = vp_codigo_usuario,
		dt_cnc_usr = now()
	    where cd_dsp = vp_cod_despesa;     
	          
       end if;
       if (vl_situacao_despesa = VL_SITUACAO_AUTORIZADA) then 	

            if vl_flag_provisao = 'S' then 
        
		       select nextval('sc_cnt.sq_lcn') into vl_numero_lancamento;
		       
		       vl_numero_lancamento_aux := null;	
		       
		       perform sc_cnt.lancar_movimento(vl_numero_lancamento,null,vl_codigo_lancamento_estorno,vl_conta_despesa,'C',vl_despesa,vl_data_autorizacao,vp_codigo_usuario,null,vp_observacao, VL_SISTEMA_DESPESA, vp_cod_despesa);

		       vl_numero_lancamento_aux := null;
			
		       if(coalesce(vl_pis,0) > 0) then
			    perform sc_cnt.lancar_movimento(vl_numero_lancamento_aux,vl_numero_lancamento,vl_codigo_lancamento_estorno,VL_CONTA_PIS_A_RECOLHER,'D',vl_pis,vl_data_autorizacao,vp_codigo_usuario,null,vp_observacao, VL_SISTEMA_DESPESA, vp_cod_despesa);
		       end if;

		       vl_numero_lancamento_aux := null;

		       if(coalesce(vl_cofins,0) > 0) then
			    perform sc_cnt.lancar_movimento(vl_numero_lancamento_aux,vl_numero_lancamento,vl_codigo_lancamento_estorno,VL_CONTA_COFINS_A_RECOLHER,'D',vl_cofins,vl_data_autorizacao,vp_codigo_usuario,null,vp_observacao, VL_SISTEMA_DESPESA, vp_cod_despesa);
		       end if;

		       vl_numero_lancamento_aux := null;

		       if(coalesce(vl_ir,0) > 0) then
			    perform sc_cnt.lancar_movimento(vl_numero_lancamento_aux,vl_numero_lancamento,vl_codigo_lancamento_estorno,VL_CONTA_IR_A_RECOLHER,'D',vl_ir,vl_data_autorizacao,vp_codigo_usuario,null,vp_observacao, VL_SISTEMA_DESPESA, vp_cod_despesa);
		       end if;

		       vl_numero_lancamento_aux := null;

		       if(coalesce(vl_inss,0) > 0) then
			    perform sc_cnt.lancar_movimento(vl_numero_lancamento_aux,vl_numero_lancamento,vl_codigo_lancamento_estorno,VL_CONTA_INSS_A_RECOLHER,'D',vl_inss,vl_data_autorizacao,vp_codigo_usuario,null,vp_observacao, VL_SISTEMA_DESPESA, vp_cod_despesa);
		       end if;

		       vl_numero_lancamento_aux := null;
		       
		       if(coalesce(vl_csll,0) > 0) then
			    perform sc_cnt.lancar_movimento(vl_numero_lancamento_aux,vl_numero_lancamento,vl_codigo_lancamento_estorno,VL_CONTA_CSLL_A_RECOLHER,'D',vl_csll,vl_data_autorizacao,vp_codigo_usuario,null,vp_observacao, VL_SISTEMA_DESPESA, vp_cod_despesa);
		       end if;

		       vl_numero_lancamento_aux := null;

		       if(coalesce(vl_iss,0) > 0) then
			    perform sc_cnt.lancar_movimento(vl_numero_lancamento_aux,vl_numero_lancamento,vl_codigo_lancamento_estorno,VL_CONTA_ISS_A_RECOLHER,'D',vl_iss,vl_data_autorizacao,vp_codigo_usuario,null,vp_observacao, VL_SISTEMA_DESPESA, vp_cod_despesa);
		       end if;

		       if(coalesce(vl_desconto,0) > 0) then
			    perform sc_cnt.lancar_movimento(vl_numero_lancamento_aux,vl_numero_lancamento,vl_codigo_lancamento_estorno,VL_CONTA_DESCONTO,'D',vl_desconto,vl_data_autorizacao,vp_codigo_usuario,null,vp_observacao, VL_SISTEMA_DESPESA, vp_cod_despesa);
		       end if;

		       perform sc_cnt.lancar_movimento(vl_numero_lancamento_aux,vl_numero_lancamento,vl_codigo_lancamento_estorno,coalesce(vl_conta_fornecedor,vl_conta_debito_despesa),'D',vl_liquido_despesa,vl_data_autorizacao,vp_codigo_usuario,null,vp_observacao, VL_SISTEMA_DESPESA, vp_cod_despesa);
	       
	      end if;   

	       update sc_cap.tbl_dsp
	       set st_dsp = VL_SITUACAO_CANCELADA,
		   cd_cnc_usr = vp_codigo_usuario,
		   dt_cnc_usr = now()
	       where cd_dsp = vp_cod_despesa;
	    
	    end if;

	end if;    

end$$;


ALTER FUNCTION sc_cap.cancelar_despesa(vp_cod_despesa numeric, vp_observacao character varying, vp_codigo_usuario numeric) OWNER TO postgres;

SET search_path = sc_cbe, pg_catalog;

--
-- TOC entry 1815 (class 1255 OID 1667151)
-- Name: cancelar_baixa_parcela(numeric, numeric); Type: FUNCTION; Schema: sc_cbe; Owner: scan
--

CREATE FUNCTION cancelar_baixa_parcela(vp_cod_baixa numeric, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_cod_acordo numeric;
  vl_cod_parcela numeric;
  
  vl_flag_entrada character;
  vl_cod_empresa_cobranca numeric;
  vl_cod_divida numeric;
   
  vl_situacao_parcela numeric;
  vl_situacao_baixa numeric;
  vl_situacao_divida numeric;
  vl_situacao_acordo numeric;
  
  vl_data_baixa date;
  vl_valor_baixa numeric;

  ct_st_acordo_cadastrado constant numeric := 1;
  ct_st_acordo_confirmado constant numeric := 2;
  ct_st_acordo_finalizado constant numeric := 3;

  ct_st_divida_liquidada constant numeric := 3;
  ct_st_divida_confirmada constant numeric := 6;

  ct_st_parc_cadastrada constant numeric := 1;
  ct_st_parc_paga constant numeric       := 2;

  ct_st_baixa_cancelada constant numeric := 2;

  CT_NUMERO_DIAS_MAXIMO constant numeric := 10;
begin
  --obtendo os dados da baixa, da parcela e do arcodo
  select acr.st_acr, prd.st_prd, bpr.st_bpr, bpr.dt_bpr, prd.fg_ent_prd, 
         acr.cd_acr, acr.cd_emc, acr.cd_dvd, prd.cd_prd,
         bpr.vl_bpr, dvd.st_dvd
    into vl_situacao_acordo, vl_situacao_parcela, vl_situacao_baixa, vl_data_baixa, vl_flag_entrada, 
         vl_cod_acordo, vl_cod_empresa_cobranca, vl_cod_divida, vl_cod_parcela,
         vl_valor_baixa, vl_situacao_divida
  from sc_cbe.tbl_acr acr
       inner join sc_cbe.tbl_dvd dvd on acr.cd_dvd = dvd.cd_dvd
       inner join sc_cbe.tbl_prd prd on prd.cd_acr = acr.cd_acr
       inner join sc_cbe.tbl_bpr bpr on prd.cd_prd = bpr.cd_prd
  where bpr.cd_bpr = vp_cod_baixa;  

  if vl_situacao_baixa = ct_st_baixa_cancelada then
    raise exception 'A BAIXA DE NÚMERO: % JÁ FOI CANCELADA', vp_cod_baixa;
  end if;

  if vl_data_baixa < current_date - (interval '1 day' * CT_NUMERO_DIAS_MAXIMO) then
    raise exception 'A BAIXA FOI REALIZADA MAIS DE % DIAS E NÃO PODE SER MAIS CANCELADA', CT_NUMERO_DIAS_MAXIMO;
  end if;

  --alterando a situacao da baixa para cancelada
  update sc_cbe.tbl_bpr 
     set st_bpr = ct_st_baixa_cancelada,
         cd_alt_usr = vp_usuario,
         dt_alt_usr = now()
  where cd_bpr = vp_cod_baixa;

  --alterando a situacao da parcela para cadastrada
  update sc_cbe.tbl_prd 
     set st_prd = ct_st_parc_cadastrada,
         vlr_pgt_prd = coalesce(vlr_pgt_prd,0) - vl_valor_baixa,
         dt_ult_pgm_prd = (select max(dt_bpr) from sc_cbe.tbl_bpr where cd_prd = vl_cod_parcela and st_bpr = ct_st_parc_cadastrada)
  where cd_prd = vl_cod_parcela;

  --atualizando a situacao do acordo, caso tenha sido confirmado pela baixa
  if vl_situacao_acordo = ct_st_acordo_confirmado and vl_flag_entrada = 'S' then
    update sc_cbe.tbl_acr set st_acr = ct_st_acordo_cadastrado where cd_acr = vl_cod_acordo;
  end if;

  --atualizando a situacao do acordo, caso tenha sido finalizado pela baixa
  if vl_situacao_acordo = ct_st_acordo_finalizado then
    update sc_cbe.tbl_acr set st_acr = ct_st_acordo_confirmado where cd_acr = vl_cod_acordo;
  end if; 

  --atualizando a situacao da divida, caso ela tenha sido liquidada pela baixa
  if vl_situacao_divida = ct_st_divida_liquidada then
    update sc_cbe.tbl_dvd set st_dvd = ct_st_divida_confirmada where cd_dvd = vl_cod_divida;
  end if;
  
end$$;


ALTER FUNCTION sc_cbe.cancelar_baixa_parcela(vp_cod_baixa numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1519 (class 1255 OID 855502)
-- Name: efetuar_baixa_parcela(numeric, numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_cbe; Owner: scan
--

CREATE FUNCTION efetuar_baixa_parcela(vp_cod_parcela numeric, vp_valor numeric, vp_tipo_baixa numeric, vp_data date, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   st_parc_cadastrada numeric := 1;
   st_parc_paga numeric       := 2;

   vl_cod_acordo numeric;
   vl_situacao_acordo numeric;
   vl_flag_entrada character;
   vl_cod_empresa_cobranca numeric;
   vl_cod_divida numeric;

  ct_st_acordo_cadastrado numeric := 1;
  ct_st_acordo_confirmado numeric := 2;
  ct_st_acordo_finalizado numeric := 3;

  ct_st_divida_liquidada numeric := 3;
  

  vl_num_parc_aberto numeric:=0;

  vl_situacao_parcela numeric;
  vl_valor_restante numeric;
   
begin

     select acr.st_acr,prd.fg_ent_prd,acr.cd_acr, acr.cd_emc, acr.cd_dvd,vlr_prd - coalesce(vlr_pgt_prd,0) 
     into vl_situacao_acordo,vl_flag_entrada,vl_cod_acordo,vl_cod_empresa_cobranca, vl_cod_divida, vl_valor_restante
     from sc_cbe.tbl_acr acr
       inner join sc_cbe.tbl_prd prd on prd.cd_acr = acr.cd_acr
     where prd.cd_prd = vp_cod_parcela;  

     insert into sc_cbe.tbl_bpr(cd_bpr,cd_prd,st_bpr,dsc_bpr,dt_bpr,cd_inc_usr,dt_inc_usr, tp_bpr, cd_emc, vl_bpr) 
       values(nextval('sc_cbe.sq_bpr'),vp_cod_parcela,1,'BAIXA COBRANCA', vp_data, vp_usuario, now(), vp_tipo_baixa, vl_cod_empresa_cobranca, vp_valor);


     if vp_valor >= vl_valor_restante then
        vl_situacao_parcela := st_parc_paga;
     else
        vl_situacao_parcela := st_parc_cadastrada;
     end if;
     
     update sc_cbe.tbl_prd 
     set vlr_pgt_prd = coalesce(vlr_pgt_prd,0) + vp_valor,
	 st_prd = vl_situacao_parcela,
	 dt_ult_pgm_prd = now() 
     where cd_prd = vp_cod_parcela;     

     if vl_situacao_acordo = ct_st_acordo_cadastrado and vl_flag_entrada = 'S' then

        update sc_cbe.tbl_acr set st_acr = ct_st_acordo_confirmado where cd_acr = vl_cod_acordo;
  
     end if; 

     select count(*)
     into vl_num_parc_aberto
     from sc_cbe.tbl_prd
     where st_prd = st_parc_cadastrada
       and cd_acr = vl_cod_acordo;


     if vl_num_parc_aberto = 0 then
       update sc_cbe.tbl_acr set st_acr = ct_st_acordo_finalizado where cd_acr = vl_cod_acordo;
       update sc_cbe.tbl_dvd set st_dvd = ct_st_divida_liquidada where cd_dvd = vl_cod_divida;
     end if;
     
  
end$$;


ALTER FUNCTION sc_cbe.efetuar_baixa_parcela(vp_cod_parcela numeric, vp_valor numeric, vp_tipo_baixa numeric, vp_data date, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1508 (class 1255 OID 844406)
-- Name: existe_acordo_vigente(numeric, numeric); Type: FUNCTION; Schema: sc_cbe; Owner: scan
--

CREATE FUNCTION existe_acordo_vigente(vp_tipo_origem numeric, vp_nsu_origem numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$declare
  CT_SITUACAO_DIVIDA_RENEGOCIADA numeric := 2;
  vl_quantidade numeric := 0;
begin

   select count(*)
   into vl_quantidade
   from sc_cbe.tbl_dvd dvd
   where dvd.tp_org_dvd = vp_tipo_origem
     and dvd.nsu_org_dvd = vp_nsu_origem
     and dvd.st_dvd = CT_SITUACAO_DIVIDA_RENEGOCIADA;

   if coalesce(vl_quantidade,0) > 0 then
      return true;
   end if;

   return false;  
end$$;


ALTER FUNCTION sc_cbe.existe_acordo_vigente(vp_tipo_origem numeric, vp_nsu_origem numeric) OWNER TO scan;

--
-- TOC entry 1773 (class 1255 OID 1672261)
-- Name: gerar_acordo_funcionario_empresa(integer, date, date); Type: FUNCTION; Schema: sc_cbe; Owner: scan
--

CREATE FUNCTION gerar_acordo_funcionario_empresa(vp_empresa integer, vp_data_venc_entrada date, vp_data_venc_parcela_1 date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;

  vl_codigo_acordo numeric;
  vl_qtde_parcelas numeric;

  vl_nr_parcela integer := 1;
  vl_data_vencimento date;
  vl_i integer;
begin
  for vl_rg in select afe.id, dvd.cd_dvd as codigo_divida, afe.valor_entrada, afe.valor_parcela_1, afe.valor_parcela_2, 
                       afe.valor_parcela_3, afe.valor_parcela_4, afe.valor_parcela_5, afe.valor_parcela_6,
                       afe.valor_parcela_7, afe.valor_parcela_8, afe.valor_parcela_9, afe.valor_parcela_10,
                       afe.valor_parcela_11, afe.valor_parcela_12
                from sc_cbe.acordo_funcionario_empresa afe
                     inner join sc_cad.tbl_cun cun on cun.nr_cpf_cnpj_cun = afe.cpf
                     inner join sc_cbe.tbl_dvd dvd on cun.cd_cun = dvd.cd_cun and dvd.nsu_org_dvd = afe.cartao
                where afe.cd_acr is null
                  --and dvd.cd_dvd = 11794
                  and dvd.st_dvd = 1
                  and afe.empresa = afe.empresa loop

    vl_nr_parcela := 1;
    
    select nextval('sc_cbe.sq_acr')
      into vl_codigo_acordo;
    
    vl_qtde_parcelas := 1;

    if vl_rg.valor_parcela_2 > 0 then
      vl_qtde_parcelas := vl_qtde_parcelas + 1;
      if vl_rg.valor_parcela_3 > 0 then
        vl_qtde_parcelas := vl_qtde_parcelas + 1;
        if vl_rg.valor_parcela_4 > 0 then
          vl_qtde_parcelas := vl_qtde_parcelas + 1;
          if vl_rg.valor_parcela_5 > 0 then
            vl_qtde_parcelas := vl_qtde_parcelas + 1;
            if vl_rg.valor_parcela_6 > 0 then
              vl_qtde_parcelas := vl_qtde_parcelas + 1;
              if vl_rg.valor_parcela_7 > 0 then
                vl_qtde_parcelas := vl_qtde_parcelas + 1;
                if vl_rg.valor_parcela_8 > 0 then
                  vl_qtde_parcelas := vl_qtde_parcelas + 1;
                  if vl_rg.valor_parcela_9 > 0 then
                    vl_qtde_parcelas := vl_qtde_parcelas + 1;
                    if vl_rg.valor_parcela_10 > 0 then
                      vl_qtde_parcelas := vl_qtde_parcelas + 1;
                      if vl_rg.valor_parcela_11 > 0 then
                        vl_qtde_parcelas := vl_qtde_parcelas + 1;
                        if vl_rg.valor_parcela_12 > 0 then
                          vl_qtde_parcelas := vl_qtde_parcelas + 1;
                        end if;
                      end if;
                    end if;
                  end if;
                end if;
              end if;
            end if;
          end if;
        end if;
      end if;
    end if;

    insert into sc_cbe.tbl_acr(cd_acr, cd_dvd, st_acr, frm_pgm_acr, vlr_mlt_acr, vlr_mra_acr, vlr_dsc_acr, vlr_ent_acr, vlr_cms_acr, qnt_prc_acr, vlr_prc_acr,
                               dt_vnc_ent_acr, dt_vnc_prm_prc_acr, cd_inc_usr, dt_inc_usr, vlr_esp_acr, cd_emc, tx_jrs_acr)
    values(vl_codigo_acordo, vl_rg.codigo_divida, 1, 2, 3.0, 2.0, 0.0, vl_rg.valor_entrada, 30.00, vl_qtde_parcelas, vl_rg.valor_parcela_1,
           vp_data_venc_entrada, vp_data_venc_parcela_1, 1, now(), 0, 2, 6.5);

    insert into sc_cbe.tbl_prd(cd_prd, cd_acr, nr_prd, vlr_prd, st_prd, dt_vnc_prd, fg_ent_prd, fg_dbt_aut_prd)
    values(nextval('sc_cbe.sq_prd'), vl_codigo_acordo, vl_nr_parcela, vl_rg.valor_entrada, 1, vp_data_venc_entrada, 'S', 'S');

    vl_data_vencimento := vp_data_venc_parcela_1;

    for vl_i in 1..vl_qtde_parcelas loop
      vl_nr_parcela := vl_nr_parcela + 1;

      insert into sc_cbe.tbl_prd(cd_prd, cd_acr, nr_prd, vlr_prd, st_prd, dt_vnc_prd, fg_ent_prd, fg_dbt_aut_prd)
      values(nextval('sc_cbe.sq_prd'), vl_codigo_acordo, vl_nr_parcela, vl_rg.valor_parcela_1, 1, vl_data_vencimento, 'N', 'S');

      vl_data_vencimento := vl_data_vencimento + interval '1 month';
    end loop;

    update sc_cbe.acordo_funcionario_empresa set cd_acr = vl_codigo_acordo where id = vl_rg.id;
    update sc_cbe.tbl_dvd set st_dvd = 2, cd_acr = vl_codigo_acordo where cd_dvd = vl_rg.codigo_divida;
  end loop;
end;$$;


ALTER FUNCTION sc_cbe.gerar_acordo_funcionario_empresa(vp_empresa integer, vp_data_venc_entrada date, vp_data_venc_parcela_1 date) OWNER TO scan;

--
-- TOC entry 7712 (class 0 OID 0)
-- Dependencies: 1773
-- Name: FUNCTION gerar_acordo_funcionario_empresa(vp_empresa integer, vp_data_venc_entrada date, vp_data_venc_parcela_1 date); Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON FUNCTION gerar_acordo_funcionario_empresa(vp_empresa integer, vp_data_venc_entrada date, vp_data_venc_parcela_1 date) IS 'rotina que a partir da tabela acordo_funcionario_empresa gera os registros na tabela de acordo';


--
-- TOC entry 1822 (class 1255 OID 1009383)
-- Name: gerar_arquivo_cobranca_padrao(numeric); Type: FUNCTION; Schema: sc_cbe; Owner: scan
--

CREATE FUNCTION gerar_arquivo_cobranca_padrao(vp_empresa_cobranca numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg_emc record;

  vl_nome_arquivo varchar;
  vl_local_arquivo varchar;

  vl_codigo_arquivo numeric;
  vl_data_referencia date := current_date;
  
  CT_EMPRESA_COBRANCA_VALOR constant numeric := 5;
  CT_TP_COBRANCA_TERCEIRIZADA constant numeric := 4;
  CT_ST_ARQUIVO_GERADO constant numeric := 2;
  CT_ST_DOWNLOAD_GERADO constant numeric := 1;
begin
    for vl_rg_emc in select * 
                     from sc_cbe.tbl_emc  
                     where fg_atv_emc = 'S'
					   and nm_dir_arq is not null
                       and cd_emc = coalesce(vp_empresa_cobranca, cd_emc) loop 

        -- populando o arquivo
        vl_codigo_arquivo := sc_cbe.popula_arquivo_cobranca_tercerizada(vl_rg_emc.cd_emc);

        if vl_codigo_arquivo is not null then
      
            --definindo o nome do arquivo
            vl_nome_arquivo := vl_rg_emc.nm_emc || to_char(vl_data_referencia, 'yyyymmdd') || '.' || trim(to_char(vl_codigo_arquivo, repeat('0', 5))) || '.csv';

            --definindo onde o arquivo sera gravado
            vl_local_arquivo := vl_rg_emc.nm_dir_arq || E'\\' || vl_nome_arquivo;

            if vl_rg_emc.cd_emc = CT_EMPRESA_COBRANCA_VALOR then
                perform sc_cbe.gerar_detalhe_arquivo_cobranca_valor(vl_local_arquivo, vl_codigo_arquivo);
            else
                perform sc_cbe.gerar_detalhe_arquivo_cobranca_padrao(vl_local_arquivo, vl_codigo_arquivo);
            end if;

            --atualizando situacao do arquivo para gerado
            update sc_cbe.tbl_act set st_act = CT_ST_ARQUIVO_GERADO where cd_act = vl_codigo_arquivo;
 
            --inserindo registro na tabela de download
            insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'), vl_nome_arquivo, now(), vl_data_referencia, CT_TP_COBRANCA_TERCEIRIZADA, CT_ST_DOWNLOAD_GERADO);
        end if;   
    end loop;
exception 
    when others then
        perform sc_arq.excluirArquivo(vl_local_arquivo); 
        RAISE EXCEPTION 'Problema na geração do arquivo de emissão de plastico. NUM:%, DETAILS:%', SQLSTATE, SQLERRM;
end;
$$;


ALTER FUNCTION sc_cbe.gerar_arquivo_cobranca_padrao(vp_empresa_cobranca numeric) OWNER TO scan;

--
-- TOC entry 1132 (class 1255 OID 1622953)
-- Name: gerar_detalhe_arquivo_cobranca_padrao(character varying, numeric); Type: FUNCTION; Schema: sc_cbe; Owner: scan
--

CREATE FUNCTION gerar_detalhe_arquivo_cobranca_padrao(vp_local_arquivo character varying, vp_codigo_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  vl_rg_dct record;

  ct_tipo_residencial constant numeric := 1;
  ct_tipo_celular constant numeric := 2;
  ct_tipo_comercial constant numeric := 3;

  separador varchar := ';';
  
  CT_TP_INCLUSAO constant numeric := 1;
  CT_TP_EXCLUSAO constant numeric := 3;

  vl_local_arquivo varchar;
  vl_ddd_telefone varchar;

  vl_codigo_arquivo numeric;

  linha varchar;

  vl_rg_edr sc_cad.vw_edr%rowtype;
  vl_rg_tlf sc_cad.tbl_tlf%rowtype;
  vl_rg_cel sc_cad.tbl_tlf%rowtype;
  vl_rg_tlf_emp sc_cad.tbl_tlf%rowtype;
begin

    vl_local_arquivo := vp_local_arquivo; 
    vl_codigo_arquivo := vp_codigo_arquivo;

    --gravando a linha de cabecalho
    linha := 'NUM_TITULO; CPF; NOME_TITULAR; ENDERECO; BAIRRO; CIDADE; UF; CEP; TEL_RESIDENCIAL; VL_COMPRA; VL_CCB; VL_PRINCIPAL;' 
             -- VL_ENCARGOS; coluna retirada
             'DATA_DIVIDA; OBS1; OBS2; NOME_MAE; RG; TEL_CELULAR;'
             -- DATA_EMISSAO; coluna retirada
             'NOSSO_NUMERO; EMAIL; NR_CONTRATO; NOME_EMPRESA; OPERACAO';
               
    perform sc_arq.gravarlinha(vl_local_arquivo, linha);

    -- iterando nos registros do arquivo
    for vl_rg_dct in select  dct.*, cun.nr_cpf_cnpj_cun, 
                             cun.nm_cun, cun.eml_cun, cpf.*, dvd.nsu_org_dvd, emp.nm_emp,
                             (case when dct.tp_dct = CT_TP_INCLUSAO then 'INCLUSAO' else 'EXCLUSAO' end) as operacao							 
                     from sc_cbe.tbl_dct dct
                          inner join sc_cbe.tbl_dvd dvd on dvd.cd_dvd = dct.cd_dvd
                          inner join sc_cad.tbl_cun cun on cun.cd_cun = dvd.cd_cun
                          inner join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
                          inner join sc_opr.tbl_crt crt on crt.cd_crt = dvd.nsu_org_dvd
			              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
			              inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                     where dct.cd_act = vl_codigo_arquivo loop
        --campo numero do titulo 
        linha := vl_rg_dct.cd_dvd || separador;

        --campo CPF
        linha := linha || vl_rg_dct.nr_cpf_cnpj_cun || separador;
        
	    --campo NOME_TITULAR
        linha := linha || vl_rg_dct.nm_cun || separador;

        --obtendo informacoes do endereco
	    select * 
          into vl_rg_edr 
        from sc_aeo.get_endereco(vl_rg_dct.cd_cun);

	    --campo ENDERECO
	    --linha := linha || vl_rg_edr.logradouro || ', ' || vl_rg_edr.nr_edr;
	    if vl_rg_edr.logradouro is not null then
           linha := linha || vl_rg_edr.logradouro;
        else
           linha := linha || ' ';
        end if;

        if vl_rg_edr.nr_edr is not null then
           linha := linha || ', ' || vl_rg_edr.nr_edr;
        else
           linha := linha || ' ';
        end if;
        

	    if vl_rg_edr.cpl_edr is not null then
	        linha := linha || ' - ' || vl_rg_edr.cpl_edr || separador;
	    else
	        linha := linha || separador;
	    end if;
        
        --campo BAIRRO
        linha := linha || vl_rg_edr.bairro || separador;
	
        --campo CIDADE
        linha := linha || vl_rg_edr.localidade || separador;
        
        --campo UF
        linha := linha || vl_rg_edr.uf || separador;
        
        --campo CEP
        linha := linha || vl_rg_edr.cep_edr || separador;
        
        --obtendo as informacoes do telefone residencial
	    select *
          into vl_rg_tlf
        from sc_aeo.get_telefone(vl_rg_dct.cd_cun, ct_tipo_residencial);
     
        --campo TELEFONE RESIDENCIAL
        if vl_rg_tlf.nr_ddd_tlf is not null and vl_rg_tlf.nr_tlf is not null then
          vl_ddd_telefone := vl_rg_tlf.nr_ddd_tlf::text || vl_rg_tlf.nr_tlf::text;
          linha := linha ||  vl_ddd_telefone || separador;
        else
          linha := linha || separador;
        end if;
        

        -- tratamento especifico para cliente FAMA
	    -- solicita as informacoes em linhas separadas para valor principal e tarifa da operacao
 
	    --campo VALOR COMPRA
        linha := linha || sc_arq.formatar_moeda(vl_rg_dct.vl_cmp_dct, 13, 2, ',') || separador;
		
	    --campo VALOR CCB
        linha := linha || sc_arq.formatar_moeda(vl_rg_dct.vl_ccb_dct, 13, 2, ',') || separador;
		
	    --campo VALOR PRINCIPAL
        linha := linha || sc_arq.formatar_moeda(vl_rg_dct.vl_prc_dct, 13, 2, ',') || separador;

	    --campo VALOR ENCARGOS -- coluna retirada
        --linha := linha || sc_arq.formatar_moeda(vl_rg_dct.vl_ttl_dct - vl_rg_dct.vl_prc_dct, 13, 2, ',') || separador;

        --campo VENCIMENTO
        linha := linha || (vl_rg_dct.dt_dvd_dct)::date || separador;

        --campo OBS1 (FILIAL DO CLIENTE)
	    linha := linha || separador;

        --campo OBS2 (OUTRAS OBSERVACOES)  
	    linha := linha || separador;

        --campo MAE
        linha := linha || COALESCE(vl_rg_dct.nm_mae_cpf, '') || separador;

        --campo RG
        linha := linha || COALESCE(vl_rg_dct.nr_rg_cpf, '0') || separador;

        --obtendo as informacoes do telefone celular
	    select *
          into vl_rg_cel
        from sc_aeo.get_telefone(vl_rg_dct.cd_cun, ct_tipo_celular);
        
        --campo TELEFONE CELULAR
        if vl_rg_cel.nr_ddd_tlf is not null and vl_rg_cel.nr_tlf is not null then
            vl_ddd_telefone := vl_rg_cel.nr_ddd_tlf::text || vl_rg_cel.nr_tlf::text;
            linha := linha || vl_ddd_telefone || separador;
        else
            linha := linha || separador;
        end if;
	
        --campo DATA EMISSAO -- coluna retirada
	    --linha := linha || current_date  || separador;

	    --campo NOSSO NUMERO
	    linha := linha || vl_rg_dct.cd_dvd || separador;

	    --campo EMAIL DEVEDOR
	    linha := linha || COALESCE(vl_rg_dct.eml_cun, '') || separador;

        --campo NUMERO CONTRATO
	    linha := linha || vl_rg_dct.nsu_org_dvd || separador;

        --campo NOME DA EMPRESA
	    linha := linha || vl_rg_dct.nm_emp || separador;

        --campo OPERACAO
	    linha := linha || vl_rg_dct.operacao || separador;
		
	    --raise notice 'linha: %',linha;	
        -- gravando a linha de registro
        if(linha is not null and linha <> '' and linha <> '<NULL>') then
	        perform sc_arq.gravarlinha(vl_local_arquivo, linha);
        ELSE 
           raise notice '**************** PROBLEMA *****************';	    
        end if;    
    end loop;
exception 
    when others then
       RAISE EXCEPTION 'Problema na geração do arquivo de remessa de cobranca padrao. NUM:%, DETAILS:%', SQLSTATE, SQLERRM;
end;
$$;


ALTER FUNCTION sc_cbe.gerar_detalhe_arquivo_cobranca_padrao(vp_local_arquivo character varying, vp_codigo_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1329 (class 1255 OID 1622950)
-- Name: gerar_detalhe_arquivo_cobranca_valor(character varying, numeric); Type: FUNCTION; Schema: sc_cbe; Owner: scan
--

CREATE FUNCTION gerar_detalhe_arquivo_cobranca_valor(vp_local_arquivo character varying, vp_codigo_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

    vl_rg_dct record;

    ct_tipo_residencial constant numeric := 1;
    ct_tipo_celular constant numeric := 2;
    ct_tipo_comercial constant numeric := 3;

    separador varchar := ';';

    vl_local_arquivo varchar;
    vl_ddd_telefone varchar;

    CT_TP_INCLUSAO constant numeric := 1;
    CT_TP_EXCLUSAO constant numeric := 3;
  
    vl_codigo_arquivo numeric;

    linha varchar;

    vl_rg_edr sc_cad.vw_edr%rowtype;
    vl_rg_tlf sc_cad.tbl_tlf%rowtype;
    vl_rg_cel sc_cad.tbl_tlf%rowtype;
    vl_rg_tlf_emp sc_cad.tbl_tlf%rowtype;
begin

    vl_local_arquivo := vp_local_arquivo; 
    vl_codigo_arquivo := vp_codigo_arquivo;

    --gravando a linha de cabecalho
    linha := 'DEVEDOR; CPF/CNPJ; ENDERECO; NUMEROC; BAIRRO; CIDADE; UF; FONE1; FONE2; TITULO; VENCIMENTO; VALOR COMPRA; VALOR CCB; VALOR; PROTESTO; CUSTAS; TIPO TITULO; OBS; OPERACAO';
               
    perform sc_arq.gravarlinha(vl_local_arquivo, linha);

    -- iterando nos registros do arquivo
    for vl_rg_dct in select  dct.*, cun.nr_cpf_cnpj_cun, 
                             cun.nm_cun, cun.eml_cun, cpf.*, dvd.nsu_org_dvd, emp.nm_emp,
                            (case when dct.tp_dct = CT_TP_INCLUSAO then 'INCLUSAO' else 'EXCLUSAO' end) as operacao							 
                     from sc_cbe.tbl_dct dct
                          inner join sc_cbe.tbl_dvd dvd on dvd.cd_dvd = dct.cd_dvd
                          inner join sc_cad.tbl_cun cun on cun.cd_cun = dvd.cd_cun
                          inner join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
                          inner join sc_opr.tbl_crt crt on crt.cd_crt = dvd.nsu_org_dvd
			              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
			              inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                    where dct.cd_act = vl_codigo_arquivo loop
        
        --campo NOME_TITULAR
        linha := vl_rg_dct.nm_cun || separador;

        --campo CPF
        linha := linha || vl_rg_dct.nr_cpf_cnpj_cun || separador;
        
        --obtendo informacoes do endereco
	    select * 
          into vl_rg_edr 
        from sc_aeo.get_endereco(vl_rg_dct.cd_cun);

	    --campo ENDERECO
	    --linha := linha || vl_rg_edr.logradouro || ', ' || vl_rg_edr.nr_edr;
	    if vl_rg_edr.logradouro is not null then
            linha := linha || vl_rg_edr.logradouro || separador;
        else
            linha := linha || separador;
        end if;

        -- campo NUMERO
        if vl_rg_edr.nr_edr is not null then
            linha := linha || vl_rg_edr.nr_edr || separador;
        else
            linha := linha || separador;
        end if;
        

        /*
        -- campo COMPLEMENTO
	    if vl_rg_edr.cpl_edr is not null then
	        linha := linha || ' - ' || vl_rg_edr.cpl_edr || separador;
	    else
	        linha := linha || separador;
	    end if;
	    */
        
        --campo BAIRRO
        linha := linha || vl_rg_edr.bairro || separador;
	
        --campo CIDADE
        linha := linha || vl_rg_edr.localidade || separador;
        
        --campo UF
        linha := linha || vl_rg_edr.uf || separador;
        
        --campo CEP
        --linha := linha || vl_rg_edr.cep_edr || separador;
        
        --obtendo as informacoes do telefone residencial
	    select *
          into vl_rg_tlf
        from sc_aeo.get_telefone(vl_rg_dct.cd_cun, ct_tipo_residencial);
     
        --campo TELEFONE RESIDENCIAL
        if vl_rg_tlf.nr_ddd_tlf is not null and vl_rg_tlf.nr_tlf is not null then
            vl_ddd_telefone := vl_rg_tlf.nr_ddd_tlf::text || vl_rg_tlf.nr_tlf::text;
            linha := linha ||  vl_ddd_telefone || separador;
        else
            linha := linha || separador;
        end if;

        --campo TELEFONE CELULAR
        --obtendo as informacoes do telefone celular
	    select *
          into vl_rg_cel
        from sc_aeo.get_telefone(vl_rg_dct.cd_cun, ct_tipo_celular);
                
        if vl_rg_cel.nr_ddd_tlf is not null and vl_rg_cel.nr_tlf is not null then
            vl_ddd_telefone := vl_rg_cel.nr_ddd_tlf::text || vl_rg_cel.nr_tlf::text;
            linha := linha || vl_ddd_telefone || separador;
        else
            linha := linha || separador;
        end if;

        -- campo EMAIL
        linha := linha || vl_rg_dct.eml_cun;

        --campo numero do titulo 
        linha := linha || vl_rg_dct.cd_dvd || separador; 

        --campo VENCIMENTO
        linha := linha || (vl_rg_dct.dt_dvd_dct)::date || separador;

 	    --campo VALOR COMPRA
        linha := linha || sc_arq.formatar_moeda(vl_rg_dct.vl_cmp_dct, 13, 2, ',') || separador;
		
 	    --campo VALOR CCB
        linha := linha || sc_arq.formatar_moeda(vl_rg_dct.vl_ccb_dct, 13, 2, ',') || separador;
		
 	    --campo VALOR 
        linha := linha || sc_arq.formatar_moeda(vl_rg_dct.vl_prc_dct, 13, 2, ',') || separador;

	    --campo PROTESTOS
        linha := linha ||  separador;

        --campo CUSTAS
        linha := linha ||  separador;

        --campo TIPO DE TITULO
        linha := linha || 'CCB' || separador;
       
        --campo OBS
	    linha := linha || separador;
		
		--campo OPERACAO
	    linha := linha || vl_rg_dct.operacao || separador;

	    --raise notice 'linha: %',linha;	
        -- gravando a linha de registro
        if(linha is not null and linha <> '' and linha <> '<NULL>') then
	        perform sc_arq.gravarlinha(vl_local_arquivo, linha);
        ELSE 
           raise notice '**************** PROBLEMA *****************';	    
        end if;    

      end loop;
exception 
    when others then
        RAISE EXCEPTION 'Problema na geração do arquivo de cobranca empresa valor. NUM:%, DETAILS:%', SQLSTATE, SQLERRM;
end;
$$;


ALTER FUNCTION sc_cbe.gerar_detalhe_arquivo_cobranca_valor(vp_local_arquivo character varying, vp_codigo_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1813 (class 1255 OID 1668904)
-- Name: popula_arquivo_cobranca_tercerizada(numeric); Type: FUNCTION; Schema: sc_cbe; Owner: scan
--

CREATE FUNCTION popula_arquivo_cobranca_tercerizada(vp_empresa_cobranca numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

  vl_rg record;

  CT_A_RENEGOCIAR constant numeric := 1;
  
  CT_A_INCLUIR constant numeric := 1;
  CT_INCLUIDO constant numeric := 2;
  CT_A_EXCLUIR constant numeric := 3;
  CT_EXCLUIDO constant numeric := 4;

  vl_qtd_reg_inclusao numeric;
  vl_valor_ccb_inclusao numeric(13,2);
  vl_valor_compra_inclusao numeric(13,2);
  vl_valor_principal_inclusao numeric(13,2);
  vl_valor_total_inclusao numeric(13, 2);
  
  vl_qtd_reg_exclusao numeric;
  vl_valor_ccb_exclusao numeric(13,2);
  vl_valor_compra_exclusao numeric(13,2);
  vl_valor_principal_exclusao numeric(13,2);
  vl_valor_total_exclusao numeric(13,2);

  vl_codigo_header numeric := null;
  vl_codigo_detalhe numeric;
begin
    select 
	       --totalizadores de inclusao
	       sum(case when (dvd.cd_act is null and dvd.st_arq_dvd = CT_A_INCLUIR) then 1 else 0 end) as qtde_reg_inclusao,
	       sum(case when (dvd.cd_act is null and dvd.st_arq_dvd = CT_A_INCLUIR) then dvd.vl_ccb_dvd else 0 end) as valor_ccb_inclusao,
	       sum(case when (dvd.cd_act is null and dvd.st_arq_dvd = CT_A_INCLUIR) then dvd.vl_cmp_dvd else 0 end) as valor_compra_inclusao,
	       sum(case when (dvd.cd_act is null and dvd.st_arq_dvd = CT_A_INCLUIR) then dvd.vlr_prn_dvd else 0 end) as valor_principal_inclusao,
	       sum(case when (dvd.cd_act is null and dvd.st_arq_dvd = CT_A_INCLUIR) then dvd.vlr_prn_dvd + dvd.vlr_enc_dvd else 0 end) as valor_total_inclusao,
		   --totalizadores de exclusao
		   sum(case when (dvd.cd_exc_act is null and dvd.st_arq_dvd = CT_A_EXCLUIR) then 1 else 0 end) as qtde_reg_exclusao,
	       sum(case when (dvd.cd_exc_act is null and dvd.st_arq_dvd = CT_A_EXCLUIR) then dvd.vl_ccb_dvd else 0 end) as valor_ccb_exclusao,
	       sum(case when (dvd.cd_exc_act is null and dvd.st_arq_dvd = CT_A_EXCLUIR) then dvd.vl_cmp_dvd else 0 end) as valor_compra_exclusao,
	       sum(case when (dvd.cd_exc_act is null and dvd.st_arq_dvd = CT_A_EXCLUIR) then dvd.vlr_prn_dvd else 0 end) as valor_principal_exclusao,
	       sum(case when (dvd.cd_exc_act is null and dvd.st_arq_dvd = CT_A_EXCLUIR) then dvd.vlr_prn_dvd + dvd.vlr_enc_dvd else 0 end) as valor_total_exclusao
      into 
			--totalizadores de inclusao
			vl_qtd_reg_inclusao, vl_valor_ccb_inclusao, vl_valor_compra_inclusao, vl_valor_principal_inclusao, vl_valor_total_inclusao,
			--totalizadores de exclusao
			vl_qtd_reg_exclusao, vl_valor_ccb_exclusao, vl_valor_compra_exclusao, vl_valor_principal_exclusao, vl_valor_total_exclusao
    from sc_cbe.tbl_dvd dvd
    where dvd.cd_emc = vp_empresa_cobranca
      and dvd.st_dvd = CT_A_RENEGOCIAR
      and (
			(dvd.cd_act is null and dvd.st_arq_dvd = CT_A_INCLUIR) --registro deve ser incluído
			or
			(dvd.cd_exc_act is null and dvd.st_arq_dvd = CT_A_EXCLUIR) --registro deve ser excluído
		);  

    if vl_qtd_reg_inclusao + vl_qtd_reg_exclusao > 0 then

        -- inserindo registro na tabela de arquivo de cobranca tercerizada
        select nextval('sc_cbe.sq_act') into vl_codigo_header;
        
        insert into sc_cbe.tbl_act (cd_act, cd_emc, dt_grc_act, 
		                            nr_reg_act, vl_ttl_ccb_act, vl_ttl_cmp_act, vl_ttl_prc_act, vl_ttl_act,
		                            nr_reg_exc_act, vl_ttl_ccb_exc_act, vl_ttl_cmp_exc_act, vl_ttl_prc_exc_act, vl_ttl_exc_act)
        values (vl_codigo_header, vp_empresa_cobranca, now(), 
				vl_qtd_reg_inclusao, vl_valor_ccb_inclusao, vl_valor_compra_inclusao, vl_valor_principal_inclusao, vl_valor_total_inclusao,
				vl_qtd_reg_exclusao, vl_valor_ccb_exclusao, vl_valor_compra_exclusao, vl_valor_principal_exclusao, vl_valor_total_exclusao);

        -- inserindo detalhes na tabela de detalhe de arquivo de cobranca tercerizada
	    for vl_rg in select dvd.cd_dvd as divida, current_date - dvd.dt_dvd::date as dias_atraso, dvd.dt_dvd,
			                coalesce(dvd.vlr_prn_dvd,0) + coalesce(dvd.vlr_enc_dvd,0) as saldo_devedor,
							dvd.vlr_prn_dvd as valor_principal, dvd.vl_ccb_dvd as valor_ccb, dvd.vl_cmp_dvd as valor_compra,
							dvd.st_arq_dvd as tipo
	                 from sc_cbe.tbl_dvd dvd
	                 where dvd.cd_emc = vp_empresa_cobranca
			           and st_dvd = CT_A_RENEGOCIAR
	                   and (
						     (dvd.cd_act is null and dvd.st_arq_dvd = CT_A_INCLUIR) --registro deve ser incluído
						     or
						     (dvd.cd_exc_act is null and dvd.st_arq_dvd = CT_A_EXCLUIR) --registro deve ser excluído
				        ) loop       

	        select nextval('sc_cbe.sq_dct') into vl_codigo_detalhe;
	     
	        -- gravando na tabela para gerar o arquivo
            insert into sc_cbe.tbl_dct (cd_dct, cd_act, cd_dvd, vl_prc_dct, vl_ttl_dct, vl_ccb_dct, vl_cmp_dct, nr_dia_atr_dct, dt_dvd_dct, tp_dct)
            values (vl_codigo_detalhe, vl_codigo_header, vl_rg.divida, vl_rg.valor_principal, vl_rg.saldo_devedor, vl_rg.valor_ccb, vl_rg.valor_compra, vl_rg.dias_atraso, vl_rg.dt_dvd, vl_rg.tipo);

	        if vl_rg.tipo = CT_A_INCLUIR then
			    update sc_cbe.tbl_dvd 
			       set cd_act = vl_codigo_header,
                       st_arq_dvd = CT_INCLUIDO		   
			    where cd_dvd = vl_rg.divida;
		    else
			    update sc_cbe.tbl_dvd 
			       set cd_exc_act = vl_codigo_header,
                       st_arq_dvd = CT_EXCLUIDO		   
			    where cd_dvd = vl_rg.divida;
			end if;
	    end loop;    
    end if;
	
	return vl_codigo_header;

end;$$;


ALTER FUNCTION sc_cbe.popula_arquivo_cobranca_tercerizada(vp_empresa_cobranca numeric) OWNER TO scan;

--
-- TOC entry 7713 (class 0 OID 0)
-- Dependencies: 1813
-- Name: FUNCTION popula_arquivo_cobranca_tercerizada(vp_empresa_cobranca numeric); Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON FUNCTION popula_arquivo_cobranca_tercerizada(vp_empresa_cobranca numeric) IS 'rotina que atualiza a tabela para gerar o arquivo de cobranca';


SET search_path = sc_cbr, pg_catalog;

--
-- TOC entry 1221 (class 1255 OID 564197)
-- Name: alterar_data_vencimento(numeric, date, double precision, numeric, boolean); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION alterar_data_vencimento(vp_boleto numeric, vp_data_vencimento_nova date, vp_valor_novo double precision, vp_usuario numeric, vp_validar boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
       
        ct_banco_hsbc numeric := 399;
        ct_banco_bradesco numeric := 237;

        ct_tipo_origem_cartao numeric := 2; 
    
	vl_situacao_boleto	numeric;
	vl_codigo_barras	varchar;
	vl_linha_digitavel	varchar;
	vl_codigo_barras_novo	varchar;
	vl_linha_digitavel_nova	varchar;
	vl_dt_vencimento	date;
	vl_nosso_numero		numeric;
	vl_nosso_numero_novo	varchar;
	vl_dgt_nosso_numero_novo varchar;
	vl_nosso_numero_antigo	numeric;
	vl_dgt_nosso_numero_antigo varchar;
	vl_valor		numeric;
	vl_contrato_cobranca	numeric;
	vl_dac			varchar;
	vl_motivo		varchar;
	vl_cont_cobranca  	sc_cbr.tbl_ccb%rowtype;
	vl_tarifa_cobranca  	sc_cbr.tbl_tcb%rowtype;
	vl_numero_origem        numeric;
	vl_tipo_origem          numeric;
	vl_dt_vnc_boleto        date;
	vl_valor_juros          numeric;
	vl_valor_multa          numeric;
	vl_desc_instrucao       varchar;
	vl_desc_informacao      varchar;
begin
    
        -- validando o boleto para saber se poderá alterar o vencimento - inicio
	begin
		select blt.st_blt, blt.cd_brr_blt, blt.nr_lin_dgt_blt, blt.dt_vnc_blt, case when blt.cd_ccb = 2 then trunc(blt.cd_doc_blt/1000) else blt.cd_doc_blt end, blt.cd_doc_blt, blt.cd_ccb, blt.nr_nsu_org_blt, blt.tp_org_blt, dgt_cd_doc_blt
		  into vl_situacao_boleto, vl_codigo_barras, vl_linha_digitavel, vl_dt_vencimento, vl_nosso_numero, vl_nosso_numero_antigo, vl_contrato_cobranca, vl_numero_origem, vl_tipo_origem, vl_dgt_nosso_numero_antigo
		from sc_cbr.tbl_blt blt
		where blt.cd_blt = vp_boleto;
	exception when others then
		raise exception 'Não existe boleto com esse código informado.';
	end;

	if vp_validar then

	  --if vl_situacao_boleto in (3,4,5,6) then -- pago parcial, pago total, prorrogado e cancelado
	  --  raise exception 'Não é possível alterar o vencimento do boleto pois o mesmo está na situação paga parcial ou paga total ou prorrogado ou cancelado.';
	  --end if;
	
	  if vp_data_vencimento_nova = vl_dt_vencimento then
	    raise exception 'Não é possível alterar o vencimento do boleto pois a nova data de vencimento informada é igual a data de vencimento do boleto.';
	  end if;
	  -- validando o boleto para saber se poderá alterar o vencimento - fim
        end if;

        -- capturando os dados do contrato de cobranca
	select ccb.* 
	  into vl_cont_cobranca
        from sc_cbr.tbl_ccb ccb
	where ccb.cd_ccb = vl_contrato_cobranca;

        -- capturando os dados da tarifa do contrato de cobranca
        select tcb.*
          into vl_tarifa_cobranca
         from sc_cbr.tbl_tcb tcb
         where tcb.cd_tcb = vl_cont_cobranca.cd_tcb;

	-- verificando se boleto eh contra apresentacao
        vl_dt_vnc_boleto := vp_data_vencimento_nova;
        if vl_tipo_origem = ct_tipo_origem_cartao then
          vl_dt_vnc_boleto = null;
        end if;

        if vl_cont_cobranca.cd_bnc = ct_banco_hsbc then
          select trunc(coalesce(max(blt.cd_doc_blt), 0)/1000) + 1
            into vl_nosso_numero
          from sc_cbr.tbl_blt blt
	     inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
          where ccb.cd_bnc = vl_cont_cobranca.cd_bnc
            and ccb.cd_agn_ccb = vl_cont_cobranca.cd_agn_ccb
            and ccb.cd_cnt_ccb = vl_cont_cobranca.cd_cnt_ccb;
        end if;

        if vl_cont_cobranca.cd_bnc = ct_banco_bradesco then
          select coalesce(max(blt.cd_doc_blt), 0) + 1
            into vl_nosso_numero
          from sc_cbr.tbl_blt blt
	    inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
          where ccb.cd_bnc = vl_cont_cobranca.cd_bnc
            and ccb.cd_agn_ccb = vl_cont_cobranca.cd_agn_ccb
            and ccb.cd_cnt_ccb = vl_cont_cobranca.cd_cnt_ccb;
        end if; 

        -- gerando o novo nosso numero
	if vl_cont_cobranca.cd_bnc = ct_banco_hsbc then
	  select sc_cbr.gerar_nosso_numero_hsbc(vl_nosso_numero, vl_cont_cobranca.nr_cdt_ccb, vl_dt_vnc_boleto)
	  into vl_nosso_numero_novo;

	  vl_dgt_nosso_numero_novo := substr(vl_nosso_numero_novo,length(vl_nosso_numero_novo)-2);
	end if;

	if vl_cont_cobranca.cd_bnc = ct_banco_bradesco then
	  select sc_cbr.gerar_nosso_numero_bradesco(vl_nosso_numero, vl_cont_cobranca.nr_car_ccb)
	  into vl_nosso_numero_novo;

	  vl_dgt_nosso_numero_novo := substr(vl_nosso_numero_novo,length(vl_nosso_numero_novo));
	  vl_nosso_numero_novo := substr(vl_nosso_numero_novo,1,length(vl_nosso_numero_novo)-1);
	end if;
        
	-- gerando o novo codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vp_valor_novo::numeric, vl_nosso_numero_novo::numeric, vl_dt_vnc_boleto)
          into vl_codigo_barras_novo;
	  
        -- gerando a nova linha digitavel 
	vl_dac := substr(vl_codigo_barras_novo, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vp_valor_novo::numeric, vl_nosso_numero_novo::numeric, vl_dt_vnc_boleto, vl_dac::numeric)
          into vl_linha_digitavel_nova;
        
        -- gerando juros, multa, intrucao e informacao
        select * from sc_cbr.gerar_boleto_instrucao_informacao(vp_valor_novo::numeric, vl_tipo_origem, vl_numero_origem, vl_tarifa_cobranca)
           into vl_valor_multa, vl_valor_juros, vl_desc_instrucao, vl_desc_informacao;
	
	-- gravando historico de alteracao (data de vencimento, codigo de barras, linha digitavel e nosso numero)
	vl_motivo := 'ALTERACAO DA DATA DE VENCIMENTO DO BOLETO';
	insert into sc_cbr.tbl_hadb(cd_hadb, cd_blt, tp_hadb, vl_ant_hadb, vl_atl_hadb, mt_alt_hadb, cd_inc_usr, dt_inc_usr)
        values (nextval('sc_cbr.sq_hadb'), vp_boleto, 1, vl_dt_vencimento, vp_data_vencimento_nova, vl_motivo, vp_usuario, now());

	insert into sc_cbr.tbl_hadb(cd_hadb, cd_blt, tp_hadb, vl_ant_hadb, vl_atl_hadb, mt_alt_hadb, cd_inc_usr, dt_inc_usr)
        values (nextval('sc_cbr.sq_hadb'), vp_boleto, 2, vl_codigo_barras, vl_codigo_barras_novo, vl_motivo, vp_usuario, now());	
	
	insert into sc_cbr.tbl_hadb(cd_hadb, cd_blt, tp_hadb, vl_ant_hadb, vl_atl_hadb, mt_alt_hadb, cd_inc_usr, dt_inc_usr)
        values (nextval('sc_cbr.sq_hadb'), vp_boleto, 3, vl_linha_digitavel, vl_linha_digitavel_nova, vl_motivo, vp_usuario, now());
		
	insert into sc_cbr.tbl_hadb(cd_hadb, cd_blt, tp_hadb, vl_ant_hadb, vl_atl_hadb, mt_alt_hadb, cd_inc_usr, dt_inc_usr)
        values (nextval('sc_cbr.sq_hadb'), vp_boleto, 4, vl_nosso_numero_antigo, vl_nosso_numero_novo, vl_motivo, vp_usuario, now());

        insert into sc_cbr.tbl_hadb(cd_hadb, cd_blt, tp_hadb, vl_ant_hadb, vl_atl_hadb, mt_alt_hadb, cd_inc_usr, dt_inc_usr)
        values (nextval('sc_cbr.sq_hadb'), vp_boleto, 6, vl_dgt_nosso_numero_antigo, vl_dgt_nosso_numero_novo, vl_motivo, vp_usuario, now());
		
	-- alterando o boleto
	update sc_cbr.tbl_blt
	   set 	cd_brr_blt = vl_codigo_barras_novo, 
		nr_lin_dgt_blt = vl_linha_digitavel_nova, 
		cd_doc_blt = vl_nosso_numero_novo::numeric,
		dt_vnc_blt = vp_data_vencimento_nova,
		vl_blt = vp_valor_novo,
		pc_atr_blt = vl_tarifa_cobranca.pc_mlt_tcb,
		vl_atr_blt = vl_valor_multa,
		pc_jrs_blt = vl_tarifa_cobranca.pc_jrs_tcb, 
		vl_jrs_blt = vl_valor_juros,
		ds_ins_blt = vl_desc_instrucao, 
		ds_out_inf_blt = vl_desc_informacao,
		dgt_cd_doc_blt = vl_dgt_nosso_numero_novo,
		st_blt = 3 -- PRORROGADO
	where cd_blt = vp_boleto;
	
end
$$;


ALTER FUNCTION sc_cbr.alterar_data_vencimento(vp_boleto numeric, vp_data_vencimento_nova date, vp_valor_novo double precision, vp_usuario numeric, vp_validar boolean) OWNER TO scan;

--
-- TOC entry 1222 (class 1255 OID 564200)
-- Name: calcula_data_formato_juliano(date); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION calcula_data_formato_juliano(vp_data_vencimento date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
   vl_retorno         varchar;
   vl_venc_juliano    varchar;
   vl_auxiliar        numeric;
   vl_dt_base_juliano date;
   vl_ano             numeric;
begin

   if vp_data_vencimento is not null then
      vl_ano := extract(year from vp_data_vencimento);
      vl_dt_base_juliano := to_date('01-01-' || vl_ano, 'DD-MM-YYYY');
      vl_auxiliar := vp_data_vencimento - vl_dt_base_juliano + 1;
      vl_venc_juliano := to_char(vl_auxiliar, 'FM99099');
      vl_retorno := vl_venc_juliano || substr(vl_ano::text, 4);
   else
      vl_retorno := '0000';
   end if;
   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr.calcula_data_formato_juliano(vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 7714 (class 0 OID 0)
-- Dependencies: 1222
-- Name: FUNCTION calcula_data_formato_juliano(vp_data_vencimento date); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION calcula_data_formato_juliano(vp_data_vencimento date) IS 'Rotina que realiza os calculos para obter a data no formato Juliano';


--
-- TOC entry 1211 (class 1255 OID 564201)
-- Name: calcula_fator_vencimento(date); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION calcula_fator_vencimento(vp_data_vencimento date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
   vl_retorno         varchar;
   vl_valor	      numeric;
   vl_venc_juliano    numeric;
begin
   
   if vp_data_vencimento is not null then
      vl_venc_juliano := vp_data_vencimento - '03-07-2000';
      vl_valor := vl_venc_juliano + 1000;
   else
      vl_valor := 0;
   end if;

   vl_retorno := sc_arq.preencher(4, vl_valor, '0', 2);
   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr.calcula_fator_vencimento(vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 7715 (class 0 OID 0)
-- Dependencies: 1211
-- Name: FUNCTION calcula_fator_vencimento(vp_data_vencimento date); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION calcula_fator_vencimento(vp_data_vencimento date) IS 'Rotina que realiza os calculos para obter o fator de uma determinada data';


--
-- TOC entry 1494 (class 1255 OID 564202)
-- Name: efetuar_baixas_retorno(numeric, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION efetuar_baixas_retorno(vp_cod_arquivo numeric, vp_cod_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

    ST_DRC_CADASTRADO sc_cbr.tbl_drc_t.st_drc%type := 1;
    ST_DRC_VALIDADO sc_cbr.tbl_drc_t.st_drc%type := 2;
    ST_DRC_INVALIDADO sc_cbr.tbl_drc_t.st_drc%type := 3;
    
    ST_HARC_VALIDADO sc_cbr.tbl_drc_t.st_drc%type := 2;
    
    TP_ORG_FATURA_CARTAO sc_cbr.tbl_blt.tp_org_blt%type := 2;
    TP_ORG_FATURA_EMPRESA sc_cbr.tbl_blt.tp_org_blt%type := 1;
    TP_ORG_RENEGOCIACAO_CARTAO sc_cbr.tbl_blt.tp_org_blt%type := 3;
    TP_ORG_BOLETO_AVULSO sc_cbr.tbl_blt.tp_org_blt%type := 4;
    TP_ORG_BOLETO_AVULSO_CARTAO sc_cbr.tbl_blt.tp_org_blt%type := 6;
    
    vl_tipo_lancamento sc_cnt.tbl_tlc.cd_tlc%type;
    vl_cod_lancamento_ctpd sc_cnt.tbl_lcn.cd_lcn%type;
    vl_tipo_origem_aux sc_cnt.tbl_lcn.cd_lcn%type;
    vl_conta_banco sc_cnt.tbl_cnt.cd_cnt%type;
    rg record;
    
    vl_valor_total numeric := 0;
    vl_codigo_fatura numeric;
    vl_conta_grupo_empresarial numeric;
    vl_grupo_empresarial numeric;
    
    CD_SST_SISTEMA_BAIXA_BOLETO sc_cnt.tbl_sst.cd_sst%type := 13;
BEGIN

	for rg in select drc_u.vl_lqd_drc,
    			     drc_u.dt_lqd_drc,
    			     drc_u.dt_crd_drc,
                     blt.cd_blt,
                     blt.tp_org_blt,
                     blt.nr_nsu_org_blt,
                     ccb.cd_cnt
              from sc_cbr.tbl_drc_t drc
                 inner join sc_cbr.tbl_drc_u drc_u on drc_u.cd_drc = drc.cd_drc
                 inner join sc_cbr.tbl_hlsc hlsc on hlsc.cd_hlsc = drc.cd_hlsc
                 inner join sc_cbr.tbl_harc harc on harc.cd_harc = hlsc.cd_harc
                 inner join sc_cbr.tbl_blt blt on blt.cd_blt = drc.cd_blt
                 inner join sc_cbr.tbl_ccb ccb on blt.cd_ccb = ccb.cd_ccb
              where drc.st_drc = ST_DRC_VALIDADO
                and harc.cd_harc = vp_cod_arquivo
                and harc.st_harc = ST_HARC_VALIDADO
              order by blt.tp_org_blt loop
              
         vl_conta_banco := rg.cd_cnt;
         
         if coalesce(vl_tipo_origem_aux,0) <> rg.tp_org_blt then
            
            vl_tipo_origem_aux = rg.tp_org_blt;
            
            if(vl_valor_total > 0) then
               perform sc_cnt.lancar_movimento(vl_cod_lancamento_ctpd,
                                               NULL,
                                               vl_tipo_lancamento,
                                               vl_conta_banco,
                                               'D',
                                               vl_valor_total,
                                               now()::timestamp,
                                               vp_cod_usuario,
                                               null,
                                               'Ref a baixa do arquivo '|| vp_cod_arquivo,
                                               CD_SST_SISTEMA_BAIXA_BOLETO,
                                               (to_char(now(),'yyyymmdd'))::numeric
                                               );
              vl_valor_total := 0;                                
            end if;
            
            select nextval('sc_cnt.sq_lcn') into vl_cod_lancamento_ctpd;  
            
         end if;
         

    
         if rg.tp_org_blt = TP_ORG_FATURA_CARTAO then
             
              select sc_cbr.lancar_baixa_fatura_cartao( rg.vl_lqd_drc,
                                                        rg.nr_nsu_org_blt,
                                                        vl_cod_lancamento_ctpd,
                                                        rg.cd_blt,
                                                        vp_cod_usuario,
                                                        rg.dt_lqd_drc::timestamp without time zone,
                                                        vl_conta_banco)
             into  vl_tipo_lancamento;

         elsif rg.tp_org_blt = TP_ORG_RENEGOCIACAO_CARTAO then

              select cd_fcr
                into vl_codigo_fatura
              from sc_rnc.tbl_rnc 
               where cd_rnc =  rg.nr_nsu_org_blt; 
             
              select sc_cbr.lancar_baixa_fatura_cartao( rg.vl_lqd_drc,
                                                        vl_codigo_fatura,
                                                        vl_cod_lancamento_ctpd,
                                                        rg.cd_blt,
                                                        vp_cod_usuario,
                                                        rg.dt_lqd_drc::timestamp without time zone,
                                                        vl_conta_banco)
             into  vl_tipo_lancamento;                                             
                                                        
         elsif rg.tp_org_blt = TP_ORG_FATURA_EMPRESA then
             
             select sc_cbr.lancar_baixa_fatura_empresa( rg.vl_lqd_drc,
                                                        rg.nr_nsu_org_blt,
                                                        vl_cod_lancamento_ctpd,
                                                        rg.cd_blt,
                                                        vp_cod_usuario,
                                                        rg.dt_lqd_drc::timestamp without time zone,
                                                        vl_conta_banco) 
             into vl_tipo_lancamento;

         elsif rg.tp_org_blt = TP_ORG_BOLETO_AVULSO then

             select sc_cbr.lancar_boleto_avulso_empresa(rg.vl_lqd_drc,
                                                        rg.nr_nsu_org_blt,
                                                        vl_cod_lancamento_ctpd,
                                                        rg.cd_blt,
                                                        vp_cod_usuario,
                                                        rg.dt_crd_drc::timestamp without time zone,
                                                        vl_conta_banco) 
             into vl_tipo_lancamento;
                         
         elsif rg.tp_org_blt = TP_ORG_FATURA_CARTAO then
             
              select sc_cbr.lancar_baixa_boleto_avulso_cartao( rg.vl_lqd_drc,
                                                        rg.nr_nsu_org_blt,
                                                        vl_cod_lancamento_ctpd,
                                                        rg.cd_blt,
                                                        vp_cod_usuario,
                                                        rg.dt_lqd_drc::timestamp without time zone,
                                                        vl_conta_banco)
             into  vl_tipo_lancamento;    

         end if;
         
--         update sc_cbr.tbl_blt set dt_prc_blt = now() where cd_blt = rg.cd_blt;
         
         vl_valor_total := vl_valor_total + rg.vl_lqd_drc;
              
    end loop;          
    
    if(vl_valor_total > 0) then
         perform sc_cnt.lancar_movimento(vl_cod_lancamento_ctpd,
                                         NULL,
                                         vl_tipo_lancamento,
                                         vl_conta_banco,
                                         'D',
                                         vl_valor_total,
                                         now()::timestamp,
                                         vp_cod_usuario,
                                         null,
                                         'Ref a baixa do arquivo '|| vp_cod_arquivo,
                                         CD_SST_SISTEMA_BAIXA_BOLETO,
                                         (to_char(now(),'yyyymmdd'))::numeric
                                         );
     end if;                                    



END;
$$;


ALTER FUNCTION sc_cbr.efetuar_baixas_retorno(vp_cod_arquivo numeric, vp_cod_usuario numeric) OWNER TO scan;

--
-- TOC entry 1710 (class 1255 OID 564203)
-- Name: efetuar_baixas_retorno_gen(numeric, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION efetuar_baixas_retorno_gen(vp_cod_arquivo numeric, vp_cod_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

    ST_DRC_CADASTRADO sc_cbr.tbl_drc_t.st_drc%type := 1;
    ST_DRC_VALIDADO sc_cbr.tbl_drc_t.st_drc%type := 2;
    ST_DRC_INVALIDADO sc_cbr.tbl_drc_t.st_drc%type := 3;
    
    ST_HARC_VALIDADO sc_cbr.tbl_drc_t.st_drc%type := 2;
    
    TP_ORG_FATURA_CARTAO sc_cbr.tbl_blt.tp_org_blt%type := 2;
    TP_ORG_FATURA_EMPRESA sc_cbr.tbl_blt.tp_org_blt%type := 1;
    TP_ORG_RENEGOCIACAO_CARTAO sc_cbr.tbl_blt.tp_org_blt%type := 3;
    TP_ORG_BOLETO_AVULSO sc_cbr.tbl_blt.tp_org_blt%type := 4;
    TP_ORG_BOLETO_AVULSO_CARTAO sc_cbr.tbl_blt.tp_org_blt%type := 6;
    TP_ORG_ARQUIVO_DEPOSITO_PREPAGO sc_cbr.tbl_blt.tp_org_blt%type := 7;
    TP_ORG_COBRANCA_EXTERNA sc_cbr.tbl_blt.tp_org_blt%type := 8;
    
    vl_tipo_lancamento sc_cnt.tbl_tlc.cd_tlc%type;
    vl_cod_lancamento_ctpd sc_cnt.tbl_lcn.cd_lcn%type;
    vl_tipo_origem_aux sc_cnt.tbl_lcn.cd_lcn%type;
    vl_conta_banco sc_cnt.tbl_cnt.cd_cnt%type;
    rg record;
    
    vl_valor_total numeric := 0;
    vl_codigo_fatura numeric;
    vl_conta_grupo_empresarial numeric;
    vl_grupo_empresarial numeric;

    TP_OCORRENCIA_LIQUIDACAO numeric := 6;
    TP_OCORRENCIA_LIQUIDACAO_POS_BAIXA_OU_TITULO_NAO_REGISTRADO numeric := 17;
    
    CD_SST_SISTEMA_BAIXA_BOLETO sc_cnt.tbl_sst.cd_sst%type := 13;
    vl_cod_lanc_aux numeric;
BEGIN
	for rg in select     darcg.vl_pgt_darcg,
    			     darcg.dt_ocb_darcg,
    			     darcg.dt_crd_darcg,
    			     darcg.vl_jrs_darcg,
			     blt.cd_blt,
			     blt.tp_org_blt,
			     blt.nr_nsu_org_blt,
			     ccb.cd_cnt
              from sc_cbr.tbl_darcg darcg
                 inner join sc_cbr.tbl_harcg harcg on harcg.cd_harcg = darcg.cd_harcg
                 inner join sc_cbr.tbl_blt blt on blt.cd_blt = darcg.cd_blt
                 inner join sc_cbr.tbl_ccb ccb on blt.cd_ccb = ccb.cd_ccb
              where darcg.st_darcg = ST_DRC_VALIDADO
                and harcg.cd_harcg = vp_cod_arquivo
                and harcg.st_harcg = ST_HARC_VALIDADO
                and darcg.nr_ocr_darcg in (TP_OCORRENCIA_LIQUIDACAO, TP_OCORRENCIA_LIQUIDACAO_POS_BAIXA_OU_TITULO_NAO_REGISTRADO)
              order by blt.tp_org_blt loop
              
         vl_conta_banco := rg.cd_cnt;
         
         if coalesce(vl_tipo_origem_aux,0) <> rg.tp_org_blt then
            
            vl_tipo_origem_aux = rg.tp_org_blt;
            
            if(vl_valor_total > 0) then
               perform sc_cnt.lancar_movimento(vl_cod_lancamento_ctpd,
                                               NULL,
                                               vl_tipo_lancamento,
                                               vl_conta_banco,
                                               'D',
                                               vl_valor_total,
                                               now()::timestamp,
                                               vp_cod_usuario,
                                               null,
                                               'Ref a baixa do arquivo '|| vp_cod_arquivo,
                                               CD_SST_SISTEMA_BAIXA_BOLETO,
                                               (to_char(now(),'yyyymmdd'))::numeric
                                               );
              vl_valor_total := 0;                                
            end if;
            
            select nextval('sc_cnt.sq_lcn') into vl_cod_lancamento_ctpd;  
            
         end if;
         

    
         if rg.tp_org_blt = TP_ORG_FATURA_CARTAO then
             
              select sc_cbr.lancar_baixa_fatura_cartao( rg.vl_pgt_darcg,
                                                        rg.nr_nsu_org_blt,
                                                        vl_cod_lancamento_ctpd,
                                                        rg.cd_blt,
                                                        vp_cod_usuario,
                                                        rg.dt_ocb_darcg::timestamp without time zone,
                                                        vl_conta_banco)
             into  vl_tipo_lancamento;

         elsif rg.tp_org_blt = TP_ORG_RENEGOCIACAO_CARTAO then

              select cd_fcr
                into vl_codigo_fatura
              from sc_rnc.tbl_rnc 
               where cd_rnc =  rg.nr_nsu_org_blt; 
             
              select sc_cbr.lancar_baixa_fatura_cartao( rg.vl_pgt_darcg,
                                                        vl_codigo_fatura,
                                                        vl_cod_lancamento_ctpd,
                                                        rg.cd_blt,
                                                        vp_cod_usuario,
                                                        rg.dt_ocb_darcg::timestamp without time zone,
                                                        vl_conta_banco)
             into  vl_tipo_lancamento;                                             
                                                        
         elsif rg.tp_org_blt = TP_ORG_FATURA_EMPRESA then
             
             select sc_cbr.lancar_baixa_fatura_empresa( rg.vl_pgt_darcg - coalesce(rg.vl_jrs_darcg),
                                                        rg.nr_nsu_org_blt,
                                                        vl_cod_lancamento_ctpd,
                                                        rg.cd_blt,
                                                        vp_cod_usuario,
                                                        rg.dt_ocb_darcg::timestamp without time zone,
                                                        vl_conta_banco) 
             into vl_tipo_lancamento;

             -- caso exista pagamento de juros de mora e multa
             if rg.vl_jrs_darcg > 0 then

               vl_cod_lanc_aux := null;
               perform sc_cnt.lancar_movimento(vl_cod_lanc_aux,
                                               vl_cod_lancamento_ctpd,
                                               vl_tipo_lancamento,
                                               63231,
                                               'C',
                                               rg.vl_jrs_darcg,
                                               now()::timestamp,
                                               vp_cod_usuario,
                                               null,
                                               'Ref a baixa do arquivo '|| vp_cod_arquivo,
                                               CD_SST_SISTEMA_BAIXA_BOLETO,
                                               (to_char(now(),'yyyymmdd'))::numeric
                                               );
             end if;                                  
             

         elsif rg.tp_org_blt = TP_ORG_BOLETO_AVULSO then

             select sc_cbr.lancar_boleto_avulso_empresa(rg.vl_pgt_darcg,
                                                        rg.nr_nsu_org_blt,
                                                        vl_cod_lancamento_ctpd,
                                                        rg.cd_blt,
                                                        vp_cod_usuario,
                                                        rg.dt_ocb_darcg::timestamp without time zone,
                                                        vl_conta_banco) 
             into vl_tipo_lancamento;
                         
         elsif rg.tp_org_blt = TP_ORG_BOLETO_AVULSO_CARTAO then
             
              select sc_cbr.lancar_baixa_boleto_avulso_cartao( rg.vl_pgt_darcg,
                                                        rg.nr_nsu_org_blt,
                                                        vl_cod_lancamento_ctpd,
                                                        rg.cd_blt,
                                                        vp_cod_usuario,
                                                        rg.dt_ocb_darcg::timestamp without time zone,
                                                        vl_conta_banco)
             into  vl_tipo_lancamento;
             
          elsif rg.tp_org_blt = TP_ORG_ARQUIVO_DEPOSITO_PREPAGO then
             
              select sc_cbr.lancar_baixa_boleto_arquivo_prepago(rg.vl_pgt_darcg,
                                                        rg.nr_nsu_org_blt,
                                                        vl_cod_lancamento_ctpd,
                                                        rg.cd_blt,
                                                        vp_cod_usuario,
                                                        rg.dt_ocb_darcg::timestamp without time zone,
                                                        vl_conta_banco)
             into  vl_tipo_lancamento;    


          elsif rg.tp_org_blt = TP_ORG_COBRANCA_EXTERNA then
             
              select sc_cbr.lancar_baixa_boleto_cobranca_externa(rg.vl_pgt_darcg,
                                                        rg.nr_nsu_org_blt,
                                                        vl_cod_lancamento_ctpd,
                                                        rg.cd_blt,
                                                        vp_cod_usuario,
                                                        rg.dt_ocb_darcg::timestamp without time zone,
                                                        vl_conta_banco)
             into  vl_tipo_lancamento;    
             

         end if;         

         
         
--         update sc_cbr.tbl_blt set dt_prc_blt = now() where cd_blt = rg.cd_blt;
         
         vl_valor_total := vl_valor_total + rg.vl_pgt_darcg;
              
    end loop;          
    
    if(vl_valor_total > 0) then
         perform sc_cnt.lancar_movimento(vl_cod_lancamento_ctpd,
                                         NULL,
                                         vl_tipo_lancamento,
                                         vl_conta_banco,
                                         'D',
                                         vl_valor_total,
                                         now()::timestamp,
                                         vp_cod_usuario,
                                         null,
                                         'Ref a baixa do arquivo '|| vp_cod_arquivo,
                                         CD_SST_SISTEMA_BAIXA_BOLETO,
                                         (to_char(now(),'yyyymmdd'))::numeric
                                         );
     end if;                                    



END;
$$;


ALTER FUNCTION sc_cbr.efetuar_baixas_retorno_gen(vp_cod_arquivo numeric, vp_cod_usuario numeric) OWNER TO scan;

--
-- TOC entry 1223 (class 1255 OID 564204)
-- Name: gerar_arquivo_remessa_cobranca(); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_arquivo_remessa_cobranca() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;

begin

    --obtendo os dados da tabela de cotrato de cobranca
    for rg in select cd_ccb 
    from sc_cbr.tbl_ccb 
    where fg_atv_ccb = 'S'
      and nr_cdt_ccb is not null loop


       perform sc_cbr.gerar_arquivo_remessa_cobranca(rg.cd_ccb);


    end loop;  
    
    
end;$$;


ALTER FUNCTION sc_cbr.gerar_arquivo_remessa_cobranca() OWNER TO scan;

--
-- TOC entry 7716 (class 0 OID 0)
-- Dependencies: 1223
-- Name: FUNCTION gerar_arquivo_remessa_cobranca(); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_arquivo_remessa_cobranca() IS 'rotina responsavel por gerar uma remessa de cobranca bancaria chamada pelo job';


--
-- TOC entry 1224 (class 1255 OID 564205)
-- Name: gerar_arquivo_remessa_cobranca(numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_arquivo_remessa_cobranca(vp_codigo_contrato_cobranca numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg_ccb sc_cbr.tbl_ccb%rowtype;

  ct_banco_hsbc constant numeric := 399;  
  ct_banco_bracce constant numeric := 65;  
  ct_banco_bradesco constant numeric := 237;  

  vl_cod_arquivo numeric;
begin

    --obtendo os dados da tabela de cotrato de cobranca
    select * 
    into vl_rg_ccb
    from sc_cbr.tbl_ccb 
    where cd_ccb = vp_codigo_contrato_cobranca
      and nr_cdt_ccb is not null;
    
   if vl_rg_ccb.cd_bnc = ct_banco_bradesco then
       select sc_cbr.gerar_dados_arquivo_remessa_cobranca_bradesco(vl_rg_ccb) into vl_cod_arquivo;

       if vl_cod_arquivo is not null then
         perform sc_cbr.gerar_arquivo_remessa_cobranca_bradesco(vl_cod_arquivo);
       end if;
         
    end if;
end;$$;


ALTER FUNCTION sc_cbr.gerar_arquivo_remessa_cobranca(vp_codigo_contrato_cobranca numeric) OWNER TO scan;

--
-- TOC entry 7717 (class 0 OID 0)
-- Dependencies: 1224
-- Name: FUNCTION gerar_arquivo_remessa_cobranca(vp_codigo_contrato_cobranca numeric); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_arquivo_remessa_cobranca(vp_codigo_contrato_cobranca numeric) IS 'rotina responsavel por gerar uma remessa de cobranca para o bradesco';


--
-- TOC entry 1762 (class 1255 OID 564206)
-- Name: gerar_arquivo_remessa_cobranca_bradesco(numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_arquivo_remessa_cobranca_bradesco(vp_codigo_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_diretorio varchar;
  vl_arquivo varchar;
  vl_linha varchar;
  vl_seq_registro numeric := 0;
  vl_identificador varchar;
  

  -- constantes
  ct_emissao_papeleta numeric := 2; -- Cliente emite o boleto e banco so precessa
  ct_emite_debito_automatico varchar := 'N';
  ct_identifica_rateio_credito varchar := ' '; 
  ct_enderecamento_aviso_debito_automatico  numeric := 2; 
  ct_especie_titulo  numeric := 1;
  
  vl_rg_ccb sc_cbr.tbl_ccb%rowtype;
  vl_rg_cun sc_cad.tbl_cun%rowtype;
  vl_rg_hrb sc_cbr.tbl_hrb%rowtype;
  vl_rg_drb sc_cbr.tbl_drb%rowtype;

  ct_banco_hsbc constant numeric := 399;  
  ct_banco_bracce constant numeric := 65;  
  ct_banco_bradesco constant numeric := 237;  

  ALINHAMENTO_DIREITA numeric := 1;
  ALINHAMENTO_ESQUERDA numeric := 2;

  vl_cnpj_avalista varchar(50);

  
begin

    -- obtendo as informacoes do arquivo
    select *
      into vl_rg_hrb
    from sc_cbr.tbl_hrb
    where cd_hrb = vp_codigo_arquivo;

    if vl_rg_hrb is null then
      raise exception 'Não existe dados para geraçào do arquivo.';
    end if;

    begin 

    -- obtendo os dados do contrato de cobranca
    select *
      into vl_rg_ccb
    from sc_cbr.tbl_ccb
    where cd_ccb = vl_rg_hrb.cd_ccb;

    -- obtendo os dados da empresa do contrato de cobranca
    select cun.*
      into vl_rg_cun
    from sc_cbr.tbl_cdt cdt
      inner join sc_cad.tbl_cun cun on cun.cd_cun = cdt.cd_cun
    where cdt.cd_cdt = vl_rg_ccb.cd_cdt;    

    -- obtendo o diretorio do arquivo
    select vl_prm
      into vl_diretorio
    from sc_cad.tbl_prm
    where nm_prm = 'DIRETORIO_ARQUIVO_REMESSA_COBRANCA_BRADESCO';  

    vl_arquivo := vl_diretorio || '\\'|| vl_rg_hrb.nm_arq_hrb;

    -- GERANDO O HEADER

    vl_linha := '0'; -- Identificador do Registro

    vl_linha := vl_linha || '1'; -- Identificador do Arquivo de Remessa

    vl_linha := vl_linha || 'REMESSA'; -- Literal Remessa

    vl_linha := vl_linha || '01'; -- Código de Serviço

    vl_linha := vl_linha || sc_arq.preencher(15,'COBRANCA',' ',ALINHAMENTO_DIREITA); -- Literal Serviço

    vl_linha := vl_linha || sc_arq.preencher(20,vl_rg_ccb.nr_cdt_ccb,'0',ALINHAMENTO_ESQUERDA); -- Código da Empresa (usamos a acessoria escritural)

    vl_linha := vl_linha || sc_arq.preencher(30,UPPER(vl_rg_cun.nm_cun),' ',ALINHAMENTO_DIREITA); -- Código da Empresa (usamos a acessoria escritural)

    vl_linha := vl_linha || '237'; -- Número do Bradesco na Camara de Compensacao

    vl_linha := vl_linha || sc_arq.preencher(15,'BRADESCO',' ',ALINHAMENTO_DIREITA); -- Nome do banco por extenso

    vl_linha := vl_linha || to_char(vl_rg_hrb.dt_grc_hrb,'ddMMyy'); -- Data da Gravação do Arquivo

    vl_linha := vl_linha || sc_arq.repetir(' ',8); -- Branco

    vl_linha := vl_linha || 'MX'; -- Identificação do Sistema

    vl_linha := vl_linha || sc_arq.preencher(7,vl_rg_hrb.nr_seq_rem_hrb,'0',ALINHAMENTO_ESQUERDA); -- Número Sequencial da Remessa

    vl_linha := vl_linha || sc_arq.repetir(' ',277); -- Branco

    vl_seq_registro := vl_seq_registro + 1;
    vl_linha := vl_linha || sc_arq.preencher(6,vl_seq_registro,'0',ALINHAMENTO_ESQUERDA); -- Número Sequencial do Registro

    perform sc_arq.gravarlinha(vl_arquivo,vl_linha);

    --GERANDO O DETALHE

    for vl_rg_drb in
     select *
     from sc_cbr.tbl_drb 
     where cd_hrb = vl_rg_hrb.cd_hrb loop

     vl_linha :=  '1'; -- Identificador do Registro

     -- os campos abaixo funcionam para casoa escolha for debito automatico (OPICIONAL)
     vl_linha := vl_linha || sc_arq.repetir(' ',5); -- Agencia do Pagador
     vl_linha := vl_linha || sc_arq.repetir(' ',1); -- Digito Agencia do Pagador
     vl_linha := vl_linha || sc_arq.repetir(' ',5); -- Razao da Conta do Pagador
     vl_linha := vl_linha || sc_arq.repetir(' ',7); -- Numero da Conta do Pagador
     vl_linha := vl_linha || sc_arq.repetir(' ',1); -- Digito Numero da Conta do Pagador

     vl_linha := vl_linha || vl_rg_drb.idt_emp_ben_drb; -- Identificador da Empresa Beneficiara no banco (Zero, Carteira, Agencia e Conta Corrente)

     vl_linha := vl_linha || vl_rg_drb.nr_ctl_drb; -- Número do Controle do Participante

     vl_linha := vl_linha || '000'; -- Código do Banco a ser debitado na camara de compensacao (preenchiso somente se débito automatico)
  
     vl_linha := vl_linha || vl_rg_drb.multa_drb; -- Campo de Multa

     vl_linha := vl_linha || sc_arq.formatar_moeda(4,vl_rg_drb.prc_multa_drb); -- Percentual de Multa

     vl_linha := vl_linha || sc_arq.preencher(11,vl_rg_drb.nr_doc_drb,'0',ALINHAMENTO_ESQUERDA); -- Identificacao do Titulo no Banco (Nosso Numero)

     vl_linha := vl_linha || vl_rg_drb.dg_nr_doc_drb; -- Digito do Nosso Numero

     vl_linha := vl_linha || sc_arq.repetir('0',10); -- Desconto bonificacao dia

     vl_linha := vl_linha || ct_emissao_papeleta; -- Condicao de Emissao da papeleta (1 = banco emite e processa, 2 = cliente emite e banco processa)

     vl_linha := vl_linha || ct_emite_debito_automatico; -- N = nao registra na cobranca, N != registra e emite o boleto

     vl_linha := vl_linha || sc_arq.repetir(' ',10); -- (Brancos) Identificacao da operacao do Banco

     vl_linha := vl_linha || ct_identifica_rateio_credito; -- R = Se servico de rateio de credito foi contratadao, ' ' = caso contrario

     vl_linha := vl_linha || ct_enderecamento_aviso_debito_automatico; -- 1 = emite aviso e assume endereco do pagador informado no arquivo, 2 = nao emite aviso, caso contrario emite aviso e assume endereco cadastrado no banco

     vl_linha := vl_linha || sc_arq.repetir(' ',2); -- Brancos

     vl_linha := vl_linha || sc_arq.preencher(2,vl_rg_drb.idt_ocr_drb,'0',ALINHAMENTO_ESQUERDA); -- Identificacao da ocorrencia 01 = Remessa

     vl_linha := vl_linha || sc_arq.preencher(10,vl_rg_drb.cd_doc_drb,' ',ALINHAMENTO_DIREITA); -- Numero do documento

     vl_linha := vl_linha || to_char(vl_rg_drb.dt_vnc_drb,'ddMMyy'); -- Data do Vencimento

     vl_linha := vl_linha || sc_arq.formatar_moeda(13,vl_rg_drb.vl_drb); -- Valor do Titulo

     vl_linha := vl_linha || sc_arq.repetir('0',3); -- Banco encarregado da cobranca

     vl_linha := vl_linha || sc_arq.repetir('0',5); -- Agencia Depositaria

     vl_linha := vl_linha || sc_arq.preencher(2,ct_especie_titulo,'0',ALINHAMENTO_ESQUERDA); -- Especie de Titulo 01 = Duplicata, 02= Nota Promissoria, 05 = Recibo, 99 = Outros, etc

     vl_linha := vl_linha || 'N'; -- Identificacao (Sempre N)

     vl_linha := vl_linha || to_char(vl_rg_drb.dt_ems_drb,'ddMMyy'); -- Data da Emissao do Titulo

     -- os campos abaixo sao utlizados somente em caso de protesto (Preencher com zeros caso nao )
     vl_linha := vl_linha || sc_arq.repetir('0',2); -- 1 Instrucao
     vl_linha := vl_linha || sc_arq.repetir('0',2); -- 2 Instrucao

     vl_linha := vl_linha || sc_arq.formatar_moeda(13,vl_rg_drb.vl_mora_drb); -- Valor de mora, cobrado por dia de atraso

     vl_linha := vl_linha || sc_arq.repetir('0',6); -- Data Limite para concessao de desconto

     vl_linha := vl_linha || sc_arq.repetir('0',13); -- Valor do Desconto

     vl_linha := vl_linha || sc_arq.repetir('0',13); -- Valor do IOF

     vl_linha := vl_linha || sc_arq.repetir('0',13); -- Valor do Abatimento

     vl_linha := vl_linha || sc_arq.preencher(2,vl_rg_drb.idt_tpi_pgd_drb,'0',ALINHAMENTO_ESQUERDA); -- Identificacao do tipo de inscricao do pagador

     -- efetuando o tratamento para geracao do identificador
     if vl_rg_drb.idt_tpi_pgd_drb = 2 then -- CASO CNPJ

       vl_identificador := sc_arq.preencher(14,vl_rg_drb.nr_insc_pgd_drb,'0',ALINHAMENTO_ESQUERDA);
       --vl_identificador := substr(vl_identificador,1,8) || substr(vl_identificador,9,4) || substr(vl_identificador,13);
                           
     else

        vl_identificador := '000';
        vl_identificador := vl_identificador || sc_arq.preencher(11,vl_rg_drb.nr_insc_pgd_drb,'0',ALINHAMENTO_ESQUERDA);

     end if;

     vl_linha := vl_linha || vl_identificador; -- Identificacao do tipo de inscricao do pagador

     vl_linha := vl_linha || sc_arq.preencher(40,vl_rg_drb.nm_pgd_drb,' ',ALINHAMENTO_DIREITA); -- Nome do pagador

     vl_linha := vl_linha || sc_arq.repetir(' ',40); -- Endereco do Pagador

     vl_linha := vl_linha || sc_arq.repetir(' ',12); -- 1 Mensagem
   
     vl_linha := vl_linha || sc_arq.repetir('0',5); -- CEP do pagador

     vl_linha := vl_linha || sc_arq.repetir('0',3); -- Sufixo do CEP do pagador

     --CAMPO AVALISTA E SEGUNDA MENSAGEM

     if vl_rg_drb.nr_cpf_cnpj_avl_drb is not null then

        vl_cnpj_avalista := sc_arq.preencher(15, vl_rg_drb.nr_cpf_cnpj_avl_drb,'0',ALINHAMENTO_ESQUERDA);

        --vl_cnpj_avalista := substr(vl_cnpj_avalista,14,2) || substr(vl_cnpj_avalista,10,4) || substr(vl_cnpj_avalista,1,9);

        vl_linha := vl_linha || vl_cnpj_avalista;
        vl_linha := vl_linha || '  ';
        vl_linha := vl_linha || sc_arq.preencher(43,vl_rg_drb.nm_avl_drb,' ',ALINHAMENTO_DIREITA);
     
     else

        vl_linha := vl_linha || sc_arq.repetir(' ',60); -- 2 Mensagem
     
     end if;
     
     

     --FIM DO CAMPO AVALISTA E SEGUNDA MENSAGEM

     vl_seq_registro := vl_seq_registro + 1;
     vl_linha := vl_linha || sc_arq.preencher(6,vl_seq_registro,'0',ALINHAMENTO_ESQUERDA); -- Número Sequencial do Registro

     perform sc_arq.gravarlinha(vl_arquivo,vl_linha);

    end loop;

    -- GERANDO TRAILLER

    vl_linha := '9'; -- Identificador do Registro

    vl_linha := vl_linha || sc_arq.repetir(' ',393); -- Brancos

    vl_seq_registro := vl_seq_registro + 1;
    vl_linha := vl_linha || sc_arq.preencher(6,vl_seq_registro,'0',ALINHAMENTO_ESQUERDA); -- Número Sequencial do ultimo Registro

    perform sc_arq.gravarlinha(vl_arquivo,vl_linha);


    --inserindo registro na tabela de download
    insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'), vl_rg_hrb.nm_arq_hrb, now(), current_date, 11, 1);
     
    exception when others then

        perform sc_arq.excluirarquivo(vl_arquivo);
	raise exception 'Ocorreu um erro na geração do arquivo de remessa do bradesco.';   
    end;	
    
end;$$;


ALTER FUNCTION sc_cbr.gerar_arquivo_remessa_cobranca_bradesco(vp_codigo_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1477 (class 1255 OID 564209)
-- Name: gerar_boleto(numeric, numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_boleto(vp_contrato_cobranca numeric, vp_tipo_origem numeric, vp_nsu_origem numeric, vp_nosso_numero numeric DEFAULT NULL::numeric, vp_codigo_boleto numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  /* CONSTANTES */
  tp_origem_empresa numeric := 1;
  tp_origem_cartao  numeric := 2;
  tp_origem_renegociacao  numeric := 3;
  tp_origem_boleto_avulso numeric := 4;
  tp_origem_boleto_parcela numeric := 5;
  tp_origem_boleto_avulso_cartao numeric := 6;
  tp_origem_boleto_arquivo_deposito numeric := 7;
  tp_origem_boleto_cobranca_externa numeric := 8; 
  
  st_cadastrado     numeric := 1;

  ct_banco_hsbc numeric := 399;
  ct_banco_bradesco numeric := 237;
  
  -- VARIAVEIS
  vl_fat_empresa                             sc_fep.tbl_fep%rowtype;
  vl_fat_cartao                                  sc_fcr.tbl_fcr%rowtype;
  vl_boleto_avulso                          sc_fin.tbl_bla%rowtype;
  vl_boleto_avulso_cartao           sc_cbr.tbl_bac%rowtype;
  
  vl_rnc_cartao                  sc_rnc.tbl_rnc%rowtype;
  vl_cont_cobranca         sc_cbr.tbl_ccb%rowtype;
  vl_tarifa_cobranca    sc_cbr.tbl_tcb%rowtype;
  vl_prc_cartao         sc_cbr.tbl_prc%rowtype;
  
  vl_codigo_documento   numeric;
  vl_nosso_numero       varchar;
  vl_dgt_nosso_numero   varchar;        
  vl_codigo_barras      varchar;
  vl_dac                varchar;
  vl_valor_boleto             numeric;
  vl_data_vencimento   date;
  vl_data_venc_boleto  date;
  vl_nm_sacado                varchar; 
  vl_cpfcnpj_sacado        numeric;
  vl_lin_digitavel               varchar;
  vl_valor_juros numeric;
  vl_valor_multa               numeric;
  vl_desc_instrucao     varchar;
  vl_desc_informacao    varchar;
  vl_codigo_contrato_cobranca numeric;

  vl_dias_acrescimo     numeric := 0;

  vl_tp_pessoa numeric := null;
  vl_cpf_cnpj_avalista numeric :=null;
  vl_nome_avalista varchar := null;
begin

  -- validando o horario da geracao do boleto
  /*if NOT (to_char(current_timestamp,'HH24')::numeric >= 1 and to_char(current_timestamp,'HH24')::numeric < 17) then
    raise exception 'FORA DO HORÁRIO PERMITIDO. GERAÇÃO DE BOLETO PERMITIDA DAS 06:00 AS 17:00.';
  end if;*/
  
  -- capturando o contrato de cobranca
  select * 
    into vl_cont_cobranca
  from sc_cbr.tbl_ccb ccb
  where ccb.cd_ccb = vp_contrato_cobranca
    AND ccb.fg_atv_ccb = 'S';
  
  -- capturando os dados das tarifas
  select tcb.*
    into vl_tarifa_cobranca
  from sc_cbr.tbl_tcb tcb
  where tcb.cd_tcb = vl_cont_cobranca.cd_tcb;

  if vp_nosso_numero is null then

                  -- codigo do documento
                  if vl_cont_cobranca.cd_bnc = ct_banco_hsbc then
                    select trunc(coalesce(max(blt.cd_doc_blt), 0)/1000) + 1
                      into vl_codigo_documento
                    from sc_cbr.tbl_blt blt
                                    inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
                    where ccb.cd_bnc = vl_cont_cobranca.cd_bnc
                      and ccb.cd_agn_ccb = vl_cont_cobranca.cd_agn_ccb
                      and ccb.cd_cnt_ccb = vl_cont_cobranca.cd_cnt_ccb;
                 end if;

                  if vl_cont_cobranca.cd_bnc = ct_banco_bradesco then

                    if vp_tipo_origem = tp_origem_boleto_cobranca_externa then

                                   select cce.cd_cce,tit.ns_nmr_tit
                                   into vl_codigo_contrato_cobranca,vl_codigo_documento
                                   from sc_cce.tbl_tit tit
                                     inner join sc_cce.tbl_cce cce on cce.cd_cce = tit.cd_cce
                                   where tit.cd_tit = vp_nsu_origem;

                                   if vl_codigo_documento is null then
                                                   select coalesce(max(blt.cd_doc_blt), 0) + 1
                                                     into vl_codigo_documento
                                                   from sc_cbr.tbl_blt blt
                                                                    inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
                                                                    inner join sc_cce.tbl_cce cce on cce.cd_ccb = ccb.cd_cce
                                                   where ccb.cd_bnc = vl_cont_cobranca.cd_bnc
                                                     and ccb.cd_agn_ccb = vl_cont_cobranca.cd_agn_ccb
                                                     and ccb.cd_cnt_ccb = vl_cont_cobranca.cd_cnt_ccb
                                                     and blt.cd_doc_blt >= cce.ns_nmr_ini_cce
                                                     and cce.cd_cce = vl_codigo_contrato_cobranca;
                                   end if;
                    else

                                   select coalesce(max(blt.cd_doc_blt), 0) + 1
                                     into vl_codigo_documento
                                   from sc_cbr.tbl_blt blt
                                                    inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
                                                    left join sc_cce.tbl_cce cce on cce.cd_ccb = ccb.cd_ccb
                                   where ccb.cd_bnc = vl_cont_cobranca.cd_bnc
                                     and ccb.cd_agn_ccb = vl_cont_cobranca.cd_agn_ccb
                                     and ccb.cd_cnt_ccb = vl_cont_cobranca.cd_cnt_ccb
                                     and (cce.cd_cce is null or blt.tp_org_blt <> 8);
                      
                    end if;

                      
                  end if;

  else
    vl_codigo_documento := vp_nosso_numero;
  end if;
   
  if vp_tipo_origem = tp_origem_empresa then
                
                -- capturando os dados da fatura empresa
                begin
                  select *
                    into vl_fat_empresa
                   from sc_fep.tbl_fep fep
                   where fep.cd_fep = vp_nsu_origem;
                exception when others then
                   raise exception 'Não existe fatura de empresa com esse código.';
                end;
                
                -- capturando dados para gerar o boleto
                vl_valor_boleto := vl_fat_empresa.vl_fep;
                vl_data_vencimento := vl_fat_empresa.dt_vnc_fep;
                vl_data_venc_boleto := vl_fat_empresa.dt_vnc_fep;

                -- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
                  into vl_codigo_barras;

                -- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;             
                               
        -- capturando os dados do sacado
                select distinct cun.nm_cun, cun.nr_cpf_cnpj_cun
                  into vl_nm_sacado, vl_cpfcnpj_sacado
                from sc_fep.tbl_fep fep
                  inner join sc_cad.tbl_cun cun on cun.cd_cun = fep.cd_cun
                where fep.cd_fep = vp_nsu_origem;
                
  elsif vp_tipo_origem = tp_origem_boleto_avulso then

        select *
        into vl_boleto_avulso
        from sc_fin.tbl_bla
        where cd_bla = vp_nsu_origem;

        -- se empresa saqcard nao gerar boleto
        if vl_boleto_avulso.cd_emp = 541 and vl_boleto_avulso.dt_vnc_bla is null then
          return;
        end if;

        -- retornando parametro de acrescimo ao vencimento do boleto avulso
        select vl_prm::numeric 
          into vl_dias_acrescimo
        from sc_cad.tbl_prm 
          where nm_prm = 'DIAS_ACRESCIMO_VENCIMENTO_BOLETO_AVULSO';

        -- capturando dados para gerar o boleto
                vl_valor_boleto := vl_boleto_avulso.vl_bla;

        if vl_boleto_avulso.dt_vnc_bla is not null then
          vl_data_vencimento := vl_boleto_avulso.dt_vnc_bla;
        else
          vl_data_vencimento := current_date + interval '1 day' * vl_dias_acrescimo;
           
          update sc_fin.tbl_bla set dt_vnc_bla = vl_data_vencimento where cd_bla = vl_boleto_avulso.cd_bla;
        end if;

        vl_data_venc_boleto := vl_data_vencimento;

                -- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
                  into vl_codigo_barras;

                -- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;           

                -- capturando os dados do sacado
                select distinct emp.nm_emp, cun.nr_cpf_cnpj_cun
                  into vl_nm_sacado, vl_cpfcnpj_sacado
                from sc_fin.tbl_bla bla
                  inner join sc_cad.tbl_emp emp on emp.cd_emp = bla.cd_emp
                  inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp
                  inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
                where bla.cd_bla = vp_nsu_origem
                  and fem.cd_fem = (CASE WHEN fem.fg_mtz_fem = 'S' THEN fem.cd_fem ELSE (SELECT min(cd_fem) from sc_cad.tbl_fem where cd_emp = emp.cd_emp) end);

  elsif vp_tipo_origem = tp_origem_boleto_arquivo_deposito then

        /*select *
        into vl_boleto_avulso
        from sc_fin.tbl_bla
        where cd_bla = vp_nsu_origem;*/

        select t.vl_reg_env_tfe + coalesce(t.vl_trf_tfe,0),
               h.dt_vnc_hfe
        into vl_valor_boleto,
             vl_data_vencimento
        from sc_adp.tbl_hfe h
          inner join sc_adp.tbl_tfe t on t.cd_hfe = h.cd_hfe
        where h.cd_hfe = vp_nsu_origem;

        vl_data_venc_boleto := vl_data_vencimento;

                -- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
                  into vl_codigo_barras;

                -- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;           

                -- capturando os dados do sacado
                select distinct emp.nm_emp, cun.nr_cpf_cnpj_cun
                  into vl_nm_sacado, vl_cpfcnpj_sacado
                from sc_adp.tbl_hfe hfe
                 inner join sc_cad.tbl_emp emp on emp.cd_emp = hfe.cd_emp
                  inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp
                  inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
                where hfe.cd_hfe = vp_nsu_origem
                  and fem.cd_fem = (CASE WHEN fem.fg_mtz_fem = 'S' THEN fem.cd_fem ELSE (SELECT min(cd_fem) from sc_cad.tbl_fem where cd_emp = emp.cd_emp) end);
                  
                
  elsif vp_tipo_origem = tp_origem_cartao  then

        -- capturando dados da fatura de cartao
        select *
          into vl_fat_cartao
        from sc_fcr.tbl_fcr fcr
        where fcr.cd_fcr = vp_nsu_origem;

        -- retornnando parametro de acrescimo ao vencimento da fatura do cartao
        select vl_prm::numeric 
          into vl_dias_acrescimo
        from sc_cad.tbl_prm 
          where nm_prm = 'DIAS_ACRESCIMO_VENCIMENTO_FATURA_CARTAO';

        -- capturando dados para gerar o boleto
                vl_valor_boleto := vl_fat_cartao.vl_sld_dvd_fcr;
        vl_data_vencimento := current_date + interval '1 day' * vl_dias_acrescimo;

        if vl_fat_cartao.dt_vnc_fcr > vl_data_vencimento then
          vl_data_vencimento := vl_fat_cartao.dt_vnc_fcr;
        end if; 

                vl_data_venc_boleto := vl_data_vencimento;


                -- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
                  into vl_codigo_barras;

                -- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;           

                -- capturando os dados do sacado
                select distinct cun.nm_cun, cun.nr_cpf_cnpj_cun
                  into vl_nm_sacado, vl_cpfcnpj_sacado
                from sc_fcr.tbl_fcr fcr
                  inner join sc_opr.tbl_crt crt on crt.cd_crt = fcr.cd_crt
                  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                  inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
                where fcr.cd_fcr = vp_nsu_origem;
                

  elsif vp_tipo_origem = tp_origem_renegociacao  then -- tipo origem renegociacao
        -- capturando dados da fatura de cartao atraves da renegociacao
        select *
          into vl_rnc_cartao
        from sc_rnc.tbl_rnc rnc
        where rnc.cd_rnc = vp_nsu_origem;

        -- capturando dados para gerar o boleto
                vl_valor_boleto := vl_rnc_cartao.vl_ent_rnc;
                vl_data_vencimento := (vl_rnc_cartao.dt_vnc_ent_rnc)::date;
                vl_data_venc_boleto := (vl_rnc_cartao.dt_vnc_ent_rnc)::date;

                -- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
                  into vl_codigo_barras;

                -- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;           

                -- capturando os dados do sacado
                select distinct cun.nm_cun, cun.nr_cpf_cnpj_cun
                  into vl_nm_sacado, vl_cpfcnpj_sacado
                from sc_fcr.tbl_fcr fcr
                  inner join sc_opr.tbl_crt crt on crt.cd_crt = fcr.cd_crt
                  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                  inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
                where fcr.cd_fcr = vl_rnc_cartao.cd_fcr;

  elsif vp_tipo_origem = tp_origem_boleto_parcela  then -- tipo origem renegociacao
        -- capturando dados da fatura de cartao atraves da renegociacao
        select *
          into vl_prc_cartao
        from sc_cbr.tbl_prc
        where cd_prc = vp_nsu_origem;

        -- capturando dados para gerar o boleto
                vl_valor_boleto := vl_prc_cartao.vl_prc;
                vl_data_vencimento := (vl_prc_cartao.dt_vnc_prc)::date;
                vl_data_venc_boleto := (vl_prc_cartao.dt_vnc_prc)::date;

                -- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
                  into vl_codigo_barras;

                -- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;           

                -- capturando os dados do sacado
                select distinct cun.nm_cun, cun.nr_cpf_cnpj_cun
                  into vl_nm_sacado, vl_cpfcnpj_sacado
                from sc_opr.tbl_crt crt
                  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                  inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
                where crt.cd_crt = vl_prc_cartao.cd_crt;
  elsif vp_tipo_origem = tp_origem_boleto_avulso_cartao then -- tipo origem boleto avulso cartao
                
                select *
        into vl_boleto_avulso_cartao
        from sc_cbr.tbl_bac
        where cd_bac = vp_nsu_origem;

        -- retornando parametro de acrescimo ao vencimento do boleto avulso
        select vl_prm::numeric 
          into vl_dias_acrescimo
        from sc_cad.tbl_prm 
          where nm_prm = 'DIAS_ACRESCIMO_VENCIMENTO_BOLETO_AVULSO';

        -- capturando dados para gerar o boleto
                vl_valor_boleto := vl_boleto_avulso_cartao.vlr_bac;
        vl_data_vencimento := vl_boleto_avulso_cartao.dt_vnc_bac;
                vl_data_venc_boleto := vl_data_vencimento;

                -- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
                  into vl_codigo_barras;

                -- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;

        -- capturando os dados do sacado
                select cun.nm_cun, cun.nr_cpf_cnpj_cun
                  into vl_nm_sacado, vl_cpfcnpj_sacado
                from sc_cbr.tbl_bac bac
                  inner join sc_opr.tbl_crt crt on bac.cd_crt = crt.cd_crt
                  inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
                  inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
                where bac.cd_bac = vp_nsu_origem;

  elsif vp_tipo_origem = tp_origem_boleto_cobranca_externa then

        select t.vl_tit,
               t.dt_vnc_tit,
               nr_cpf_cnpj_scd,
               nm_scd,
               case when cun.tp_pss_cun = 'F' then 1 else 2 end,
               cun_a.nr_cpf_cnpj_cun,
               cun_a.nm_cun
        into vl_valor_boleto,
             vl_data_vencimento,
             vl_cpfcnpj_sacado,
             vl_nm_sacado,
             vl_tp_pessoa,
             vl_cpf_cnpj_avalista,
             vl_nome_avalista
        from sc_cce.tbl_tit t
          inner join sc_cce.tbl_cce cce on cce.cd_cce = t.cd_cce
          inner join sc_cce.tbl_scd scd on scd.cd_scd = t.cd_scd
          inner join sc_cad.tbl_cun cun on cun.cd_cun = scd.cd_cun
          inner join sc_cad.tbl_cun cun_a on cun_a.cd_cun = cce.cd_cun
        where t.cd_tit = vp_nsu_origem;

        vl_data_venc_boleto := vl_data_vencimento;

                -- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
                  into vl_codigo_barras;

                -- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;
        
  end if;
   
  -- inserindo o digito verificador no nosso numero
  if vl_cont_cobranca.cd_bnc = ct_banco_hsbc then
    raise exception 'Contrato de cobrança inválido';
  
    select sc_cbr.gerar_nosso_numero_hsbc(vl_codigo_documento, vl_cont_cobranca.nr_cdt_ccb, vl_data_vencimento)
    into vl_nosso_numero;

    vl_dgt_nosso_numero := substr(vl_nosso_numero,length(vl_nosso_numero)-2);
  end if;

  if vl_cont_cobranca.cd_bnc = ct_banco_bradesco then
    select sc_cbr.gerar_nosso_numero_bradesco(vl_codigo_documento, vl_cont_cobranca.nr_car_ccb)
    into vl_nosso_numero;

    vl_dgt_nosso_numero := substr(vl_nosso_numero,length(vl_nosso_numero));
    vl_nosso_numero := substr(vl_nosso_numero,1,length(vl_nosso_numero)-1);
  end if;
  

  -- gerando valor multa, valor juros, instrucao e informacao
  select * from sc_cbr.gerar_boleto_instrucao_informacao(vl_valor_boleto, vp_tipo_origem, vp_nsu_origem, vl_tarifa_cobranca)
    into vl_valor_multa, vl_valor_juros, vl_desc_instrucao, vl_desc_informacao;
  

  -- inserindo o boleto
  if vp_codigo_boleto is null then
    vp_codigo_boleto := nextval('sc_cbr.sq_blt');
  end if;
  
  INSERT INTO sc_cbr.tbl_blt(
            cd_blt, cd_ccb, cd_brr_blt, nr_lin_dgt_blt, vl_blt, dt_vnc_blt, 
            dt_grc_blt, cd_doc_blt, st_blt, tp_org_blt, nr_nsu_org_blt, 
            nm_sac_blt, nr_cpfcnpj_sac_blt, pc_atr_blt, vl_atr_blt, 
            pc_jrs_blt, vl_jrs_blt, ds_ins_blt, ds_out_inf_blt, dgt_cd_doc_blt, tp_pss_blt, nr_cpf_cnpj_avl_blt,nm_avl_blt)
    VALUES (vp_codigo_boleto, vl_cont_cobranca.cd_ccb, vl_codigo_barras, vl_lin_digitavel, vl_valor_boleto, vl_data_venc_boleto, 
            NOW(), vl_nosso_numero::numeric, st_cadastrado, vp_tipo_origem, vp_nsu_origem, 
            vl_nm_sacado, vl_cpfcnpj_sacado, vl_tarifa_cobranca.pc_mlt_tcb, vl_valor_multa,
            vl_tarifa_cobranca.pc_jrs_tcb, vl_valor_juros, vl_desc_instrucao, vl_desc_informacao,vl_dgt_nosso_numero, vl_tp_pessoa,vl_cpf_cnpj_avalista,vl_nome_avalista);

  if vp_tipo_origem = tp_origem_empresa then
     update sc_fep.tbl_fep
       set cd_blt = vp_codigo_boleto
     where cd_fep = vp_nsu_origem;
  end if;

  if vp_tipo_origem = tp_origem_boleto_avulso then
     update sc_fin.tbl_bla
       set cd_blt = vp_codigo_boleto
     where cd_bla = vp_nsu_origem;
  end if;

  if vp_tipo_origem = tp_origem_cartao  then
    update sc_fcr.tbl_fcr
       set cd_blt = vp_codigo_boleto
     where cd_fcr = vp_nsu_origem;
  end if;

  if vp_tipo_origem = tp_origem_renegociacao  then 
    update sc_rnc.tbl_rnc
       set cd_blt = vp_codigo_boleto
     where cd_rnc = vp_nsu_origem;
  end if;

  if vp_tipo_origem = tp_origem_boleto_parcela  then
    update sc_cbr.tbl_prc
       set cd_blt = vp_codigo_boleto
     where cd_prc = vp_nsu_origem;
  end if;

  if vp_tipo_origem = tp_origem_boleto_avulso_cartao then -- tipo origem boleto avulso cartao
    update sc_cbr.tbl_bac
      set cd_blt = vp_codigo_boleto
    where cd_bac = vp_nsu_origem;
  end if;

  if vp_tipo_origem = tp_origem_boleto_arquivo_deposito then
    update sc_adp.tbl_hfe
      set cd_blt = vp_codigo_boleto
    where cd_hfe = vp_nsu_origem;
  end if;

  if vp_tipo_origem = tp_origem_boleto_cobranca_externa then
    update sc_cce.tbl_tit
      set cd_blt = vp_codigo_boleto
    where cd_tit = vp_nsu_origem;
  end if;

end$$;


ALTER FUNCTION sc_cbr.gerar_boleto(vp_contrato_cobranca numeric, vp_tipo_origem numeric, vp_nsu_origem numeric, vp_nosso_numero numeric, vp_codigo_boleto numeric) OWNER TO scan;

--
-- TOC entry 1225 (class 1255 OID 564212)
-- Name: gerar_boleto_OLD(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION "gerar_boleto_OLD"(vp_contrato_cobranca numeric, vp_tipo_origem numeric, vp_nsu_origem numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  /* CONSTANTES */
  tp_origem_empresa numeric := 1;
  tp_origem_cartao  numeric := 2;
  tp_origem_renegociacao  numeric := 3;
  tp_origem_boleto_avulso numeric := 4;
  tp_origem_boleto_parcela numeric := 5;
  st_cadastrado     numeric := 1;

  ct_banco_hsbc numeric := 399;
  ct_banco_bradesco numeric := 237;
  
  -- VARIAVEIS
  vl_fat_empresa    	sc_fep.tbl_fep%rowtype;
  vl_fat_cartao   	sc_fcr.tbl_fcr%rowtype;
  vl_boleto_avulso   	sc_fin.tbl_bla%rowtype;
  
  vl_rnc_cartao   	sc_rnc.tbl_rnc%rowtype;
  vl_cont_cobranca  	sc_cbr.tbl_ccb%rowtype;
  vl_tarifa_cobranca    sc_cbr.tbl_tcb%rowtype;
  vl_prc_cartao         sc_cbr.tbl_prc%rowtype;
  
  vl_codigo_documento   numeric;
  vl_nosso_numero       varchar;
  vl_dgt_nosso_numero   varchar;        
  vl_codigo_barras      varchar;
  vl_dac		varchar;
  vl_valor_boleto	numeric;
  vl_data_vencimento	date;
  vl_data_venc_boleto	date;
  vl_nm_sacado		varchar; 
  vl_cpfcnpj_sacado	numeric;
  vl_lin_digitavel	varchar;
  vl_valor_juros	numeric;
  vl_valor_multa	numeric;
  vl_desc_instrucao     varchar;
  vl_desc_informacao	varchar;
begin
  
  -- capturando o contrato de cobranca
  select * 
    into vl_cont_cobranca
  from sc_cbr.tbl_ccb ccb
  where ccb.cd_ccb = vp_contrato_cobranca;
  
  -- capturando os dados das tarifas
  select tcb.*
    into vl_tarifa_cobranca
  from sc_cbr.tbl_tcb tcb
  where tcb.cd_tcb = vl_cont_cobranca.cd_tcb;

  -- codigo do documento
  if vl_cont_cobranca.cd_bnc = ct_banco_hsbc then
    select trunc(coalesce(max(blt.cd_doc_blt), 0)/1000) + 1
      into vl_codigo_documento
    from sc_cbr.tbl_blt blt
	     inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
    where ccb.cd_bnc = vl_cont_cobranca.cd_bnc
      and ccb.cd_agn_ccb = vl_cont_cobranca.cd_agn_ccb
      and ccb.cd_cnt_ccb = vl_cont_cobranca.cd_cnt_ccb;
  end if;

  if vl_cont_cobranca.cd_bnc = ct_banco_bradesco then
    select coalesce(max(blt.cd_doc_blt), 0) + 1
      into vl_codigo_documento
    from sc_cbr.tbl_blt blt
	     inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
    where ccb.cd_bnc = vl_cont_cobranca.cd_bnc
      and ccb.cd_agn_ccb = vl_cont_cobranca.cd_agn_ccb
      and ccb.cd_cnt_ccb = vl_cont_cobranca.cd_cnt_ccb;
  end if;
   
  if vp_tipo_origem = tp_origem_empresa then
	
	-- capturando os dados da fatura empresa
	begin
	  select *
	    into vl_fat_empresa
	   from sc_fep.tbl_fep fep
	   where fep.cd_fep = vp_nsu_origem;
	exception when others then
	   raise exception 'Não existe fatura de empresa com esse código.';
	end;
	
	-- capturando dados para gerar o boleto
	vl_valor_boleto := vl_fat_empresa.vl_fep;
	vl_data_vencimento := vl_fat_empresa.dt_vnc_fep;
	vl_data_venc_boleto := vl_fat_empresa.dt_vnc_fep;

	-- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
	  into vl_codigo_barras;

	-- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;	  
	  	
        -- capturando os dados do sacado
	select distinct cun.nm_cun, cun.nr_cpf_cnpj_cun
	  into vl_nm_sacado, vl_cpfcnpj_sacado
	from sc_fep.tbl_fep fep
		inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = fep.cd_ctr
		inner join sc_cad.tbl_fem_ctr fc on fc.cd_ctr = ctr.cd_ctr
		inner join sc_cad.tbl_fem fem on fem.cd_emp = fc.cd_emp and fem.cd_fem = fc.cd_fem and fc.fg_atv_fem_ctr = 'S'
		inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
	where fep.cd_fep = vp_nsu_origem;
	
  elsif vp_tipo_origem = tp_origem_boleto_avulso then

        select *
        into vl_boleto_avulso
        from sc_fin.tbl_bla
        where cd_bla = vp_nsu_origem;

        -- capturando dados para gerar o boleto
	vl_valor_boleto := vl_boleto_avulso.vl_bla;
        vl_data_vencimento := null;
	vl_data_venc_boleto := current_date + interval '2 days';

	-- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
	  into vl_codigo_barras;

	-- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;	

	-- capturando os dados do sacado
	select distinct emp.nm_emp, 99999999999
	  into vl_nm_sacado, vl_cpfcnpj_sacado
	from sc_fin.tbl_bla bla
	  inner join sc_cad.tbl_emp emp on emp.cd_emp = bla.cd_emp
	where bla.cd_bla = vp_nsu_origem;
	
  elsif vp_tipo_origem = tp_origem_cartao  then

        -- capturando dados da fatura de cartao
        select *
          into vl_fat_cartao
        from sc_fcr.tbl_fcr fcr
        where fcr.cd_fcr = vp_nsu_origem;

        -- capturando dados para gerar o boleto
	vl_valor_boleto := vl_fat_cartao.vl_fcr;
        vl_data_vencimento := null;
	vl_data_venc_boleto := vl_fat_cartao.dt_vnc_fcr;

	-- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
	  into vl_codigo_barras;

	-- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;	

	-- capturando os dados do sacado
	select distinct cun.nm_cun, cun.nr_cpf_cnpj_cun
	  into vl_nm_sacado, vl_cpfcnpj_sacado
	from sc_fcr.tbl_fcr fcr
	  inner join sc_opr.tbl_crt crt on crt.cd_crt = fcr.cd_crt
	  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	  inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	where fcr.cd_fcr = vp_nsu_origem;
	

  elsif vp_tipo_origem = tp_origem_renegociacao  then -- tipo origem renegociacao
        -- capturando dados da fatura de cartao atraves da renegociacao
        select *
          into vl_rnc_cartao
        from sc_rnc.tbl_rnc rnc
        where rnc.cd_rnc = vp_nsu_origem;

        -- capturando dados para gerar o boleto
	vl_valor_boleto := vl_rnc_cartao.vl_ent_rnc;
	vl_data_vencimento := (vl_rnc_cartao.dt_vnc_ent_rnc)::date;
	vl_data_venc_boleto := (vl_rnc_cartao.dt_vnc_ent_rnc)::date;

	-- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
	  into vl_codigo_barras;

	-- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;	

	-- capturando os dados do sacado
	select distinct cun.nm_cun, cun.nr_cpf_cnpj_cun
	  into vl_nm_sacado, vl_cpfcnpj_sacado
	from sc_fcr.tbl_fcr fcr
	  inner join sc_opr.tbl_crt crt on crt.cd_crt = fcr.cd_crt
	  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	  inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	where fcr.cd_fcr = vl_rnc_cartao.cd_fcr;

  elsif vp_tipo_origem = tp_origem_boleto_parcela  then -- tipo origem renegociacao
        -- capturando dados da fatura de cartao atraves da renegociacao
        select *
          into vl_prc_cartao
        from sc_cbr.tbl_prc
        where cd_prc = vp_nsu_origem;

        -- capturando dados para gerar o boleto
	vl_valor_boleto := vl_prc_cartao.vl_prc;
	vl_data_vencimento := (vl_prc_cartao.dt_vnc_prc)::date;
	vl_data_venc_boleto := (vl_prc_cartao.dt_vnc_prc)::date;

	-- gerando o codigo de barras
        select sc_cbr.gerar_codigo_barras(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento)
	  into vl_codigo_barras;

	-- gerando a linha digitavel
        vl_dac := substr(vl_codigo_barras, 5, 1);
        select sc_cbr.gerar_linha_digitavel(vl_cont_cobranca, 9, vl_valor_boleto, vl_codigo_documento, vl_data_vencimento, vl_dac::numeric)
          into vl_lin_digitavel;	

	-- capturando os dados do sacado
	select distinct cun.nm_cun, cun.nr_cpf_cnpj_cun
	  into vl_nm_sacado, vl_cpfcnpj_sacado
	from sc_opr.tbl_crt crt
	  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	  inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	where crt.cd_crt = vl_prc_cartao.cd_crt;
	  
  end if;
   
  -- inserindo o digito verificador no nosso numero
  if vl_cont_cobranca.cd_bnc = ct_banco_hsbc then
    select sc_cbr.gerar_nosso_numero_hsbc(vl_codigo_documento, vl_cont_cobranca.nr_cdt_ccb, vl_data_vencimento)
    into vl_nosso_numero;

    vl_dgt_nosso_numero := substr(vl_nosso_numero,length(vl_nosso_numero)-2);
  end if;

  if vl_cont_cobranca.cd_bnc = ct_banco_bradesco then
    select sc_cbr.gerar_nosso_numero_bradesco(vl_codigo_documento, vl_cont_cobranca.nr_car_ccb)
    into vl_nosso_numero;

    vl_dgt_nosso_numero := substr(vl_nosso_numero,length(vl_nosso_numero));
    vl_nosso_numero := substr(vl_nosso_numero,1,length(vl_nosso_numero)-1);
  end if;
  

  -- gerando valor multa, valor juros, instrucao e informacao
  select * from sc_cbr.gerar_boleto_instrucao_informacao(vl_valor_boleto, vp_tipo_origem, vp_nsu_origem, vl_tarifa_cobranca)
    into vl_valor_multa, vl_valor_juros, vl_desc_instrucao, vl_desc_informacao;
  

  -- inserindo o boleto
  INSERT INTO sc_cbr.tbl_blt(
            cd_blt, cd_ccb, cd_brr_blt, nr_lin_dgt_blt, vl_blt, dt_vnc_blt, 
            dt_grc_blt, cd_doc_blt, st_blt, tp_org_blt, nr_nsu_org_blt, 
            nm_sac_blt, nr_cpfcnpj_sac_blt, pc_atr_blt, vl_atr_blt, 
            pc_jrs_blt, vl_jrs_blt, ds_ins_blt, ds_out_inf_blt, dgt_cd_doc_blt)
    VALUES (nextval('sc_cbr.sq_blt'), vl_cont_cobranca.cd_ccb, vl_codigo_barras, vl_lin_digitavel, vl_valor_boleto, vl_data_venc_boleto, 
            NOW(), vl_nosso_numero::numeric, st_cadastrado, vp_tipo_origem, vp_nsu_origem, 
            vl_nm_sacado, vl_cpfcnpj_sacado, vl_tarifa_cobranca.pc_mlt_tcb, vl_valor_multa,
            vl_tarifa_cobranca.pc_jrs_tcb, vl_valor_juros, vl_desc_instrucao, vl_desc_informacao,vl_dgt_nosso_numero);
end$$;


ALTER FUNCTION sc_cbr."gerar_boleto_OLD"(vp_contrato_cobranca numeric, vp_tipo_origem numeric, vp_nsu_origem numeric) OWNER TO scan;

--
-- TOC entry 7718 (class 0 OID 0)
-- Dependencies: 1225
-- Name: FUNCTION "gerar_boleto_OLD"(vp_contrato_cobranca numeric, vp_tipo_origem numeric, vp_nsu_origem numeric); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION "gerar_boleto_OLD"(vp_contrato_cobranca numeric, vp_tipo_origem numeric, vp_nsu_origem numeric) IS 'Rotina de geracao dos boletos';


--
-- TOC entry 1740 (class 1255 OID 1631296)
-- Name: gerar_boleto_cobranca_externa(); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_boleto_cobranca_externa() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin
  for rg in select tit.cd_tit,cce.cd_ccb
            from sc_cce.tbl_tit tit
              inner join sc_cce.tbl_cce cce on cce.cd_cce = tit.cd_cce
            where cd_blt is null
            loop
    perform sc_cbr.gerar_boleto(rg.cd_ccb, 8,rg.cd_tit);
  end loop;
end;$$;


ALTER FUNCTION sc_cbr.gerar_boleto_cobranca_externa() OWNER TO scan;

--
-- TOC entry 1229 (class 1255 OID 564215)
-- Name: gerar_boleto_fatura_cartao(); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_boleto_fatura_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin
  for rg in select fcr.cd_fcr as fatura
            from sc_fcr.tbl_fcr fcr
            where fcr.st_fcr = 1 
              and not exists (select 1
			   	      from sc_cbr.tbl_blt blt
				     where blt.tp_org_blt = 2
				       and blt.nr_nsu_org_blt = fcr.cd_fcr)

            loop
              
    perform sc_cbr.gerar_boleto(1, 2, rg.fatura);
    
  end loop;
end;$$;


ALTER FUNCTION sc_cbr.gerar_boleto_fatura_cartao() OWNER TO scan;

--
-- TOC entry 1215 (class 1255 OID 564216)
-- Name: gerar_boleto_fatura_cartao_inadimplente(); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_boleto_fatura_cartao_inadimplente() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin
  for rg in select fcr.cd_fcr as fatura
            from sc_opr.tbl_crt crt
              inner join sc_fcr.tbl_fcr fcr on fcr.cd_crt = crt.cd_crt
            where crt.fg_ind_crt = 'S'
              and fcr.st_fcr = 1
              and current_date - dt_ini_atr_crt > 3
              and not exists (select 1
			   	      from sc_cbr.tbl_blt blt
				     where blt.tp_org_blt = 2
				       and blt.nr_nsu_org_blt = fcr.cd_fcr) loop

    perform sc_cbr.gerar_boleto(1, 2, rg.fatura);
    
  end loop;
end;$$;


ALTER FUNCTION sc_cbr.gerar_boleto_fatura_cartao_inadimplente() OWNER TO scan;

--
-- TOC entry 1214 (class 1255 OID 564217)
-- Name: gerar_boleto_fatura_empresa(numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_boleto_fatura_empresa(vp_fatura numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg_fep  record;
begin

   for rg_fep in select fep.cd_fep
  		    from sc_fep.tbl_fep fep
		    where fep.cd_fep = coalesce(vp_fatura, fep.cd_fep)
		      and not exists (select 1
			   	      from sc_cbr.tbl_blt blt
				     where blt.tp_org_blt = 1
				       and blt.nr_nsu_org_blt = fep.cd_fep) loop

	perform sc_cbr.gerar_boleto(1, 1, rg_fep.cd_fep);
			
   end loop;
end;
$$;


ALTER FUNCTION sc_cbr.gerar_boleto_fatura_empresa(vp_fatura numeric) OWNER TO scan;

--
-- TOC entry 7719 (class 0 OID 0)
-- Dependencies: 1214
-- Name: FUNCTION gerar_boleto_fatura_empresa(vp_fatura numeric); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_boleto_fatura_empresa(vp_fatura numeric) IS 'Rotina que gera os boletos das faturas das empresas';


--
-- TOC entry 1216 (class 1255 OID 564218)
-- Name: gerar_boleto_fatura_empresa_por_data_vencimento(date); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_boleto_fatura_empresa_por_data_vencimento(vp_data_vencimento date DEFAULT ('now'::text)::date) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg_fep  record;
begin

   for rg_fep in select fep.cd_fep
  		    from sc_fep.tbl_fep fep
		    where fep.dt_vnc_fep = vp_data_vencimento
		      and not exists (select 1
			   	      from sc_cbr.tbl_blt blt
				     where blt.tp_org_blt = 1
				       and blt.nr_nsu_org_blt = fep.cd_fep) loop

	perform sc_cbr.gerar_boleto(1, 1, rg_fep.cd_fep);
			
   end loop;
end;
$$;


ALTER FUNCTION sc_cbr.gerar_boleto_fatura_empresa_por_data_vencimento(vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 7720 (class 0 OID 0)
-- Dependencies: 1216
-- Name: FUNCTION gerar_boleto_fatura_empresa_por_data_vencimento(vp_data_vencimento date); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_boleto_fatura_empresa_por_data_vencimento(vp_data_vencimento date) IS 'Rotina que gera os boletos das faturas das empresas por data vencimento';


--
-- TOC entry 1217 (class 1255 OID 564219)
-- Name: gerar_boleto_fatura_empresa_por_data_vencimento(numeric, date); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_boleto_fatura_empresa_por_data_vencimento(vp_contrato_cobranca numeric, vp_data_vencimento date DEFAULT ('now'::text)::date) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg_fep  record;
begin

   for rg_fep in select fep.cd_fep
  		    from sc_fep.tbl_fep fep
		    where fep.dt_vnc_fep = vp_data_vencimento
		      and not exists (select 1
			   	      from sc_cbr.tbl_blt blt
				     where blt.tp_org_blt = 1
				       and blt.nr_nsu_org_blt = fep.cd_fep) loop

	perform sc_cbr.gerar_boleto(vp_contrato_cobranca, 1, rg_fep.cd_fep);
			
   end loop;
end;
$$;


ALTER FUNCTION sc_cbr.gerar_boleto_fatura_empresa_por_data_vencimento(vp_contrato_cobranca numeric, vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 7721 (class 0 OID 0)
-- Dependencies: 1217
-- Name: FUNCTION gerar_boleto_fatura_empresa_por_data_vencimento(vp_contrato_cobranca numeric, vp_data_vencimento date); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_boleto_fatura_empresa_por_data_vencimento(vp_contrato_cobranca numeric, vp_data_vencimento date) IS 'Rotina que gera os boletos das faturas das empresas por data vencimento';


--
-- TOC entry 225 (class 1259 OID 564220)
-- Name: tbl_tcb; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_tcb (
    cd_tcb numeric(5,0) NOT NULL,
    pc_mlt_tcb numeric(5,2),
    pc_jrs_tcb numeric(5,2),
    pc_dsc_tcb numeric(5,2)
);


ALTER TABLE tbl_tcb OWNER TO scan;

--
-- TOC entry 7722 (class 0 OID 0)
-- Dependencies: 225
-- Name: TABLE tbl_tcb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON TABLE tbl_tcb IS 'Tabela de Tarifas de Contrato de Cobrança';


--
-- TOC entry 7723 (class 0 OID 0)
-- Dependencies: 225
-- Name: COLUMN tbl_tcb.cd_tcb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_tcb.cd_tcb IS 'Codigo do Tarifa';


--
-- TOC entry 7724 (class 0 OID 0)
-- Dependencies: 225
-- Name: COLUMN tbl_tcb.pc_mlt_tcb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_tcb.pc_mlt_tcb IS 'Percentual de Multa';


--
-- TOC entry 7725 (class 0 OID 0)
-- Dependencies: 225
-- Name: COLUMN tbl_tcb.pc_jrs_tcb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_tcb.pc_jrs_tcb IS 'Percentual de Juros';


--
-- TOC entry 7726 (class 0 OID 0)
-- Dependencies: 225
-- Name: COLUMN tbl_tcb.pc_dsc_tcb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_tcb.pc_dsc_tcb IS 'Percentual de Desconto';


--
-- TOC entry 1673 (class 1255 OID 564223)
-- Name: gerar_boleto_instrucao_informacao(numeric, numeric, numeric, tbl_tcb); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_boleto_instrucao_informacao(vp_valor_boleto numeric, vp_tipo_origem numeric, vp_nsu_origem numeric, vp_tarifa_cobranca tbl_tcb, OUT vr_valor_juros numeric, OUT vr_valor_multa numeric, OUT vr_desc_instrucao character varying, OUT vr_desc_informacao character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
declare

  /* CONSTANTES */
  tp_origem_empresa numeric := 1;
  tp_origem_cartao  numeric := 2;
  tp_origem_renegociacao  numeric := 3;
  tp_origem_boleto_avulso numeric := 4;
  tp_origem_boleto_parcela numeric := 5;
  tp_origem_boleto_avulso_cartao numeric := 6;

  vl_prc sc_cbr.tbl_prc%rowtype;
  
begin

  vr_valor_juros := null;
  vr_valor_multa := null;
    
  if vp_tipo_origem = tp_origem_empresa then

        vr_valor_juros := round((vp_valor_boleto * vp_tarifa_cobranca.pc_jrs_tcb / 100::numeric)/30, 2);
        vr_valor_multa := round(vp_valor_boleto * vp_tarifa_cobranca.pc_mlt_tcb / 100::numeric, 2);
	
        -- instrucoes
        vr_desc_instrucao := 'APÓS VENCIMENTO COBRAR MULTA DE R$ ' || trim(to_char(vr_valor_multa, '9G990D00')) || ' E MORA DE R$ ' || trim(to_char(vr_valor_juros, '9G990D00')) || ' POR DIA DE ATRASO.';
                
	-- informacoes gerais
	vr_desc_informacao := '\nNÃO RECEBER APÓS 30 DIAS DO VENCIMENTO.';

  elsif vp_tipo_origem = tp_origem_boleto_avulso then

        -- instrucoes
        vr_desc_instrucao := 'O pagamento deve ser INTEGRAL no Valor do Documento.';
                
	-- informacoes gerais
	vr_desc_informacao := '\nNÃO RECEBER APÓS O VENCIMENTO.';	
	

  elsif vp_tipo_origem = tp_origem_cartao  then

        -- instrucoes
        vr_desc_instrucao := 'Evite atrasos, pague o valor total da sua fatura até o vencimento quitando assim seus débitos.';
        vr_desc_instrucao := vr_desc_instrucao || '\n' || 'Os encargos referente ao(s) pagamento(s) após o vencimento da fatura serão inseridos na próxima fatura.';
                
	-- informacoes gerais
	vr_desc_informacao := '\nPreencher o valor pago, entre o mínimo e o total dessa fatura.';

  elsif vp_tipo_origem = tp_origem_renegociacao then -- tipo origem renegociacao
               
        -- instrucoes
        vr_desc_instrucao := 'Efetuando o pagamento deste boleto até o vencimento, sua renegociação será confirmada.';
        vr_desc_instrucao := vr_desc_instrucao || '\n' || 'O não pagamento deste boleto até o vencimento acarretará no cancelamento da renegociação.';
                
	-- informacoes gerais
	vr_desc_informacao := '\nNÃO RECEBER APÓS O VENCIMENTO.';
  
  elsif vp_tipo_origem = tp_origem_boleto_parcela then -- tipo origem boleto de parcela

        select *
          into vl_prc
        from sc_cbr.tbl_prc
        where cd_prc = vp_nsu_origem;
               
        -- instrucoes
        vr_desc_instrucao := 'Efetue o pagamento deste boleto até o vencimento e garanta as condições especiais concedidas no seu acordo.';
        vr_desc_instrucao := vr_desc_instrucao || '\n\nSr. Caixa receber até 10 dias após o vencimento sem cobrança de multa e mora(juros).';
                
	-- informacoes gerais
        if vl_prc.nr_prc = 0 then
	  vr_desc_informacao := '\n\n\n' || 'ENTRADA para confirmação de acordo.';	
        else
          vr_desc_informacao := '\n\n\n' || 'Parcela: ' || vl_prc.nr_prc || '/' || vl_prc.nr_ttl_prc;
        end if;

  elsif vp_tipo_origem = tp_origem_boleto_avulso_cartao then -- tipo origem boleto avulso cartao

    -- instrucoes
    vr_desc_instrucao := 'O pagamento deve ser INTEGRAL no Valor do Documento.';
                
    -- informacoes gerais
    vr_desc_informacao := '\nNÃO RECEBER APÓS O VENCIMENTO.';	

  end if;
   
end$_$;


ALTER FUNCTION sc_cbr.gerar_boleto_instrucao_informacao(vp_valor_boleto numeric, vp_tipo_origem numeric, vp_nsu_origem numeric, vp_tarifa_cobranca tbl_tcb, OUT vr_valor_juros numeric, OUT vr_valor_multa numeric, OUT vr_desc_instrucao character varying, OUT vr_desc_informacao character varying) OWNER TO scan;

--
-- TOC entry 7727 (class 0 OID 0)
-- Dependencies: 1673
-- Name: FUNCTION gerar_boleto_instrucao_informacao(vp_valor_boleto numeric, vp_tipo_origem numeric, vp_nsu_origem numeric, vp_tarifa_cobranca tbl_tcb, OUT vr_valor_juros numeric, OUT vr_valor_multa numeric, OUT vr_desc_instrucao character varying, OUT vr_desc_informacao character varying); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_boleto_instrucao_informacao(vp_valor_boleto numeric, vp_tipo_origem numeric, vp_nsu_origem numeric, vp_tarifa_cobranca tbl_tcb, OUT vr_valor_juros numeric, OUT vr_valor_multa numeric, OUT vr_desc_instrucao character varying, OUT vr_desc_informacao character varying) IS 'Rotina de geracao das instrucoes e informacoes boletos';


--
-- TOC entry 1227 (class 1255 OID 564224)
-- Name: gerar_boleto_instrucao_informacao_OLD(numeric, numeric, tbl_tcb); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION "gerar_boleto_instrucao_informacao_OLD"(vp_valor_boleto numeric, vp_tipo_origem numeric, vp_tarifa_cobranca tbl_tcb, OUT vr_valor_juros numeric, OUT vr_valor_multa numeric, OUT vr_desc_instrucao character varying, OUT vr_desc_informacao character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
declare

  /* CONSTANTES */
  tp_origem_empresa numeric := 1;
  tp_origem_cartao  numeric := 2;
  tp_origem_renegociacao  numeric := 3;
  tp_origem_boleto_avulso numeric := 4;
  
begin

  vr_valor_juros := null;
  vr_valor_multa := null;
    
  if vp_tipo_origem = tp_origem_empresa then

        vr_valor_juros := round((vp_valor_boleto * vp_tarifa_cobranca.pc_jrs_tcb / 100::numeric)/30, 2);
        vr_valor_multa := round(vp_valor_boleto * vp_tarifa_cobranca.pc_mlt_tcb / 100::numeric, 2);
	
        -- instrucoes
        vr_desc_instrucao := 'APÓS VENCIMENTO COBRAR MULTA DE R$ ' || trim(to_char(vr_valor_multa, '9G990D00')) || ' E MORA DE R$ ' || trim(to_char(vr_valor_juros, '9G990D00')) || ' POR DIA DE ATRASO.';
                
	-- informacoes gerais
	vr_desc_informacao := '\nNÃO RECEBER APÓS 30 DIAS DO VENCIMENTO.';

  elsif vp_tipo_origem = tp_origem_boleto_avulso then

        -- instrucoes
        vr_desc_instrucao := 'O pagamento deve ser INTEGRAL no Valor do Documento.';
                
	-- informacoes gerais
	vr_desc_informacao := '\nNÃO RECEBER APÓS 30 DIAS DA DATA DE EMISSÃO.';	
	

  elsif vp_tipo_origem = tp_origem_cartao  then

        -- instrucoes
        vr_desc_instrucao := 'Evite atrasos, pague o valor total da sua fatura até o vencimento quitando assim seus débitos.';
        vr_desc_instrucao := vr_desc_instrucao || '\n' || 'Os encargos referente ao(s) pagamento(s) após o vencimento da fatura serão inseridos na próxima fatura.';
                
	-- informacoes gerais
	vr_desc_informacao := '\nPreencher o valor pago, entre o mínimo e o total dessa fatura.';

  else -- tipo origem renegociacao
               
        -- instrucoes
        vr_desc_instrucao := 'Efetuando o pagamento deste boleto até o vencimento, sua renegociação será confirmada.';
        vr_desc_instrucao := vr_desc_instrucao || '\n' || 'O não pagamento deste boleto até o vencimento acarretará no cancelamento da renegociação.';
                
	-- informacoes gerais
	vr_desc_informacao := '\nNÃO RECEBER APÓS O VENCIMENTO.';  

  end if;
   
end$_$;


ALTER FUNCTION sc_cbr."gerar_boleto_instrucao_informacao_OLD"(vp_valor_boleto numeric, vp_tipo_origem numeric, vp_tarifa_cobranca tbl_tcb, OUT vr_valor_juros numeric, OUT vr_valor_multa numeric, OUT vr_desc_instrucao character varying, OUT vr_desc_informacao character varying) OWNER TO scan;

--
-- TOC entry 7728 (class 0 OID 0)
-- Dependencies: 1227
-- Name: FUNCTION "gerar_boleto_instrucao_informacao_OLD"(vp_valor_boleto numeric, vp_tipo_origem numeric, vp_tarifa_cobranca tbl_tcb, OUT vr_valor_juros numeric, OUT vr_valor_multa numeric, OUT vr_desc_instrucao character varying, OUT vr_desc_informacao character varying); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION "gerar_boleto_instrucao_informacao_OLD"(vp_valor_boleto numeric, vp_tipo_origem numeric, vp_tarifa_cobranca tbl_tcb, OUT vr_valor_juros numeric, OUT vr_valor_multa numeric, OUT vr_desc_instrucao character varying, OUT vr_desc_informacao character varying) IS 'Rotina de geracao das instrucoes e informacoes boletos';


--
-- TOC entry 1228 (class 1255 OID 564225)
-- Name: gerar_boleto_parcela_cartao(); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_boleto_parcela_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin
  for rg in select prc.cd_prc as parcela
            from sc_cbr.tbl_prc prc
            where prc.st_prc = 1 
              and not exists (select 1
			   	      from sc_cbr.tbl_blt blt
				     where blt.tp_org_blt = 5
				       and blt.nr_nsu_org_blt = prc.cd_prc)

            loop
              
    perform sc_cbr.gerar_boleto(1, 5, rg.parcela);
    
  end loop;
end;$$;


ALTER FUNCTION sc_cbr.gerar_boleto_parcela_cartao() OWNER TO scan;

--
-- TOC entry 1230 (class 1255 OID 564226)
-- Name: gerar_boleto_renegociacao_cartao(); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_boleto_renegociacao_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin
  for rg in select rnc.cd_rnc as renegociacao
            from sc_rnc.tbl_rnc rnc
            where rnc.st_rnc = 1
              and rnc.vl_ent_rnc > 0
              and not exists (select 1
			   	      from sc_cbr.tbl_blt blt
				     where blt.tp_org_blt = 3
				       and blt.nr_nsu_org_blt = rnc.cd_rnc)

            loop
              
    perform sc_cbr.gerar_boleto(1, 3, rg.renegociacao);
    
  end loop;
end;$$;


ALTER FUNCTION sc_cbr.gerar_boleto_renegociacao_cartao() OWNER TO scan;

--
-- TOC entry 226 (class 1259 OID 564227)
-- Name: tbl_ccb; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_ccb (
    cd_ccb numeric(10,0) NOT NULL,
    cd_cdt numeric(10,0) NOT NULL,
    cd_bnc numeric(5,0) NOT NULL,
    cd_tcb numeric(5,0) NOT NULL,
    cd_agn_ccb numeric(5,0) NOT NULL,
    nr_dgt_vrf_agn_ccb character varying(1),
    cd_cnt_ccb numeric(9,0) NOT NULL,
    nr_dgt_vrf_cnt_ccb character varying(2),
    fg_atv_ccb character varying(1),
    nr_cdt_ccb numeric(13,0) NOT NULL,
    tp_ccb numeric(2,0) NOT NULL,
    nr_car_ccb numeric(5,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_cnt numeric(10,0)
);


ALTER TABLE tbl_ccb OWNER TO scan;

--
-- TOC entry 7729 (class 0 OID 0)
-- Dependencies: 226
-- Name: TABLE tbl_ccb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON TABLE tbl_ccb IS 'Tabela de Contrato de Cobrança';


--
-- TOC entry 7730 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.cd_ccb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.cd_ccb IS 'Codigo do Contrato';


--
-- TOC entry 7731 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.cd_cdt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.cd_cdt IS 'Codigo do Cedente';


--
-- TOC entry 7732 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.cd_bnc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.cd_bnc IS 'Codigo do Banco';


--
-- TOC entry 7733 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.cd_tcb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.cd_tcb IS 'Codigo da tarifa de contrato de cobranca';


--
-- TOC entry 7734 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.cd_agn_ccb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.cd_agn_ccb IS 'Número da agência';


--
-- TOC entry 7735 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.nr_dgt_vrf_agn_ccb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.nr_dgt_vrf_agn_ccb IS 'Dígito Verificador da Agência';


--
-- TOC entry 7736 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.cd_cnt_ccb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.cd_cnt_ccb IS 'Número da Conta';


--
-- TOC entry 7737 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.nr_dgt_vrf_cnt_ccb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.nr_dgt_vrf_cnt_ccb IS 'Dígito Verificador da Conta';


--
-- TOC entry 7738 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.fg_atv_ccb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.fg_atv_ccb IS 'Flag de Ativo';


--
-- TOC entry 7739 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.nr_cdt_ccb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.nr_cdt_ccb IS 'Número do Cedente';


--
-- TOC entry 7740 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.tp_ccb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.tp_ccb IS 'Tipo de Cobrança(ver dominio)';


--
-- TOC entry 7741 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.nr_car_ccb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.nr_car_ccb IS 'Número da carteira de cobrança';


--
-- TOC entry 7742 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.cd_inc_usr; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 7743 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.dt_inc_usr; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 7744 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.cd_alt_usr; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 7745 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.dt_alt_usr; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 7746 (class 0 OID 0)
-- Dependencies: 226
-- Name: COLUMN tbl_ccb.cd_cnt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.cd_cnt IS 'Codigo da conta do sistema vinculada ao contrato';


--
-- TOC entry 1231 (class 1255 OID 564230)
-- Name: gerar_codigo_barras(tbl_ccb, numeric, numeric, numeric, date); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_codigo_barras(vp_contrato_cobranca tbl_ccb, vp_moeda numeric, vp_valor numeric, vp_codigo_documento numeric, vp_data_vencimento date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
   ct_banco_hsbc numeric := 399;
   ct_banco_bradesco numeric := 237;

   vl_retorno    	varchar;
begin
	
   if vp_contrato_cobranca.cd_bnc = ct_banco_hsbc then
     select sc_cbr.gerar_codigo_barras_hsbc(vp_contrato_cobranca.cd_bnc, vp_moeda, vp_valor, vp_contrato_cobranca.nr_cdt_ccb, vp_codigo_documento::text, vp_data_vencimento, 2)
	  into vl_retorno;
   end if;

   if vp_contrato_cobranca.cd_bnc = ct_banco_bradesco then
     select sc_cbr.gerar_codigo_barras_bradesco(vp_contrato_cobranca.cd_bnc, vp_moeda, vp_data_vencimento, vp_valor, vp_contrato_cobranca.cd_agn_ccb, vp_contrato_cobranca.nr_car_ccb, vp_codigo_documento, vp_contrato_cobranca.cd_cnt_ccb)
        into vl_retorno;
   end if;
   
   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr.gerar_codigo_barras(vp_contrato_cobranca tbl_ccb, vp_moeda numeric, vp_valor numeric, vp_codigo_documento numeric, vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 7747 (class 0 OID 0)
-- Dependencies: 1231
-- Name: FUNCTION gerar_codigo_barras(vp_contrato_cobranca tbl_ccb, vp_moeda numeric, vp_valor numeric, vp_codigo_documento numeric, vp_data_vencimento date); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_codigo_barras(vp_contrato_cobranca tbl_ccb, vp_moeda numeric, vp_valor numeric, vp_codigo_documento numeric, vp_data_vencimento date) IS 'Rotina que realiza os calculos para obter o código de barras do Boleto';


--
-- TOC entry 1232 (class 1255 OID 564231)
-- Name: gerar_codigo_barras_OLD(numeric, numeric, numeric, numeric, character varying, date, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION "gerar_codigo_barras_OLD"(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
   vl_retorno    	varchar;
   vl_banco		varchar;
   vl_numero_dac 	varchar;
   vl_dac		numeric;
   vl_fator_venc 	varchar;
   vl_valor		varchar;
   vl_cedente	 	varchar;
   vl_codigo_doc 	varchar;
   vl_venc_juliano  	varchar;
   vl_auxiliar   	numeric;
   vl_dt_base_juliano 	date;
   vl_ano        	numeric;
begin
	
   -- banco
   vl_banco := to_char(vp_banco, 'FM99099');
   -- fator vencimento
   select sc_cbr.calcula_fator_vencimento(vp_data_vencimento) into vl_fator_venc;
   -- data juliano
   select sc_cbr.calcula_data_formato_juliano(vp_data_vencimento) into vl_venc_juliano;
   -- valor do boleto
   if vp_data_vencimento is null then
     vl_valor := sc_arq.formatar_moeda(10, 0);
   else
     vl_valor := sc_arq.formatar_moeda(10, vp_valor);
   end if;
   -- codigo do cedente
   vl_cedente := sc_arq.preencher(7, vp_codigo_cedente, '0', 2);
   -- codigo do documento (sem os digitos e tipo verificador)
   vl_codigo_doc := sc_arq.preencher(13, vp_codigo_documento, '0', 2);
   -- dac
   vl_numero_dac := vl_banco || vp_moeda || vl_fator_venc || vl_valor || vl_cedente || vl_codigo_doc || vl_venc_juliano || vp_produto;
   select sc_pbl.modulo11_dac (vl_numero_dac) into vl_dac;

   vl_retorno := vl_banco || vp_moeda || vl_dac || vl_fator_venc || vl_valor || vl_cedente || vl_codigo_doc || vl_venc_juliano || vp_produto;
   
   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr."gerar_codigo_barras_OLD"(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric) OWNER TO scan;

--
-- TOC entry 7748 (class 0 OID 0)
-- Dependencies: 1232
-- Name: FUNCTION "gerar_codigo_barras_OLD"(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION "gerar_codigo_barras_OLD"(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric) IS 'Rotina que realiza os calculos para obter o código de barras do Boleto';


--
-- TOC entry 1233 (class 1255 OID 564232)
-- Name: gerar_codigo_barras_bradesco(numeric, numeric, date, numeric, numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_codigo_barras_bradesco(vp_banco numeric, vp_moeda numeric, vp_data_vencimento date, vp_valor numeric, vp_agencia numeric, vp_carteira numeric, vp_numero_documento numeric, vp_conta numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
   vl_retorno    	varchar;
   vl_banco		varchar;
   vl_dac		numeric;
   vl_fator_venc 	varchar;
   vl_valor		varchar;
   vl_agencia	 	varchar;
   vl_carteira 	        varchar;
   vl_nosso_numero	varchar;
   vl_conta      	varchar;
   vl_auxiliar   	varchar;
begin
	
   -- banco
   vl_banco := to_char(vp_banco, 'FM99099');
   -- fator vencimento
   select sc_cbr.calcula_fator_vencimento(vp_data_vencimento) into vl_fator_venc;
   -- valor do boleto
   if vp_data_vencimento is null then
     vl_valor := sc_arq.formatar_moeda(10, 0);
   else
     vl_valor := sc_arq.formatar_moeda(10, vp_valor);
   end if;
   -- agencia beneficiaria sem DV
   vl_agencia := sc_arq.preencher(4, vp_agencia, '0', 2);
   -- carteira
   vl_carteira := sc_arq.preencher(2, vp_carteira, '0', 2);
   -- nosso numero sem DV
   vl_nosso_numero := sc_arq.preencher(11, vp_numero_documento, '0', 2);
   -- conta beneficiaria sem DV
   vl_conta := sc_arq.preencher(7, vp_conta, '0', 2);
   
   
   -- digito verificador do codigo de barras
   vl_auxiliar := vl_banco || vp_moeda || vl_fator_venc || vl_valor || vl_agencia || vl_carteira || vl_nosso_numero || vl_conta || '0';
   select sc_pbl.modulo11_dac(vl_auxiliar) into vl_dac;

   vl_retorno := vl_banco || vp_moeda || vl_dac || vl_fator_venc || vl_valor || vl_agencia || vl_carteira || vl_nosso_numero || vl_conta || '0';
   
   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr.gerar_codigo_barras_bradesco(vp_banco numeric, vp_moeda numeric, vp_data_vencimento date, vp_valor numeric, vp_agencia numeric, vp_carteira numeric, vp_numero_documento numeric, vp_conta numeric) OWNER TO scan;

--
-- TOC entry 7749 (class 0 OID 0)
-- Dependencies: 1233
-- Name: FUNCTION gerar_codigo_barras_bradesco(vp_banco numeric, vp_moeda numeric, vp_data_vencimento date, vp_valor numeric, vp_agencia numeric, vp_carteira numeric, vp_numero_documento numeric, vp_conta numeric); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_codigo_barras_bradesco(vp_banco numeric, vp_moeda numeric, vp_data_vencimento date, vp_valor numeric, vp_agencia numeric, vp_carteira numeric, vp_numero_documento numeric, vp_conta numeric) IS 'Rotina que realiza os calculos para obter o código de barras do Boleto';


--
-- TOC entry 1236 (class 1255 OID 564233)
-- Name: gerar_codigo_barras_hsbc(numeric, numeric, numeric, numeric, character varying, date, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_codigo_barras_hsbc(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
   vl_retorno    	varchar;
   vl_banco		varchar;
   vl_numero_dac 	varchar;
   vl_dac		numeric;
   vl_fator_venc 	varchar;
   vl_valor		varchar;
   vl_cedente	 	varchar;
   vl_codigo_doc 	varchar;
   vl_venc_juliano  	varchar;
   vl_auxiliar   	numeric;
   vl_dt_base_juliano 	date;
   vl_ano        	numeric;
begin
	
   -- banco
   vl_banco := to_char(vp_banco, 'FM99099');
   -- fator vencimento
   select sc_cbr.calcula_fator_vencimento(vp_data_vencimento) into vl_fator_venc;
   -- data juliano
   select sc_cbr.calcula_data_formato_juliano(vp_data_vencimento) into vl_venc_juliano;
   -- valor do boleto
   if vp_data_vencimento is null then
     vl_valor := sc_arq.formatar_moeda(10, 0);
   else
     vl_valor := sc_arq.formatar_moeda(10, vp_valor);
   end if;
   -- codigo do cedente
   vl_cedente := sc_arq.preencher(7, vp_codigo_cedente, '0', 2);
   -- codigo do documento (sem os digitos e tipo verificador)
   vl_codigo_doc := sc_arq.preencher(13, vp_codigo_documento, '0', 2);
   -- dac
   vl_numero_dac := vl_banco || vp_moeda || vl_fator_venc || vl_valor || vl_cedente || vl_codigo_doc || vl_venc_juliano || vp_produto;
   select sc_pbl.modulo11_dac (vl_numero_dac) into vl_dac;

   vl_retorno := vl_banco || vp_moeda || vl_dac || vl_fator_venc || vl_valor || vl_cedente || vl_codigo_doc || vl_venc_juliano || vp_produto;
   
   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr.gerar_codigo_barras_hsbc(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric) OWNER TO scan;

--
-- TOC entry 7750 (class 0 OID 0)
-- Dependencies: 1236
-- Name: FUNCTION gerar_codigo_barras_hsbc(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_codigo_barras_hsbc(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric) IS 'Rotina que realiza os calculos para obter o código de barras do Boleto';


--
-- TOC entry 1742 (class 1255 OID 564234)
-- Name: gerar_dados_arquivo_remessa_cobranca_bradesco(tbl_ccb); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_dados_arquivo_remessa_cobranca_bradesco(vp_contrato_cobranca tbl_ccb) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

  tp_origem_empresa numeric := 1;
  tp_origem_cartao  numeric := 2;
  tp_origem_renegociacao  numeric := 3;
  tp_origem_boleto_avulso numeric := 4;
  tp_origem_boleto_parcela numeric := 5;

  rg record;
  vl_rg_tcb sc_cbr.tbl_tcb%rowtype;
  vl_existe numeric;
  vl_seq_remessa numeric;

  vl_seq_arq_dia numeric;
  vl_nm_arq varchar;

  vl_codigo_header numeric;
  vl_codigo_detalhe numeric;

  vl_identificador_empresa varchar;
  vl_controle_empresa varchar;
  vl_considerar_multa numeric;
  vl_identifica_pagador numeric;
  vl_inscricao_pagador varchar;

  vl_alinhar_esquerda numeric := 2;
  vl_alinhar_direita numeric := 1;

  ct_ocorrencia_remessa numeric := 1; 
  ct_ocorrencia_alteracao_vencimento numeric := 6; 
  
  vl_historico_anterior varchar;
  vl_historico_atual varchar;
  vl_ocorrencia numeric;
begin

    -- verificando se existem boletos para geracao de remessa
    select count(*)
      into vl_existe
    from sc_cbr.tbl_blt
    where cd_ccb = vp_contrato_cobranca.cd_ccb
      and st_blt in (1,3)
      and dt_vnc_blt >= current_date - 1; -- CADASTRADO OU PRORROGADO

    if vl_existe > 0 then

      -- obtendo a tabela de tarifas do contrato de cobranca bancaria
      select *
        into vl_rg_tcb
      from sc_cbr.tbl_tcb
       where cd_tcb = vp_contrato_cobranca.cd_tcb;  
      
      -- obtendo o sequencial de arquivo do dia
      select count(cd_hrb) + 1
        into vl_seq_arq_dia
        from sc_cbr.tbl_hrb
       where cd_ccb = vp_contrato_cobranca.cd_ccb
         and dt_grc_hrb::date = current_date;

      -- obtendo o nome do arquivo
      vl_nm_arq = 'COBN_' || to_char(current_date,'ddMM') || sc_arq.preencher(3, vp_contrato_cobranca.cd_ccb, '0', vl_alinhar_esquerda) || vl_seq_arq_dia || '.REM';

      -- obtendo o numero sequencial da remessa
      select coalesce(max(nr_seq_rem_hrb),0) + 1
        into vl_seq_remessa
        from sc_cbr.tbl_hrb
       where cd_ccb = vp_contrato_cobranca.cd_ccb;

      -- inserindo header de remessa de boleto
      vl_codigo_header := nextval('sc_cbr.sq_hrb');
      
      insert into sc_cbr.tbl_hrb (cd_hrb, cd_ccb, nm_arq_hrb, st_hrb, dt_grc_hrb, cd_inc_usr, dt_inc_usr, nr_seq_rem_hrb)
             values (vl_codigo_header, vp_contrato_cobranca.cd_ccb, vl_nm_arq, 1, now(), 1, now(), vl_seq_remessa);
               
      --obtendo os dados dos boletos nao processados
      for rg in
        select * 
        from sc_cbr.tbl_blt
          where cd_ccb = vp_contrato_cobranca.cd_ccb
        and st_blt in (1,3) -- CADASTRADO OU PRORROGADO
        and dt_vnc_blt >= current_date - 1
      loop

         vl_codigo_detalhe := nextval('sc_cbr.sq_drb');

         -- gerando o identificador da empresa
         vl_identificador_empresa := '0' || 
			              sc_arq.preencher(3, vp_contrato_cobranca.nr_car_ccb, '0', vl_alinhar_esquerda) ||	
                                      sc_arq.preencher(5, vp_contrato_cobranca.cd_agn_ccb, '0', vl_alinhar_esquerda) ||
                                      sc_arq.preencher(7, vp_contrato_cobranca.cd_cnt_ccb, '0', vl_alinhar_esquerda) ||
                                      sc_arq.preencher(1, vp_contrato_cobranca.nr_dgt_vrf_cnt_ccb, '0', vl_alinhar_esquerda);

         -- usado pela empresa para controle dno arquico de retorno 
         vl_controle_empresa := sc_arq.preencher(25, rg.cd_blt, ' ', vl_alinhar_direita);                             

         -- verificando se considera de juros e multa
         if vl_rg_tcb.pc_mlt_tcb > 0 then
           vl_considerar_multa := 2; --considera multa
         else
           vl_considerar_multa := 0; --nao considera multa
         end if;

         vl_identifica_pagador := rg.tp_pss_blt;

         -- verificando identificacao do pagador
         if vl_identifica_pagador is null then
         
		 if rg.tp_org_blt in (tp_origem_empresa,tp_origem_boleto_avulso) then
		   vl_identifica_pagador := 2; --CNPJ
		 else
		   vl_identifica_pagador := 1; --CPF
		 end if;
	end if;	 

         -- efetuando os controles
         vl_historico_anterior := 'BOLETO CADASTRADO';
         vl_historico_atual := 'BOLETO ENVIADO REMESSA';
         vl_ocorrencia := ct_ocorrencia_remessa;

         if rg.st_blt = 3 then
           vl_historico_anterior := 'BOLETO PRORROGADO';
           vl_ocorrencia := ct_ocorrencia_alteracao_vencimento;
         end if;
          
         insert into sc_cbr.tbl_drb (cd_drb, cd_hrb, idt_emp_ben_drb, nr_ctl_drb, multa_drb, prc_multa_drb, nr_doc_drb, dg_nr_doc_drb, 
                                     idt_ocr_drb, cd_doc_drb, dt_vnc_drb, vl_drb, dt_ems_drb, vl_mora_drb, idt_tpi_pgd_drb, nr_insc_pgd_drb, nm_pgd_drb,nr_cpf_cnpj_avl_drb,nm_avl_drb)
           values (vl_codigo_detalhe, vl_codigo_header, vl_identificador_empresa, vl_controle_empresa, vl_considerar_multa, vl_rg_tcb.pc_mlt_tcb, rg.cd_doc_blt, rg.dgt_cd_doc_blt,
                                     vl_ocorrencia, rg.nr_nsu_org_blt, rg.dt_vnc_blt, rg.vl_blt, rg.dt_grc_blt, coalesce(rg.vl_atr_blt,0), vl_identifica_pagador, rg.nr_cpfcnpj_sac_blt, substr(rg.nm_sac_blt,1,40),rg.nr_cpf_cnpj_avl_blt,rg.nm_avl_blt);

         -- inserindo ocorrencia de geracao de arquivo
         insert into sc_cbr.tbl_hadb values (nextval('sc_cbr.sq_hadb'),rg.cd_blt,7,vl_historico_anterior,vl_historico_atual,'INCLUSAO E(OU) ATUALIZACAO NO ARQUIVO DE REMESSA', 1, now());
  
         -- atualizando o boleto com o codigo do detalhe da remessa
         update sc_cbr.tbl_blt set st_blt = 2, cd_drb = vl_codigo_detalhe where cd_blt = rg.cd_blt;
 
      end loop;  

    end if;

    return vl_codigo_header;
end;$$;


ALTER FUNCTION sc_cbr.gerar_dados_arquivo_remessa_cobranca_bradesco(vp_contrato_cobranca tbl_ccb) OWNER TO scan;

--
-- TOC entry 7751 (class 0 OID 0)
-- Dependencies: 1742
-- Name: FUNCTION gerar_dados_arquivo_remessa_cobranca_bradesco(vp_contrato_cobranca tbl_ccb); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_dados_arquivo_remessa_cobranca_bradesco(vp_contrato_cobranca tbl_ccb) IS 'rotina responsavel por gerar os dados de uma remessa de cobranca para o bradesco';


--
-- TOC entry 1237 (class 1255 OID 564237)
-- Name: gerar_linha_digitavel(tbl_ccb, numeric, numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_linha_digitavel(vp_contrato_cobranca tbl_ccb, vp_moeda numeric, vp_valor numeric, vp_codigo_documento numeric, vp_data_vencimento date, vp_dac numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare

   ct_banco_hsbc numeric := 399;
   ct_banco_bradesco numeric := 237;

   vl_retorno    	varchar;
   
begin
   
   if vp_contrato_cobranca.cd_bnc = ct_banco_hsbc then
     select sc_cbr.gerar_linha_digitavel_hsbc(vp_contrato_cobranca.cd_bnc, vp_moeda, vp_valor, vp_contrato_cobranca.nr_cdt_ccb, vp_codigo_documento::text, vp_data_vencimento, 2, vp_dac)
       into vl_retorno;
   end if;

   if vp_contrato_cobranca.cd_bnc = ct_banco_bradesco then
     select sc_cbr.gerar_linha_digitavel_bradesco(vp_contrato_cobranca.cd_bnc, vp_moeda, vp_data_vencimento, vp_valor, vp_contrato_cobranca.cd_agn_ccb, vp_contrato_cobranca.nr_car_ccb, vp_codigo_documento, vp_contrato_cobranca.cd_cnt_ccb, vp_dac)
       into vl_retorno;
   end if;
   
   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr.gerar_linha_digitavel(vp_contrato_cobranca tbl_ccb, vp_moeda numeric, vp_valor numeric, vp_codigo_documento numeric, vp_data_vencimento date, vp_dac numeric) OWNER TO scan;

--
-- TOC entry 7752 (class 0 OID 0)
-- Dependencies: 1237
-- Name: FUNCTION gerar_linha_digitavel(vp_contrato_cobranca tbl_ccb, vp_moeda numeric, vp_valor numeric, vp_codigo_documento numeric, vp_data_vencimento date, vp_dac numeric); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_linha_digitavel(vp_contrato_cobranca tbl_ccb, vp_moeda numeric, vp_valor numeric, vp_codigo_documento numeric, vp_data_vencimento date, vp_dac numeric) IS 'Rotina que gera a linha digitavel do boleto';


--
-- TOC entry 1238 (class 1255 OID 564238)
-- Name: gerar_linha_digitavel_OLD(numeric, numeric, numeric, numeric, character varying, date, numeric, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION "gerar_linha_digitavel_OLD"(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric, vp_dac numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
   vl_retorno    	varchar;
   vl_banco		varchar;
   vl_venc_juliano	varchar;
   vl_fator_venc 	varchar;
   vl_valor		varchar;
   vl_cedente_1	 	varchar;
   vl_cedente_2	 	varchar;
   vl_digito_1		numeric;
   vl_digito_2		numeric;
   vl_digito_3		numeric;
   vl_campo_1		varchar;
   vl_campo_2		varchar;
   vl_campo_3		varchar;
   vl_campo_4		varchar;
   vl_campo_5		varchar;
   vl_codigo_documento  varchar;
   vl_codigo_documento_1 varchar;
   vl_codigo_documento_2 varchar;
begin
   
   -- campo 1: banco, moeda e parte do cedente(5 caracteres)
   vl_banco := to_char(vp_banco, 'FM99099');
   vl_cedente_1 := substr(vp_codigo_cedente::text, 1, 5);
   vl_campo_1 := vl_banco || vp_moeda || vl_cedente_1;
   
   select sc_pbl.modulo10(vl_campo_1) into vl_digito_1;
   vl_campo_1 := vl_campo_1 || vl_digito_1;
   vl_campo_1 := substr(vl_campo_1, 1, 5) || '.' || substr(vl_campo_1, 6, 5);
   
   -- campo 2: restante do cedente (2 caracteres), parte do codigo do documento (8 caracteres)
   vl_codigo_documento := sc_arq.preencher(13, vp_codigo_documento, '0', 2);
   vl_cedente_2 := substr(vp_codigo_cedente::text, 6, 2);
   vl_codigo_documento_1 := substr(vl_codigo_documento, 1, 8);
   vl_campo_2 := vl_cedente_2 || vl_codigo_documento_1;
   
   select sc_pbl.modulo10(vl_campo_2) into vl_digito_2;
   vl_campo_2 := vl_campo_2 || vl_digito_2;
   vl_campo_2 := substr(vl_campo_2, 1, 5) || '.' || substr(vl_campo_2, 6, 6);
   
   -- campo 3: restante do codigo documento (5 caracteres), data de vencimento no formato juliano, codigo do produto
   vl_codigo_documento_2 := substr(vl_codigo_documento, 9, 5);
   select sc_cbr.calcula_data_formato_juliano(vp_data_vencimento) into vl_venc_juliano;
   vl_campo_3 := vl_codigo_documento_2 || vl_venc_juliano || vp_produto;
   
   select sc_pbl.modulo10(vl_campo_3) into vl_digito_3;
   vl_campo_3 := vl_campo_3 || vl_digito_3;
   vl_campo_3 := substr(vl_campo_3, 1, 5) || '.' || substr(vl_campo_3, 6, 6);
   
   -- campo 4: somente o DAC(digito de auto conferencia obtido no codigo de barras)
   vl_campo_4 := vp_dac;
   
   -- campo 5: fator vencimento e o valor do documento
   select sc_cbr.calcula_fator_vencimento(vp_data_vencimento) into vl_fator_venc;
   
   if vp_data_vencimento is null then
     vl_valor := sc_arq.formatar_moeda(10, 0);
   else
     vl_valor := sc_arq.formatar_moeda(10, vp_valor);
   end if;
   
   vl_campo_5 := vl_fator_venc || vl_valor;

   vl_retorno := vl_campo_1 || vl_campo_2 || vl_campo_3 || vl_campo_4 || vl_campo_5;
   
   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr."gerar_linha_digitavel_OLD"(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric, vp_dac numeric) OWNER TO scan;

--
-- TOC entry 7753 (class 0 OID 0)
-- Dependencies: 1238
-- Name: FUNCTION "gerar_linha_digitavel_OLD"(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric, vp_dac numeric); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION "gerar_linha_digitavel_OLD"(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric, vp_dac numeric) IS 'Rotina que gera a linha digitavel do boleto';


--
-- TOC entry 1241 (class 1255 OID 564239)
-- Name: gerar_linha_digitavel_bradesco(numeric, numeric, date, numeric, numeric, numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_linha_digitavel_bradesco(vp_banco numeric, vp_moeda numeric, vp_data_vencimento date, vp_valor numeric, vp_agencia numeric, vp_carteira numeric, vp_numero_documento numeric, vp_conta numeric, vp_dac numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
   vl_retorno    	varchar;
   vl_banco		varchar;
   vl_dac		numeric;
   vl_fator_venc 	varchar;
   vl_valor		varchar;
   vl_agencia	 	varchar;
   vl_carteira 	        varchar;
   vl_carteira_1 	varchar;
   vl_carteira_2 	varchar;
   vl_nosso_numero	varchar;
   vl_nosso_numero_1	varchar;
   vl_nosso_numero_2	varchar;
   vl_conta      	varchar;
   vl_digito_1		numeric;
   vl_digito_2		numeric;
   vl_digito_3		numeric;
   vl_campo_1		varchar;
   vl_campo_2		varchar;
   vl_campo_3		varchar;
   vl_campo_4		varchar;
   vl_campo_5		varchar;
   
begin

   vl_carteira := sc_arq.preencher(2,vp_carteira,'0',2); -- preencher com zero a esquerda;

   -- campo 1: banco, moeda, 5 primeiras posicoes do campo livre(agencia + posicao 1 da carteira)  e DV
   vl_banco := to_char(vp_banco, 'FM99099');
   vl_agencia := sc_arq.preencher(4, vp_agencia, '0', 2);
   vl_carteira_1 := substr(vl_carteira, 1, 1);

   vl_campo_1 := vl_banco || vp_moeda || vl_agencia || vl_carteira_1;
   
   select sc_pbl.modulo10(vl_campo_1) into vl_digito_1;

   vl_campo_1 := vl_campo_1 || vl_digito_1;
   vl_campo_1 := substr(vl_campo_1, 1, 5) || '.' || substr(vl_campo_1, 6, 5);
   
   -- campo 2: posicoes 6 a 15 do campo livre (posicao 2 da carteira + 8 primeiros digitos do nosso numero)
   vl_carteira_2 := substr(vl_carteira, 2, 1);
   vl_nosso_numero := sc_arq.preencher(11, vp_numero_documento, '0', 2);
   vl_nosso_numero_1 := substr(vl_nosso_numero,1,9);

   vl_campo_2 := vl_carteira_2 || vl_nosso_numero_1;
   
   select sc_pbl.modulo10(vl_campo_2) into vl_digito_2;
   vl_campo_2 := vl_campo_2 || vl_digito_2;
   vl_campo_2 := substr(vl_campo_2, 1, 5) || '.' || substr(vl_campo_2, 6, 6);
   
   -- campo 3: posicoes 16 a 25 do campo livre (ultimas 2 posicoes do nosso numero + conta)
   vl_nosso_numero_2 := substr(vl_nosso_numero, 10, 2);
   vl_conta := sc_arq.preencher(7, vp_conta, '0', 2);

   vl_campo_3 := vl_nosso_numero_2 || vl_conta || '0';
   
   select sc_pbl.modulo10(vl_campo_3) into vl_digito_3;
   vl_campo_3 := vl_campo_3 || vl_digito_3;
   vl_campo_3 := substr(vl_campo_3, 1, 5) || '.' || substr(vl_campo_3, 6, 6);
   
   -- campo 4: somente o DAC(digito de auto conferencia obtido no codigo de barras)
   vl_campo_4 := vp_dac;
   
   -- campo 5: fator vencimento e o valor do documento
   select sc_cbr.calcula_fator_vencimento(vp_data_vencimento) into vl_fator_venc;
   
   if vp_data_vencimento is null then
     vl_valor := sc_arq.formatar_moeda(10, 0);
   else
     vl_valor := sc_arq.formatar_moeda(10, vp_valor);
   end if;
   
   vl_campo_5 := vl_fator_venc || vl_valor;

   vl_retorno := vl_campo_1 || vl_campo_2 || vl_campo_3 || vl_campo_4 || vl_campo_5;
   
   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr.gerar_linha_digitavel_bradesco(vp_banco numeric, vp_moeda numeric, vp_data_vencimento date, vp_valor numeric, vp_agencia numeric, vp_carteira numeric, vp_numero_documento numeric, vp_conta numeric, vp_dac numeric) OWNER TO scan;

--
-- TOC entry 7754 (class 0 OID 0)
-- Dependencies: 1241
-- Name: FUNCTION gerar_linha_digitavel_bradesco(vp_banco numeric, vp_moeda numeric, vp_data_vencimento date, vp_valor numeric, vp_agencia numeric, vp_carteira numeric, vp_numero_documento numeric, vp_conta numeric, vp_dac numeric); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_linha_digitavel_bradesco(vp_banco numeric, vp_moeda numeric, vp_data_vencimento date, vp_valor numeric, vp_agencia numeric, vp_carteira numeric, vp_numero_documento numeric, vp_conta numeric, vp_dac numeric) IS 'Rotina que gera a linha digitavel do boleto';


--
-- TOC entry 1242 (class 1255 OID 564240)
-- Name: gerar_linha_digitavel_hsbc(numeric, numeric, numeric, numeric, character varying, date, numeric, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_linha_digitavel_hsbc(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric, vp_dac numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
   vl_retorno    	varchar;
   vl_banco		varchar;
   vl_venc_juliano	varchar;
   vl_fator_venc 	varchar;
   vl_valor		varchar;
   vl_cedente_1	 	varchar;
   vl_cedente_2	 	varchar;
   vl_digito_1		numeric;
   vl_digito_2		numeric;
   vl_digito_3		numeric;
   vl_campo_1		varchar;
   vl_campo_2		varchar;
   vl_campo_3		varchar;
   vl_campo_4		varchar;
   vl_campo_5		varchar;
   vl_codigo_documento  varchar;
   vl_codigo_documento_1 varchar;
   vl_codigo_documento_2 varchar;
begin
   
   -- campo 1: banco, moeda e parte do cedente(5 caracteres)
   vl_banco := to_char(vp_banco, 'FM99099');
   vl_cedente_1 := substr(vp_codigo_cedente::text, 1, 5);
   vl_campo_1 := vl_banco || vp_moeda || vl_cedente_1;
   
   select sc_pbl.modulo10(vl_campo_1) into vl_digito_1;
   vl_campo_1 := vl_campo_1 || vl_digito_1;
   vl_campo_1 := substr(vl_campo_1, 1, 5) || '.' || substr(vl_campo_1, 6, 5);
   
   -- campo 2: restante do cedente (2 caracteres), parte do codigo do documento (8 caracteres)
   vl_codigo_documento := sc_arq.preencher(13, vp_codigo_documento, '0', 2);
   vl_cedente_2 := substr(vp_codigo_cedente::text, 6, 2);
   vl_codigo_documento_1 := substr(vl_codigo_documento, 1, 8);
   vl_campo_2 := vl_cedente_2 || vl_codigo_documento_1;
   
   select sc_pbl.modulo10(vl_campo_2) into vl_digito_2;
   vl_campo_2 := vl_campo_2 || vl_digito_2;
   vl_campo_2 := substr(vl_campo_2, 1, 5) || '.' || substr(vl_campo_2, 6, 6);
   
   -- campo 3: restante do codigo documento (5 caracteres), data de vencimento no formato juliano, codigo do produto
   vl_codigo_documento_2 := substr(vl_codigo_documento, 9, 5);
   select sc_cbr.calcula_data_formato_juliano(vp_data_vencimento) into vl_venc_juliano;
   vl_campo_3 := vl_codigo_documento_2 || vl_venc_juliano || vp_produto;
   
   select sc_pbl.modulo10(vl_campo_3) into vl_digito_3;
   vl_campo_3 := vl_campo_3 || vl_digito_3;
   vl_campo_3 := substr(vl_campo_3, 1, 5) || '.' || substr(vl_campo_3, 6, 6);
   
   -- campo 4: somente o DAC(digito de auto conferencia obtido no codigo de barras)
   vl_campo_4 := vp_dac;
   
   -- campo 5: fator vencimento e o valor do documento
   select sc_cbr.calcula_fator_vencimento(vp_data_vencimento) into vl_fator_venc;
   
   if vp_data_vencimento is null then
     vl_valor := sc_arq.formatar_moeda(10, 0);
   else
     vl_valor := sc_arq.formatar_moeda(10, vp_valor);
   end if;
   
   vl_campo_5 := vl_fator_venc || vl_valor;

   vl_retorno := vl_campo_1 || vl_campo_2 || vl_campo_3 || vl_campo_4 || vl_campo_5;
   
   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr.gerar_linha_digitavel_hsbc(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric, vp_dac numeric) OWNER TO scan;

--
-- TOC entry 7755 (class 0 OID 0)
-- Dependencies: 1242
-- Name: FUNCTION gerar_linha_digitavel_hsbc(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric, vp_dac numeric); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_linha_digitavel_hsbc(vp_banco numeric, vp_moeda numeric, vp_valor numeric, vp_codigo_cedente numeric, vp_codigo_documento character varying, vp_data_vencimento date, vp_produto numeric, vp_dac numeric) IS 'Rotina que gera a linha digitavel do boleto';


--
-- TOC entry 1243 (class 1255 OID 564241)
-- Name: gerar_nosso_numero_OLD(numeric, numeric, date); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION "gerar_nosso_numero_OLD"(vp_codigo_sacado numeric, vp_codigo_cedente numeric, vp_data_vencimento date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
   vl_digito_1   numeric;
   vl_digito_2   numeric;
   vl_digito_3   numeric;
   vl_soma       bigint;
   vl_data	 varchar(6);
   vl_data_numero numeric(20,0);
   vl_retorno    varchar(16) := '';
begin

   -- o nosso número é formado pelo codigo do sacado mais 3 digitos pre calculos
   vl_retorno := vp_codigo_sacado;
  
   -- o primeiro digito é obtido através do modulo 11
   select sc_pbl.modulo11(vp_codigo_sacado) into vl_digito_1;

   -- o segundo digito é tipo identificador do boleto (4 -> boletos com vencimentos, 5 -> boletos sem vencimentos)
   if vp_data_vencimento is not null then
      vl_digito_2 := 4;

      select --to_number(
	  extract(day from vp_data_vencimento) -- dia
	  || to_char(extract(month from vp_data_vencimento), 'FM909') -- mes
	  || substr(extract(year from vp_data_vencimento) || '', 3) --, '99999D9') -- ano
       into vl_data_numero;
   else
      vl_digito_2 := 5;
      vl_data_numero := 0;
   end if;

   -- o terceiro digito é obtido através do modulo 11 passando como parametro de entrada o numero do sacado com o 1 e 2 digito obtidos
   vl_retorno := vl_retorno || vl_digito_1 || vl_digito_2;
          
   vl_soma := to_number(vl_retorno, '999999999999999D9') + vp_codigo_cedente + vl_data_numero;

   select sc_pbl.modulo11(vl_soma) into vl_digito_3;

   vl_retorno := vl_retorno || vl_digito_3;

   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr."gerar_nosso_numero_OLD"(vp_codigo_sacado numeric, vp_codigo_cedente numeric, vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 7756 (class 0 OID 0)
-- Dependencies: 1243
-- Name: FUNCTION "gerar_nosso_numero_OLD"(vp_codigo_sacado numeric, vp_codigo_cedente numeric, vp_data_vencimento date); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION "gerar_nosso_numero_OLD"(vp_codigo_sacado numeric, vp_codigo_cedente numeric, vp_data_vencimento date) IS 'Rotina que realiza os calculos para obter o Nosso Numero do Boleto';


--
-- TOC entry 1244 (class 1255 OID 564242)
-- Name: gerar_nosso_numero_bradesco(numeric, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_nosso_numero_bradesco(vl_codigo_documento numeric, vp_numero_caretira numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
   vl_sequencial varchar(11) := '';
   vl_digito_1   varchar(1) := '';
   vl_retorno    varchar(16) := '';
begin

   -- sequencial
   vl_sequencial := to_char(vl_codigo_documento,'FM00000000000'); 

   -- o nosso número é formado pelo numero da carteira a esquedar + sequencial + digito modulo 11 base 7
   vl_retorno := vp_numero_caretira || vl_sequencial;
  
   -- o primeiro digito é obtido através do modulo 11
   select sc_pbl.modulo11_bradesco(vl_retorno::numeric) into vl_digito_1;
          
   vl_retorno := to_number(vl_sequencial, '999999999999999D9') || vl_digito_1;

   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr.gerar_nosso_numero_bradesco(vl_codigo_documento numeric, vp_numero_caretira numeric) OWNER TO scan;

--
-- TOC entry 7757 (class 0 OID 0)
-- Dependencies: 1244
-- Name: FUNCTION gerar_nosso_numero_bradesco(vl_codigo_documento numeric, vp_numero_caretira numeric); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_nosso_numero_bradesco(vl_codigo_documento numeric, vp_numero_caretira numeric) IS 'Rotina que realiza os calculos para obter o Nosso Numero do Boleto Cobranca Bradesco';


--
-- TOC entry 1246 (class 1255 OID 564243)
-- Name: gerar_nosso_numero_hsbc(numeric, numeric, date); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION gerar_nosso_numero_hsbc(vp_codigo_sacado numeric, vp_codigo_cedente numeric, vp_data_vencimento date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
   vl_digito_1   numeric;
   vl_digito_2   numeric;
   vl_digito_3   numeric;
   vl_soma       bigint;
   vl_data	 varchar(6);
   vl_data_numero numeric(20,0);
   vl_retorno    varchar(16) := '';
begin

   -- o nosso número é formado pelo codigo do sacado mais 3 digitos pre calculos
   vl_retorno := vp_codigo_sacado;
  
   -- o primeiro digito é obtido através do modulo 11
   select sc_pbl.modulo11(vp_codigo_sacado) into vl_digito_1;

   -- o segundo digito é tipo identificador do boleto (4 -> boletos com vencimentos, 5 -> boletos sem vencimentos)
   if vp_data_vencimento is not null then
      vl_digito_2 := 4;

      select --to_number(
	  extract(day from vp_data_vencimento) -- dia
	  || to_char(extract(month from vp_data_vencimento), 'FM909') -- mes
	  || substr(extract(year from vp_data_vencimento) || '', 3) --, '99999D9') -- ano
       into vl_data_numero;
   else
      vl_digito_2 := 5;
      vl_data_numero := 0;
   end if;

   -- o terceiro digito é obtido através do modulo 11 passando como parametro de entrada o numero do sacado com o 1 e 2 digito obtidos
   vl_retorno := vl_retorno || vl_digito_1 || vl_digito_2;
          
   vl_soma := to_number(vl_retorno, '999999999999999D9') + vp_codigo_cedente + vl_data_numero;

   select sc_pbl.modulo11(vl_soma) into vl_digito_3;

   vl_retorno := vl_retorno || vl_digito_3;

   return vl_retorno;
end
$$;


ALTER FUNCTION sc_cbr.gerar_nosso_numero_hsbc(vp_codigo_sacado numeric, vp_codigo_cedente numeric, vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 7758 (class 0 OID 0)
-- Dependencies: 1246
-- Name: FUNCTION gerar_nosso_numero_hsbc(vp_codigo_sacado numeric, vp_codigo_cedente numeric, vp_data_vencimento date); Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON FUNCTION gerar_nosso_numero_hsbc(vp_codigo_sacado numeric, vp_codigo_cedente numeric, vp_data_vencimento date) IS 'Rotina que realiza os calculos para obter o Nosso Numero do Boleto';


--
-- TOC entry 1784 (class 1255 OID 1078550)
-- Name: lancar_baixa_boleto_arquivo_prepago(numeric, numeric, numeric, numeric, numeric, timestamp without time zone, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION lancar_baixa_boleto_arquivo_prepago(OUT vp_tipo_lancamento numeric, vp_valor numeric, vp_cod_arquivo numeric, vp_cod_lanc_ctpd numeric, vp_cod_boleto numeric, vp_cod_usuario numeric, vp_data_pagamento timestamp without time zone, vp_conta_origem numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  
  TP_LCN_RECEBIMENTO_RECURSOS   sc_cnt.tbl_tlc.cd_tlc%type := 1453;
  CD_SST_SISTEMA_BAIXA_BOLETO   sc_cnt.tbl_sst.cd_sst%type := 13;
  
  vl_grupo_empresarial 		numeric;
  vl_conta_grupo_empresarial 	numeric;
  vl_conta_empresa              numeric;
  vl_empresa			numeric;
  vl_contrato			numeric;
  vl_existe 			numeric := 0;
  vl_valor_boleto	        numeric := 0;
  vl_data_referencia 		sc_fin.tbl_rrc.dt_ref_rrc%type;
  vl_data_prevista_liberacao 	sc_fin.tbl_rrc.dt_ref_rrc%type;
  vl_nr_lancamento 		sc_cnt.tbl_lcn.cd_lcn%type;
  vl_tarifa_deposito            numeric := 0; 
  
BEGIN

    vp_tipo_lancamento := TP_LCN_RECEBIMENTO_RECURSOS;
    
    -- capturando os dados da empresa para cadastrar o recebimento
     select ctr.cd_cnt, ctr.cd_emp, ctr.cd_ctr, (tfe.vl_reg_env_tfe + coalesce(tfe.vl_trf_tfe,0)),coalesce(tfe.vl_trf_tfe,0)
       into vl_conta_empresa, vl_empresa, vl_contrato, vl_valor_boleto, vl_tarifa_deposito
     from sc_adp.tbl_hfe hfe
        inner join sc_adp.tbl_tfe tfe on tfe.cd_hfe = hfe.cd_hfe
	inner join sc_cad.tbl_emp emp on emp.cd_emp = hfe.cd_emp
	inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = hfe.cd_ctr
     where hfe.cd_hfe = vp_cod_arquivo;

     -- verificando se o valor pago foi igual ou superior ao valor do boleto, caso contrário, não irá fazer nenhum lançamento nem marcar o boleto como baixado
     if vp_valor >= vl_valor_boleto then

       -- contabilizando o recebimento de recurso na conta do grupo empresarial
       perform  sc_cnt.lancar_movimento (vl_nr_lancamento,
                                    vp_cod_lanc_ctpd,
                                    vp_tipo_lancamento,
                                    vl_conta_empresa,
                                    'C',
                                    vp_valor,
                                    now()::timestamp,
                                    vp_cod_usuario,
                                    null,
                                    'Credito referente ao boleto do Arquivo de Depósito NR: ' || vp_cod_arquivo::varchar,
                                    CD_SST_SISTEMA_BAIXA_BOLETO,
                                    vp_cod_boleto
                                    );


      -- bloqueando o valor do boleto de acordo com a distribuição realizada                                
      select count(*) 
        into vl_existe
      from sc_cnt.tbl_tbc_cnt 
      where cd_cnt = vl_conta_empresa
        and cd_tbc = 8; -- tipo de bloqueio recebimento de recursos

  

      if vl_existe > 0 then
        update sc_cnt.tbl_tbc_cnt set vl_blq_tbc_cnt = COALESCE(vl_blq_tbc_cnt,0) + vp_valor where cd_cnt = vl_conta_empresa and cd_tbc = 8;
      else
        insert into sc_cnt.tbl_tbc_cnt(cd_tbc_cnt, cd_tbc, cd_cnt, vl_blq_tbc_cnt, fg_atv_tbc_cnt, cd_inc_usr, dt_inc_usr)
		    values (nextval('sc_cnt.sq_tbc_cnt'), 8, vl_conta_empresa, vp_valor, 'S', 1, now());
      end if;
    end if;
END;
$$;


ALTER FUNCTION sc_cbr.lancar_baixa_boleto_arquivo_prepago(OUT vp_tipo_lancamento numeric, vp_valor numeric, vp_cod_arquivo numeric, vp_cod_lanc_ctpd numeric, vp_cod_boleto numeric, vp_cod_usuario numeric, vp_data_pagamento timestamp without time zone, vp_conta_origem numeric) OWNER TO scan;

--
-- TOC entry 1497 (class 1255 OID 838235)
-- Name: lancar_baixa_boleto_avulso_cartao(numeric, numeric, numeric, numeric, numeric, timestamp without time zone, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION lancar_baixa_boleto_avulso_cartao(OUT vp_tipo_lancamento numeric, vp_valor numeric, vp_cod_boleto_avulso numeric, vp_cod_lanc_ctpd numeric, vp_cod_boleto numeric, vp_cod_usuario numeric, vp_data_pagamento timestamp without time zone, vp_conta_origem numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  
  CD_TPC_BOLETO_BANCARIO sc_fcr.tbl_tpc.cd_tpc%type := 3;
  
  vl_cod_cartao sc_opr.tbl_crt.cd_crt%type;
  vl_cnt_prioridade_1 sc_cnt.tbl_cnt.cd_cnt%type;
  
  vl_cod_lancamento sc_cnt.tbl_lcn.cd_lcn%type;
  
  CD_SST_SISTEMA_BAIXA_BOLETO sc_cnt.tbl_sst.cd_sst%type := 13;

  CD_TLC_TRANSF_BAIXA_BOLETO_AVULSO_CARTAO sc_cnt.tbl_tlc.cd_tlc%type := 1380;
  
BEGIN

    vp_tipo_lancamento := CD_TLC_TRANSF_BAIXA_BOLETO_AVULSO_CARTAO;
     
    select bac.cd_crt
    into vl_cod_cartao
    from sc_cbr.tbl_bac bac
    where bac.cd_bac = vp_cod_boleto_avulso;

    -- Obtendo a conta de prioridade 1 do cartao
    select cnt_crt.cd_cnt
    into vl_cnt_prioridade_1
    from sc_opr.tbl_cnt_crt cnt_crt
    where cnt_crt.cd_crt = vl_cod_cartao
      and cnt_crt.prp_cnt_crt = 1;
    
      
    perform sc_cnt.lancar_movimento(vl_cod_lancamento,
                                    vp_cod_lanc_ctpd,
                                    vp_tipo_lancamento,
                                    vl_cnt_prioridade_1,
                                    'C',
                                    vp_valor,
                                    now()::timestamp,
                                    vp_cod_usuario,
                                    null,
                                    'Baixa referente ao boleto avulso cartao nr. '||vp_cod_boleto,
                                    CD_SST_SISTEMA_BAIXA_BOLETO,
                                    vp_cod_boleto);
                                    
    perform sc_fcr.efetuar_baixa_cartao(vl_cod_cartao,
                                        null,
                                        CD_TPC_BOLETO_BANCARIO,
                                        vp_data_pagamento,
                                        vp_cod_usuario,
                                        vp_conta_origem);


   update sc_cbr.tbl_bac set st_bac = 2 where cd_bac = vp_cod_boleto_avulso;                                     

END;
$$;


ALTER FUNCTION sc_cbr.lancar_baixa_boleto_avulso_cartao(OUT vp_tipo_lancamento numeric, vp_valor numeric, vp_cod_boleto_avulso numeric, vp_cod_lanc_ctpd numeric, vp_cod_boleto numeric, vp_cod_usuario numeric, vp_data_pagamento timestamp without time zone, vp_conta_origem numeric) OWNER TO scan;

--
-- TOC entry 1840 (class 1255 OID 1631392)
-- Name: lancar_baixa_boleto_cobranca_externa(numeric, numeric, numeric, numeric, numeric, timestamp without time zone, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION lancar_baixa_boleto_cobranca_externa(OUT vp_tipo_lancamento numeric, vp_valor numeric, vp_cod_titulo numeric, vp_cod_lanc_ctpd numeric, vp_cod_boleto numeric, vp_cod_usuario numeric, vp_data_pagamento timestamp without time zone, vp_conta_origem numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  
  TP_LCN_RECEB_TIT_COBRANCA   sc_cnt.tbl_tlc.cd_tlc%type := 1456;
  CD_SST_SISTEMA_BAIXA_BOLETO   sc_cnt.tbl_sst.cd_sst%type := 13;
  
  vl_conta_credito              numeric;
  vl_valor_titulo	        numeric := 0;
  vl_nr_lancamento 		sc_cnt.tbl_lcn.cd_lcn%type;
  vl_nosso_numero               numeric;
  vl_valor_pagamento            numeric;

  vl_situacao_titulo numeric;
  
BEGIN

    vp_tipo_lancamento := TP_LCN_RECEB_TIT_COBRANCA;

    select cce.cd_cnt, tit.vl_tit, tit.vl_pgt_tit, tit.ns_nmr_tit, tit.st_tit
    into vl_conta_credito, vl_valor_titulo, vl_valor_pagamento, vl_nosso_numero , vl_situacao_titulo
    from sc_cce.tbl_tit tit
      inner join sc_cce.tbl_cce cce on cce.cd_cce = tit.cd_cce
    where tit.cd_tit = vp_cod_titulo;  

    if vl_situacao_titulo = 3 then
       raise exception 'UM TITULO CANCELADO NAO PODE SOFRER BAIXAS';
    end if;
    
       perform  sc_cnt.lancar_movimento (vl_nr_lancamento,
                                    vp_cod_lanc_ctpd,
                                    vp_tipo_lancamento,
                                    vl_conta_credito,
                                    'C',
                                    vp_valor,
                                    now()::timestamp,
                                    vp_cod_usuario,
                                    null,
                                    'Credito referente ao Título de Cobranca. Nosso Numero: ' || vl_nosso_numero::varchar,
                                    CD_SST_SISTEMA_BAIXA_BOLETO,
                                    vp_cod_boleto
                                    );

     if vp_valor >= vl_valor_titulo - coalesce(vl_valor_pagamento,0) then

         update sc_cce.tbl_tit 
            set vl_pgt_tit = coalesce(vl_pgt_tit,0) + vp_valor,
                st_tit = 2,
                dt_rcb_tit = now(),
                dt_pgt_tit = vp_data_pagamento
         where cd_tit = vp_cod_titulo;       
    else

         update sc_cce.tbl_tit 
            set vl_pgt_tit = coalesce(vl_pgt_tit,0) + vp_valor,
                dt_rcb_tit = now(),
                dt_pgt_tit = vp_data_pagamento
         where cd_tit = vp_cod_titulo;       

    end if;
END;
$$;


ALTER FUNCTION sc_cbr.lancar_baixa_boleto_cobranca_externa(OUT vp_tipo_lancamento numeric, vp_valor numeric, vp_cod_titulo numeric, vp_cod_lanc_ctpd numeric, vp_cod_boleto numeric, vp_cod_usuario numeric, vp_data_pagamento timestamp without time zone, vp_conta_origem numeric) OWNER TO scan;

--
-- TOC entry 1247 (class 1255 OID 564244)
-- Name: lancar_baixa_fatura_cartao(numeric, numeric, numeric, numeric, numeric, timestamp without time zone, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION lancar_baixa_fatura_cartao(OUT vp_tipo_lancamento numeric, vp_valor numeric, vp_cod_fatura numeric, vp_cod_lanc_ctpd numeric, vp_cod_boleto numeric, vp_cod_usuario numeric, vp_data_pagamento timestamp without time zone, vp_conta_origem numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  
  CD_TPC_BOLETO_BANCARIO sc_fcr.tbl_tpc.cd_tpc%type := 3;
  
  vl_cod_cartao sc_opr.tbl_crt.cd_crt%type;
  vl_cnt_prioridade_1 sc_cnt.tbl_cnt.cd_cnt%type;
  
  vl_cod_lancamento sc_cnt.tbl_lcn.cd_lcn%type;
  
  CD_SST_SISTEMA_BAIXA_BOLETO sc_cnt.tbl_sst.cd_sst%type := 13;

  CD_TLC_TRANSF_BAIXA_FATURA_CARTAO sc_cnt.tbl_tlc.cd_tlc%type := 141;
  
BEGIN

    select tpc.cd_tlc
    into vp_tipo_lancamento
    from sc_fcr.tbl_tpc tpc
    where tpc.cd_tpc = CD_TPC_BOLETO_BANCARIO;
     
    select fcr.cd_crt
    into vl_cod_cartao
    from sc_fcr.tbl_fcr fcr
    where fcr.cd_fcr = vp_cod_fatura;
    

    -- Obtendo a conta de prioridade 1 do cartao
    select cnt_crt.cd_cnt
    into vl_cnt_prioridade_1
    from sc_opr.tbl_cnt_crt cnt_crt
    where cnt_crt.cd_crt = vl_cod_cartao
      and cnt_crt.prp_cnt_crt = 1;
    
      
    perform sc_cnt.lancar_movimento(vl_cod_lancamento,
                                    vp_cod_lanc_ctpd,
                                    vp_tipo_lancamento,
                                    vl_cnt_prioridade_1,
                                    'C',
                                    vp_valor,
                                    now()::timestamp,
                                    vp_cod_usuario,
                                    null,
                                    'Baixa referente ao boleto nr. '||vp_cod_boleto,
                                    CD_SST_SISTEMA_BAIXA_BOLETO,
                                    vp_cod_boleto);
                                    
    perform sc_fcr.efetuar_baixa_cartao(vl_cod_cartao,
                                        vp_valor,
                                        CD_TPC_BOLETO_BANCARIO,
                                        vp_data_pagamento,
                                        vp_cod_usuario,
                                        vp_conta_origem);

END;
$$;


ALTER FUNCTION sc_cbr.lancar_baixa_fatura_cartao(OUT vp_tipo_lancamento numeric, vp_valor numeric, vp_cod_fatura numeric, vp_cod_lanc_ctpd numeric, vp_cod_boleto numeric, vp_cod_usuario numeric, vp_data_pagamento timestamp without time zone, vp_conta_origem numeric) OWNER TO scan;

--
-- TOC entry 1495 (class 1255 OID 564245)
-- Name: lancar_baixa_fatura_empresa(numeric, numeric, numeric, numeric, numeric, timestamp without time zone, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION lancar_baixa_fatura_empresa(OUT vp_tipo_lancamento numeric, vp_valor numeric, vp_cod_fatura numeric, vp_cod_lanc_ctpd numeric, vp_cod_boleto numeric, vp_cod_usuario numeric, vp_data_pagamento timestamp without time zone, vp_conta_origem numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE

  CD_TPE_BOLETO_BANCARIO sc_fep.tbl_tpe.cd_tpe%type := 4;
  CD_SST_SISTEMA_BAIXA_BOLETO sc_cnt.tbl_sst.cd_sst%type := 13;
  
  vl_cod_fatura sc_fep.tbl_fep.cd_fep%type;
  vl_cod_conta_empresa sc_cnt.tbl_cnt.cd_cnt%type;
  
  vl_nr_lancamento sc_cnt.tbl_lcn.cd_lcn%type;
  
  CD_TLC_TRANSF_BAIXA_FATURA_EMPRESA sc_cnt.tbl_tlc.cd_tlc%type := 98;

  CT_CONTA_DEPOSITO_NAO_IDENTIFICADO constant integer := 6376;
  CT_TP_LANC_DEPOSITO_NAO_IDENTIFICADO constant integer := 101;
BEGIN

  vp_tipo_lancamento := CD_TLC_TRANSF_BAIXA_FATURA_EMPRESA;

  select ctr.cd_cnt
  into vl_cod_conta_empresa
  from sc_fep.tbl_fep fep
    inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = fep.cd_ctr
  where fep.cd_fep = vp_cod_fatura;

  raise notice 'código da fatura de empresa: %, código da conta da empresa: %', vp_cod_fatura, vl_cod_conta_empresa;
  
  if  vl_cod_conta_empresa is not null then
    perform  sc_cnt.lancar_movimento (vl_nr_lancamento,
                                    vp_cod_lanc_ctpd,
                                    vp_tipo_lancamento,
                                    vl_cod_conta_empresa,
                                    'C',
                                    vp_valor,
                                    now()::timestamp,
                                    vp_cod_usuario,
                                    null,
                                    'Baixa referente ao boleto nr. ' || vp_cod_boleto::varchar,
                                    CD_SST_SISTEMA_BAIXA_BOLETO,
                                    vp_cod_boleto
                                    );
    
    perform sc_fep.baixar_fatura_empresa(vp_cod_fatura,
                                       vp_valor,
                                       CD_TPE_BOLETO_BANCARIO,
                                       vp_data_pagamento,
                                       vp_cod_usuario,
                                       vp_conta_origem);
  else
    perform  sc_cnt.lancar_movimento (vl_nr_lancamento,
                                      vp_cod_lanc_ctpd,
                                      CT_TP_LANC_DEPOSITO_NAO_IDENTIFICADO,
                                      CT_CONTA_DEPOSITO_NAO_IDENTIFICADO,
                                      'C',
                                      vp_valor,
                                      now()::timestamp,
                                      vp_cod_usuario,
                                      null,
                                      'Baixa não identificada referente ao boleto nr. ' || vp_cod_boleto::varchar || '. Fatura empresa: ' || vp_cod_fatura::varchar,
                                      CD_SST_SISTEMA_BAIXA_BOLETO,
                                      vp_cod_boleto
                                    );
  end if;
END;
$$;


ALTER FUNCTION sc_cbr.lancar_baixa_fatura_empresa(OUT vp_tipo_lancamento numeric, vp_valor numeric, vp_cod_fatura numeric, vp_cod_lanc_ctpd numeric, vp_cod_boleto numeric, vp_cod_usuario numeric, vp_data_pagamento timestamp without time zone, vp_conta_origem numeric) OWNER TO scan;

--
-- TOC entry 1249 (class 1255 OID 564246)
-- Name: lancar_boleto_avulso_empresa(numeric, numeric, numeric, numeric, numeric, timestamp without time zone, numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION lancar_boleto_avulso_empresa(OUT vp_tipo_lancamento numeric, vp_valor numeric, vp_cod_boleto_avulso numeric, vp_cod_lanc_ctpd numeric, vp_cod_boleto numeric, vp_cod_usuario numeric, vp_data_pagamento timestamp without time zone, vp_conta_origem numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  
  TP_LCN_RECEBIMENTO_RECURSOS   sc_cnt.tbl_tlc.cd_tlc%type := 1;
  TP_LCN_DISTRIBUICAO_RECURSOS  sc_cnt.tbl_tlc.cd_tlc%type := 132;
  TP_RECEBIMENTO_RECURSOS	sc_fin.tbl_rrc.cd_trc%type := 3;
  ST_RECEB_RECURSOS_CADASTRADA	sc_fin.tbl_rrc.st_rrc%type := 1;
  ST_BOLETO_AVULSO_BAIXADO	sc_fin.tbl_bla.st_bla%type := 2;
  CD_SST_SISTEMA_BAIXA_BOLETO   sc_cnt.tbl_sst.cd_sst%type := 13;
  CD_SST_SISTEMA_DIST_RECURSOS  sc_cnt.tbl_sst.cd_sst%type := 14;
  
  vl_grupo_empresarial 		numeric;
  vl_conta_grupo_empresarial 	numeric;
  vl_conta_empresa              numeric;
  vl_empresa			numeric;
  vl_contrato			numeric;
  vl_existe 			numeric := 0;
  vl_valor_boleto	        numeric := 0;
  vl_data_referencia 		sc_fin.tbl_rrc.dt_ref_rrc%type;
  vl_data_prevista_liberacao 	sc_fin.tbl_rrc.dt_ref_rrc%type;
  vl_nr_lancamento 		sc_cnt.tbl_lcn.cd_lcn%type;
  
BEGIN

    vp_tipo_lancamento := TP_LCN_RECEBIMENTO_RECURSOS;
    vl_data_referencia := current_date + interval '9 hour';
    vl_data_prevista_liberacao := vl_data_referencia + interval '1 day';
    
    -- capturando os dados da empresa para cadastrar o recebimento
     select gem.cd_gem, gem.cd_cnt, ctr.cd_cnt, ctr.cd_emp, ctr.cd_ctr, bla.vl_bla
       into vl_grupo_empresarial, vl_conta_grupo_empresarial, vl_conta_empresa, vl_empresa, vl_contrato, vl_valor_boleto
     from sc_fin.tbl_bla bla
	inner join sc_cad.tbl_emp emp on emp.cd_emp = bla.cd_emp
	inner join sc_cad.tbl_gem gem on gem.cd_gem = emp.cd_gem
	inner join sc_cad.tbl_ctr ctr on ctr.cd_emp = emp.cd_emp
     where cd_bla = vp_cod_boleto_avulso;

     -- verificando se o valor pago foi igual ou superior ao valor do boleto, caso contrário, não irá fazer nenhum lançamento nem marcar o boleto como baixado
     if vp_valor >= vl_valor_boleto then

       -- atualizando o boleto avulso para BAIXADO
       update sc_fin.tbl_bla
          set st_bla = ST_BOLETO_AVULSO_BAIXADO, 
              dt_pgt_bla = now()
       where cd_bla = vp_cod_boleto_avulso;
             
       -- cadastrar o recebimento
       INSERT INTO sc_fin.tbl_rrc(cd_rrc, cd_cnt_crd, cd_cnt_dbt, dt_ref_rrc, 
		    vl_rrc, st_rrc, cd_inc_usr, dt_inc_usr, 
		    cd_trc, vl_lbr_rrc, dt_prv_lbr_rrc, cd_gem)
	    VALUES (nextval('sc_fin.sq_rrc'), vl_conta_grupo_empresarial, vp_conta_origem, vl_data_referencia, 
		    vp_valor, ST_RECEB_RECURSOS_CADASTRADA, 1, now(),
		    TP_RECEBIMENTO_RECURSOS, 0, vl_data_prevista_liberacao, vl_grupo_empresarial);

       -- contabilizando o recebimento de recurso na conta do grupo empresarial
       perform  sc_cnt.lancar_movimento (vl_nr_lancamento,
                                    vp_cod_lanc_ctpd,
                                    vp_tipo_lancamento,
                                    vl_conta_grupo_empresarial,
                                    'C',
                                    vp_valor,
                                    now()::timestamp,
                                    vp_cod_usuario,
                                    null,
                                    'Credito referente ao boleto avulso. Nr do Boleto: ' || vp_cod_boleto::varchar,
                                    CD_SST_SISTEMA_BAIXA_BOLETO,
                                    vp_cod_boleto
                                    );

      -- cadastrando a distribuição de recursos para a empresa vinculada ao boleto avulso
      insert into sc_fin.tbl_drr(cd_drr, cd_rrc, cd_emp, cd_ctr, vl_drr, st_drr, dt_inc_usr, cd_inc_usr, vl_lbr_ant_drr, vl_lbr_prz_drr)
		    values (nextval('sc_fin.sq_drr'), currval('sc_fin.sq_rrc'), vl_empresa, vl_contrato, vp_valor, ST_RECEB_RECURSOS_CADASTRADA, now(), 1, 0, 0);
		    
      -- contabilizando a distribuição de recursos na conta da empresa
      -- cnt_dbt numeric, cnt_crd numeric, tipo_lancamento numeric, historico character varying, comp_hst character varying, valor double precision, dt_ref timestamp without time zone, cd_usr numeric, cd_sst numeric, nsu numeric)
      perform sc_cnt.lancar_debito_credito(vl_conta_grupo_empresarial, vl_conta_empresa, TP_LCN_DISTRIBUICAO_RECURSOS, 'DISTRIBUICAO DE RECEBIMENTO DE RECURSO', 'DISTRIBUICAO DE RECEBIMENTO DE RECURSO', vp_valor, now()::timestamp, 1, CD_SST_SISTEMA_DIST_RECURSOS, vp_cod_boleto_avulso);
  
      -- bloqueando o valor do boleto de acordo com a distribuição realizada                                
      select count(*) 
        into vl_existe
      from sc_cnt.tbl_tbc_cnt 
      where cd_cnt = vl_conta_empresa
        and cd_tbc = 1; -- tipo de bloqueio recebimento de recursos

      if vl_existe > 0 then
        update sc_cnt.tbl_tbc_cnt set vl_blq_tbc_cnt = COALESCE(vl_blq_tbc_cnt,0) + vp_valor where cd_cnt = vl_conta_empresa and cd_tbc = 1;
      else
        insert into sc_cnt.tbl_tbc_cnt(cd_tbc_cnt, cd_tbc, cd_cnt, vl_blq_tbc_cnt, fg_atv_tbc_cnt, cd_inc_usr, dt_inc_usr)
		    values (nextval('sc_cnt.sq_tbc_cnt'), 1, vl_conta_empresa, vp_valor, 'S', 1, now());
      end if;
    end if;
END;
$$;


ALTER FUNCTION sc_cbr.lancar_boleto_avulso_empresa(OUT vp_tipo_lancamento numeric, vp_valor numeric, vp_cod_boleto_avulso numeric, vp_cod_lanc_ctpd numeric, vp_cod_boleto numeric, vp_cod_usuario numeric, vp_data_pagamento timestamp without time zone, vp_conta_origem numeric) OWNER TO scan;

--
-- TOC entry 1250 (class 1255 OID 564249)
-- Name: processar_arquivo_retorno(numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION processar_arquivo_retorno(vp_cod_usuario numeric DEFAULT 1) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	rg record;
BEGIN
  for rg in select harc.cd_harc
            from sc_cbr.tbl_harc harc
            where st_harc = 1 loop
            
     perform sc_cbr.validar_arquivo_retorno(rg.cd_harc);
     
     perform sc_cbr.efetuar_baixas_retorno(rg.cd_harc,vp_cod_usuario);
            
  end loop;          
  perform sc_cbr.processar_arquivo_retorno_gen(vp_cod_usuario);
END;
$$;


ALTER FUNCTION sc_cbr.processar_arquivo_retorno(vp_cod_usuario numeric) OWNER TO scan;

--
-- TOC entry 1251 (class 1255 OID 564250)
-- Name: processar_arquivo_retorno_gen(numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION processar_arquivo_retorno_gen(vp_cod_usuario numeric DEFAULT 1) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	rg record;
BEGIN
  for rg in select harcg.cd_harcg
            from sc_cbr.tbl_harcg harcg
            where st_harcg = 1 order by dt_grc_harcg loop
            
     perform sc_cbr.validar_arquivo_retorno_gen(rg.cd_harcg);
     
     perform sc_cbr.efetuar_baixas_retorno_gen(rg.cd_harcg,vp_cod_usuario);
            
  end loop;          
END;
$$;


ALTER FUNCTION sc_cbr.processar_arquivo_retorno_gen(vp_cod_usuario numeric) OWNER TO scan;

--
-- TOC entry 1252 (class 1255 OID 564251)
-- Name: validar_arquivo_retorno(numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION validar_arquivo_retorno(vp_cod_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

	rg record;
    
    vl_cod_parametro_cobranca sc_cbr.tbl_ccb.cd_ccb%type;
    
    vl_cod_contrato_cobranca sc_cbr.tbl_ccb.nr_cdt_ccb%type;
    
    vl_qtd_blt numeric;
    vl_cod_boleto sc_cbr.tbl_blt.cd_blt%type;
    
    vl_qtd_reg_vld numeric := 0;
    
    vl_ttl_arq_trl numeric;
    vl_ttl_arq_reg numeric;
    vl_ttl_arq_dsc_reg numeric;
    vl_ttl_arq_acr_reg numeric;
    
    vl_qtd_ttl_arq_trl numeric;
    vl_qtd_ttl_arq_reg numeric;
    
    CD_ERR_HARC_ARQUIVO_CONTRATO_INEXISTENTE sc_cbr.tbl_harc.cd_err_harc%type := 1;    
    CD_ERR_HARC_ARQUIVO_CONTRATO_DUPLICADO sc_cbr.tbl_harc.cd_err_harc%type := 2;
    CD_ERR_HARC_ARQUIVO_NENHUM_REG_VALIDO sc_cbr.tbl_harc.cd_err_harc%type := 3;
    CD_ERR_HARC_ARQUIVO_DADOS_DIVERGENTE_TRAILLER sc_cbr.tbl_harc.cd_err_harc%type := 4;
    
    CD_ERR_DRC_BOLETO_DUPLICADO sc_cbr.tbl_drc_t.cd_err_drc%type := 1;
    CD_ERR_DRC_BOLETO_INEXISTENTE sc_cbr.tbl_drc_t.cd_err_drc%type := 2;
    CD_ERR_DRC_BOLETO_PAGO_POR_OUTRA_REMESSA sc_cbr.tbl_drc_t.cd_err_drc%type := 3;
    CD_ERR_DRC_BOLETO_PAGO_EM_CHEQUE sc_cbr.tbl_drc_t.cd_err_drc%type := 4;
    
    ST_HARC_CADASTRADO sc_cbr.tbl_harc.st_harc%type := 1;
    ST_HARC_VALIDADO sc_cbr.tbl_harc.st_harc%type := 2;
    ST_HARC_INVALIDADO sc_cbr.tbl_harc.st_harc%type := 3;
    
    ST_DRC_CADASTRADO sc_cbr.tbl_harc.st_harc%type := 1;
    ST_DRC_VALIDADO sc_cbr.tbl_harc.st_harc%type := 2;
    ST_DRC_INVALIDADO sc_cbr.tbl_harc.st_harc%type := 3;

    
BEGIN
    
    -- Obtendo o contrato de cobranca
    select harc.nr_ctr_harc
    into vl_cod_contrato_cobranca
    from sc_cbr.tbl_harc harc
    where harc.cd_harc = vp_cod_arquivo;
    
    -- Verificando se existe o contrato(cedente) cadastrado no sistema
    begin
    
      select ccb.cd_ccb
      into strict vl_cod_parametro_cobranca
      from sc_cbr.tbl_ccb ccb
      where ccb.fg_atv_ccb = 'S'
        and ccb.nr_cdt_ccb = vl_cod_contrato_cobranca;
        
    exception
      
      when NO_DATA_FOUND then
      
        update sc_cbr.tbl_harc 
        set st_harc = ST_HARC_INVALIDADO,
            cd_err_harc = CD_ERR_HARC_ARQUIVO_CONTRATO_INEXISTENTE
        where cd_harc = vp_cod_arquivo;      
        
        return;
      
      when TOO_MANY_ROWS then
      
        update sc_cbr.tbl_harc 
        set st_harc = ST_HARC_INVALIDADO,
            cd_err_harc = CD_ERR_HARC_ARQUIVO_CONTRATO_DUPLICADO
        where cd_harc = vp_cod_arquivo;
        
        return;
      when others then 
        
        update sc_cbr.tbl_harc 
        set st_harc = ST_HARC_INVALIDADO
        where cd_harc = vp_cod_arquivo;
               
        return;
        
    end;    
    
    select count(*),sum(drc.vlr_nmn_prc_drc)
    into vl_qtd_ttl_arq_reg,vl_ttl_arq_reg
    from sc_cbr.tbl_drc_t drc
       inner join sc_cbr.tbl_hlsc hlsc on drc.cd_hlsc = hlsc.cd_hlsc
    where hlsc.cd_harc = vp_cod_arquivo; 

    select sum(dru.vl_acr_drc),sum(dru.vl_dsc_drc)
    into vl_ttl_arq_acr_reg,vl_ttl_arq_dsc_reg
    from sc_cbr.tbl_drc_u dru
       inner join sc_cbr.tbl_hlsc hlsc on dru.cd_hlsc = hlsc.cd_hlsc
    where hlsc.cd_harc = vp_cod_arquivo;   

    vl_ttl_arq_reg := vl_ttl_arq_reg + vl_ttl_arq_acr_reg - vl_ttl_arq_dsc_reg;
    
    select sum(tlsc.qtd_prc_tlsc),sum(tlsc.vl_ttl_tlsc)
    into vl_qtd_ttl_arq_trl,vl_ttl_arq_trl
    from sc_cbr.tbl_tlsc tlsc
      inner join sc_cbr.tbl_hlsc hlsc on tlsc.cd_hlsc = hlsc.cd_hlsc
    where hlsc.cd_harc = vp_cod_arquivo;  
    
    if (vl_qtd_ttl_arq_reg <> vl_qtd_ttl_arq_trl or vl_ttl_arq_trl <> vl_ttl_arq_reg) then
    
        update sc_cbr.tbl_harc 
        set st_harc = ST_HARC_INVALIDADO,
            cd_err_harc = CD_ERR_HARC_ARQUIVO_DADOS_DIVERGENTE_TRAILLER
        where cd_harc = vp_cod_arquivo;
        
        return;
        
    end if;
    
    -- Validando os registros do arquivo
	for rg in select drc.cd_drc,
                     drc.cd_doc_drc,
                     drc.tp_lqd_drc,
                     harc.nr_ctr_harc
              from sc_cbr.tbl_drc_t drc
                inner join sc_cbr.tbl_hlsc hlsc on drc.cd_hlsc = hlsc.cd_hlsc
                inner join sc_cbr.tbl_harc harc on harc.cd_harc = hlsc.cd_harc
              where harc.cd_harc = vp_cod_arquivo
                and drc.st_drc = ST_DRC_CADASTRADO loop
                
       -- Verificando se o boleto já foi pago por outra remessa
       
       select count(*)
       into vl_qtd_blt
       from sc_cbr.tbl_drc_t drc
          inner join sc_cbr.tbl_hlsc hlsc on drc.cd_hlsc = hlsc.cd_hlsc
          inner join sc_cbr.tbl_harc harc on harc.cd_harc = hlsc.cd_harc
       where drc.cd_doc_drc = rg.cd_doc_drc
         and harc.nr_ctr_harc = rg.nr_ctr_harc
         and drc.cd_drc <> rg.cd_drc;
       
       if vl_qtd_blt > 0 then
       
          update sc_cbr.tbl_drc_t
             set st_drc = ST_DRC_INVALIDADO,
                 cd_err_drc = CD_ERR_DRC_BOLETO_PAGO_POR_OUTRA_REMESSA
           where cd_drc = rg.cd_drc;
           
          continue;
       end if;
       
       begin
       
         select blt.cd_blt
         into strict vl_cod_boleto
         from sc_cbr.tbl_blt blt
           inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
         where blt.cd_doc_blt = rg.cd_doc_drc
           and ccb.nr_cdt_ccb = rg.nr_ctr_harc;      
         
       exception       
       
         when TOO_MANY_ROWS then
         
           update sc_cbr.tbl_drc_t 
              set st_drc = ST_DRC_INVALIDADO,
                  cd_err_drc = CD_ERR_DRC_BOLETO_DUPLICADO
           where  cd_drc = rg.cd_drc;
           
           continue;      
         when NO_DATA_FOUND then
         
           update sc_cbr.tbl_drc_t
              set st_drc = ST_DRC_INVALIDADO,
                  cd_err_drc = CD_ERR_DRC_BOLETO_INEXISTENTE
           where  cd_drc = rg.cd_drc;
         
         continue;
       end;
       
       update sc_cbr.tbl_drc_t
       set cd_blt = vl_cod_boleto,
           st_drc = ST_DRC_VALIDADO
       where cd_drc = rg.cd_drc;
       
       vl_qtd_reg_vld := vl_qtd_reg_vld + 1;
       
    end loop;
    
      if vl_qtd_reg_vld > 0 then
         update sc_cbr.tbl_harc
         set st_harc = ST_HARC_VALIDADO
         where cd_harc = vp_cod_arquivo
           and st_harc = ST_HARC_CADASTRADO;
      else
         update sc_cbr.tbl_harc
         set st_harc = ST_HARC_INVALIDADO,
             cd_err_harc = CD_ERR_HARC_ARQUIVO_NENHUM_REG_VALIDO
         where cd_harc = vp_cod_arquivo
           and st_harc = ST_HARC_CADASTRADO;
      end if;

    
END;
$$;


ALTER FUNCTION sc_cbr.validar_arquivo_retorno(vp_cod_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1263 (class 1255 OID 564252)
-- Name: validar_arquivo_retorno_gen(numeric); Type: FUNCTION; Schema: sc_cbr; Owner: scan
--

CREATE FUNCTION validar_arquivo_retorno_gen(vp_cod_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    rg record;
    
    vl_cod_parametro_cobranca sc_cbr.tbl_ccb.cd_ccb%type;    
    vl_cod_contrato_cobranca sc_cbr.tbl_ccb.nr_cdt_ccb%type;
    
    vl_qtd_blt numeric;
    vl_cod_boleto sc_cbr.tbl_blt.cd_blt%type;
    
    vl_qtd_reg_vld numeric := 0;
    
    vl_ttl_arq_trl numeric;
    vl_ttl_arq_reg numeric;
    vl_ttl_arq_dsc_reg numeric;
    vl_ttl_arq_acr_reg numeric;
    
    vl_qtd_ttl_arq_trl numeric;
    vl_qtd_ttl_arq_reg numeric;
    
    CD_ERR_HARC_ARQUIVO_CONTRATO_INEXISTENTE sc_cbr.tbl_harc.cd_err_harc%type := 1;    
    CD_ERR_HARC_ARQUIVO_CONTRATO_DUPLICADO sc_cbr.tbl_harc.cd_err_harc%type := 2;
    CD_ERR_HARC_ARQUIVO_NENHUM_REG_VALIDO sc_cbr.tbl_harc.cd_err_harc%type := 3;
    CD_ERR_HARC_ARQUIVO_DADOS_DIVERGENTE_TRAILLER sc_cbr.tbl_harc.cd_err_harc%type := 4;
    
    CD_ERR_DRC_BOLETO_DUPLICADO sc_cbr.tbl_drc_t.cd_err_drc%type := 1;
    CD_ERR_DRC_BOLETO_INEXISTENTE sc_cbr.tbl_drc_t.cd_err_drc%type := 2;
    CD_ERR_DRC_BOLETO_PAGO_POR_OUTRA_REMESSA sc_cbr.tbl_drc_t.cd_err_drc%type := 3;
    CD_ERR_DRC_BOLETO_PAGO_EM_CHEQUE sc_cbr.tbl_drc_t.cd_err_drc%type := 4;
    
    ST_HARC_CADASTRADO sc_cbr.tbl_harc.st_harc%type := 1;
    ST_HARC_VALIDADO sc_cbr.tbl_harc.st_harc%type := 2;
    ST_HARC_INVALIDADO sc_cbr.tbl_harc.st_harc%type := 3;
    
    ST_DRC_CADASTRADO sc_cbr.tbl_harc.st_harc%type := 1;
    ST_DRC_VALIDADO sc_cbr.tbl_harc.st_harc%type := 2;
    ST_DRC_INVALIDADO sc_cbr.tbl_harc.st_harc%type := 3;

    TP_OCORRENCIA_LIQUIDACAO numeric := 6;
    TP_OCORRENCIA_LIQUIDACAO_POS_BAIXA_OU_TITULO_NAO_REGISTRADO numeric := 17;

    
BEGIN
    -- Obtendo o contrato de cobranca (cedente)
    select harcg.nr_cdt_harcg
    into vl_cod_contrato_cobranca
    from sc_cbr.tbl_harcg harcg
    where harcg.cd_harcg = vp_cod_arquivo;
    
    -- Verificando se existe o contrato(cedente) cadastrado no sistema
    begin
    
      select ccb.cd_ccb
      into strict vl_cod_parametro_cobranca
      from sc_cbr.tbl_ccb ccb
      where ccb.fg_atv_ccb = 'S'
        and ccb.nr_cdt_ccb = vl_cod_contrato_cobranca;
        
    exception
      
      when NO_DATA_FOUND then
      
        update sc_cbr.tbl_harcg 
        set st_harcg = ST_HARC_INVALIDADO,
            cd_err_harcg = CD_ERR_HARC_ARQUIVO_CONTRATO_INEXISTENTE
        where cd_harcg = vp_cod_arquivo;      
        
        return;
      
      when TOO_MANY_ROWS then
      
        update sc_cbr.tbl_harcg 
        set st_harcg = ST_HARC_INVALIDADO,
            cd_err_harcg = CD_ERR_HARC_ARQUIVO_CONTRATO_DUPLICADO
        where cd_harcg = vp_cod_arquivo;
        
        return;
      when others then 
        
        update sc_cbr.tbl_harcg 
        set st_harcg = ST_HARC_INVALIDADO
        where cd_harcg = vp_cod_arquivo;
               
        return;
        
    end;    

/*    select count(*),sum(drc.vlr_nmn_prc_drc)
    into vl_qtd_ttl_arq_reg,vl_ttl_arq_reg
    from sc_cbr.tbl_drc_t drc
       inner join sc_cbr.tbl_hlsc hlsc on drc.cd_hlsc = hlsc.cd_hlsc
    where hlsc.cd_harc = vp_cod_arquivo; 

    select sum(dru.vl_acr_drc),sum(dru.vl_dsc_drc)
    into vl_ttl_arq_acr_reg,vl_ttl_arq_dsc_reg
    from sc_cbr.tbl_drc_u dru
       inner join sc_cbr.tbl_hlsc hlsc on dru.cd_hlsc = hlsc.cd_hlsc
    where hlsc.cd_harc = vp_cod_arquivo;   

    vl_ttl_arq_reg := vl_ttl_arq_reg + vl_ttl_arq_acr_reg - vl_ttl_arq_dsc_reg;
    
    select sum(tlsc.qtd_prc_tlsc),sum(tlsc.vl_ttl_tlsc)
    into vl_qtd_ttl_arq_trl,vl_ttl_arq_trl
    from sc_cbr.tbl_tlsc tlsc
      inner join sc_cbr.tbl_hlsc hlsc on tlsc.cd_hlsc = hlsc.cd_hlsc
    where hlsc.cd_harc = vp_cod_arquivo;  
    
    if (vl_qtd_ttl_arq_reg <> vl_qtd_ttl_arq_trl or vl_ttl_arq_trl <> vl_ttl_arq_reg) then
    
        update sc_cbr.tbl_harc 
        set st_harc = ST_HARC_INVALIDADO,
            cd_err_harc = CD_ERR_HARC_ARQUIVO_DADOS_DIVERGENTE_TRAILLER
        where cd_harc = vp_cod_arquivo;
        
        return;
        
    end if;*/

    
    -- Validando os registros do arquivo
	for rg in select drc.cd_darcg,
                     drc.idt_ttl_darcg,
                     drc.nr_ocr_darcg,
                     harcg.nr_cdt_harcg,
                     drc.vl_ttl_darcg
              from sc_cbr.tbl_darcg drc
                  inner join sc_cbr.tbl_harcg harcg on harcg.cd_harcg = drc.cd_harcg
              where drc.cd_harcg = vp_cod_arquivo
                and drc.st_darcg = ST_DRC_CADASTRADO loop
                
       -- Verificando se o boleto já foi pago por outra remessa

       if rg.nr_ocr_darcg in (TP_OCORRENCIA_LIQUIDACAO, TP_OCORRENCIA_LIQUIDACAO_POS_BAIXA_OU_TITULO_NAO_REGISTRADO) then
       
	       select count(*)
	       into vl_qtd_blt
	       from sc_cbr.tbl_darcg drc
		 inner join sc_cbr.tbl_harcg harcg on harcg.cd_harcg = drc.cd_harcg
	       where drc.idt_ttl_darcg = rg.idt_ttl_darcg
		 and harcg.nr_cdt_harcg = rg.nr_cdt_harcg
		 and drc.vl_ttl_darcg = rg.vl_ttl_darcg
		 and drc.nr_ocr_darcg in (TP_OCORRENCIA_LIQUIDACAO, TP_OCORRENCIA_LIQUIDACAO_POS_BAIXA_OU_TITULO_NAO_REGISTRADO)
		 and drc.cd_darcg <> rg.cd_darcg;
	       
	       if vl_qtd_blt > 0 then
	       
		  update sc_cbr.tbl_darcg
		     set st_darcg = ST_DRC_INVALIDADO,
			 cd_err_darcg = CD_ERR_DRC_BOLETO_PAGO_POR_OUTRA_REMESSA
		   where cd_darcg = rg.cd_darcg;
		   
		  continue;
	       end if;
       end if;	       
       
       begin
       
         select max(blt.cd_blt)
         into strict vl_cod_boleto
         from sc_cbr.tbl_blt blt
           inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
         where blt.cd_doc_blt = rg.idt_ttl_darcg
           and ccb.nr_cdt_ccb = rg.nr_cdt_harcg;      
         
       exception       
       
         when TOO_MANY_ROWS then

	   update sc_cbr.tbl_darcg
             set st_darcg = ST_DRC_INVALIDADO,
                 cd_err_darcg = CD_ERR_DRC_BOLETO_DUPLICADO
           where cd_darcg = rg.cd_darcg;         
           
           continue;      
         when NO_DATA_FOUND then

	   update sc_cbr.tbl_darcg
             set st_darcg = ST_DRC_INVALIDADO,
                 cd_err_darcg = CD_ERR_DRC_BOLETO_INEXISTENTE
           where cd_darcg = rg.cd_darcg;           
         
         continue;
       end;
       
       
       update sc_cbr.tbl_darcg
       set st_darcg = ST_DRC_VALIDADO,
           cd_blt = vl_cod_boleto
       where cd_darcg = rg.cd_darcg;           
       
       
       vl_qtd_reg_vld := vl_qtd_reg_vld + 1;
       
    end loop;
    
      if vl_qtd_reg_vld > 0 then
         update sc_cbr.tbl_harcg
         set st_harcg = ST_HARC_VALIDADO
         where cd_harcg = vp_cod_arquivo
           and st_harcg = ST_HARC_CADASTRADO;
      else
         update sc_cbr.tbl_harcg
         set st_harcg = ST_HARC_INVALIDADO,
             cd_err_harcg = CD_ERR_HARC_ARQUIVO_NENHUM_REG_VALIDO
         where cd_harcg = vp_cod_arquivo
           and st_harcg = ST_HARC_CADASTRADO;
      end if;

    
END;
$$;


ALTER FUNCTION sc_cbr.validar_arquivo_retorno_gen(vp_cod_arquivo numeric) OWNER TO scan;

SET search_path = sc_ccb, pg_catalog;

--
-- TOC entry 1072 (class 1255 OID 932409)
-- Name: atualizar_ccb(numeric, date); Type: FUNCTION; Schema: sc_ccb; Owner: postgres
--

CREATE FUNCTION atualizar_ccb(vp_codigo_ccb numeric DEFAULT NULL::numeric, vp_data_atualizacao date DEFAULT ('now'::text)::date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  ct_situacao_ccb_liquidada numeric := 2;
  ct_situacao_ccb_cancelada numeric := 3;
  
  ct_taxa_multa numeric := 2;
  ct_taxa_juros_mora numeric := 2.1;
  PRM_QTD_DIAS_CARENCIA sc_cad.tbl_prm.nm_prm%type := 'QTD_DIAS_JRS_MLT';

  vl_qtd_dias_carencia numeric;  

  vl_multa numeric(13,2);
  vl_juros_mora numeric(13,2);
  vl_data_ult_atualizacao date;
  vl_qtd_dias numeric;
  vl_codigo_fatura numeric;
  rg record;
  vl_total_encargos numeric(13,2);
  vl_cod_parcela_encargos numeric;
  vl_taxa_juros numeric;
  vl_dt_vencimento_fatura date;
  vl_situacao_fatura numeric;
begin

    -- Obtendo a quantitade de dias de carencia
    select prm.vl_prm::numeric
    into vl_qtd_dias_carencia
    from sc_cad.tbl_prm prm 
    where prm.nm_prm = PRM_QTD_DIAS_CARENCIA;

    for rg in select *
              from sc_ccb.tbl_ccb ccb
                inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
                inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
                inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
                inner join sc_opr.tbl_tvt tvt on tvt.cd_tvt = crt.cd_tvt
	        inner join sc_opr.tbl_dtv dtv on dtv.cd_tvt = tvt.cd_tvt    
              where st_ccb not in(ct_situacao_ccb_liquidada,ct_situacao_ccb_cancelada) 
                and dt_vnc_ccb <= vp_data_atualizacao - vl_qtd_dias_carencia::integer
                and (dt_ult_atu_ccb is null or dt_ult_atu_ccb::date<vp_data_atualizacao)
                and (ccb.cd_ccb = vp_codigo_ccb or vp_codigo_ccb is null)
                and dtv.cd_top = 5
	        and dtv.tp_cbr_dtv = 1 loop
                
       vl_multa := 0;
       vl_juros_mora := 0;

     /*  if (vp_data_atualizacao - rg.dt_vnc_ccb::date) > 15 then -- Se o cessionario for Saqpag
         vl_taxa_juros := ct_taxa_juros_mora;
       else -- Se for Gaia
         vl_taxa_juros := rg.vl_dtv;
       end if;*/
       
       -- Calcula o valor da multa, caso ainda nao tenha havido cobranca
       
       if coalesce(rg.vlr_mlt_ccb,0) <= 0 then 
	  vl_multa := (ct_taxa_multa / 100) * (rg.vlr_org_ccb - coalesce(rg.vl_pgt_pri_ccb,0));
       end if;
       
       --

       -- Calculando o Juros de Mora desde a data da ultima atualizacao
       
       if rg.dt_ult_atu_ccb is null then
         vl_data_ult_atualizacao := rg.dt_vnc_ccb;
       else  
         vl_data_ult_atualizacao := rg.dt_ult_atu_ccb;
       end if;

       vl_juros_mora := 0;
       
       while vl_data_ult_atualizacao < vp_data_atualizacao loop
       
         vl_data_ult_atualizacao := vl_data_ult_atualizacao + 1;
         
         if (vl_data_ult_atualizacao - rg.dt_vnc_ccb::date) > 15 then -- Se o cessionario for Saqpag
	    vl_taxa_juros := ct_taxa_juros_mora;
         else -- Se for Gaia
	    vl_taxa_juros := rg.vl_dtv;
         end if;
         
          vl_juros_mora := vl_juros_mora + (vl_taxa_juros / 100 / 30) *1* (rg.vlr_org_ccb - coalesce(rg.vl_pgt_pri_ccb,0));
       end loop;
       

--       vl_qtd_dias := vp_data_atualizacao - vl_data_ult_atualizacao::date;

--       vl_juros_mora := (vl_taxa_juros / 100 / 30) * vl_qtd_dias * (rg.vlr_org_ccb - coalesce(rg.vl_pgt_pri_ccb,0));

       --

       -- Atualiza a fatura a qual a operacao que originou a ccb esta vinculada

       vl_total_encargos := coalesce(vl_juros_mora,0) + coalesce(vl_multa,0) ; 

       if  vl_total_encargos > 0 then

          select prc.cd_fcr_atu_prc,fcr.dt_vnc_fcr,fcr.st_fcr
          into vl_codigo_fatura,vl_dt_vencimento_fatura, vl_situacao_fatura
          from sc_fcr.tbl_prc prc
            inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = prc.cd_fcr_atu_prc
          where prc.cd_opr = rg.cd_opr;

          if vl_situacao_fatura = 1 then

		  select prc.cd_prc
		  into vl_cod_parcela_encargos
		  from sc_fcr.tbl_prc prc
		    inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
		    inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = prc.cd_fcr
		  where opr.cd_top = 23
		    and fcr.cd_fcr = vl_codigo_fatura
		    and opr.cd_pai_opr = rg.cd_opr;

		  if vl_cod_parcela_encargos is null then
		  
		     insert into sc_opr.tbl_opr(cd_opr,cd_top,cd_pls,dt_opr,vl_opr,vl_jrs_opr,vl_trf_opr,nr_prc_opr,nr_nsu_org_opr,st_opr,cd_pai_opr)
		     values(nextval('sc_opr.sq_opr'), 23, rg.cd_pls, now(), vl_total_encargos, 0, 0, 1, rg.cd_ccb, 2,rg.cd_opr);

		     insert into sc_fcr.tbl_prc(cd_prc,cd_crt,cd_fcr,vl_prc,fg_dcr_prc,st_prc,cd_opr,dt_grc_prc,dt_vnc_prc,ds_prc,nr_prc,cd_fcr_atu_prc)
		     values(nextval('sc_fcr.sq_prc'), rg.cd_crt, vl_codigo_fatura,vl_total_encargos, 'D', 2, currval('sc_opr.sq_opr'), now(),vl_dt_vencimento_fatura, 'REF A ENCARGOS POR ATRASO SOBRE CCB',1,vl_codigo_fatura);

		    update sc_fcr.tbl_fcr 
		       set vl_fcr = vl_fcr + vl_total_encargos,
			   vl_sld_dvd_fcr = vl_sld_dvd_fcr + vl_total_encargos,
			   vl_enc_ctr_fcr = vl_enc_ctr_fcr + vl_total_encargos,
			   vl_rst_enc_fcr = vl_rst_enc_fcr + vl_total_encargos,
			   vl_mnm_fcr = vl_mnm_fcr + vl_total_encargos
		     where cd_fcr = vl_codigo_fatura;             

		  else

		    update sc_fcr.tbl_prc 
		    set vl_prc = vl_prc + vl_total_encargos,
                        dt_grc_prc = now() 
		    where cd_prc =  vl_cod_parcela_encargos;
		    
		    update sc_fcr.tbl_fcr 
		       set vl_fcr = vl_fcr + vl_total_encargos,
			   vl_sld_dvd_fcr = vl_sld_dvd_fcr + vl_total_encargos,
			   vl_enc_ctr_fcr = vl_enc_ctr_fcr + vl_total_encargos,
			   vl_rst_enc_fcr = vl_rst_enc_fcr + vl_total_encargos,
			   vl_mnm_fcr = vl_mnm_fcr + vl_total_encargos
		     where cd_fcr = vl_codigo_fatura;      
		    
		  end if;

		  update sc_ccb.tbl_ccb 
	          set vlr_jrs_ccb = coalesce(vlr_jrs_ccb,0) + coalesce(vl_juros_mora,0),
	 	    vlr_mlt_ccb = coalesce(vlr_mlt_ccb,0) + coalesce(vl_multa,0),
	 	    vlr_sld_dvd_ccb = vlr_sld_dvd_ccb + coalesce(vl_juros_mora,0) + coalesce(vl_multa,0),
		    dt_ult_atu_ccb = vp_data_atualizacao
	          where cd_ccb = rg.cd_ccb ;      
		  
	      end  if;    


	          

	 end if;      
       

    end loop;          
end$$;


ALTER FUNCTION sc_ccb.atualizar_ccb(vp_codigo_ccb numeric, vp_data_atualizacao date) OWNER TO postgres;

--
-- TOC entry 1578 (class 1255 OID 886771)
-- Name: atualizar_ccb_old(); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION atualizar_ccb_old() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  ct_situacao_ccb_liquidada numeric := 2;
  ct_situacao_ccb_cancelada numeric := 3;
  
  ct_taxa_multa numeric := 2;
  ct_taxa_juros_mora numeric := 2.1;
  PRM_QTD_DIAS_CARENCIA sc_cad.tbl_prm.nm_prm%type := 'QTD_DIAS_JRS_MLT';

  vl_qtd_dias_carencia numeric;  

  vl_multa numeric(13,2);
  vl_juros_mora numeric(13,2);
  vl_data_ult_atualizacao date;
  vl_qtd_dias numeric;
  vl_codigo_fatura numeric;
  rg record;
  vl_total_encargos numeric(13,2);
  vl_cod_parcela_encargos numeric;
  vl_taxa_juros numeric;
  vl_dt_vencimento_fatura date;
  vl_situacao_fatura numeric;
begin

    -- Obtendo a quantitade de dias de carencia
    select prm.vl_prm::numeric
    into vl_qtd_dias_carencia
    from sc_cad.tbl_prm prm 
    where prm.nm_prm = PRM_QTD_DIAS_CARENCIA;

    for rg in select *
              from sc_ccb.tbl_ccb ccb
                inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
                inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
                inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
                inner join sc_opr.tbl_tvt tvt on tvt.cd_tvt = crt.cd_tvt
	        inner join sc_opr.tbl_dtv dtv on dtv.cd_tvt = tvt.cd_tvt    
              where st_ccb not in(ct_situacao_ccb_liquidada,ct_situacao_ccb_cancelada) 
                and dt_vnc_ccb <= current_date - vl_qtd_dias_carencia::integer
                and (dt_ult_atu_ccb is null or dt_ult_atu_ccb::date<current_date)
                and dtv.cd_top = 5
	        and dtv.tp_cbr_dtv = 1 loop
                
       vl_multa := 0;
       vl_juros_mora := 0;

       if (current_date - rg.dt_vnc_ccb::date) > 15 then -- Se o cessionario for Saqpag
         vl_taxa_juros := ct_taxa_juros_mora;
       else -- Se for Gaia
         vl_taxa_juros := rg.vl_dtv;
       end if;
       
       -- Calcula o valor da multa, caso ainda nao tenha havido cobranca
       
       if coalesce(rg.vlr_mlt_ccb,0) <= 0 then 
	  vl_multa := (ct_taxa_multa / 100) * (rg.vlr_org_ccb - coalesce(rg.vl_pgt_pri_ccb,0));
       end if;
       
       --

       -- Calculando o Juros de Mora desde a data da ultima atualizacao
       
       if rg.dt_ult_atu_ccb is null then
         vl_data_ult_atualizacao := rg.dt_vnc_ccb;
       else  
         vl_data_ult_atualizacao := rg.dt_ult_atu_ccb;
       end if;

       vl_qtd_dias := current_date - vl_data_ult_atualizacao::date;

       vl_juros_mora := (vl_taxa_juros / 100 / 30) * vl_qtd_dias * (rg.vlr_org_ccb - coalesce(rg.vl_pgt_pri_ccb,0));

       --

       -- Atualiza a fatura a qual a operacao que originou a ccb esta vinculada

       vl_total_encargos := coalesce(vl_juros_mora,0) + coalesce(vl_multa,0) ; 

       if  vl_total_encargos > 0 then

          select prc.cd_fcr_atu_prc,fcr.dt_vnc_fcr,fcr.st_fcr
          into vl_codigo_fatura,vl_dt_vencimento_fatura, vl_situacao_fatura
          from sc_fcr.tbl_prc prc
            inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = prc.cd_fcr_atu_prc
          where prc.cd_opr = rg.cd_opr;

          if vl_situacao_fatura = 1 then

		  select prc.cd_prc
		  into vl_cod_parcela_encargos
		  from sc_fcr.tbl_prc prc
		    inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
		    inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = prc.cd_fcr
		  where opr.cd_top = 23
		    and fcr.cd_fcr = vl_codigo_fatura
		    and opr.cd_pai_opr = rg.cd_opr;

		  if vl_cod_parcela_encargos is null then
		  
		     insert into sc_opr.tbl_opr(cd_opr,cd_top,cd_pls,dt_opr,vl_opr,vl_jrs_opr,vl_trf_opr,nr_prc_opr,nr_nsu_org_opr,st_opr,cd_pai_opr)
		     values(nextval('sc_opr.sq_opr'), 23, rg.cd_pls, now(), vl_total_encargos, 0, 0, 1, rg.cd_ccb, 2,rg.cd_opr);

		     insert into sc_fcr.tbl_prc(cd_prc,cd_crt,cd_fcr,vl_prc,fg_dcr_prc,st_prc,cd_opr,dt_grc_prc,dt_vnc_prc,ds_prc,nr_prc,cd_fcr_atu_prc)
		     values(nextval('sc_fcr.sq_prc'), rg.cd_crt, vl_codigo_fatura,vl_total_encargos, 'D', 2, currval('sc_opr.sq_opr'), now(),vl_dt_vencimento_fatura, 'REF A ENCARGOS POR ATRASO SOBRE CCB',1,vl_codigo_fatura);

		    update sc_fcr.tbl_fcr 
		       set vl_fcr = vl_fcr + vl_total_encargos,
			   vl_sld_dvd_fcr = vl_sld_dvd_fcr + vl_total_encargos,
			   vl_enc_ctr_fcr = vl_enc_ctr_fcr + vl_total_encargos,
			   vl_rst_enc_fcr = vl_rst_enc_fcr + vl_total_encargos,
			   vl_mnm_fcr = vl_mnm_fcr + vl_total_encargos
		     where cd_fcr = vl_codigo_fatura;             

		  else

		    update sc_fcr.tbl_prc 
		    set vl_prc = vl_prc + vl_total_encargos 
		    where cd_prc =  vl_cod_parcela_encargos;
		    
		    update sc_fcr.tbl_fcr 
		       set vl_fcr = vl_fcr + vl_total_encargos,
			   vl_sld_dvd_fcr = vl_sld_dvd_fcr + vl_total_encargos,
			   vl_enc_ctr_fcr = vl_enc_ctr_fcr + vl_total_encargos,
			   vl_rst_enc_fcr = vl_rst_enc_fcr + vl_total_encargos,
			   vl_mnm_fcr = vl_mnm_fcr + vl_total_encargos
		     where cd_fcr = vl_codigo_fatura;      
		    
		  end if;

		  update sc_ccb.tbl_ccb 
	          set vlr_jrs_ccb = coalesce(vlr_jrs_ccb,0) + coalesce(vl_juros_mora,0),
	 	    vlr_mlt_ccb = coalesce(vlr_mlt_ccb,0) + coalesce(vl_multa,0),
	 	    vlr_sld_dvd_ccb = vlr_sld_dvd_ccb + coalesce(vl_juros_mora,0) + coalesce(vl_multa,0),
		    dt_ult_atu_ccb = now()
	          where cd_ccb = rg.cd_ccb ;      
		  
	      end  if;    


	          

	 end if;      
       

    end loop;          
end$$;


ALTER FUNCTION sc_ccb.atualizar_ccb_old() OWNER TO scan;

--
-- TOC entry 1579 (class 1255 OID 894045)
-- Name: comprar_ccb(); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION comprar_ccb() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   ct_qtd_dias_compra integer := 15;
   ct_cessionario_gaia numeric := 2;
   ct_cessionario_soma numeric := 1;

   rg record;
begin

   for rg in select *
             from sc_ccb.tbl_ccb
             where dt_vnc_ccb <= current_date - ct_qtd_dias_compra
               and cd_csn <> ct_cessionario_soma
               and st_ccb = 1 loop


       -- Alterar para o novo cessionario
       update sc_ccb.tbl_ccb set cd_csn = ct_cessionario_soma,dt_cmp_ccb=now() where cd_ccb = rg.cd_ccb;


  end loop;             

end$$;


ALTER FUNCTION sc_ccb.comprar_ccb() OWNER TO scan;

--
-- TOC entry 1653 (class 1255 OID 888597)
-- Name: contabiliza_baixa(); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION contabiliza_baixa() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   rg record;
   ct_cnt_credores_diverso_cobranca numeric := 117356;
   ct_tipo_lancamento_baixa_ccb numeric := 1414;
   ct_sistema_ccb numeric := 30;
   ct_cessionario_gaia numeric := 2;
   ct_cessionario_adicional numeric := 3;

begin

    for rg in select (coalesce(ccb_pfc.vl_pgt_jrs_ccb_pfc,0) + 
                      coalesce(ccb_pfc.vl_pgt_mlt_ccb_pfc,0) + 
                      coalesce(ccb_pfc.vl_pgt_prc_ccb_pfc,0)) as total_pagamento,
                     ccb.cd_csn,
                     ccb.cd_ccb,
                     pfc.dt_rcb_pfc,
                     crt.cd_cnt,
                     pfc.cd_pfc
              from sc_ccb.tbl_ccb_pfc ccb_pfc
                inner join sc_ccb.tbl_ccb ccb on ccb.cd_ccb = ccb_pfc.cd_ccb
                inner join sc_fcr.tbl_pfc pfc on pfc.cd_pfc = ccb_pfc.cd_pfc
                inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
                inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
                inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
              where ccb_pfc.dt_ctb_ccb_pfc is null loop

        if rg.cd_csn in( ct_cessionario_gaia, ct_cessionario_adicional)  then
           perform sc_cnt.lancar_debito_credito(rg.cd_cnt, ct_cnt_credores_diverso_cobranca,ct_tipo_lancamento_baixa_ccb,null,'REF A BAIXA CCB COD '|| rg.cd_ccb,rg.total_pagamento,rg.dt_rcb_pfc,1,ct_sistema_ccb,rg.cd_ccb); 
           update sc_ccb.tbl_ccb_pfc 
           set dt_ctb_ccb_pfc = now() 
           where cd_ccb = rg.cd_ccb 
              and cd_pfc = rg.cd_pfc;           
        end if;   

        


    end loop;          
                
              
end$$;


ALTER FUNCTION sc_ccb.contabiliza_baixa() OWNER TO scan;

--
-- TOC entry 1575 (class 1255 OID 887894)
-- Name: corrige_valor_parcela_saqueextra(); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION corrige_valor_parcela_saqueextra() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin
   for rg in select prc.cd_prc,
                    opr.cd_opr,
                    ccb.vlr_iof_ccb,
                    ccb.vlr_ccb,
                    ccb.vlr_jrs_ccb,
                    opr.vl_trf_opr,
                    opr.vl_opr,
                    opr.vl_jrs_opr,
                    opr.vl_iof_opr,
                    ccb.vlr_lib_ccb
             from sc_opr.tbl_opr opr
               inner join sc_ccb.tbl_ccb ccb on ccb.cd_opr = opr.cd_opr
               inner join sc_fcr.tbl_prc prc on prc.cd_opr = opr.cd_opr
             where prc.st_prc <> 2 
               and prc.dt_grc_prc >= current_Date loop


      update sc_fcr.tbl_prc 
         set vl_prc = rg.vlr_ccb 
      where cd_prc = rg.cd_prc;
      
      update sc_opr.tbl_opr 
         set vl_opr = rg.vlr_ccb,
             vl_jrs_opr = rg.vlr_ccb-rg.vlr_iof_ccb::numeric(13,2)-rg.vlr_lib_ccb::numeric(13,2),
             vl_iof_opr = rg.vlr_iof_ccb::numeric(13,2)
      where cd_opr = rg.cd_opr;

      --raise notice 'valor operacao % alterado de % para %, juros de % para %, iof de % para %',rg.cd_opr,rg.vl_opr,rg.vlr_ccb,rg.vl_jrs_opr,(rg.vlr_ccb-rg.vlr_iof_ccb-rg.vlr_lib_ccb)::numeric(13,2),rg.vl_iof_opr,rg.vlr_iof_ccb::numeric(13,2);

  end loop;             
end$$;


ALTER FUNCTION sc_ccb.corrige_valor_parcela_saqueextra() OWNER TO scan;

--
-- TOC entry 1577 (class 1255 OID 891070)
-- Name: corrige_valor_parcela_saqueextra_new(); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION corrige_valor_parcela_saqueextra_new() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  vl_valor_iof numeric;
  vl_valor_ccb numeric;
  vl_valor_liberado numeric;
  retorno_parcela record;
begin
   for rg in select prc.cd_prc,
                    opr.cd_opr,
                    opr.vl_trf_opr,
                    opr.vl_opr,
                    opr.vl_jrs_opr,
                    opr.vl_iof_opr,
                    opr.dt_opr,
                    dtv.vl_dtv,
                    opr.vl_opr,
                    opr.vl_iof_opr,
                    opr.vl_jrs_opr,
                    prc.dt_vnc_prc
             from sc_opr.tbl_opr opr
               inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
               inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
               inner join sc_fcr.tbl_prc prc on prc.cd_opr = opr.cd_opr
	       inner join sc_opr.tbl_tvt tvt on tvt.cd_tvt = crt.cd_tvt
	       inner join sc_opr.tbl_dtv dtv on dtv.cd_tvt = tvt.cd_tvt               
             where prc.st_prc <> 2 
               and dtv.cd_top = 5
               and opr.cd_top = 5
	       and dtv.tp_cbr_dtv = 1
               and prc.dt_grc_prc >= current_date loop


   select * from sc_calc.calcula_valor_parcela(rg.dt_opr::date, rg.dt_vnc_prc, rg.vl_dtv, 0, 1, (rg.vl_opr - (rg.vl_iof_opr + rg.vl_jrs_opr)))
   into retorno_parcela;

    vl_valor_iof := retorno_parcela.vr_vl_iof;
    vl_valor_ccb := retorno_parcela.vr_vl_parcela;   
    vl_valor_liberado := rg.vl_opr - (rg.vl_iof_opr + rg.vl_jrs_opr);


      update sc_fcr.tbl_prc 
         set vl_prc = vl_valor_ccb 
      where cd_prc = rg.cd_prc;
      
      update sc_opr.tbl_opr 
         set vl_opr = vl_valor_ccb,
             vl_jrs_opr = vl_valor_ccb-vl_valor_iof::numeric(13,2)-vl_valor_liberado::numeric(13,2),
             vl_iof_opr = vl_valor_iof::numeric(13,2)
      where cd_opr = rg.cd_opr;

      raise notice 'valor operacao % alterado de % para %, juros de % para %, iof de % para %',rg.cd_opr,rg.vl_opr,vl_valor_ccb,rg.vl_jrs_opr,vl_valor_ccb-vl_valor_iof::numeric(13,2)-vl_valor_liberado::numeric(13,2),rg.vl_iof_opr,vl_valor_iof::numeric(13,2);

  end loop;             
end$$;


ALTER FUNCTION sc_ccb.corrige_valor_parcela_saqueextra_new() OWNER TO scan;

--
-- TOC entry 1666 (class 1255 OID 1000343)
-- Name: gerar_arquivo_baixa_adicional(date); Type: FUNCTION; Schema: sc_ccb; Owner: postgres
--

CREATE FUNCTION gerar_arquivo_baixa_adicional(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare


   rg record;
   vl_nome_arquivo varchar;
   vl_local_arquivo varchar;
   vl_linha varchar;

   vl_diretorio varchar;

begin

  select dir_tda
  into vl_diretorio
  from sc_dwn.tbl_tda
  where cd_tda = 14;
  
  vl_nome_arquivo := 'BXA_ADICIONAL_CCB_'|| to_char(vp_data, 'yyyymmdd') || '.CSV';
  vl_local_arquivo := vl_diretorio || '\\' || vl_nome_arquivo;

  --GARANTINDO QUE O SISTEMA NÃO IRÁ ADICIONAR LINHAS A ARQUIVOS JÁ EXISTENTES, GARANTE A CONSISTENCIA EM RELAÇÃO A REPROCESSAMENTO
  begin
    perform sc_arq.excluirarquivo(vl_local_arquivo);
  exception
    when others then
      raise notice 'ocorreu um erro ao tentar apagar o arquivo: %, descricao do erro: %', vl_local_arquivo, sqlerrm;
  end;
  
  perform sc_arq.gravarlinha(vl_local_arquivo, 'DATA_GERACAO;CODIGO;VALOR_CCB;VALOR_IOF;VALOR_JUROS;VALOR_TARIFA;VALOR_LIQUIDO;VALOR_COMPRA;DATA_VENCIMENTO;SACADO;LOGRADOURO;BAIRRO;LOCALIDADE;UF;CEP;DATA_REPASSE;VALOR_PAGAMENTO;MORA;MULTA;SITUACAO;CPF');

  for rg in select ccb.dt_inc_ccb::date,
	           ccb.cd_ccb,
	           vlr_ccb,
	           opr.vl_jrs_opr,
	           ccb.vlr_iof_ccb,
	           opr.vl_trf_opr,
	           opr.vl_opr - opr.vl_trf_opr - opr.vl_iof_opr - opr.vl_jrs_opr valor_liquido,
	           opr.vl_opr - opr.vl_jrs_opr valor_compra,
	           dt_vnc_ccb,
	           cun.nm_cun,
	           ccb.dt_rps_Ccb,
	           ccb.vl_pgt_ccb,
	           ccb.vlr_jrs_ccb,
	           ccb.vlr_mlt_ccb,
	           dmn.nm_vlr_dmn st_ccb,
	           cun.nr_cpf_cnpj_cun
            from sc_ccb.tbl_ccb ccb
              inner join sc_ccb.tbl_csn csn on csn.cd_csn = ccb.cd_csn
              inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
              inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
              inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
              inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
              inner join sc_cad.tbl_dmn dmn on dmn.nm_cmp_dmn = 'ST_CCB' AND dmn.vl_cmp_dmn = ccb.st_ccb
            where dt_rps_ccb::date = vp_data
            order by dt_lqd_ccb loop
		  
	  vl_linha := '';
	  vl_linha := vl_linha || to_char(rg.dt_inc_ccb,'dd-mm-yyyy') || ';';
	  vl_linha := vl_linha || rg.cd_ccb || ';';
	  vl_linha := vl_linha || replace(rg.vlr_ccb::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(rg.vlr_iof_ccb::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(rg.vl_jrs_opr::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(rg.vl_trf_opr::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(rg.valor_liquido::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(rg.valor_compra::varchar,'.',',') || ';';
	  vl_linha := vl_linha || to_char(rg.dt_vnc_ccb,'dd-mm-yyyy') || ';';
	  vl_linha := vl_linha || rg.nm_cun || ';';

	  vl_linha := vl_linha || ';';
	  vl_linha := vl_linha || ';';
	  vl_linha := vl_linha || ';';
	  vl_linha := vl_linha || ';';
	  vl_linha := vl_linha || ';';
	  
	  vl_linha := vl_linha || coalesce(to_char(rg.dt_rps_ccb,'dd-mm-yyyy'),'')  || ';';
	  vl_linha := vl_linha || replace(rg.vl_pgt_ccb::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(coalesce(rg.vlr_jrs_ccb,0)::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(coalesce(rg.vlr_mlt_ccb,0)::varchar,'.',',') || ';';
	  vl_linha := vl_linha || rg.st_ccb || ';';
	  vl_linha := vl_linha || rg.nr_cpf_cnpj_cun;

	  perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);
  end loop;          
  
  insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_arquivo,now(),vp_data,14,1);     
  
  
end$$;


ALTER FUNCTION sc_ccb.gerar_arquivo_baixa_adicional(vp_data date) OWNER TO postgres;

--
-- TOC entry 1709 (class 1255 OID 1004944)
-- Name: gerar_arquivo_baixa_adicional_cnab(date); Type: FUNCTION; Schema: sc_ccb; Owner: postgres
--

CREATE FUNCTION gerar_arquivo_baixa_adicional_cnab(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   rg record;
   vl_nome_arquivo varchar;
   vl_local_arquivo varchar;
   vl_linha varchar;

   vl_diretorio varchar;

  ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
  ALINHAMENTO_A_DIREITA numeric(2,0) := 1;

  vl_sequencial numeric;

  vl_total numeric;
begin

  select dir_tda
  into vl_diretorio
  from sc_dwn.tbl_tda
  where cd_tda = 14;
  
  vl_nome_arquivo := 'CB'|| to_char(vp_data, 'ddmmyyyy') || '.RET';
  vl_local_arquivo := vl_diretorio || '\\' || vl_nome_arquivo;

  -- HEADER
  vl_linha := '02RETORNO01';
  vl_linha := vl_linha || sc_arq.preencher(15,'COBRANCA',' ',ALINHAMENTO_A_DIREITA);
  vl_linha := vl_linha || sc_arq.preencher(20,'4725540','0',ALINHAMENTO_A_ESQUERDA);
  vl_linha := vl_linha || 'ADICIONAL - FUNDO DE INVESTIME';
  vl_linha := vl_linha || '237';
  vl_linha := vl_linha || sc_arq.preencher(15,'BRADESCO',' ',ALINHAMENTO_A_DIREITA);
  vl_linha := vl_linha || TO_CHAR(CURRENT_DATE,'DDMMYY');
  vl_linha := vl_linha || '01600000';--DENSIDADE
  vl_linha := vl_linha || '00212';--NR AVISO
  vl_linha := vl_linha || sc_arq.preencher(266,' ',' ',ALINHAMENTO_A_DIREITA);
  vl_linha := vl_linha || TO_CHAR(CURRENT_DATE,'DDMMYY');
  vl_linha := vl_linha || sc_arq.preencher(9,' ',' ',ALINHAMENTO_A_DIREITA);
  vl_linha := vl_linha || '000001';

  perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);
  vl_sequencial := 1;
  for rg in select ccb.dt_inc_ccb::date,
	           ccb.cd_ccb,
	           vlr_ccb,
	           opr.vl_jrs_opr,
	           ccb.vlr_iof_ccb,
	           opr.vl_trf_opr,
	           opr.vl_opr - opr.vl_trf_opr - opr.vl_iof_opr - opr.vl_jrs_opr valor_liquido,
	           dt_vnc_ccb,
	           cun.nm_cun,
	           ccb.dt_rps_Ccb,
	           ccb.vl_pgt_ccb,
	           ccb.vlr_jrs_ccb,
	           ccb.vlr_mlt_ccb,
	           dmn.nm_vlr_dmn st_ccb,
	           cun.tp_pss_cun,
	           cun.nr_cpf_cnpj_cun
            from sc_ccb.tbl_ccb ccb
              inner join sc_ccb.tbl_csn csn on csn.cd_csn = ccb.cd_csn
              inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
              inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
              inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
              inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
              inner join sc_cad.tbl_dmn dmn on dmn.nm_cmp_dmn = 'ST_CCB' AND dmn.vl_cmp_dmn = ccb.st_ccb
            where dt_lqd_ccb::date = vp_data 
              and dt_inc_ccb::date = '29-08-2017' loop

	  vl_linha := '';
	  vl_sequencial := vl_sequencial + 1;
	  vl_linha := vl_linha || '1';
	  vl_linha := vl_linha || case when rg.tp_pss_cun = 'F' then '01' else '02' end;
	  vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_cpf_cnpj_cun,'0',ALINHAMENTO_A_ESQUERDA);
	  vl_linha := vl_linha || '000';
	  vl_linha := vl_linha || '00090364500004073';--VERIFICAR ESSE CAMPO
          vl_linha := vl_linha || sc_arq.preencher(25,rg.cd_ccb,' ',ALINHAMENTO_A_DIREITA);--NR CONTROLE DO PARTICIPANTE
          vl_linha := vl_linha || sc_arq.preencher(8,'0','0',ALINHAMENTO_A_DIREITA);--ZEROS
          vl_linha := vl_linha || sc_arq.preencher(12,rg.cd_ccb,' ',ALINHAMENTO_A_DIREITA);--identiicacao do titulo no banco
          vl_linha := vl_linha || sc_arq.preencher(10,'0','0',ALINHAMENTO_A_DIREITA);--ZEROS
          vl_linha := vl_linha || sc_arq.preencher(12,'0','0',ALINHAMENTO_A_DIREITA);--ZEROS
          vl_linha := vl_linha || sc_arq.preencher(1,'0','0',ALINHAMENTO_A_DIREITA);--rateio
          vl_linha := vl_linha || '00'; -- Pagamento parcial
          vl_linha := vl_linha || '9'; -- carteira
          vl_linha := vl_linha || '06'; -- Identificacao da ocorrencia
          vl_linha := vl_linha || TO_CHAR(CURRENT_DATE,'DDMMYY'); -- Data Ocorrencia Banco
          vl_linha := vl_linha || sc_arq.preencher(10,rg.cd_ccb,' ',ALINHAMENTO_A_DIREITA);--numero do documento
          vl_linha := vl_linha || sc_arq.preencher(20,rg.cd_ccb,' ',ALINHAMENTO_A_DIREITA);--identificacao do titulo no banco
          vl_linha := vl_linha || TO_CHAR(rg.dt_vnc_ccb,'DDMMYY'); -- Data vencimento titulo
          vl_linha := vl_linha || sc_arq.formatar_moeda(13,rg.vlr_ccb); -- Valor do titulo
          vl_linha := vl_linha || '237'; -- Banco Cobrador
          vl_linha := vl_linha || '04452'; -- Agencia Cobradora
          vl_linha := vl_linha || '  '; -- Espécie do título
          vl_linha := vl_linha || sc_arq.formatar_moeda(13,0); -- Despesas Despesas
          vl_linha := vl_linha || sc_arq.formatar_moeda(13,0); -- Outras Despesas
          vl_linha := vl_linha || sc_arq.formatar_moeda(13,0); -- Juros Operacao em Atraso
          vl_linha := vl_linha || sc_arq.formatar_moeda(13,0); -- IOF
          vl_linha := vl_linha || sc_arq.formatar_moeda(13,0); -- ABATIMENTO
          vl_linha := vl_linha || sc_arq.formatar_moeda(13,0); -- DESCONTO CONCEDIDO
          vl_linha := vl_linha || sc_arq.formatar_moeda(13,rg.vlr_ccb); -- VALOR PAGO
          vl_linha := vl_linha || sc_arq.formatar_moeda(13,0); -- JUROS DE MORA
          vl_linha := vl_linha || sc_arq.formatar_moeda(13,0); -- OUTROS CREDITOS
          vl_linha := vl_linha || '  ';
          vl_linha := vl_linha || ' '; -- MOTIVO DO CODIGO DE OCORRENCIA 25
	  vl_linha := vl_linha || to_char(rg.dt_rps_ccb,'ddmmyy'); -- Data do credito	  
          vl_linha := vl_linha || sc_arq.preencher(3,' ',' ',ALINHAMENTO_A_DIREITA); -- Origem Pagamento
          vl_linha := vl_linha || sc_arq.preencher(10,' ',' ',ALINHAMENTO_A_DIREITA); -- Brancos
          vl_linha := vl_linha || sc_arq.preencher(4,' ',' ',ALINHAMENTO_A_DIREITA); -- Código do Banco
          vl_linha := vl_linha || sc_arq.preencher(10,'0','0',ALINHAMENTO_A_DIREITA); -- motivo das rejeicoes
          vl_linha := vl_linha || sc_arq.preencher(40,' ',' ',ALINHAMENTO_A_DIREITA); -- Brancos
          vl_linha := vl_linha || sc_arq.preencher(2,' ',' ',ALINHAMENTO_A_DIREITA); -- numero do cartorio
          vl_linha := vl_linha || sc_arq.preencher(10,' ',' ',ALINHAMENTO_A_DIREITA); -- numero do protocolo
          vl_linha := vl_linha || sc_arq.preencher(14,' ',' ',ALINHAMENTO_A_DIREITA); -- Brancos
          vl_linha := vl_linha || sc_arq.preencher(6,vl_sequencial,'0',ALINHAMENTO_A_ESQUERDA); -- SEQUENCIAL
          
	  perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);
	  vl_total = vl_total + rg.vlr_ccb;
  end loop;  

        vl_linha := '';
        vl_linha := '9201237';        
        vl_linha := vl_linha || sc_arq.preencher(10,' ',' ',ALINHAMENTO_A_DIREITA); -- Brancos
        vl_linha := vl_linha || sc_arq.preencher(8,vl_sequencial - 1,' ',ALINHAMENTO_A_DIREITA); -- Quantidade de titulos
        vl_linha := vl_linha || sc_arq.formatar_moeda(14,vl_total); -- Valor total cobranca
        vl_linha := vl_linha || sc_arq.preencher(8,6,'0',ALINHAMENTO_A_ESQUERDA); -- Nr Do Aviso
        vl_linha := vl_linha || sc_arq.preencher(10,' ',' ',ALINHAMENTO_A_DIREITA); -- Brancos
        vl_linha := vl_linha || sc_arq.preencher(5,'0','0',ALINHAMENTO_A_DIREITA); -- Quantidade de registros tipo 02
        vl_linha := vl_linha || sc_arq.preencher(12,'0','0',ALINHAMENTO_A_DIREITA); -- Valor dos Registros tipo 02
        vl_linha := vl_linha || sc_arq.formatar_moeda(12,vl_total); -- Valor dos registros tipo 06
        vl_linha := vl_linha || sc_arq.preencher(5,vl_sequencial - 1,'0',ALINHAMENTO_A_ESQUERDA); -- Quantidade dos registros tipo 06
        vl_linha := vl_linha || sc_arq.formatar_moeda(12,vl_total); -- Valor dos registros tipo 06
        vl_linha := vl_linha || sc_arq.preencher(5,'0','0',ALINHAMENTO_A_DIREITA); -- 
        vl_linha := vl_linha || sc_arq.preencher(12,'0','0',ALINHAMENTO_A_DIREITA); --
        vl_linha := vl_linha || sc_arq.preencher(5,'0','0',ALINHAMENTO_A_DIREITA); -- 
        vl_linha := vl_linha || sc_arq.preencher(12,'0','0',ALINHAMENTO_A_DIREITA); --
        vl_linha := vl_linha || sc_arq.preencher(5,'0','0',ALINHAMENTO_A_DIREITA); -- 
        vl_linha := vl_linha || sc_arq.preencher(12,'0','0',ALINHAMENTO_A_DIREITA); --
        vl_linha := vl_linha || sc_arq.preencher(5,'0','0',ALINHAMENTO_A_DIREITA); -- 
        vl_linha := vl_linha || sc_arq.preencher(12,'0','0',ALINHAMENTO_A_DIREITA); --
        vl_linha := vl_linha || sc_arq.preencher(5,'0','0',ALINHAMENTO_A_DIREITA); -- 
        vl_linha := vl_linha || sc_arq.preencher(12,'0','0',ALINHAMENTO_A_DIREITA); --
        vl_linha := vl_linha || sc_arq.preencher(174,' ',' ',ALINHAMENTO_A_DIREITA); --
        vl_linha := vl_linha || sc_arq.preencher(15,'0','0',ALINHAMENTO_A_DIREITA); --
        vl_linha := vl_linha || sc_arq.preencher(8,'0','0',ALINHAMENTO_A_DIREITA); --
        vl_linha := vl_linha || sc_arq.preencher(9,' ',' ',ALINHAMENTO_A_DIREITA); --
        vl_linha := vl_linha || sc_arq.preencher(6,vl_sequencial+1,'0',ALINHAMENTO_A_ESQUERDA); -- SEQUENCIAL
        perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);


  
  insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_arquivo,now(),vp_data,14,1);     
  
end$$;


ALTER FUNCTION sc_ccb.gerar_arquivo_baixa_adicional_cnab(vp_data date) OWNER TO postgres;

--
-- TOC entry 1697 (class 1255 OID 1000853)
-- Name: gerar_arquivo_baixa_adicional_periodo(date, date); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION gerar_arquivo_baixa_adicional_periodo(vp_data_inicial date, vp_data_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_data date;
begin

   vl_data := vp_data_inicial;
   
   while vl_data <=vp_data_final loop
   
      perform sc_ccb.gerar_arquivo_baixa_adicional(vl_data);
      vl_data := vl_data + interval '1 day';
      
   end loop;
           
end$$;


ALTER FUNCTION sc_ccb.gerar_arquivo_baixa_adicional_periodo(vp_data_inicial date, vp_data_final date) OWNER TO scan;

--
-- TOC entry 1768 (class 1255 OID 1666465)
-- Name: gerar_arquivo_baixa_parcial_adicional(); Type: FUNCTION; Schema: sc_ccb; Owner: postgres
--

CREATE FUNCTION gerar_arquivo_baixa_parcial_adicional() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   vl_rg record;
   vl_nome_arquivo varchar;
   vl_local_arquivo varchar;
   vl_linha varchar;

   CT_CCBS_BAIXAS_PARCIAIS constant integer := 17;

   vl_diretorio varchar;
begin
  select dir_tda
  into vl_diretorio
  from sc_dwn.tbl_tda
  where cd_tda = CT_CCBS_BAIXAS_PARCIAIS;
  
  vl_nome_arquivo := 'BAIXAS_PARCIAIS_'|| to_char(current_date, 'yyyymmdd') || '.CSV';
  vl_local_arquivo := vl_diretorio || '\\' || vl_nome_arquivo;

  --GARANTINDO QUE O SISTEMA NÃO IRÁ ADICIONAR LINHAS A ARQUIVOS JÁ EXISTENTES, GARANTE A CONSISTENCIA EM RELAÇÃO A REPROCESSAMENTO
  begin
    perform sc_arq.excluirarquivo(vl_local_arquivo);
  exception
    when others then
      raise notice 'ocorreu um erro ao tentar apagar o arquivo: %, descricao do erro: %', vl_local_arquivo, sqlerrm;
  end;
  
  perform sc_arq.gravarlinha(vl_local_arquivo, 'DATA_GERACAO;CODIGO;CARTAO;VALOR_CCB;VALOR_JUROS;VALOR_IOF;VALOR_TARIFA;VALOR_LIQUIDO;VALOR_COMPRA;DATA_VENCIMENTO;'||
                                               'NOME;VALOR_PAGO;VALOR_MULTA_POR_ATRASO;CPF;VALOR_PAGO_JUROS;VALOR_PAGO_MULTA;VALOR_PAGO_PRINCIPAL;CESSIONARIO');

  for vl_rg in select to_char(ccb.dt_inc_ccb, 'dd/MM/yyyy') as data_geracao, ccb.cd_ccb as codigo, 
		       pls.cd_crt as cartao, ccb.vlr_ccb as valor_ccb, opr.vl_jrs_opr as valor_juros, 
		       opr.vl_iof_opr as valor_iof, opr.vl_trf_opr as valor_tarifa, ccb.vlr_lib_ccb - opr.vl_trf_opr as valor_liquido,
		       ccb.vlr_slc_ccb as valor_compra, to_char(ccb.dt_vnc_ccb, 'dd/MM/yyyy') as data_vencimento,
		       cun.nm_cun as nome, ccb.vl_pgt_ccb as valor_pago, ccb.vlr_jrs_ccb as valor_juros_mora,
		       ccb.vlr_mlt_ccb as valor_multa_por_atraso, cun.nr_cpf_cnpj_cun as cpf, ccb.vl_pgt_jrs_ccb as valor_pago_juros,
		       ccb.vl_pgt_mlt_ccb as valor_pago_multa, ccb.vl_pgt_pri_ccb as valor_pago_principal, csn.nm_csn as cessionario
		from sc_ccb.tbl_ccb ccb
		     inner join sc_ccb.tbl_csn csn on ccb.cd_csn = csn.cd_csn
		     inner join sc_opr.tbl_opr opr on ccb.cd_opr = opr.cd_opr
		     inner join sc_opr.tbl_pls pls on opr.cd_pls = pls.cd_pls
		     inner join sc_opr.tbl_crt crt on pls.cd_crt = crt.cd_crt
		     inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
		     inner join sc_cad.tbl_cun cun on fnc.cd_cun = cun.cd_cun
		where ccb.vlr_sld_dvd_ccb > 0 --possui saldo devedor
		  and ccb.vl_pgt_ccb > 0 --possui algum pagamento
		  and ccb.st_ccb = 1 --situacao cadastrado
		  --and ccb.cd_ccb in (82637, 79877, 32291, 24420, 71558, 191234, 61503, 194979)
		order by codigo loop

	  --DATA_GERACAO
	  vl_linha := vl_rg.data_geracao || ';';
	  
	  --CODIGO
	  vl_linha := vl_linha || vl_rg.codigo || ';';

	  --CARTAO
	  vl_linha := vl_linha || vl_rg.cartao || ';';

	  --VALOR_CCB
	  vl_linha := vl_linha || replace(vl_rg.valor_ccb::varchar,'.',',') || ';';

	  --VALOR_JUROS
	  vl_linha := vl_linha || replace(vl_rg.valor_juros::varchar,'.',',') || ';';

	  --VALOR_IOF
	  vl_linha := vl_linha || replace(vl_rg.valor_iof::varchar,'.',',') || ';';

	  --VALOR_TARIFA
	  vl_linha := vl_linha || replace(vl_rg.valor_tarifa::varchar,'.',',') || ';';

	  --VALOR_LIQUIDO
	  vl_linha := vl_linha || replace(vl_rg.valor_liquido::varchar,'.',',') || ';';

	  --VALOR_COMPRA
	  vl_linha := vl_linha || coalesce(replace(vl_rg.valor_compra::varchar,'.',','), '') || ';';

	  --DATA_VENCIMENTO
	  vl_linha := vl_linha || vl_rg.data_vencimento || ';';

	  --NOME
	  vl_linha := vl_linha || vl_rg.nome || ';';

	  --VALOR_PAGO
	  vl_linha := vl_linha || replace(vl_rg.valor_pago::varchar,'.',',') || ';';

          --VALOR_MULTA_POR_ATRASO
	  vl_linha := vl_linha || coalesce(replace(vl_rg.valor_multa_por_atraso::varchar,'.',','), '') || ';';

	  --CPF
	  vl_linha := vl_linha || vl_rg.cpf || ';';

	  --VALOR_PAGO_JUROS
	  vl_linha := vl_linha || coalesce(replace(vl_rg.valor_pago_juros::varchar,'.',','), '') || ';';

	  --VALOR_PAGO_MULTA
	  vl_linha := vl_linha || coalesce(replace(vl_rg.valor_pago_multa::varchar,'.',','), '') || ';';

	  --VALOR_PAGO_PRINCIPAL
	  vl_linha := vl_linha || coalesce(replace(vl_rg.valor_pago_principal::varchar,'.',','), '') || ';';

	  --CESSIONARIO
	  vl_linha := vl_linha || vl_rg.cessionario;

	  perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);
  end loop;          
  
  insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_arquivo,now(),current_date,CT_CCBS_BAIXAS_PARCIAIS,1);     
  
  
end$$;


ALTER FUNCTION sc_ccb.gerar_arquivo_baixa_parcial_adicional() OWNER TO postgres;

--
-- TOC entry 1658 (class 1255 OID 1000324)
-- Name: gerar_arquivo_remessa_adicional(date); Type: FUNCTION; Schema: sc_ccb; Owner: postgres
--

CREATE FUNCTION gerar_arquivo_remessa_adicional(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   rg record;
   vl_nome_arquivo varchar;
   vl_local_arquivo varchar;
   vl_linha varchar;

   vl_diretorio varchar;
begin

  select dir_tda
  into vl_diretorio
  from sc_dwn.tbl_tda
  where cd_tda = 13;


  
  vl_nome_arquivo := 'REM_ADICIONAL_CCB_'|| to_char(vp_data, 'ddmmyyyy') || '.CSV';
  vl_local_arquivo := vl_diretorio || '\\' || vl_nome_arquivo;
--  perform sc_arq.gravarlinha(vl_local_arquivo, 'CODIGO;CESSIONARIO;SACADO;SITUACAO;DATA DA GERACAO;DATA VENCIMENTO;DATA LIQUIDACAO;DATA REPASSE;VALOR_CCB;VALOR LIQUIDO;VALOR TARIFA;VALOR JUROS;VALOR IOF; MORA;MULTA');
--  perform sc_arq.gravarlinha(vl_local_arquivo, 'DATA_GERACAO;CODIGO;VALOR_CCB;VALOR_IOF;VALOR_JUROS;VALOR_TARIFA;VALOR_LIQUIDO;VALOR_COMPRA;DATA_VENCIMENTO;SACADO;DATA_REPASSE;VALOR_PAGAMENTO;MORA;MULTA;SITUACAO;CPF');
  perform sc_arq.gravarlinha(vl_local_arquivo, 'DATA_GERACAO;CODIGO;VALOR_CCB;VALOR_COMPRA;DATA_VENCIMENTO;SACADO;LOGRADOURO;BAIRRO;LOCALIDADE;UF;CEP;DATA_REPASSE;VALOR_PAGAMENTO;MORA;MULTA;SITUACAO;CPF');
  

  for rg in select ccb.dt_inc_ccb::date,
	           ccb.cd_ccb,
	           vlr_ccb,
	           opr.vl_jrs_opr,
	           ccb.vlr_iof_ccb,
	           opr.vl_trf_opr,
	           opr.vl_opr - opr.vl_trf_opr - opr.vl_iof_opr - opr.vl_jrs_opr valor_liquido,
	           opr.vl_opr - opr.vl_jrs_opr valor_compra,
	           dt_vnc_ccb,
	           cun.nm_cun,
	           ccb.dt_rps_Ccb,
	           ccb.vl_pgt_ccb,
	           ccb.vlr_jrs_ccb,
	           ccb.vlr_mlt_ccb,
	           dmn.nm_vlr_dmn st_ccb,
	           cun.nr_cpf_cnpj_cun,
	           edr.logradouro,
	           edr.bairro,
	           edr.localidade,
	           edr.uf,
	           edr.cep_edr,
	           edr.nr_edr
            from sc_ccb.tbl_ccb ccb
              inner join sc_ccb.tbl_csn csn on csn.cd_csn = ccb.cd_csn
              inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
              inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
              inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
              inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
              inner join sc_cad.tbl_dmn dmn on dmn.nm_cmp_dmn = 'ST_CCB' AND dmn.vl_cmp_dmn = ccb.st_ccb
              left join sc_cad.vw_edr edr on edr.cd_cun = cun.cd_cun and edr.fg_atv_edr = 'S'
            where ccb.cd_csn = 3
              and (edr.cd_edr is null or edr.cd_edr = (select max(cd_edr) 
				from sc_cad.vw_edr e 
				where e.cd_cun = cun.cd_cun 
				  and e.fg_atv_edr = 'S'))  loop
            
	  vl_linha := '';
	  vl_linha := vl_linha || to_char(rg.dt_inc_ccb,'dd-mm-yyyy') || ';';
	  vl_linha := vl_linha || rg.cd_ccb || ';';
	  vl_linha := vl_linha || replace(rg.vlr_ccb::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(rg.valor_compra::varchar,'.',',') || ';';
	  vl_linha := vl_linha || to_char(rg.dt_vnc_ccb,'dd-mm-yyyy') || ';';
	  vl_linha := vl_linha || rg.nm_cun || ';';
	  
	  vl_linha := vl_linha || rg.logradouro || ' - ' ||rg.nr_edr ||';';
	  vl_linha := vl_linha || rg.bairro || ';';
	  vl_linha := vl_linha || rg.localidade || ';';
	  vl_linha := vl_linha || rg.uf || ';';
	  vl_linha := vl_linha || rg.cep_edr || ';';
	  
	  vl_linha := vl_linha || coalesce(to_char(rg.dt_rps_ccb,'dd-mm-yyyy'),'')  || ';';
	  vl_linha := vl_linha || coalesce(replace(rg.vl_pgt_ccb::varchar,'.',','),'') || ';';
	  vl_linha := vl_linha || replace(coalesce(rg.vlr_jrs_ccb,0)::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(coalesce(rg.vlr_mlt_ccb,0)::varchar,'.',',') || ';';
	  vl_linha := vl_linha || rg.st_ccb || ';';
	  vl_linha := vl_linha || rg.nr_cpf_cnpj_cun;

	  perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);
  end loop;          
  insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_arquivo,now(),vp_data,13,1);     
  
end$$;


ALTER FUNCTION sc_ccb.gerar_arquivo_remessa_adicional(vp_data date) OWNER TO postgres;

--
-- TOC entry 1698 (class 1255 OID 1000852)
-- Name: gerar_arquivo_remessa_adicional_periodo(date, date); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION gerar_arquivo_remessa_adicional_periodo(vp_data_inicial date, vp_data_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_data date;
begin

   vl_data := vp_data_inicial;
   
   while vl_data <=vp_data_final loop
   
      perform sc_ccb.gerar_arquivo_remessa_adicional_sem_endereco(vl_data);
      vl_data := vl_data + interval '1 day';
      
   end loop;
           
end$$;


ALTER FUNCTION sc_ccb.gerar_arquivo_remessa_adicional_periodo(vp_data_inicial date, vp_data_final date) OWNER TO scan;

--
-- TOC entry 1612 (class 1255 OID 1009987)
-- Name: gerar_arquivo_remessa_adicional_sem_endereco(date); Type: FUNCTION; Schema: sc_ccb; Owner: postgres
--

CREATE FUNCTION gerar_arquivo_remessa_adicional_sem_endereco(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   rg record;
   vl_nome_arquivo varchar;
   vl_local_arquivo varchar;
   vl_linha varchar;

   vl_diretorio varchar;
begin

  select dir_tda
  into vl_diretorio
  from sc_dwn.tbl_tda
  where cd_tda = 13;


  
  vl_nome_arquivo := 'REM_ADICIONAL_CCB_'|| to_char(vp_data, 'ddmmyyyy') || '.CSV';
  vl_local_arquivo := vl_diretorio || '\\' || vl_nome_arquivo;
  
  --GARANTINDO QUE O SISTEMA NÃO IRÁ ADICIONAR LINHAS A ARQUIVOS JÁ EXISTENTES, GARANTE A CONSISTENCIA EM RELAÇÃO A REPROCESSAMENTO
  begin
    perform sc_arq.excluirarquivo(vl_local_arquivo);
  exception
    when others then
      raise notice 'ocorreu um erro ao tentar apagar o arquivo: %, descricao do erro: %', vl_local_arquivo, sqlerrm;
  end;
  
--  perform sc_arq.gravarlinha(vl_local_arquivo, 'CODIGO;CESSIONARIO;SACADO;SITUACAO;DATA DA GERACAO;DATA VENCIMENTO;DATA LIQUIDACAO;DATA REPASSE;VALOR_CCB;VALOR LIQUIDO;VALOR TARIFA;VALOR JUROS;VALOR IOF; MORA;MULTA');
--  perform sc_arq.gravarlinha(vl_local_arquivo, 'DATA_GERACAO;CODIGO;VALOR_CCB;VALOR_IOF;VALOR_JUROS;VALOR_TARIFA;VALOR_LIQUIDO;VALOR_COMPRA;DATA_VENCIMENTO;SACADO;DATA_REPASSE;VALOR_PAGAMENTO;MORA;MULTA;SITUACAO;CPF');
  --perform sc_arq.gravarlinha(vl_local_arquivo, 'DATA_GERACAO;CODIGO;VALOR_CCB;VALOR_IOF;VALOR_JUROS;VALOR_TARIFA;VALOR_LIQUIDO;VALOR_COMPRA;DATA_VENCIMENTO;SACADO;DATA_REPASSE;VALOR_PAGAMENTO;MORA;MULTA;SITUACAO;CPF');
  perform sc_arq.gravarlinha(vl_local_arquivo, 'DATA_GERACAO;CODIGO;VALOR_CCB;VALOR_IOF;VALOR_JUROS;VALOR_TARIFA;VALOR_LIQUIDO;VALOR_COMPRA;DATA_VENCIMENTO;SACADO;LOGRADOURO;BAIRRO;LOCALIDADE;UF;CEP;DATA_REPASSE;VALOR_PAGAMENTO;MORA;MULTA;SITUACAO;CPF');
  

  for rg in select ccb.dt_inc_ccb::date,
	           ccb.cd_ccb,
	           vlr_ccb,
	           opr.vl_jrs_opr,
	           ccb.vlr_iof_ccb,
	           opr.vl_trf_opr,
	           opr.vl_opr - opr.vl_trf_opr - opr.vl_iof_opr - opr.vl_jrs_opr valor_liquido,
	           opr.vl_opr - opr.vl_jrs_opr valor_compra,
	           dt_vnc_ccb,
	           cun.nm_cun,
	           ccb.dt_rps_Ccb,
	           ccb.vl_pgt_ccb,
	           ccb.vlr_jrs_ccb,
	           ccb.vlr_mlt_ccb,
	           dmn.nm_vlr_dmn st_ccb,
	           cun.nr_cpf_cnpj_cun
            from sc_ccb.tbl_ccb ccb
              inner join sc_ccb.tbl_csn csn on csn.cd_csn = ccb.cd_csn
              inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
              inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
              inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
              inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
              inner join sc_cad.tbl_dmn dmn on dmn.nm_cmp_dmn = 'ST_CCB' AND dmn.vl_cmp_dmn = ccb.st_ccb
              --left join sc_cad.vw_edr edr on edr.cd_cun = cun.cd_cun and edr.fg_atv_edr = 'S'
            where dt_inc_ccb::date = vp_data loop
            
	  vl_linha := '';
	  vl_linha := vl_linha || to_char(rg.dt_inc_ccb,'dd-mm-yyyy') || ';';
	  vl_linha := vl_linha || rg.cd_ccb || ';';
	  vl_linha := vl_linha || replace(rg.vlr_ccb::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(rg.vlr_iof_ccb::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(rg.vl_jrs_opr::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(rg.vl_trf_opr::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(rg.valor_liquido::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(rg.valor_compra::varchar,'.',',') || ';';
	  vl_linha := vl_linha || to_char(rg.dt_vnc_ccb,'dd-mm-yyyy') || ';';
	  vl_linha := vl_linha || rg.nm_cun || ';';
	  
	  vl_linha := vl_linha || ';;;;;';--ENDERECO
	  	  
	  vl_linha := vl_linha || coalesce(to_char(rg.dt_rps_ccb,'dd-mm-yyyy'),'')  || ';';
	  vl_linha := vl_linha || coalesce(replace(rg.vl_pgt_ccb::varchar,'.',','),'') || ';';
	  vl_linha := vl_linha || replace(coalesce(rg.vlr_jrs_ccb,0)::varchar,'.',',') || ';';
	  vl_linha := vl_linha || replace(coalesce(rg.vlr_mlt_ccb,0)::varchar,'.',',') || ';';
	  vl_linha := vl_linha || rg.st_ccb || ';';
	  vl_linha := vl_linha || rg.nr_cpf_cnpj_cun;

	  perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);
  end loop;          
  insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_arquivo,now(),vp_data,13,1);     
  
end$$;


ALTER FUNCTION sc_ccb.gerar_arquivo_remessa_adicional_sem_endereco(vp_data date) OWNER TO postgres;

--
-- TOC entry 1576 (class 1255 OID 885453)
-- Name: gerar_ccb(); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION gerar_ccb() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  ct_cessionario_padrao numeric := 3;

  rg record;
  vl_data_vencimento date;
  vl_diferenca numeric;
  vl_valor_solicitado numeric;
  vl_valor_iof numeric;
  vl_valor_ccb numeric;
  vl_valor_liberado numeric;
  
  retorno_parcela record;
begin

   for rg in select opr.cd_opr,dtv.vl_dtv,opr.dt_opr,opr.vl_opr,opr.vl_trf_opr,opr.vl_jrs_opr,opr.vl_iof_opr,prc.dt_vnc_prc
             from sc_opr.tbl_opr opr
               inner join sc_fcr.tbl_prc prc on prc.cd_opr = opr.cd_opr
	       inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
	       inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
	       inner join sc_opr.tbl_tvt tvt on tvt.cd_tvt = crt.cd_tvt
	       inner join sc_opr.tbl_dtv dtv on dtv.cd_tvt = tvt.cd_tvt       
             where dt_opr::date >= '08-09-2016'
               and opr.cd_top = 5
               and opr.st_opr = 2
	       and dtv.cd_top = 5
	       and dtv.tp_cbr_dtv = 1
	       and dt_opr<current_date
               and not exists(select 1 
                              from sc_ccb.tbl_ccb 
                              where cd_opr = opr.cd_opr) loop

           -- Calculando data de vencimento
           vl_diferenca := rg.dt_vnc_prc::date - rg.dt_opr::date;
           vl_data_vencimento := current_date + vl_diferenca::int;

           vl_valor_solicitado := rg.vl_opr - (rg.vl_iof_opr + rg.vl_jrs_opr);
           --sc_calc.calcula_valor_parcela(IN vp_data_base date, IN vp_data_venc_primeira date, IN vp_taxa_juros numeric, IN vp_valor_tarifa numeric, IN vp_qt_prestacoes numeric, IN vp_vl_financiado numeric, OUT vr_vl_iof numeric, OUT vr_vl_parcela numeric, OUT vr_vl_cet numeric)

	   select * from sc_calc.calcula_valor_parcela(current_date, vl_data_vencimento, rg.vl_dtv, 0, 1, vl_valor_solicitado)
	   into retorno_parcela;

	    vl_valor_iof := retorno_parcela.vr_vl_iof;
	    vl_valor_ccb := retorno_parcela.vr_vl_parcela;   
	    vl_valor_liberado := vl_valor_solicitado;


	    vl_valor_solicitado := vl_valor_solicitado + vl_valor_iof;

           insert into sc_ccb.tbl_ccb(cd_ccb,cd_opr,cd_csn,vlr_ccb,vlr_org_ccb,st_ccb,dt_inc_ccb,dt_vnc_ccb,vlr_sld_dvd_ccb,vlr_slc_ccb,vlr_lib_ccb,vlr_iof_ccb,vlr_tx_ccb) 
           values(nextval('sc_ccb.sq_ccb'),rg.cd_opr,ct_cessionario_padrao,vl_valor_ccb,vl_valor_ccb,1,now(),vl_data_vencimento,vl_valor_ccb,vl_valor_solicitado,vl_valor_liberado,vl_valor_iof, rg.vl_dtv);
           
   end loop;          
end$$;


ALTER FUNCTION sc_ccb.gerar_ccb() OWNER TO scan;

--
-- TOC entry 1581 (class 1255 OID 886652)
-- Name: popula_dados_arquivo_bracce(date); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION popula_dados_arquivo_bracce(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;
vl_rg_edr record;

ct_taxa_fundo constant numeric := 3.0;
ct_vl_tarifa_fundo constant numeric := 0;

ct_tipo_operacao_saque_extra constant numeric := 5;
ct_situacao_operacao_confirmada constant numeric := 2;
ct_tipo_cobranca_juros_saque_extra constant numeric := 1;

ct_cod_nacionalidade constant numeric := 0;

vl_dt_inicio timestamp := vp_data_referencia;
vl_dt_final timestamp := vp_data_referencia;

vl_data_base date;
vl_data_base_util date;
vl_data_vencimento date;
vl_valor_solicitado numeric := 0;
vl_valor_liberado numeric := 0;
-- bracce[1 – Solteiro 2 – Casado 3 – Desquitado 4 – Divorciado 5 – Viúvo 9 – Outros] saq[1 - Solteiro 2 - Casado 3 - Viuvo 4 - Divorciado]
cd_estado_civil numeric;
vl_renda_mensal numeric;
contador numeric;

vr_vl_iof numeric(13,4) := 0;
vr_vl_parcela numeric(13,2) := 0;

ct_regex varchar := '([^a-zA-Z0-9\(\)\. _@<>/:,-])';

retorno_parcela record;
i numeric :=0;

begin

   vl_dt_inicio := vl_dt_inicio;
   --vl_dt_final := vl_dt_final + interval '17 hour';

   for rg in 
   select opr.*, crt.cd_crt, cun.nm_cun, cun.nr_cpf_cnpj_cun, cpf.*, edr.*,
          ccb.dt_vnc_ccb vencimento,ccb.vlr_iof_ccb vl_iof,ccb.vlr_slc_ccb vl_solicitado,ccb.vlr_lib_ccb vl_liberado,ccb.vlr_tx_ccb vl_taxa,
          ccb.vlr_ccb vl_parcela,ccb.dt_inc_ccb dt_base_operacao,opr.dt_opr dt_operacao
     from sc_ccb.tbl_ccb ccb
       inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
       inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
       inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
       inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
       inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
       inner join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
       inner join (select max(cd_edr) as endereco, cd_cun as cadastro 
                   from sc_cad.vw_edr 
                   where fg_atv_edr = 'S'
                   group by cd_cun) as edr_t on edr_t.cadastro = cun.cd_cun
       inner join sc_cad.vw_edr edr on edr_t.endereco = edr.cd_edr 
   where opr.dt_opr < vp_data_referencia 
     and opr.cd_opr not in(1645338,1641249,1771021,1852731,1876222,1692295,1771019) -- Operacoes que nao foram enviadas por erro.
     and not exists(select 1 from sc_aeo.tbl_eop e where e.cd_opr=opr.cd_opr)
   order by opr.cd_opr

  loop
    begin
		select *
		into vl_rg_edr
		from sc_aeo.get_endereco(rg.cd_cun);    

		-- converte estado civil
		cd_estado_civil := rg.cd_est_civil_cpf;
		if cd_estado_civil = 3 then 
		  cd_estado_civil := 5; 
		end if;

		if cd_estado_civil not in(1,2,3,4,5,9) then
		  cd_estado_civil := 9;
		end if;

		-- calculo da renda mensal
		vl_renda_mensal := sc_adp.valor_media_abastecimento_cartao(rg.cd_crt);

		insert into sc_aeo.tbl_eop (cd_eop,dt_grc_eop, cd_opr, nr_cpf_eop, nm_eop, vl_tx_eop, trf_eop, iof_eop, vl_slc_eop, vl_opr_eop, qtd_prc_eop, vl_prc_eop, vl_lib_eop, dt_opr_eop, dt_vnc_opr_eop, dt_base_eop, dt_vnc_eop, 
									rg_eop, uf_rg_eop, org_ems_rg_eop, dt_ems_rg_eop, cd_est_civ_eop, dt_nsc_eop, cd_nac_eop, cep_eop, log_edr_eop, 
									nr_edr_eop, cpl_edr_eop, brr_edr_eop, loc_edr_eop, uf_edr_eop, rnd_msl_eop, sexo_eop) 
						 values (nextval('sc_aeo.sq_eop'), now(), rg.cd_opr, rg.nr_cpf_cnpj_cun, sc_pbl.sem_acento(rg.nm_cun), rg.vl_taxa, ct_vl_tarifa_fundo, rg.vl_iof, rg.vl_solicitado, rg.vl_parcela, 1, rg.vl_parcela, rg.vl_liberado, rg.dt_operacao, rg.vencimento, rg.dt_base_operacao, rg.vencimento,
								 rg.nr_rg_cpf, rg.uf_org_ems_rg_cpf, regexp_replace(sc_pbl.sem_acento(rg.nm_org_ems_rg_cpf),ct_regex,'','g'), rg.dt_ems_rg_cpf, cd_estado_civil, rg.dt_nsc_cpf, ct_cod_nacionalidade, vl_rg_edr.cep_edr, regexp_replace(sc_pbl.sem_acento(vl_rg_edr.logradouro),ct_regex,'','g'),
								 vl_rg_edr.nr_edr, regexp_replace(sc_pbl.sem_acento(vl_rg_edr.cpl_edr),ct_regex,'','g'), regexp_replace(sc_pbl.sem_acento(vl_rg_edr.bairro),ct_regex,'','g'), regexp_replace(sc_pbl.sem_acento(vl_rg_edr.localidade),ct_regex,'','g'), vl_rg_edr.uf, vl_renda_mensal, rg.sexo_cpf);
    exception
	  when others then
	    raise notice 'POPULA_DADOS_ARQUIVO_BRACCE - ocorreu um problema ao processar a cco da operação: %, cliente: %, cpf: %, problema: %',
		    rg.cd_opr, rg.nm_cun, rg.nr_rg_cpf, SQLERRM;
	end;
  end loop;

  
end$$;


ALTER FUNCTION sc_ccb.popula_dados_arquivo_bracce(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1598 (class 1255 OID 910870)
-- Name: processar_ccbs_antigas(date); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION processar_ccbs_antigas(vp_data_ref date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  rg_p record;

  vl_pagamento numeric := 0;
  vl_outras_receitas numeric := 0;
  vl_situacao numeric;
  vl_dt_liquidacao date;
  vl_sld_dvd_ccb numeric;
  vl_cod_ccb numeric;
  vl_ccb numeric;
  vl_data_rps_ccb date;
  
begin

    if( not sc_grl.eh_dia_util(vp_data_ref)) then
       return ;
    end if;   

    for rg in select *
              from sc_ccb.tbl_ccb_ant
              where dt_vnc_ccb <= vp_data_ref
                and dt_rps_ccb is null loop

        if rg.st_ccb = 2 then -- Se liquidada
           perform sc_cnt.lancar_debito_credito(117356, 132562, 1415, null,'REF A REPASSE DIA '||TO_CHAR(VP_DATA_REF,'DD/MM/YYYY'),rg.vlr_ccb,VP_DATA_REF,1,31,TO_CHAR(VP_DATA_REF,'YYYYMM')::numeric);
        else
           if(coalesce(rg.vl_pgt_ccb,0) > 0) then
              perform sc_cnt.lancar_debito_credito(117356, 132562, 1415,null,'REF A REPASSE DIA '||TO_CHAR(VP_DATA_REF,'DD/MM/YYYY'), rg.vl_pgt_ccb, VP_DATA_REF,1,31,TO_CHAR(VP_DATA_REF,'YYYYMM')::numeric);
              perform sc_cnt.lancar_debito_credito(132729, 132562, 1415,null,'REF A REPASSE DIA '||TO_CHAR(VP_DATA_REF,'DD/MM/YYYY'), rg.vlr_ccb - rg.vl_pgt_ccb,VP_DATA_REF,1,31, TO_CHAR(VP_DATA_REF,'YYYYMM')::numeric);   
           else
              perform sc_cnt.lancar_debito_credito(132729, 132562, 1415,null,'REF A REPASSE DIA '||TO_CHAR(VP_DATA_REF,'DD/MM/YYYY')::varchar,rg.vlr_ccb,VP_DATA_REF,1,31,TO_CHAR(VP_DATA_REF,'YYYYMM')::numeric);
           end if;
        end if;

        update sc_ccb.tbl_ccb_ant 
           set dt_rps_ccb = vp_data_ref 
        where dt_vnc_ccb <= vp_data_ref 
          and dt_rps_ccb is null;
          
    end loop;

    for rg_p in select pp.vl_pfc_prc,
                       --ca.vlr_sld_dvd_ccb,
                       --ca.cd_ccb,
                       pfc.dt_rcb_pfc,
                       pfc.cd_pfc,
                       --ca.vlr_ccb,
                       --ca.dt_rps_ccb
                       ca.cd_opr
                from sc_fcr.tbl_pfc_prc pp 
                  inner join sc_fcr.tbl_pfc pfc on pfc.cd_pfc = pp.cd_pfc
                  inner join sc_fcr.tbl_prc prc on prc.cd_prc = pp.cd_prc
                  inner join sc_ccb.tbl_ccb_ant ca on ca.cd_opr = prc.cd_opr
                where pfc.dt_rcb_pfc < vp_data_ref
                  and not exists(select 1 from sc_ccb.tbl_ccb_pfc_ant where cd_pfc = pp.cd_pfc) 
                order by  pfc.dt_rcb_pfc loop

       select ca.vlr_sld_dvd_ccb,ca.cd_ccb,ca.vlr_ccb,ca.dt_rps_ccb
       into vl_sld_dvd_ccb,vl_cod_ccb,vl_ccb,vl_data_rps_ccb       
       from sc_ccb.tbl_ccb_ant ca
       where cd_opr = rg_p.cd_opr;         

       if rg_p.vl_pfc_prc >= vl_sld_dvd_ccb then
          vl_pagamento := vl_sld_dvd_ccb;
          vl_outras_receitas := rg_p.vl_pfc_prc - coalesce(vl_sld_dvd_ccb,0);
       else
          vl_pagamento := rg_p.vl_pfc_prc;
          vl_outras_receitas := 0;
       end if;

       if(vl_sld_dvd_ccb - vl_pagamento = 0)then
         vl_situacao = 2;
         vl_dt_liquidacao := vp_data_ref;
       else
         vl_situacao := 1;
         vl_dt_liquidacao := null;
       end if;

       if(vl_pagamento > 0) then
       
	       update sc_ccb.tbl_ccb_ant 
	       set vl_pgt_ccb  = coalesce(vl_pgt_ccb,0) + vl_pagamento,
		   vlr_sld_dvd_ccb = coalesce(vlr_sld_dvd_ccb,0) - vl_pagamento,
		   dt_lqd_ccb = vl_dt_liquidacao,
		   st_ccb =  vl_situacao
	       where cd_ccb = vl_cod_ccb;

	       if vl_data_rps_ccb is null then
	          perform sc_cnt.lancar_debito_credito(66155,117356,1414,null,'REF A BAIXA CCB NR '||vl_cod_ccb,vl_pagamento,vp_data_ref,1,30,vl_cod_ccb);
	       else
	          perform sc_cnt.lancar_debito_credito(66155,132729,1414,null,'REF A BAIXA CCB NR '||vl_cod_ccb,vl_pagamento,vp_data_ref,1,30,vl_cod_ccb);
	       end if;
	       
       end if;

       insert into sc_ccb.tbl_ccb_pfc_ant values(vl_cod_ccb,rg_p.cd_pfc,null,null,vl_pagamento,vp_data_ref,rg_p.dt_rcb_pfc,nextval('sc_ccb.sq_ccb_pfc_ant'));    

       if vl_outras_receitas > 0 then
       
          perform sc_cnt.lancar_debito_credito(66155,132732,1414,null,'REF A BAIXA CCB NR '||vl_cod_ccb,vl_outras_receitas,vp_data_ref,1,30,vl_cod_ccb);
          
       end if;
                
    end loop;            

end$$;


ALTER FUNCTION sc_ccb.processar_ccbs_antigas(vp_data_ref date) OWNER TO scan;

--
-- TOC entry 1782 (class 1255 OID 993574)
-- Name: processar_pagamentos_ccb(date, numeric); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION processar_pagamentos_ccb(vp_data_referencia date, vp_ccb numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg_multa_juros record;
  rg_principal record;
begin

    for rg_multa_juros in select ccb.cd_ccb,
                                 pp.cd_pfc,
                                 pp.vl_pfc_prc
		          from sc_fcr.tbl_pfc_prc pp
		            inner join sc_fcr.tbl_pfc pfc on pfc.cd_pfc = pp.cd_pfc
		            inner join sc_fcr.tbl_prc prc on prc.cd_prc = pp.cd_prc
		            inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr 
		            inner join sc_ccb.tbl_ccb ccb on ccb.cd_opr = opr.cd_pai_opr
		          where not exists(select 1 
			   	          from sc_ccb.tbl_ccb_pfc cp 
				          where pp.cd_pfc = cp.cd_pfc)
                              and ccb.cd_ccb = coalesce(vp_ccb, ccb.cd_ccb)
			      and pfc.dt_rcb_pfc::date < vp_data_referencia
                              and pfc.dt_rcb_pfc::date >= vp_data_referencia - 15
			      and opr.cd_top = 23
			      and pfc.st_pfc = 1
			      and ccb.st_ccb = 1
			      and ccb.cd_ccb not in(118084,168492,179728,239445)
			    order by ccb.cd_ccb,pfc.cd_pfc     loop

       perform sc_ccb.realizar_baixa_ccb(rg_multa_juros.cd_ccb,rg_multa_juros.cd_pfc,rg_multa_juros.vl_pfc_prc);
                

     end loop;                


    for rg_principal in select ccb.cd_ccb,
                                pp.cd_pfc,
                                pp.vl_pfc_prc
		          from sc_fcr.tbl_pfc_prc pp
		            inner join sc_fcr.tbl_pfc pfc on pfc.cd_pfc = pp.cd_pfc
		            inner join sc_fcr.tbl_prc prc on prc.cd_prc = pp.cd_prc
		            inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr 
		            inner join sc_ccb.tbl_ccb ccb on ccb.cd_opr = opr.cd_opr
		          where not exists(select 1 
			   	          from sc_ccb.tbl_ccb_pfc cp 
				          where pp.cd_pfc = cp.cd_pfc
				          and coalesce(cp.vl_pgt_prc_ccb_pfc > 0))
                              --and ccb.cd_ccb = coalesce(vp_ccb, ccb.cd_ccb)
                              and case when vp_ccb is not null then ccb.cd_ccb = vp_ccb else true end
			      and pfc.dt_rcb_pfc::date < vp_data_referencia
                              and pfc.dt_rcb_pfc::date >= vp_data_referencia - 15
			      and opr.cd_top = 5
			      and pfc.st_pfc = 1
			      and ccb.st_ccb = 1
			      and ccb.cd_ccb not in(118084,168492,179728,239445)
			    order by ccb.cd_ccb,pfc.cd_pfc     loop

       perform sc_ccb.realizar_baixa_ccb(rg_principal.cd_ccb,rg_principal.cd_pfc,rg_principal.vl_pfc_prc);
                

     end loop;                     
               
end$$;


ALTER FUNCTION sc_ccb.processar_pagamentos_ccb(vp_data_referencia date, vp_ccb numeric) OWNER TO scan;

--
-- TOC entry 1630 (class 1255 OID 887872)
-- Name: processar_pagamentos_ccb_OLD(date); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION "processar_pagamentos_ccb_OLD"(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg_multa_juros record;
  rg_principal record;
begin

    for rg_multa_juros in select ccb.cd_ccb,
                                 pp.cd_pfc,
                                 pp.vl_pfc_prc
		          from sc_fcr.tbl_pfc_prc pp
		            inner join sc_fcr.tbl_pfc pfc on pfc.cd_pfc = pp.cd_pfc
		            inner join sc_fcr.tbl_prc prc on prc.cd_prc = pp.cd_prc
		            inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr 
		            inner join sc_ccb.tbl_ccb ccb on ccb.cd_opr = opr.cd_pai_opr
		          where not exists(select 1 
			   	          from sc_ccb.tbl_ccb_pfc cp 
				          where pp.cd_pfc = cp.cd_pfc)
			      and pfc.dt_rcb_pfc::date < vp_data_referencia
			      and opr.cd_top = 23
			      and pfc.st_pfc = 1
			      and ccb.st_ccb = 1
			    order by ccb.cd_ccb,pfc.cd_pfc     loop

       perform sc_ccb.realizar_baixa_ccb(rg_multa_juros.cd_ccb,rg_multa_juros.cd_pfc,rg_multa_juros.vl_pfc_prc);
                

     end loop;                


    for rg_principal in select ccb.cd_ccb,
                                pp.cd_pfc,
                                pp.vl_pfc_prc
		          from sc_fcr.tbl_pfc_prc pp
		            inner join sc_fcr.tbl_pfc pfc on pfc.cd_pfc = pp.cd_pfc
		            inner join sc_fcr.tbl_prc prc on prc.cd_prc = pp.cd_prc
		            inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr 
		            inner join sc_ccb.tbl_ccb ccb on ccb.cd_opr = opr.cd_opr
		          where not exists(select 1 
			   	          from sc_ccb.tbl_ccb_pfc cp 
				          where pp.cd_pfc = cp.cd_pfc
				          and coalesce(cp.vl_pgt_prc_ccb_pfc > 0))
			      and pfc.dt_rcb_pfc::date < vp_data_referencia
			      and opr.cd_top = 5
			      and pfc.st_pfc = 1
			      and ccb.st_ccb = 1
			    order by ccb.cd_ccb,pfc.cd_pfc     loop

       perform sc_ccb.realizar_baixa_ccb(rg_principal.cd_ccb,rg_principal.cd_pfc,rg_principal.vl_pfc_prc);
                

     end loop;                     
               
end$$;


ALTER FUNCTION sc_ccb."processar_pagamentos_ccb_OLD"(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1283 (class 1255 OID 887666)
-- Name: realizar_baixa_ccb(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION realizar_baixa_ccb(vp_codigo_ccb numeric, vp_codigo_pagamento numeric, vp_valor numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_restante_multa numeric(13,2);
  vl_restante_juros numeric(13,2);
  vl_restante_principal numeric(13,2);
  vl_pagamento_restante numeric(13,2);

  vl_pagamento_multa numeric(13,2);
  vl_pagamento_juros numeric(13,2);
  vl_pagamento_principal numeric(13,2);

  vl_situacao numeric;

  ct_situacao_em_cobranca numeric := 1;
  ct_situacao_liquidada numeric := 2;

  vl_data_liquidacao timestamp;
begin

   select coalesce(vlr_jrs_ccb,0) - coalesce(vl_pgt_jrs_ccb,0),
          coalesce(vlr_mlt_ccb,0) - coalesce(vl_pgt_mlt_ccb,0),
          coalesce(vlr_org_ccb,0) - coalesce(vl_pgt_pri_ccb,0)
   into vl_restante_juros,
        vl_restante_multa,
        vl_restante_principal
   from sc_ccb.tbl_ccb
   where cd_ccb = vp_codigo_ccb;

   if vl_restante_juros + vl_restante_multa + vl_restante_principal <= 0 then
     raise notice 'CCB: %, Valores restantes: juros: %, multa: %, principal: %', vp_codigo_ccb, vl_restante_juros, vl_restante_multa, vl_restante_principal;
     return;
   end if;

   if vl_restante_multa > 0 then

      if vp_valor > vl_restante_multa then
        vl_pagamento_multa := vl_restante_multa;
      else  
        vl_pagamento_multa := vp_valor;
      end if;
       
   end if;

   vl_pagamento_restante := vp_valor - coalesce(vl_pagamento_multa,0);

   if vl_restante_juros > 0 then

      if vl_pagamento_restante > vl_restante_juros then
        vl_pagamento_juros := vl_restante_juros;
      else
        vl_pagamento_juros := vl_pagamento_restante;
      end if;
   
   end if;

   vl_pagamento_restante := vl_pagamento_restante - coalesce(vl_pagamento_juros,0);

   if vl_pagamento_restante > 0 then

     if vl_restante_principal > 0 then

        if vl_pagamento_restante > vl_restante_principal then
	  vl_pagamento_principal := vl_restante_principal;
        else
	  vl_pagamento_principal := vl_pagamento_restante;
        end if;
     
     else
       raise exception 'VALOR DA BAIXA MAIOR QUE O SALDO DEVEDOR DA CCB. COD. CCB: %',vp_codigo_ccb;
     end if;
   
   end if;

   if vl_pagamento_principal = vl_restante_principal then
     vl_situacao := ct_situacao_liquidada;
     vl_data_liquidacao := now();
   else 
     vl_situacao := ct_situacao_em_cobranca;  
   end if;

   insert into sc_ccb.tbl_ccb_pfc(cd_ccb_pfc,cd_ccb,cd_pfc,vl_pgt_jrs_ccb_pfc,vl_pgt_mlt_ccb_pfc,vl_pgt_prc_ccb_pfc, dt_inc_ccb_pfc) 
   values(nextval('sc_ccb.sq_ccb_pfc'),vp_codigo_ccb,vp_codigo_pagamento,vl_pagamento_juros,vl_pagamento_multa,vl_pagamento_principal, now());

   update sc_fcr.tbl_pfc 
   set vl_ttl_pgt_ccb_pfc = coalesce(vl_ttl_pgt_ccb_pfc,0) + 
			    coalesce(vl_pagamento_juros,0) + 
			    coalesce(vl_pagamento_multa,0) + 
			    coalesce(vl_pagamento_principal,0)
   where cd_pfc = vp_codigo_pagamento;			    

   update sc_ccb.tbl_ccb 
   set vl_pgt_ccb = coalesce(vl_pgt_ccb,0) + vp_valor,
       vl_pgt_jrs_ccb = coalesce(vl_pgt_jrs_ccb,0) + coalesce(vl_pagamento_juros,0),
       vl_pgt_mlt_ccb = coalesce(vl_pgt_mlt_ccb,0) + coalesce(vl_pagamento_multa,0),
       vl_pgt_pri_ccb = coalesce(vl_pgt_pri_ccb,0) + coalesce(vl_pagamento_principal,0),
       dt_ult_pgt_ccb = (select dt_pgt_pfc from sc_fcr.tbl_pfc where cd_pfc = vp_codigo_pagamento),
       vlr_sld_dvd_ccb = coalesce(vlr_sld_dvd_ccb,0) - vp_valor,
       st_ccb = vl_situacao,
       dt_lqd_ccb = vl_data_liquidacao
   where cd_ccb = vp_codigo_ccb;       
       

end$$;


ALTER FUNCTION sc_ccb.realizar_baixa_ccb(vp_codigo_ccb numeric, vp_codigo_pagamento numeric, vp_valor numeric) OWNER TO scan;

--
-- TOC entry 1692 (class 1255 OID 997231)
-- Name: repassar_cessionario(date, numeric); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION repassar_cessionario(vp_data_referencia date, vp_cessionario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $_$declare

   ct_situacao_liquidada numeric := 2;
   ct_tipo_lanc_liquidacao_cobr_terc numeric := 1415;
   ct_cnt_credores_diverso_cobranca numeric := 117356;
   ct_cnt_valor_transito_terceiro numeric := 117529;
   ct_sistema_repasse_ccb numeric := 31;

  ct_conta_cbr_principal numeric := 116311;
  ct_conta_cbr_iof numeric := 116310;
  ct_conta_cbr_juros numeric := 116309;
  ct_conta_cbr_tarifa numeric := 116312;
  ct_conta_mandatario_gaia numeric:=116308;

  ct_conta_fornecedor_gaia numeric := 117618;

  ct_tipo_despesa_repasse_principal numeric := 116;
  ct_tipo_despesa_repasse_mora_multa numeric := 117;
  ct_fornecedor_gaia numeric := 298;

  vl_valor_iof numeric;
  vl_valor_principal numeric;
  vl_valor_tarifa numeric;
  vl_valor_juros numeric;
  vl_valor_ccb numeric;  
  vl_mora_multa numeric;
  
   vl_codigo_lancamento numeric;

   vl_a_repassar numeric;

   vl_conta_cobranca numeric;
   vl_conta_liquidacao numeric;
begin

    if(sc_grl.eh_dia_util(current_date)) then
    
	     select sum(ccb.vlr_iof_ccb),
		 sum(ccb.vlr_lib_ccb - coalesce(opr.vl_trf_opr,0)),
		 sum(coalesce(opr.vl_trf_opr,0)),
		 sum(ccb.vlr_org_ccb - ccb.vlr_lib_ccb - ccb.vlr_iof_ccb),
		 sum(ccb.vlr_org_ccb),
		 sum(coalesce(ccb.vlr_jrs_ccb,0)+coalesce(ccb.vlr_mlt_ccb)),
		 csn.cd_cnt_cbr_csn,
		 csn.cd_cnt_lqd_csn
	     into vl_valor_iof,
		vl_valor_principal,
		vl_valor_tarifa,
		vl_valor_juros,
		vl_valor_ccb,
		vl_mora_multa,
		vl_conta_cobranca,
		vl_conta_liquidacao
	     from sc_ccb.tbl_ccb ccb
	       inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
	       inner join sc_ccb.tbl_csn csn on csn.cd_csn = ccb.cd_csn
	     where ccb.cd_csn = vp_cessionario
	       and st_ccb = ct_situacao_liquidada
	       --and dt_vnc_ccb <= vp_data_referencia
	       and dt_rps_ccb is null
	     group by csn.cd_cnt_cbr_csn, csn.cd_cnt_lqd_csn;

	      if coalesce(vl_valor_principal,0) > 0 then 

		      insert into sc_ccb.tbl_rps(cd_rps,dt_rps,vl_prc_rps,vl_jrs_mlt_rps) values(nextval('sc_ccb.sq_rps'),now(),vl_valor_ccb,vl_mora_multa);

		      select sc_cnt.lancar_movimento(vl_codigo_lancamento,null,ct_tipo_lanc_liquidacao_cobr_terc,ct_cnt_credores_diverso_cobranca,'D',vl_valor_ccb,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps')) into vl_codigo_lancamento;
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_principal,'C',vl_valor_principal,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_iof,'C',vl_valor_iof,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_juros,'C',vl_valor_juros,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_tarifa,'C',vl_valor_tarifa,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));

		      vl_codigo_lancamento := null;

		      if coalesce(vl_mora_multa,0) > 0 then	      
			 select sc_cnt.lancar_movimento(vl_codigo_lancamento,null,ct_tipo_lanc_liquidacao_cobr_terc,ct_cnt_credores_diverso_cobranca,'D',coalesce(vl_mora_multa,0),vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps')) into vl_codigo_lancamento;
			 perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_cnt_valor_transito_terceiro,'C',coalesce(vl_mora_multa,0),vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      end if;   

		      update sc_ccb.tbl_ccb
		      set dt_rps_ccb = now(),
			  cd_rps = currval('sc_ccb.sq_rps')
		      where cd_csn = vp_cessionario
			and st_ccb = ct_situacao_liquidada
			--and dt_vnc_ccb <= vp_data_referencia
			and dt_rps_ccb is null;

		     if vp_cessionario = 2 then
			     insert 
			     into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp,cd_cbf)
			     values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_gaia,ct_tipo_despesa_repasse_principal,2,vl_valor_ccb,vp_data_referencia,vp_data_referencia,3,'REF A RECEB COBRANCA DE TERC - GAIA',1,now(),1,1,1,vl_valor_ccb,7669);
		     elsif vp_cessionario = 3 then
			     insert 
			     into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp,cd_cbf)
			     values(nextval('sc_cap.sq_dsp'),1,445,ct_tipo_despesa_repasse_principal,2,vl_valor_ccb,vp_data_referencia,vp_data_referencia,3,'REF A RECEB COBR DE TERC - ADICIONAL',1,now(),1,1,1,vl_valor_ccb,12001);
		     end if; 	     

                     perform sc_cnt.lancar_debito_credito(vl_conta_cobranca,vl_conta_liquidacao,ct_tipo_lanc_liquidacao_cobr_terc,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),vl_valor_ccb,vp_data_referencia,1,ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		     

		     if vl_mora_multa > 0 then
		     
                        if vp_cessionario = 2 then
				insert into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp,cd_cbf)
				values(nextval('sc_cap.sq_dsp'),1,298,ct_tipo_despesa_repasse_mora_multa,2,vl_mora_multa,vp_data_referencia,vp_data_referencia,3,'REF A RECEB COBRANCA DE TERC - GAIA',1,now(),1,1,1,vl_mora_multa,7669);
			elsif vp_cessionario = 3 then
				insert into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp,cd_cbf)
				values(nextval('sc_cap.sq_dsp'),1,445,ct_tipo_despesa_repasse_mora_multa,2,vl_mora_multa,vp_data_referencia,vp_data_referencia,3,'REF A RECEB COBR DE TERC - ADICIONAL',1,now(),1,1,1,vl_mora_multa,12001);
			
			end if;	

			perform sc_cnt.lancar_debito_credito(ct_cnt_valor_transito_terceiro,vl_conta_liquidacao,ct_tipo_lanc_liquidacao_cobr_terc,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),coalesce(vl_mora_multa,0),vp_data_referencia,1,ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));		  

		     end if;
		     
	     end if;

	end if;     
     

     select sum(e.vl_opr_eop)
     into vl_a_repassar
     from sc_aeo.tbl_eop e
     where not exists(select 1 from sc_ccb.tbl_ccb c where c.cd_opr = e.cd_opr)
     and  e.dt_vnc_eop::date = vp_data_referencia;

     if coalesce(vl_a_repassar,0) > 0 then
	perform sc_pbl.enviar_email_saqpag('financeiro@saqpag.com.br;vitorvasconcelos@saqpag.com.br','VALOR A REPASSAR PARA GAIA REF A CCB VENCIDAS','SRS , O VALOR A SER REPASSADO PARA A GAIA DIA '|| TO_CHAR(vp_data_referencia,'DD/MM/YYYY')||' É DE R$ ' || trim(to_char(vl_a_repassar, '999990D99')),null);
     end if;	
   
              
end$_$;


ALTER FUNCTION sc_ccb.repassar_cessionario(vp_data_referencia date, vp_cessionario numeric) OWNER TO scan;

--
-- TOC entry 1585 (class 1255 OID 888787)
-- Name: repassar_cessionario_gaia(date); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION repassar_cessionario_gaia(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $_$declare

   ct_situacao_liquidada numeric := 2;
   ct_tipo_lanc_liquidacao_cobr_terc numeric := 1415;
   ct_cnt_credores_diverso_cobranca numeric := 117356;
   ct_cnt_valor_transito_terceiro numeric := 117529;
   ct_sistema_repasse_ccb numeric := 31;

  ct_conta_cbr_principal numeric := 116311;
  ct_conta_cbr_iof numeric := 116310;
  ct_conta_cbr_juros numeric := 116309;
  ct_conta_cbr_tarifa numeric := 116312;
  ct_conta_mandatario_gaia numeric:=116308;

  ct_conta_fornecedor_gaia numeric := 117618;

  ct_tipo_despesa_repasse_principal numeric := 116;
  ct_tipo_despesa_repasse_mora_multa numeric := 117;
  ct_fornecedor_gaia numeric := 298;

  vl_valor_iof numeric;
  vl_valor_principal numeric;
  vl_valor_tarifa numeric;
  vl_valor_juros numeric;
  vl_valor_ccb numeric;  
  vl_mora_multa numeric;
  
   vl_codigo_lancamento numeric;

   vl_a_repassar numeric;
begin

    if(sc_grl.eh_dia_util(current_date)) then
    
	     select sum(ccb.vlr_iof_ccb),
		 sum(ccb.vlr_lib_ccb - coalesce(opr.vl_trf_opr,0)),
		 sum(coalesce(opr.vl_trf_opr,0)),
		 sum(ccb.vlr_org_ccb - ccb.vlr_lib_ccb - ccb.vlr_iof_ccb),
		 sum(ccb.vlr_org_ccb),
		 sum(coalesce(ccb.vlr_jrs_ccb,0)+coalesce(ccb.vlr_mlt_ccb))
	     into vl_valor_iof,
		vl_valor_principal,
		vl_valor_tarifa,
		vl_valor_juros,
		vl_valor_ccb,
		vl_mora_multa
	     from sc_ccb.tbl_ccb ccb
	       inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
	     where cd_csn = 2
	       and st_ccb = ct_situacao_liquidada
	       and dt_vnc_ccb <= vp_data_referencia
	       and dt_rps_ccb is null;

	      if coalesce(vl_valor_principal,0) > 0 then 

		      insert into sc_ccb.tbl_rps(cd_rps,dt_rps,vl_prc_rps,vl_jrs_mlt_rps) values(nextval('sc_ccb.sq_rps'),now(),vl_valor_ccb,vl_mora_multa);

		      select sc_cnt.lancar_movimento(vl_codigo_lancamento,null,ct_tipo_lanc_liquidacao_cobr_terc,ct_cnt_credores_diverso_cobranca,'D',vl_valor_ccb,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps')) into vl_codigo_lancamento;
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_principal,'C',vl_valor_principal,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_iof,'C',vl_valor_iof,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_juros,'C',vl_valor_juros,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_tarifa,'C',vl_valor_tarifa,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));

		      vl_codigo_lancamento := null;

		      if coalesce(vl_mora_multa,0) > 0 then	      
			 select sc_cnt.lancar_movimento(vl_codigo_lancamento,null,ct_tipo_lanc_liquidacao_cobr_terc,ct_cnt_credores_diverso_cobranca,'D',coalesce(vl_mora_multa,0),vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps')) into vl_codigo_lancamento;
			 perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_cnt_valor_transito_terceiro,'C',coalesce(vl_mora_multa,0),vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      end if;   

		      update sc_ccb.tbl_ccb
		      set dt_rps_ccb = now(),
			  cd_rps = currval('sc_ccb.sq_rps')
		      where cd_csn = 2
			and st_ccb = ct_situacao_liquidada
			and dt_vnc_ccb <= vp_data_referencia
			and dt_rps_ccb is null;
			
		     insert 
		     into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp,cd_cbf)
		     values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_gaia,ct_tipo_despesa_repasse_principal,2,vl_valor_ccb,vp_data_referencia,vp_data_referencia,3,'REF A RECEB COBRANCA DE TERC - GAIA',1,now(),1,1,1,vl_valor_ccb,7669);

                     perform sc_cnt.lancar_debito_credito(ct_conta_mandatario_gaia,ct_conta_fornecedor_gaia,ct_tipo_lanc_liquidacao_cobr_terc,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),vl_valor_ccb,vp_data_referencia,1,ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		     

		     if vl_mora_multa > 0 then
		     

			insert 
			into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp,cd_cbf)
			values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_gaia,ct_tipo_despesa_repasse_mora_multa,2,vl_mora_multa,vp_data_referencia,vp_data_referencia,3,'REF A RECEB COBRANCA DE TERC - GAIA',1,now(),1,1,1,vl_mora_multa,7669);

			perform sc_cnt.lancar_debito_credito(ct_cnt_valor_transito_terceiro,ct_conta_fornecedor_gaia,ct_tipo_lanc_liquidacao_cobr_terc,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),coalesce(vl_mora_multa,0),vp_data_referencia,1,ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));		  

		     end if;
		     
	     end if;

	end if;     
     

     select sum(e.vl_opr_eop)
     into vl_a_repassar
     from sc_aeo.tbl_eop e
     where not exists(select 1 from sc_ccb.tbl_ccb c where c.cd_opr = e.cd_opr)
     and  e.dt_vnc_eop::date = vp_data_referencia;

     if coalesce(vl_a_repassar,0) > 0 then
	perform sc_pbl.enviar_email_saqpag('financeiro@saqpag.com.br;vitorvasconcelos@saqpag.com.br','VALOR A REPASSAR PARA GAIA REF A CCB VENCIDAS','SRS , O VALOR A SER REPASSADO PARA A GAIA DIA '|| TO_CHAR(vp_data_referencia,'DD/MM/YYYY')||' É DE R$ ' || trim(to_char(vl_a_repassar, '999990D99')),null);
     end if;	
   
              
end$_$;


ALTER FUNCTION sc_ccb.repassar_cessionario_gaia(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1689 (class 1255 OID 997222)
-- Name: repassar_cessionario_gaia(date, numeric); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION repassar_cessionario_gaia(vp_data_referencia date, vp_cessionario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $_$declare

   ct_situacao_liquidada numeric := 2;
   ct_tipo_lanc_liquidacao_cobr_terc numeric := 1415;
   ct_cnt_credores_diverso_cobranca numeric := 117356;
   ct_cnt_valor_transito_terceiro numeric := 117529;
   ct_sistema_repasse_ccb numeric := 31;

  ct_conta_cbr_principal numeric := 116311;
  ct_conta_cbr_iof numeric := 116310;
  ct_conta_cbr_juros numeric := 116309;
  ct_conta_cbr_tarifa numeric := 116312;
  ct_conta_mandatario_gaia numeric:=116308;

  ct_conta_fornecedor_gaia numeric := 117618;

  ct_tipo_despesa_repasse_principal numeric := 116;
  ct_tipo_despesa_repasse_mora_multa numeric := 117;
  ct_fornecedor_gaia numeric := 298;

  vl_valor_iof numeric;
  vl_valor_principal numeric;
  vl_valor_tarifa numeric;
  vl_valor_juros numeric;
  vl_valor_ccb numeric;  
  vl_mora_multa numeric;
  
   vl_codigo_lancamento numeric;

   vl_a_repassar numeric;

   vl_conta_cobranca numeric;
   vl_conta_liquidacao numeric;
begin

    if(sc_grl.eh_dia_util(current_date)) then
    
	     select sum(ccb.vlr_iof_ccb),
		 sum(ccb.vlr_lib_ccb - coalesce(opr.vl_trf_opr,0)),
		 sum(coalesce(opr.vl_trf_opr,0)),
		 sum(ccb.vlr_org_ccb - ccb.vlr_lib_ccb - ccb.vlr_iof_ccb),
		 sum(ccb.vlr_org_ccb),
		 sum(coalesce(ccb.vlr_jrs_ccb,0)+coalesce(ccb.vlr_mlt_ccb)),
		 csn.cd_cnt_cbr_csn,
		 csn.cd_cnt_lqd_csn
	     into vl_valor_iof,
		vl_valor_principal,
		vl_valor_tarifa,
		vl_valor_juros,
		vl_valor_ccb,
		vl_mora_multa,
		vl_conta_cobranca,
		vl_conta_liquidacao
	     from sc_ccb.tbl_ccb ccb
	       inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
	       inner join sc_ccb.tbl_csn csn on csn.cd_csn = ccb.cd_csn
	     where cd_csn = vp_cessionario
	       and st_ccb = ct_situacao_liquidada
	       and dt_vnc_ccb <= vp_data_referencia
	       and dt_rps_ccb is null
	     group by csn.cd_cnt_cbr_csn, csn.cd_cnt_lqd_csn;

	      if coalesce(vl_valor_principal,0) > 0 then 

		      insert into sc_ccb.tbl_rps(cd_rps,dt_rps,vl_prc_rps,vl_jrs_mlt_rps) values(nextval('sc_ccb.sq_rps'),now(),vl_valor_ccb,vl_mora_multa);

		      select sc_cnt.lancar_movimento(vl_codigo_lancamento,null,ct_tipo_lanc_liquidacao_cobr_terc,ct_cnt_credores_diverso_cobranca,'D',vl_valor_ccb,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps')) into vl_codigo_lancamento;
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_principal,'C',vl_valor_principal,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_iof,'C',vl_valor_iof,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_juros,'C',vl_valor_juros,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_tarifa,'C',vl_valor_tarifa,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));

		      vl_codigo_lancamento := null;

		      if coalesce(vl_mora_multa,0) > 0 then	      
			 select sc_cnt.lancar_movimento(vl_codigo_lancamento,null,ct_tipo_lanc_liquidacao_cobr_terc,ct_cnt_credores_diverso_cobranca,'D',coalesce(vl_mora_multa,0),vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps')) into vl_codigo_lancamento;
			 perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_cnt_valor_transito_terceiro,'C',coalesce(vl_mora_multa,0),vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      end if;   

		      update sc_ccb.tbl_ccb
		      set dt_rps_ccb = now(),
			  cd_rps = currval('sc_ccb.sq_rps')
		      where cd_csn = vp_cessionario
			and st_ccb = ct_situacao_liquidada
			and dt_vnc_ccb <= vp_data_referencia
			and dt_rps_ccb is null;
			
		     insert 
		     into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp,cd_cbf)
		     values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_gaia,ct_tipo_despesa_repasse_principal,2,vl_valor_ccb,vp_data_referencia,vp_data_referencia,3,'REF A RECEB COBRANCA DE TERC - GAIA',1,now(),1,1,1,vl_valor_ccb,7669);

                     perform sc_cnt.lancar_debito_credito(vl_conta_cobranca,vl_conta_liquidacao,ct_tipo_lanc_liquidacao_cobr_terc,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),vl_valor_ccb,vp_data_referencia,1,ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		     

		     if vl_mora_multa > 0 then
		     

			insert 
			into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp,cd_cbf)
			values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_gaia,ct_tipo_despesa_repasse_mora_multa,2,vl_mora_multa,vp_data_referencia,vp_data_referencia,3,'REF A RECEB COBRANCA DE TERC - GAIA',1,now(),1,1,1,vl_mora_multa,7669);

			perform sc_cnt.lancar_debito_credito(ct_cnt_valor_transito_terceiro,vl_conta_liquidacao,ct_tipo_lanc_liquidacao_cobr_terc,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),coalesce(vl_mora_multa,0),vp_data_referencia,1,ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));		  

		     end if;
		     
	     end if;

	end if;     
     

     select sum(e.vl_opr_eop)
     into vl_a_repassar
     from sc_aeo.tbl_eop e
     where not exists(select 1 from sc_ccb.tbl_ccb c where c.cd_opr = e.cd_opr)
     and  e.dt_vnc_eop::date = vp_data_referencia;

     if coalesce(vl_a_repassar,0) > 0 then
	perform sc_pbl.enviar_email_saqpag('financeiro@saqpag.com.br;vitorvasconcelos@saqpag.com.br','VALOR A REPASSAR PARA GAIA REF A CCB VENCIDAS','SRS , O VALOR A SER REPASSADO PARA A GAIA DIA '|| TO_CHAR(vp_data_referencia,'DD/MM/YYYY')||' É DE R$ ' || trim(to_char(vl_a_repassar, '999990D99')),null);
     end if;	
   
              
end$_$;


ALTER FUNCTION sc_ccb.repassar_cessionario_gaia(vp_data_referencia date, vp_cessionario numeric) OWNER TO scan;

--
-- TOC entry 1606 (class 1255 OID 918353)
-- Name: repassar_cessionario_gaia_tmp(date); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION repassar_cessionario_gaia_tmp(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $_$declare

   ct_situacao_liquidada numeric := 2;
   ct_tipo_lanc_liquidacao_cobr_terc numeric := 1415;
   ct_cnt_credores_diverso_cobranca numeric := 117356;
   ct_cnt_valor_transito_terceiro numeric := 117529;
   ct_sistema_repasse_ccb numeric := 31;

  ct_conta_cbr_principal numeric := 116311;
  ct_conta_cbr_iof numeric := 116310;
  ct_conta_cbr_juros numeric := 116309;
  ct_conta_cbr_tarifa numeric := 116312;
  ct_conta_mandatario_gaia numeric:=116308;

  ct_conta_fornecedor_gaia numeric := 117618;

  ct_tipo_despesa_repasse_principal numeric := 116;
  ct_tipo_despesa_repasse_mora_multa numeric := 117;
  ct_fornecedor_gaia numeric := 298;

  vl_valor_iof numeric;
  vl_valor_principal numeric;
  vl_valor_tarifa numeric;
  vl_valor_juros numeric;
  vl_valor_ccb numeric;  
  vl_mora_multa numeric;
  
   vl_codigo_lancamento numeric;

   vl_a_repassar numeric;
begin

    if(sc_grl.eh_dia_util(current_date)) then
    
	     select sum(ccb.vlr_iof_ccb),
		 sum(ccb.vlr_lib_ccb - coalesce(opr.vl_trf_opr,0)),
		 sum(coalesce(opr.vl_trf_opr,0)),
		 sum(ccb.vlr_org_ccb - ccb.vlr_lib_ccb - ccb.vlr_iof_ccb),
		 sum(ccb.vlr_org_ccb),
		 sum(coalesce(ccb.vlr_jrs_ccb,0)+coalesce(ccb.vlr_mlt_ccb))
	     into vl_valor_iof,
		vl_valor_principal,
		vl_valor_tarifa,
		vl_valor_juros,
		vl_valor_ccb,
		vl_mora_multa
	     from sc_ccb.tbl_ccb ccb
	       inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
	     where dt_rps_ccb ='30-11-2016';

	      if coalesce(vl_valor_principal,0) > 0 then 

		      insert into sc_ccb.tbl_rps(cd_rps,dt_rps,vl_prc_rps,vl_jrs_mlt_rps) values(nextval('sc_ccb.sq_rps'),vp_data_referencia,vl_valor_ccb,vl_mora_multa);

		      select sc_cnt.lancar_movimento(vl_codigo_lancamento,null,ct_tipo_lanc_liquidacao_cobr_terc,ct_cnt_credores_diverso_cobranca,'D',vl_valor_ccb,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps')) into vl_codigo_lancamento;
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_principal,'C',vl_valor_principal,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_iof,'C',vl_valor_iof,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_juros,'C',vl_valor_juros,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_conta_cbr_tarifa,'C',vl_valor_tarifa,vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));

		      vl_codigo_lancamento := null;

		      if coalesce(vl_mora_multa,0) > 0 then	      
			 select sc_cnt.lancar_movimento(vl_codigo_lancamento,null,ct_tipo_lanc_liquidacao_cobr_terc,ct_cnt_credores_diverso_cobranca,'D',coalesce(vl_mora_multa,0),vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps')) into vl_codigo_lancamento;
			 perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tipo_lanc_liquidacao_cobr_terc,ct_cnt_valor_transito_terceiro,'C',coalesce(vl_mora_multa,0),vp_data_referencia,1,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		      end if;   

		      update sc_ccb.tbl_ccb
		      set dt_rps_ccb = vp_data_referencia,
			  cd_rps = currval('sc_ccb.sq_rps')
		      where cd_csn = 2
			and st_ccb = ct_situacao_liquidada
			and dt_rps_ccb =vp_data_referencia;
			
		     insert 
		     into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp,cd_cbf)
		     values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_gaia,ct_tipo_despesa_repasse_principal,2,vl_valor_ccb,vp_data_referencia,vp_data_referencia,3,'REF A RECEB COBRANCA DE TERC - GAIA',1,now(),1,1,1,vl_valor_ccb,7669);

                     perform sc_cnt.lancar_debito_credito(ct_conta_mandatario_gaia,ct_conta_fornecedor_gaia,ct_tipo_lanc_liquidacao_cobr_terc,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),vl_valor_ccb,vp_data_referencia,1,ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));
		     

		     if vl_mora_multa > 0 then
		     

			insert 
			into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp,cd_cbf)
			values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_gaia,ct_tipo_despesa_repasse_mora_multa,2,vl_mora_multa,vp_data_referencia,vp_data_referencia,3,'REF A RECEB COBRANCA DE TERC - GAIA',1,now(),1,1,1,vl_mora_multa,7669);

			perform sc_cnt.lancar_debito_credito(ct_cnt_valor_transito_terceiro,ct_conta_fornecedor_gaia,ct_tipo_lanc_liquidacao_cobr_terc,null,'REF A REPASSE CD '||currval('sc_ccb.sq_rps'),coalesce(vl_mora_multa,0),vp_data_referencia,1,ct_sistema_repasse_ccb,currval('sc_ccb.sq_rps'));		  

		     end if;
		     
	     end if;

	end if;     
     

     select sum(e.vl_opr_eop)
     into vl_a_repassar
     from sc_aeo.tbl_eop e
     where not exists(select 1 from sc_ccb.tbl_ccb c where c.cd_opr = e.cd_opr)
     and  e.dt_vnc_eop::date = vp_data_referencia;

     if coalesce(vl_a_repassar,0) > 0 then
	perform sc_pbl.enviar_email_saqpag('financeiro@saqpag.com.br;vitorvasconcelos@saqpag.com.br','VALOR A REPASSAR PARA GAIA REF A CCB VENCIDAS','SRS , O VALOR A SER REPASSADO PARA A GAIA DIA '|| TO_CHAR(vp_data_referencia,'DD/MM/YYYY')||' É DE R$ ' || trim(to_char(vl_a_repassar, '999990D99')),null);
     end if;	
   
              
end$_$;


ALTER FUNCTION sc_ccb.repassar_cessionario_gaia_tmp(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1377 (class 1255 OID 997230)
-- Name: repassar_cessionarios(date); Type: FUNCTION; Schema: sc_ccb; Owner: postgres
--

CREATE FUNCTION repassar_cessionarios(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  CT_ADICIONAL constant integer := 3;
  CT_GAIA constant integer := 2;
  CT_SOMA constant integer := 1;

  CT_SITUACAO_LIQUIDADA constant integer := 2;
begin
   --preenchendo o campo data de repasse, para as CCB's da Soma, com situação liquidada e que ainda não possuem data de repasse preenchida
   update sc_ccb.tbl_ccb 
      set dt_rps_ccb = dt_lqd_ccb
   where dt_rps_ccb is null
     and dt_lqd_ccb is not null
     and st_ccb = CT_SITUACAO_LIQUIDADA
     and cd_csn = CT_SOMA;

   --perform sc_ccb.repassar_cessionario(vp_data_referencia, CT_GAIA);
   perform sc_ccb.repassar_cessionario(vp_data_referencia, CT_ADICIONAL);

end$$;


ALTER FUNCTION sc_ccb.repassar_cessionarios(vp_data_referencia date) OWNER TO postgres;

--
-- TOC entry 1628 (class 1255 OID 931103)
-- Name: reprocessar_pagamentos_ccb(numeric); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION reprocessar_pagamentos_ccb(vp_codigo_ccb numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg_multa_juros record;
  rg_principal record;
  rg record;
begin

    if vp_codigo_ccb is not null then
    
       delete from sc_ccb.tbl_ccb_pfc where cd_ccb = vp_codigo_ccb;
       
       update sc_ccb.tbl_ccb 
          set vl_pgt_ccb = 0,
              vl_pgt_jrs_ccb = 0,
              vl_pgt_mlt_ccb = 0,
              vl_pgt_pri_ccb = 0,
              dt_ult_pgt_ccb = null,
              vlr_sld_dvd_ccb = vlr_ccb + coalesce(vlr_jrs_ccb,0) + coalesce(vlr_mlt_ccb,0)
        where cd_ccb = vp_codigo_ccb;

        for rg in select cd_lcn
                  from sc_cnt.tbl_lcn
                  where cd_tlc = 1414 
                    and cd_sst = 30
                    and nsu_lcn = vp_codigo_ccb
                    and fg_dcr_lcn = 'C' loop

           perform sc_cnt.excluir_lancamento('REPROCESSAMENTO PGT CCB', null, null, 1, rg.cd_lcn);
                    
        end loop;            
       
    end if;
    for rg_multa_juros in select ccb.cd_ccb,
                                 pp.cd_pfc,
                                 pp.vl_pfc_prc
		          from sc_fcr.tbl_pfc_prc pp
		            inner join sc_fcr.tbl_pfc pfc on pfc.cd_pfc = pp.cd_pfc
		            inner join sc_fcr.tbl_prc prc on prc.cd_prc = pp.cd_prc
		            inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr 
		            inner join sc_ccb.tbl_ccb ccb on ccb.cd_opr = opr.cd_pai_opr
		          where not exists(select 1 
			   	          from sc_ccb.tbl_ccb_pfc cp 
				          where pp.cd_pfc = cp.cd_pfc)
			      --and pfc.dt_rcb_pfc::date <= vp_data_referencia
			      and opr.cd_top = 23
			      and pfc.st_pfc = 1
			      and ccb.st_ccb = 1
			      and (ccb.cd_ccb = vp_codigo_ccb)
			    order by ccb.cd_ccb,pfc.cd_pfc     loop

       perform sc_ccb.realizar_baixa_ccb(rg_multa_juros.cd_ccb,rg_multa_juros.cd_pfc,rg_multa_juros.vl_pfc_prc);
                

     end loop;                


    for rg_principal in select ccb.cd_ccb,
                                pp.cd_pfc,
                                pp.vl_pfc_prc
		          from sc_fcr.tbl_pfc_prc pp
		            inner join sc_fcr.tbl_pfc pfc on pfc.cd_pfc = pp.cd_pfc
		            inner join sc_fcr.tbl_prc prc on prc.cd_prc = pp.cd_prc
		            inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr 
		            inner join sc_ccb.tbl_ccb ccb on ccb.cd_opr = opr.cd_opr
		          where not exists(select 1 
			   	          from sc_ccb.tbl_ccb_pfc cp 
				          where pp.cd_pfc = cp.cd_pfc
				          and coalesce(cp.vl_pgt_prc_ccb_pfc > 0))
			      --and pfc.dt_rcb_pfc::date <= vp_data_referencia
			      and opr.cd_top = 5
			      and pfc.st_pfc = 1
			      and ccb.st_ccb = 1
			      and (ccb.cd_ccb = vp_codigo_ccb)
			    order by ccb.cd_ccb,pfc.cd_pfc     loop

       perform sc_ccb.realizar_baixa_ccb(rg_principal.cd_ccb,rg_principal.cd_pfc,rg_principal.vl_pfc_prc);
                

     end loop;                     
               
end$$;


ALTER FUNCTION sc_ccb.reprocessar_pagamentos_ccb(vp_codigo_ccb numeric) OWNER TO scan;

--
-- TOC entry 1646 (class 1255 OID 933060)
-- Name: simular_prorrogacao_ccb(numeric, date); Type: FUNCTION; Schema: sc_ccb; Owner: scan
--

CREATE FUNCTION simular_prorrogacao_ccb(vp_codigo_ccb numeric, vp_data_atualizacao date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  ct_situacao_ccb_liquidada numeric := 2;
  ct_situacao_ccb_cancelada numeric := 3;
  
  ct_taxa_multa numeric := 2;
  ct_taxa_juros_mora numeric := 2.1;
  PRM_QTD_DIAS_CARENCIA sc_cad.tbl_prm.nm_prm%type := 'QTD_DIAS_JRS_MLT';

  vl_qtd_dias_carencia numeric;  

  vl_multa numeric(13,2);
  vl_juros_mora numeric(13,2);
  vl_data_ult_atualizacao date;
  vl_qtd_dias numeric;
  vl_codigo_fatura numeric;
  rg record;
  vl_total_encargos numeric(13,2);
  vl_cod_parcela_encargos numeric;
  vl_taxa_juros numeric;
  vl_dt_vencimento_fatura date;
  vl_situacao_fatura numeric;
begin

    -- Obtendo a quantitade de dias de carencia
    select prm.vl_prm::numeric
    into vl_qtd_dias_carencia
    from sc_cad.tbl_prm prm 
    where prm.nm_prm = PRM_QTD_DIAS_CARENCIA;

    if vp_data_atualizacao < current_date then
      raise exception 'A DATA DE ATUALIZACAO NAO PODE SER MENOR QUE A DATA ATUAL.';
    end if;

    for rg in select *
              from sc_ccb.tbl_ccb ccb
                inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
                inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
                inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
                inner join sc_opr.tbl_tvt tvt on tvt.cd_tvt = crt.cd_tvt
	        inner join sc_opr.tbl_dtv dtv on dtv.cd_tvt = tvt.cd_tvt    
              where st_ccb not in(ct_situacao_ccb_liquidada,ct_situacao_ccb_cancelada) 
                and dt_vnc_ccb <= vp_data_atualizacao - vl_qtd_dias_carencia::integer
                and (dt_ult_atu_ccb is null or dt_ult_atu_ccb::date<vp_data_atualizacao)
                and (ccb.cd_ccb = vp_codigo_ccb or vp_codigo_ccb is null)
                and dtv.cd_top = 5
	        and dtv.tp_cbr_dtv = 1 loop

       perform sc_ccb.processar_pagamentos_ccb(current_Date + 1, rg.cd_ccb); 
                
       vl_multa := 0;
       vl_juros_mora := 0;

       if (vp_data_atualizacao - rg.dt_vnc_ccb::date) > 15 then -- Se o cessionario for Saqpag
         vl_taxa_juros := ct_taxa_juros_mora;
       else -- Se for Gaia
         vl_taxa_juros := rg.vl_dtv;
       end if;
       
       -- Calcula o valor da multa, caso ainda nao tenha havido cobranca
       
       if coalesce(rg.vlr_mlt_ccb,0) <= 0 then 
	  vl_multa := (ct_taxa_multa / 100) * (rg.vlr_org_ccb - coalesce(rg.vl_pgt_pri_ccb,0));
       end if;
       
       --

       -- Calculando o Juros de Mora desde a data da ultima atualizacao
       
       if rg.dt_ult_atu_ccb is null then
         vl_data_ult_atualizacao := rg.dt_vnc_ccb;
       else  
         vl_data_ult_atualizacao := rg.dt_ult_atu_ccb;
       end if;

       vl_juros_mora := 0;
       while vl_data_ult_atualizacao < vp_data_atualizacao loop
       
         vl_data_ult_atualizacao := vl_data_ult_atualizacao + 1;
         
         if (vl_data_ult_atualizacao - rg.dt_vnc_ccb::date) > 15 then -- Se o cessionario for Saqpag
	    vl_taxa_juros := ct_taxa_juros_mora;
         else -- Se for Gaia
	    vl_taxa_juros := rg.vl_dtv;
         end if;
         
          vl_juros_mora := vl_juros_mora + (vl_taxa_juros / 100 / 30) *1* (rg.vlr_org_ccb - coalesce(rg.vl_pgt_pri_ccb,0));
       end loop;

--       vl_qtd_dias := vp_data_atualizacao - vl_data_ult_atualizacao::date;

--       vl_juros_mora := (vl_taxa_juros / 100 / 30) * vl_qtd_dias * (rg.vlr_org_ccb - coalesce(rg.vl_pgt_pri_ccb,0));


       vl_total_encargos := coalesce(vl_juros_mora,0) + coalesce(vl_multa,0) ; 

    end loop;    
    
    return coalesce(vl_total_encargos,0);      
end$$;


ALTER FUNCTION sc_ccb.simular_prorrogacao_ccb(vp_codigo_ccb numeric, vp_data_atualizacao date) OWNER TO scan;

SET search_path = sc_cce, pg_catalog;

--
-- TOC entry 1340 (class 1255 OID 1636718)
-- Name: baixar_titulos_em_atraso(numeric); Type: FUNCTION; Schema: sc_cce; Owner: scan
--

CREATE FUNCTION baixar_titulos_em_atraso(vp_contrato numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin
   for rg in select cd_tit
             from sc_cce.tbl_tit
             where dt_vnc_tit <= current_date - 60 
               and st_tit = 1
               and (cd_cce = vp_contrato or vp_contrato is null) loop
               
       update sc_cce.tbl_tit 
          set st_tit = 4,
              dt_bx_tit = now(),
              cd_usr_bx_tit = 1 
        where cd_tit = rg.cd_tit;
       
   end loop;          
end$$;


ALTER FUNCTION sc_cce.baixar_titulos_em_atraso(vp_contrato numeric) OWNER TO scan;

--
-- TOC entry 1131 (class 1255 OID 1631878)
-- Name: gerar_arquivo_retorno_cobranca_externa(numeric); Type: FUNCTION; Schema: sc_cce; Owner: scan
--

CREATE FUNCTION gerar_arquivo_retorno_cobranca_externa(vp_codigo_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_diretorio varchar;
  vl_arquivo varchar;
  vl_linha varchar;
  vl_seq_registro numeric := 0;
  vl_identificador varchar;

  vl_nome_arquivo varchar;
  

  vl_rg_ccb sc_cbr.tbl_ccb%rowtype;
  vl_rg_cun sc_cad.tbl_cun%rowtype;
  vl_rg_harc sc_cce.tbl_harc%rowtype;
  vl_rg_darc sc_cce.tbl_darc%rowtype;
  vl_reg_tarc sc_cce.tbl_tarc%rowtype;

  ct_banco_hsbc constant numeric := 399;  
  ct_banco_bracce constant numeric := 65;  
  ct_banco_bradesco constant numeric := 237;  

  ALINHAMENTO_DIREITA numeric := 1;
  ALINHAMENTO_ESQUERDA numeric := 2;

  vl_cnpj_avalista varchar(50);

  
begin

    -- obtendo as informacoes do arquivo
    select *
      into vl_rg_harc
    from sc_cce.tbl_harc
    where cd_harc = vp_codigo_arquivo
      and st_harc = 1;

    if vl_rg_harc is null then
      raise exception 'Não existe dados para geraçào do arquivo.';
    end if;

   -- begin 

    -- obtendo os dados da empresa do contrato de cobranca
    select cun.*
      into vl_rg_cun
    from sc_cce.tbl_harc harc
      inner join sc_cce.tbl_cce cce on cce.cd_cce = harc.cd_cce
      inner join sc_cad.tbl_cun cun on cun.cd_cun = cce.cd_cun
      inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = cce.cd_ccb
    where harc.cd_harc = vp_codigo_arquivo;    

    select ccb.*
      into vl_rg_ccb
    from sc_cce.tbl_harc harc
      inner join sc_cce.tbl_cce cce on cce.cd_cce = harc.cd_cce
      inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = cce.cd_ccb
    where harc.cd_harc = vp_codigo_arquivo;    
    

    -- obtendo o diretorio do arquivo
    select vl_prm
      into vl_diretorio
    from sc_cad.tbl_prm
    where nm_prm = 'DIRETORIO_ARQUIVO_RETORNO_COBRANCA_EXTERNA';  


    vl_nome_arquivo := to_char(vl_rg_harc.dt_grc_harc,'ddmmyyyy') || vl_rg_harc.nr_rms_harc || '.RET';

    vl_arquivo := vl_diretorio || '\\' || vl_nome_arquivo;

    -- GERANDO O HEADER

    vl_linha := '0'; -- Identificador do Registro

    vl_linha := vl_linha || '2'; -- Identificador do Arquivo de Retorno

    vl_linha := vl_linha || 'Retorno'; -- Literal Remessa

    vl_linha := vl_linha || '01'; -- Código de Serviço

    vl_linha := vl_linha || sc_arq.preencher(15,'COBRANCA',' ',ALINHAMENTO_DIREITA); -- Literal Serviço

    vl_linha := vl_linha || sc_arq.preencher(20,vl_rg_harc.nr_cdt_harc,'0',ALINHAMENTO_ESQUERDA); -- Código da Empresa (usamos a acessoria escritural)

    vl_linha := vl_linha || sc_arq.preencher(30,UPPER(vl_rg_cun.nm_cun),' ',ALINHAMENTO_DIREITA); -- Código da Empresa (usamos a acessoria escritural)

    vl_linha := vl_linha || '237'; -- Número do Bradesco na Camara de Compensacao

    vl_linha := vl_linha || sc_arq.preencher(15,'BRADESCO',' ',ALINHAMENTO_DIREITA); -- Nome do banco por extenso

    vl_linha := vl_linha || to_char(vl_rg_harc.dt_grc_harc,'ddMMyy'); -- Data da Gravação do Arquivo

    vl_linha := vl_linha || '01600000'; -- DENSIDADE DE GRAVACAO

    vl_linha := vl_linha || '00665'; -- NR AVISO

    vl_linha := vl_linha || sc_arq.repetir(' ',266); -- Branco

    vl_linha := vl_linha || to_char(vl_rg_harc.dt_crd_harc,'ddMMyy'); -- Data do Credito

    vl_linha := vl_linha || sc_arq.repetir(' ',9); -- Branco

    vl_seq_registro := vl_seq_registro + 1;
    vl_linha := vl_linha || sc_arq.preencher(6,vl_seq_registro,'0',ALINHAMENTO_ESQUERDA); -- Número Sequencial do Registro

    perform sc_arq.gravarlinha(vl_arquivo,vl_linha);

    --GERANDO O DETALHE

    for vl_rg_darc in
     select *
     from sc_cce.tbl_darc 
     where cd_harc = vl_rg_harc.cd_harc loop

     vl_linha :=  '1'; -- Identificador do Registro

     if vl_rg_cun.tp_pss_cun = 'F' then
	vl_linha := vl_linha || '01'; -- Tipo de Inscricao da empresa
     else 	
	vl_linha := vl_linha || '02'; -- Tipo de Inscricao da empresa
     end if;	
     
     vl_linha := vl_linha || sc_arq.preencher(14,vl_rg_cun.nr_cpf_cnpj_cun,'0',ALINHAMENTO_ESQUERDA); -- Identificacao da empresa benef. no banco
     
     vl_linha := vl_linha || sc_arq.repetir('0',3); -- Zeros
     
     --Identificacao da empresa no banco
     vl_linha := vl_linha || sc_arq.repetir('0',3); -- Zeros
     vl_linha := vl_linha || vl_rg_ccb.nr_car_ccb; -- Carteira
     vl_linha := vl_linha || sc_arq.preencher(5,vl_rg_ccb.cd_agn_ccb,'0',ALINHAMENTO_ESQUERDA); -- Agencia
     vl_linha := vl_linha || sc_arq.preencher(7,vl_rg_ccb.cd_cnt_ccb,'0',ALINHAMENTO_ESQUERDA); --Conta
     vl_linha := vl_linha || vl_rg_ccb.nr_dgt_vrf_cnt_ccb; --Digito
     
     --vl_linha := vl_linha || sc_arq.preencher(25,vl_rg_darc.nr_ctl_drb,' ',ALINHAMENTO_DIREITA); -- Uso da Empresa
     vl_linha := vl_linha || sc_arq.repetir('0',25); -- Zeros
     
     vl_linha := vl_linha || sc_arq.repetir('0',8); -- Zeros
     vl_linha := vl_linha || sc_arq.preencher(12,vl_rg_darc.idt_ttl_darc,'0',ALINHAMENTO_ESQUERDA); -- Identificacao do titulo no banco
     vl_linha := vl_linha || sc_arq.repetir('0',10); -- Zeros
     vl_linha := vl_linha || sc_arq.repetir('0',12); -- Zeros
     vl_linha := vl_linha || '0'; -- Rateio
     vl_linha := vl_linha || '00'; -- Pagamento Parcial
     vl_linha := vl_linha || '9'; -- Carteira
     vl_linha := vl_linha || sc_arq.preencher(2,vl_rg_darc.NR_OCR_DARC,'0',ALINHAMENTO_ESQUERDA); -- Identificacao da Ocorrencia
     vl_linha := vl_linha || to_char(vl_rg_darc.dt_ocb_darc,'ddmmyy'); -- Data da Ocorrencia
     vl_linha := vl_linha || sc_arq.preencher(10,vl_rg_darc.nr_doc_darc,' ',ALINHAMENTO_DIREITA); -- Numero do Documento
     vl_linha := vl_linha || sc_arq.preencher(20,vl_rg_darc.idt_ttl_darc,'0',ALINHAMENTO_ESQUERDA); -- Identificacao do titulo no banco
     vl_linha := vl_linha || to_char(vl_rg_darc.dt_vnc_ttl_darc,'ddmmyy'); -- Data de Vencimento do Titulo
     vl_linha := vl_linha || sc_arq.formatar_moeda(13,vl_rg_darc.vl_ttl_darc); -- VALOR DO DOCUMENTO
     vl_linha := vl_linha || sc_arq.preencher(3,vl_rg_darc.bnc_cbr_darc,'0',ALINHAMENTO_ESQUERDA); -- Banco Cobrador
     vl_linha := vl_linha || sc_arq.preencher(5,vl_rg_darc.ag_cbr_darc,'0',ALINHAMENTO_ESQUERDA); -- Agencia Cobrador
     vl_linha := vl_linha || '  '; --Branco
     vl_linha := vl_linha || sc_arq.formatar_moeda(13,vl_rg_darc.vl_dsp_cbr_darc); -- VALOR DESPESA DE COBRANCA
     vl_linha := vl_linha || sc_arq.formatar_moeda(13,vl_rg_darc.vl_otr_dsp_darc); -- VALOR OUTRAS DESPESAS
     vl_linha := vl_linha || sc_arq.repetir('0',13); -- Juros Operacao em Atraso
     vl_linha := vl_linha || sc_arq.formatar_moeda(13,vl_rg_darc.vl_iof_darc); -- VALOR IOF DEVIDO
     vl_linha := vl_linha || sc_arq.formatar_moeda(13,vl_rg_darc.vl_abt_darc); -- VALOR ABATIMENTO
     vl_linha := vl_linha || sc_arq.formatar_moeda(13,vl_rg_darc.vl_dsc_darc); -- VALOR DESCONTO
     vl_linha := vl_linha || sc_arq.formatar_moeda(13,vl_rg_darc.vl_pgt_darc); -- VALOR PAGAMENTO
     vl_linha := vl_linha || sc_arq.formatar_moeda(13,vl_rg_darc.vl_jrs_darc); -- VALOR JUROS DE MORA
     vl_linha := vl_linha || sc_arq.formatar_moeda(13,vl_rg_darc.vl_otr_crd_darc); -- VALOR OUTROS CREDITOS
     vl_linha := vl_linha || '  '; --bRANCOS
     vl_linha := vl_linha || coalesce(vl_rg_darc.mtv_cd_ocr_darc,' '); -- Motivo codigo da ocorrencia
     vl_linha := vl_linha || coalesce(to_char(vl_rg_darc.dt_crd_darc,'ddmmyy'),'      '); -- Data do Credito
     vl_linha := vl_linha || sc_arq.preencher(3,vl_rg_darc.org_pgt_darc,'0',ALINHAMENTO_ESQUERDA); -- Origem do Pagamento
     vl_linha := vl_linha || sc_arq.repetir(' ',10); -- Brancos
     vl_linha := vl_linha || sc_arq.repetir(' ',4); -- Brancos
     vl_linha := vl_linha || sc_arq.preencher(10,vl_rg_darc.mtv_rjc_darc,'0',ALINHAMENTO_ESQUERDA); -- Motivo das Rejeicoes
     vl_linha := vl_linha || sc_arq.repetir(' ',40); -- Brancos
     vl_linha := vl_linha || sc_arq.repetir(' ',2); -- Brancos
     vl_linha := vl_linha || sc_arq.repetir(' ',10); -- Brancos
     vl_linha := vl_linha || sc_arq.repetir(' ',14); -- Brancos

     vl_seq_registro := vl_seq_registro + 1;
     
     vl_linha := vl_linha || sc_arq.preencher(6,vl_seq_registro,'0',ALINHAMENTO_ESQUERDA); -- Número Sequencial do Registro
     
     perform sc_arq.gravarlinha(vl_arquivo,vl_linha);

    end loop;

    -- GERANDO TRAILLER

    select *
    into vl_reg_tarc
    from sc_cce.tbl_tarc
    where cd_harc = vp_codigo_arquivo;

    vl_linha := '9'; -- Identificador do Registro
    vl_linha := vl_linha || '2'; -- Identificador do Retorno
    vl_linha := vl_linha || '01'; -- Identificador Tipo do Registro
    vl_linha := vl_linha || '237'; -- Codigo do Banco
    vl_linha := vl_linha || sc_arq.repetir(' ',10); -- Brancos
    vl_linha := vl_linha || sc_arq.preencher(8,vl_reg_tarc.qtd_ttl_cbr_tarc,'0',ALINHAMENTO_ESQUERDA); -- Qtd titulos em Cobr
    vl_linha := vl_linha || sc_arq.formatar_moeda(14,vl_reg_tarc.vl_ttl_cbr_tarc); -- Valor Total Cobranca
    vl_linha := vl_linha || sc_arq.repetir('0',8); -- Nr Aviso
    vl_linha := vl_linha || sc_arq.repetir(' ',10); -- Brancos
    
    vl_linha := vl_linha || sc_arq.preencher(5,vl_reg_tarc.qtd_cnf_ent_tarc,'0',ALINHAMENTO_ESQUERDA); -- Qtd titulos em Cobr
    vl_linha := vl_linha || sc_arq.formatar_moeda(12,vl_reg_tarc.vl_cnf_ent_tarc); -- Valor Total Cobranca

    vl_linha := vl_linha || sc_arq.formatar_moeda(12,vl_reg_tarc.vl_lqd_tarc); -- Valor Total Cobranca
    vl_linha := vl_linha || sc_arq.preencher(5,vl_reg_tarc.qtd_lqd_tarc,'0',ALINHAMENTO_ESQUERDA); -- Qtd titulos em Cobr
    vl_linha := vl_linha || sc_arq.formatar_moeda(12,vl_reg_tarc.vl_lqd_tarc); -- Valor Total Cobranca

    vl_linha := vl_linha || sc_arq.preencher(5,vl_reg_tarc.qtd_bx_tarc,'0',ALINHAMENTO_ESQUERDA); -- Qtd titulos em Cobr
    vl_linha := vl_linha || sc_arq.formatar_moeda(12,vl_reg_tarc.vl_bx_tarc); -- Valor Total Cobranca

    vl_linha := vl_linha || sc_arq.preencher(5,vl_reg_tarc.qtd_abt_cnc_tarc,'0',ALINHAMENTO_ESQUERDA); -- Qtd titulos em Cobr
    vl_linha := vl_linha || sc_arq.formatar_moeda(12,vl_reg_tarc.vl_abt_cnc_tarc); -- Valor Total Cobranca

    vl_linha := vl_linha || sc_arq.preencher(5,vl_reg_tarc.qtd_vnc_alt_tarc,'0',ALINHAMENTO_ESQUERDA); -- Qtd titulos em Cobr
    vl_linha := vl_linha || sc_arq.formatar_moeda(12,vl_reg_tarc.vl_vnc_alt_tarc); -- Valor Total Cobranca

    vl_linha := vl_linha || sc_arq.preencher(5,vl_reg_tarc.qtd_abt_ccd_tarc,'0',ALINHAMENTO_ESQUERDA); -- Qtd titulos em Cobr
    vl_linha := vl_linha || sc_arq.formatar_moeda(12,vl_reg_tarc.vl_abt_ccd_tarc); -- Valor Total Cobranca

    vl_linha := vl_linha || sc_arq.preencher(5,vl_reg_tarc.qtd_ptt_tarc,'0',ALINHAMENTO_ESQUERDA); -- Qtd titulos em Cobr
    vl_linha := vl_linha || sc_arq.formatar_moeda(12,vl_reg_tarc.vl_ptt_tarc); -- Valor Total Cobranca

    vl_linha := vl_linha || sc_arq.repetir(' ',174); -- Brancos

    vl_linha := vl_linha || sc_arq.formatar_moeda(15,0); -- Valor Total Cobranca
    vl_linha := vl_linha || sc_arq.preencher(8,0,'0',ALINHAMENTO_ESQUERDA); -- Qtd titulos em Cobr
    
    vl_linha := vl_linha || sc_arq.repetir(' ',9); -- Brancos
    

    vl_seq_registro := vl_seq_registro + 1;
    vl_linha := vl_linha || sc_arq.preencher(6,vl_seq_registro,'0',ALINHAMENTO_ESQUERDA); -- Número Sequencial do ultimo Registro

    perform sc_arq.gravarlinha(vl_arquivo,vl_linha);

    update sc_cce.tbl_harc set st_harc=2 where cd_harc = vl_rg_harc.cd_harc;

    --inserindo registro na tabela de download
    insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'), vl_nome_arquivo, now(), current_date, 15, 1);

   /* exception when others then

        perform sc_arq.excluirarquivo(vl_arquivo);
	raise exception 'Ocorreu um erro na geração do arquivo de remessa do bradesco.';   
    end;*/	
    
end;$$;


ALTER FUNCTION sc_cce.gerar_arquivo_retorno_cobranca_externa(vp_codigo_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1475 (class 1255 OID 1631893)
-- Name: gerar_dados_arquivo_retorno_cobr_externa(); Type: FUNCTION; Schema: sc_cce; Owner: scan
--

CREATE FUNCTION gerar_dados_arquivo_retorno_cobr_externa() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   rg record;
   rg_harc record;
begin

   for rg in select cd_cce
             from sc_cce.tbl_cce loop
             
      for rg_harc in select distinct cd_harcg
		      from sc_cbr.tbl_darcg darc
			inner join sc_cbr.tbl_blt blt on blt.cd_blt = darc.cd_blt
			inner join sc_cce.tbl_tit tit on tit.cd_tit = blt.nr_nsu_org_blt and blt.tp_org_blt = 8
		      where not exists(select 1 from sc_cce.tbl_mti mti where mti.cd_darc_cbr_mti = darc.cd_darcg)
		      order by cd_harcg loop
		      
	  perform sc_cce.gerar_dados_arquivo_retorno_cobr_externa(rg.cd_cce,rg_harc.cd_harcg);
		      
      end loop;
   end loop;          

end$$;


ALTER FUNCTION sc_cce.gerar_dados_arquivo_retorno_cobr_externa() OWNER TO scan;

--
-- TOC entry 1614 (class 1255 OID 1631891)
-- Name: gerar_dados_arquivo_retorno_cobr_externa(numeric, numeric); Type: FUNCTION; Schema: sc_cce; Owner: scan
--

CREATE FUNCTION gerar_dados_arquivo_retorno_cobr_externa(vp_codigo_contrato_cbr_externa numeric, vp_codigo_arquivo_origem numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   rg record;
   vl_data_Credito date;
   vl_numero_remessa numeric;
   vl_cedente numeric;
   vl_banco numeric;

   vl_qtd_tit_cobr numeric;
   vl_ttl_tit_cobr numeric;

   vl_qtd_reg02 numeric;
   vl_ttl_reg02 numeric;

   vl_ttl_reg06 numeric;
   vl_qtd_reg06 numeric;

   vl_qtd_reg09_10 numeric;
   vl_ttl_reg09_10 numeric;

   vl_ttl_reg13 numeric;
   vl_qtd_reg13 numeric;

   vl_ttl_reg14 numeric;
   vl_qtd_reg14 numeric;

   vl_ttl_reg12 numeric;
   vl_qtd_reg12 numeric;

   vl_ttl_reg19 numeric;
   vl_qtd_reg19 numeric;

   vl_ttl_reg_rat numeric;
   vl_qtd_reg_rat numeric;
   
begin

   /*select *
   from sc_cbr.tbl_darcg darc
       inner join sc_cbr.tbl_blt blt on blt.cd_blt = darc.cd_blt
       inner join sc_cce.tbl_tit tit on tit.cd_tit = blt.nr_nsu_org_tit and blt.tp_org_blt = 8
   where not exists(select 1 from sc_cce.tbl_mti mti where mti.cd_darc_cbr_mti = darc.cd_darcg)*/

   select dt_crd_harcg, cd_bnc
   into vl_data_credito, vl_banco
   from sc_cbr.tbl_harcg
   where cd_harcg = vp_codigo_arquivo_origem;

   select idt_cce 
   into vl_cedente 
   from sc_cce.tbl_cce
   where cd_cce = vp_codigo_contrato_cbr_externa;

   select coalesce(max(nr_rms_harc),0) + 1
   into vl_numero_remessa
   from sc_cce.tbl_harc
   where cd_cce = vp_codigo_contrato_cbr_externa;

   insert into sc_cce.tbl_harc(cd_harc,dt_grc_harc,dt_crd_harc,dt_inc_usr,nr_rms_harc,nr_cdt_harc,st_harc,cd_cce,cd_bnc)
      values(nextval('sc_cce.sq_harc'),now(),vl_data_Credito,now(),vl_numero_remessa,vl_cedente,1,vp_codigo_contrato_cbr_externa,vl_banco);
   
   for rg in select *
             from sc_cbr.tbl_darcg darc
               inner join sc_cbr.tbl_blt blt on blt.cd_blt = darc.cd_blt
               inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
               inner join sc_cce.tbl_tit tit on tit.cd_tit = blt.nr_nsu_org_blt and blt.tp_org_blt = 8
             where not exists(select 1 from sc_cce.tbl_mti mti where mti.cd_darc_cbr_mti = darc.cd_darcg)
               and darc.cd_harcg = vp_codigo_arquivo_origem loop
             
        insert into sc_cce.tbl_darc(cd_darc,nr_ocr_darc,dt_ocb_darc,vl_ttl_darc,bnc_cbr_darc,ag_cbr_darc,vl_dsp_cbr_darc,dt_vnc_ttl_darc,
                                    vl_otr_dsp_darc,vl_iof_darc,vl_abt_darc,vl_dsc_darc,vl_pgt_darc,vl_jrs_darc,vl_otr_crd_darc,mtv_cd_ocr_darc,
                                    dt_crd_darc,org_pgt_darc,mtv_rjc_darc,cd_harc,idt_ttl_darc,st_darc,cd_err_darc,cd_blt,nr_doc_darc,idt_emp_ben_darc)
		   values(nextval('sc_cce.sq_darc'),rg.nr_ocr_darcg,rg.dt_ocb_darcg,rg.vl_ttl_darcg,rg.bnc_cbr_darcg,rg.ag_cbr_darcg,rg.vl_dsp_cbr_darcg,
		   rg.dt_vnc_blt,rg.vl_otr_dsp_darcg,rg.vl_iof_darcg,rg.vl_abt_darcg,rg.vl_dsc_darcg,rg.vl_pgt_darcg,rg.vl_jrs_darcg,rg.vl_otr_crd_darcg,
		   rg.mtv_cd_ocr_darcg,rg.dt_crd_darcg,rg.org_pgt_darcg,rg.mtv_rjc_darcg,currval('sc_cce.sq_harc'),rg.idt_ttl_darcg,1,null,rg.cd_blt,null,null);
		   
	insert into sc_cce.tbl_mti(cd_mti,cd_darc_cbr_mti,cd_darc_ext_mti,cd_tit,st_mti)
	     values(nextval('sc_cce.sq_mti'),rg.cd_darcg,currval('sc_cce.sq_darc'),rg.cd_tit,1);

	if rg.nr_ocr_darcg = 2 then
	   vl_qtd_reg02 := coalesce(vl_qtd_reg02,0) + 1;
	   vl_ttl_reg02 := coalesce(vl_ttl_reg02,0) + rg.vl_ttl_darcg;
	elsif rg.nr_ocr_darcg = 6 then
	   vl_qtd_reg06 := coalesce(vl_qtd_reg06,0) + 1;
	   vl_ttl_reg06 := coalesce(vl_ttl_reg06,0) + rg.vl_ttl_darcg;
	elsif rg.nr_ocr_darcg in(9,10) then
	   vl_qtd_reg09_10 := coalesce(vl_qtd_reg09_10,0) + 1;
	   vl_ttl_reg09_10 := coalesce(vl_ttl_reg09_10,0) + rg.vl_ttl_darcg;
	elsif rg.nr_ocr_darcg = 13 then
	   vl_qtd_reg13 := coalesce(vl_qtd_reg13,0) + 1;
	   vl_ttl_reg13 := coalesce(vl_ttl_reg13,0) + rg.vl_ttl_darcg;
	elsif rg.nr_ocr_darcg = 14 then
	   vl_qtd_reg14 := coalesce(vl_qtd_reg14,0) + 1;
	   vl_ttl_reg14 := coalesce(vl_ttl_reg14,0) + rg.vl_ttl_darcg;
	elsif rg.nr_ocr_darcg = 12 then
	   vl_qtd_reg12 := coalesce(vl_qtd_reg12,0) + 1;
	   vl_ttl_reg12 := coalesce(vl_ttl_reg12,0) + rg.vl_ttl_darcg;
	elsif rg.nr_ocr_darcg = 19 then
	   vl_qtd_reg19 := coalesce(vl_qtd_reg19,0) + 1;
	   vl_ttl_reg19 := coalesce(vl_ttl_reg19,0) + rg.vl_ttl_darcg;
	end if;     

        vl_qtd_tit_cobr := coalesce(vl_qtd_tit_cobr,0) + 1;
        vl_ttl_tit_cobr := coalesce(vl_ttl_tit_cobr,0) + rg.vl_ttl_darcg;
	
   end loop;

   insert into sc_cce.tbl_tarc(cd_tarc,cd_harc,qtd_ttl_cbr_tarc,vl_ttl_cbr_tarc,nr_avs_tarc,qtd_cnf_ent_tarc,
                     vl_cnf_ent_tarc,qtd_lqd_tarc,vl_lqd_tarc,qtd_bx_tarc,vl_bx_tarc,qtd_abt_cnc_tarc,vl_abt_cnc_tarc,
                     qtd_vnc_alt_tarc,vl_vnc_alt_tarc,qtd_abt_ccd_tarc,vl_abt_ccd_tarc,qtd_ptt_tarc,vl_ptt_tarc)
      values(nextval('sc_cce.sq_tarc'),currval('sc_cce.sq_harc'),vl_qtd_tit_cobr,vl_ttl_tit_cobr,null,vl_qtd_reg02,vl_ttl_reg02,
	    vl_qtd_reg06,vl_ttl_reg06,vl_qtd_reg09_10,vl_ttl_reg09_10,vl_qtd_reg13,vl_ttl_reg13,vl_qtd_reg14,vl_ttl_reg14,
	    vl_qtd_reg12,vl_ttl_reg12,vl_qtd_reg19,vl_ttl_reg19);


              
end$$;


ALTER FUNCTION sc_cce.gerar_dados_arquivo_retorno_cobr_externa(vp_codigo_contrato_cbr_externa numeric, vp_codigo_arquivo_origem numeric) OWNER TO scan;

--
-- TOC entry 1839 (class 1255 OID 1631227)
-- Name: processar_remessa(numeric); Type: FUNCTION; Schema: sc_cce; Owner: scan
--

CREATE FUNCTION processar_remessa(vp_codigo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  vl_codigo_usuario numeric := 1;
  vl_codigo_sacado numeric;
  vl_codigo_identificador numeric;
  vl_codigo_contrato_cobranca numeric;
  vl_codigo_cun numeric;
  vl_nosso_numero numeric;

  vl_existe_titulo numeric;
begin

   select idt_emp_hrb::numeric
   into vl_codigo_identificador
   from sc_cce.tbl_hrb
   where cd_hrb = vp_codigo
     and st_hrb = 1;

    if vl_codigo_identificador is null then
       raise exception 'ARQUIVO NAO ENCONTRADO OU JA PROCESSADO';
    end if;   

    select max(nr_doc_drb)
    into vl_nosso_numero
    from sc_cce.tbl_drb
    where cd_hrb = vp_codigo;

    for rg in select * 
              from sc_cce.tbl_cce loop

      if vl_nosso_numero >= rg.ns_nmr_ini_cce and vl_nosso_numero <= rg.ns_nmr_fin_cce then
         vl_codigo_contrato_cobranca := rg.cd_cce;
         exit;
      end if;
      
    end loop;
               
     
     

    -- Atualizando codigo do contrato
    /*select cd_cce
    into vl_codigo_contrato_cobranca
    from sc_cce.tbl_cce
    where idt_cce::numeric = vl_codigo_identificador;*/

    if vl_codigo_contrato_cobranca is null then
       raise exception 'CONTRATO DE COBRANCA NAO ENCONTRADO';
    else
       update sc_cce.tbl_hrb set cd_cce = vl_codigo_contrato_cobranca where cd_hrb = vp_codigo;
    end if;

    for rg in select hrb.cd_cce,
                     drb.nr_insc_pgd_drb,
                     drb.nm_pgd_drb,
                     drb.edr_drb,
                     drb.nr_doc_drb,
                     drb.vl_drb,
                     drb.dt_vnc_drb,
                     drb.idt_tpi_pgd_drb
              from sc_cce.tbl_drb drb
                inner join sc_cce.tbl_hrb hrb on hrb.cd_hrb = drb.cd_hrb
                inner join sc_cce.tbl_cce cce on cce.cd_cce = hrb.cd_cce
              where drb.cd_hrb = vp_codigo loop

          select count(*)
          into vl_existe_titulo
          from sc_cce.tbl_tit
          where cd_cce = rg.cd_cce
            and ns_nmr_tit = rg.nr_doc_drb;

          if vl_existe_titulo > 0 then
             --raise exception 'ENVIO DE TITULO DUPLICADO';
          else

          -- Verficando sacado
          select scd.cd_scd
          into vl_codigo_sacado
          from sc_cce.tbl_scd scd
          where scd.nr_cpf_cnpj_scd = rg.nr_insc_pgd_drb
            and scd.cd_cce = rg.cd_cce;

          if vl_codigo_sacado is null then

	      select cd_cun
	      into vl_codigo_cun
	      from sc_cad.tbl_cun
	      where nr_cpf_cnpj_cun = rg.nr_insc_pgd_drb;

	      if vl_codigo_cun is null then
		 select nextval('sc_cad.sq_cun') into vl_codigo_cun;

		 insert into sc_cad.tbl_cun (cd_cun,nm_cun,nr_cpf_cnpj_cun,tp_pss_cun,cd_inc_usr,dt_inc_usr)
		  values(vl_codigo_cun,rg.nm_pgd_drb,rg.nr_insc_pgd_drb,case when rg.idt_tpi_pgd_drb = 2 then 'J' else 'F' end,1,now());
	      end if;
	      
              select nextval('sc_cce.sq_scd')
              into vl_codigo_sacado;

              insert into sc_cce.tbl_scd(cd_scd,cd_cce,cd_inc_usr,dt_inc_usr,fg_atv_scd,nr_cpf_cnpj_scd,nm_scd,end_scd,cd_cun)
                values(vl_codigo_sacado,rg.cd_cce,1,now(),'S',rg.nr_insc_pgd_drb,rg.nm_pgd_drb,rg.edr_drb,vl_codigo_cun );
                
          end if;

          insert into sc_cce.tbl_tit(cd_tit,cd_cce,ns_nmr_tit,vl_tit,dt_vnc_tit,cd_scd,cd_inc_usr,dt_inc_usr, st_tit) 
            values(nextval('sc_cce.sq_tit'),rg.cd_cce,rg.nr_doc_drb,rg.vl_drb,rg.dt_vnc_drb,vl_codigo_sacado,vl_codigo_usuario, now(), 1);
          
             
        end if;   

          

                    
    end loop;     

    update sc_cce.tbl_hrb
    set st_hrb = 2
    where cd_hrb = vp_codigo;       

end$$;


ALTER FUNCTION sc_cce.processar_remessa(vp_codigo numeric) OWNER TO scan;

--
-- TOC entry 1344 (class 1255 OID 1633089)
-- Name: processar_remessa_job(); Type: FUNCTION; Schema: sc_cce; Owner: scan
--

CREATE FUNCTION processar_remessa_job() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
begin

   for rg in select cd_hrb
             from sc_cce.tbl_hrb
             where st_hrb = 1 loop

      begin
         perform sc_cce.processar_remessa(rg.cd_hrb);
      exception when others then
         update sc_cce.tbl_hrb set st_hrb=3 where cd_hrb = rg.cd_hrb;
      end;   
             
   end loop;          

end$$;


ALTER FUNCTION sc_cce.processar_remessa_job() OWNER TO scan;

SET search_path = sc_cci, pg_catalog;

--
-- TOC entry 1253 (class 1255 OID 564255)
-- Name: atualiza_arquivo_cobranca_tercerizada(); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION atualiza_arquivo_cobranca_tercerizada() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg_emc record;
rg record;

ct_cobranca_tercerizada numeric := 4;

vl_qtd_reg_arquivo numeric;
vl_valor_principal numeric(13,2);
vl_valor_total numeric(13,2);

vl_valido numeric;
vl_codigo_header numeric;
vl_codigo_detalhe numeric;

begin

for rg_emc in select * 
                from sc_cci.tbl_emc  
               where fg_atv_emc = 'S' 
                 and cd_tci = ct_cobranca_tercerizada 
loop      

    select count(*), sum(fcr.vl_sld_dvd_fcr), sum(fcr.vl_sld_dvd_fcr - fcr.vl_rst_enc_fcr)
      into vl_qtd_reg_arquivo, vl_valor_total, vl_valor_principal
    from sc_cci.tbl_cci cci
		inner join sc_cci.tbl_cct cct on cct.cd_crt = cci.cd_crt
		inner join sc_opr.tbl_crt crt on crt.cd_crt = cci.cd_crt
		inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
    where cci.cd_emc = 2
      and cct.fg_env_cct = 'N';  

    if vl_qtd_reg_arquivo > 0 then

        -- inserindo registro na tabela de arquivo de cobranca tercerizada
        select nextval('sc_cci.sq_act') into vl_codigo_header;
        
        insert into sc_cci.tbl_act (cd_act, cd_emc, dt_grc_act, nr_reg_act, vl_ttl_prc_act, vl_ttl_act)
            values (vl_codigo_header, rg_emc.cd_emc, current_date, vl_qtd_reg_arquivo, vl_valor_principal, vl_valor_total);

        -- inserindo detalhes na tabela de detalhe de arquivo de cobranca tercerizada
	for rg in select distinct cci.cd_crt as cartao, current_date - crt.dt_ini_atr_crt as dias_atraso,
			 cct.vl_sld_cct as saldo_devedor,  fcr.vl_sld_dvd_fcr - fcr.vl_rst_enc_fcr as valor_principal
	          from sc_cci.tbl_cci cci
	              inner join sc_cci.tbl_cct cct on cct.cd_crt = cci.cd_crt
	              inner join sc_opr.tbl_crt crt on crt.cd_crt = cci.cd_crt
	              inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
	          where cci.cd_emc = 2
	            and cct.fg_env_cct = 'N'
	loop       

	     select nextval('sc_cci.sq_dct') into vl_codigo_detalhe;
	     
	     -- gravando na tabela para gerar o arquivo
             insert into sc_cci.tbl_dct (cd_dct, cd_act, cd_crt, vl_prc_dct, vl_ttl_dct, nr_dia_atr_dct)
                    values (vl_codigo_detalhe, vl_codigo_header, rg.cartao, rg.valor_principal, rg.saldo_devedor,rg.dias_atraso);

             -- atualizando a tabela informando que o cartao ja esta em um determinado arquivo
	     update sc_cci.tbl_cct 
	        set fg_env_cct = 'S', 
	            dt_env_cct = now(),
	            cd_dct = vl_codigo_detalhe
             where cd_crt = rg.cartao;
             
	end loop;

       -- validando quantidade de registros e totais do arquivo 
	    select count(cd_dct), sum(vl_ttl_dct), sum(vl_prc_dct)
	      into vl_qtd_reg_arquivo, vl_valor_total, vl_valor_principal
	    from sc_cci.tbl_dct
	     where cd_act = vl_codigo_header;

	    select coalesce(count(*),0)
	      into vl_valido
	     from sc_cci.tbl_act
	    where cd_act = vl_codigo_header
	      and nr_reg_act = vl_qtd_reg_arquivo
	      and vl_ttl_prc_act = vl_valor_principal
	      and vl_ttl_act = vl_valor_total;

	    if vl_valido = 0 then
		raise exception 'Erro na validação geração do arquivo de cobranca tercerizada';
	    end if;
    
    end if;

end loop;    

end;$$;


ALTER FUNCTION sc_cci.atualiza_arquivo_cobranca_tercerizada() OWNER TO scan;

--
-- TOC entry 7759 (class 0 OID 0)
-- Dependencies: 1253
-- Name: FUNCTION atualiza_arquivo_cobranca_tercerizada(); Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON FUNCTION atualiza_arquivo_cobranca_tercerizada() IS 'rotina que atualiza a tabela para gerar o arquivo de cobranca';


--
-- TOC entry 1256 (class 1255 OID 564256)
-- Name: carga_inicial_spc(); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION carga_inicial_spc() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;
rg_crt record;

codigo_cun numeric;
codigo_hci_local numeric;

begin


 for rg in select *
            from sc_cci.tbl_teste loop


 codigo_cun := 0;  
  
 select cd_cun
   into codigo_cun
 from sc_cad.tbl_cun  
    where nr_cpf_cnpj_cun = rg.cpf;

 if codigo_cun > 0 then

   RAISE NOTICE 'Analisando codigo unico(%)', codigo_cun;

   for rg_crt in 
     select crt.cd_crt
       from sc_cad.tbl_fnc fnc
         inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
         inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
     where fnc.cd_cun = codigo_cun
       and crt.dt_inc_usr <= '21/11/2012' loop
           
	   RAISE NOTICE '  Cartao possivel negativaocao(%)', rg_crt.cd_crt;	

       select coalesce(cd_hci,0)
         into codigo_hci_local
        from sc_cci.tbl_hci 
        where cd_crt = rg_crt.cd_crt
          and cd_tci = 1;

         RAISE NOTICE '    Existe HCI de codigo(%)', codigo_hci_local; 
 
       if codigo_hci_local  > 0 then
           update sc_cci.tbl_hci set dt_sai_hci = '21/11/2012' where cd_hci = codigo_hci_local;

           -- inserindo uma ocorrencia de inicio de cobranca do tipo spc
           insert into sc_cci.tbl_hci (cd_hci, cd_crt, cd_tci, dt_ent_hci, dt_sai_hci)
              values (nextval('sc_cci.sq_hci'),rg_crt.cd_crt, 2, '21/11/2012', null);

           RAISE NOTICE '      Cartao NEGATIVADO(%)', rg_crt.cd_crt; 
       
       end if;
       
     end loop;    
          
 end if;
  
 end loop;           
            
end;$$;


ALTER FUNCTION sc_cci.carga_inicial_spc() OWNER TO scan;

--
-- TOC entry 1257 (class 1255 OID 564257)
-- Name: enviar_sms_cobranca(); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION enviar_sms_cobranca() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

CT_PRM_QTDE_DIAS_ATRASO constant varchar := 'QTDE_DIAS_ATRASO';
CT_PRM_TIPO_MENSAGEM_COBRANCA_ATRASO constant varchar := 'TIPO_MENSAGEM_COBRANCA_ATRASO';

rg record;

vl_dias_atraso 		numeric;
vl_tipo_mensagem 	numeric;
vl_ddd			numeric;
vl_telefone		numeric;
vl_existe_mensagem	numeric;

begin

  -- capturando a quantidade de dias de atraso para ser enviado a mensagem de cobranca
  select vl_prm::numeric
  into vl_dias_atraso
  from sc_cad.tbl_prm
  where nm_prm = CT_PRM_QTDE_DIAS_ATRASO;

  -- capturando o tipo de mensagem a ser enviado para poder cadastrar as mensagens
  select vl_prm::numeric
  into vl_tipo_mensagem
  from sc_cad.tbl_prm
  where nm_prm = CT_PRM_TIPO_MENSAGEM_COBRANCA_ATRASO;
  
  for rg in select crt.cd_crt as cartao, fnc.cd_cun as cad_unico, 
                   cun.nm_cun as nome, fcr.vl_sld_dvd_fcr as saldo_devedor, 
                   to_char(fcr.dt_vnc_fcr, 'DD/MM/YYYY') || '@' || replace(fcr.vl_sld_dvd_fcr::varchar, '.', ',') as mensagem
	    from sc_fcr.tbl_fcr fcr
		inner join sc_opr.tbl_crt crt on crt.cd_fcr = fcr.cd_fcr
		inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
		inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	    where current_date - crt.dt_ini_atr_crt = vl_dias_atraso
	      --    current_date - crt.dt_ini_atr_crt >= vl_dias_atraso
	      --and current_date - crt.dt_ini_atr_crt < 31
	      and fcr.vl_sld_dvd_fcr > 10
	      and crt.fg_ind_crt = 'S' 
	      and exists (select 1 
		          from sc_cad.tbl_tlf tlf 
		          where tlf.nsu_org_tlf = cun.cd_cun 
			    and tlf.fg_atv_tlf = 'S'
			    and tlf.tp_tlf = 2 -- telefone tipo celular
			    and tlf.nr_tlf > 80000000
			    and tlf.nr_tlf <> 88888888)
	   order by saldo_devedor, cartao
  loop
     
     -- pegando o numero do celular para cadastrar a mensagem
     select tlf.nr_ddd_tlf, tlf.nr_tlf
       into vl_ddd, vl_telefone
     from sc_cad.tbl_tlf tlf
     where tlf.cd_tlf in (select max(cd_tlf) 
		          from sc_cad.tbl_tlf tl
			  where tl.nsu_org_tlf = rg.cad_unico 
			    and tl.tp_tlf = 2 -- telefone tipo celular
			    and tl.nr_tlf <> 88888888 
			    and tl.nr_tlf > 80000000 
		            and tl.fg_atv_tlf = 'S');

      -- verificando se ja existe mensagem de depoisto
      select count(*)
        into vl_existe_mensagem
      from sc_msg.tbl_msg msg
      where msg.cd_tms = vl_tipo_mensagem
        and msg.ddd_msg = vl_ddd
        and msg.nr_msg = vl_telefone
        and msg.fg_atv_msg = 'S'
        and msg.fg_env_msg = 'N';

      if vl_existe_mensagem = 0 then
        insert into sc_msg.tbl_msg(cd_msg, cd_tms, ddd_msg, nr_msg, prm_msg, fg_atv_msg, fg_env_msg, cd_inc_usr, dt_inc_usr, cd_crt)
          values (nextval('sc_msg.sq_msg'), vl_tipo_mensagem, vl_ddd, vl_telefone, rg.mensagem, 'S', 'N', 1, now(), rg.cartao);
      end if;
     
  end loop; 

end;$$;


ALTER FUNCTION sc_cci.enviar_sms_cobranca() OWNER TO scan;

--
-- TOC entry 7760 (class 0 OID 0)
-- Dependencies: 1257
-- Name: FUNCTION enviar_sms_cobranca(); Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON FUNCTION enviar_sms_cobranca() IS 'rotina que envia as mensagens para clientes com um determinado dias de atraso';


--
-- TOC entry 1258 (class 1255 OID 564258)
-- Name: excluir_cartao_cobranca(numeric, numeric); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION excluir_cartao_cobranca(vp_cartao numeric, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

vl_tipo_cobranca numeric := 0;
begin

  if vp_empresa = 1 then
    vl_tipo_cobranca := 1;
  else
    vl_tipo_cobranca := 4;
  end if;
  
  -- marcando no historico que saiu na cobranca
  update sc_cci.tbl_hci hci 
     set dt_sai_hci = current_date
  where hci.cd_crt = vp_cartao 	
     and hci.cd_tci = vl_tipo_cobranca
     and dt_sai_hci is null;

  -- retirando o cartao da cobranca tercerizada
  update sc_cci.tbl_cci
     set cd_emc = 1, -- saqcard 
	 fg_atv_cci = 'N'	          
  where cd_crt = vp_cartao;

  -- retirando a marcacao de inadimplente do cartao
  update sc_opr.tbl_crt crt
     set fg_ind_crt = 'N', 
         dt_fim_atr_crt = now()
  where cd_crt = vp_cartao;   

  -- excluir cartao da negativacao do SPC
  perform sc_cci.excluir_cartao_negativacao_spc(vp_cartao);
  
end;$$;


ALTER FUNCTION sc_cci.excluir_cartao_cobranca(vp_cartao numeric, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 7761 (class 0 OID 0)
-- Dependencies: 1258
-- Name: FUNCTION excluir_cartao_cobranca(vp_cartao numeric, vp_empresa numeric); Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON FUNCTION excluir_cartao_cobranca(vp_cartao numeric, vp_empresa numeric) IS 'Rotina que exclui um determinado cartao da cobranca devido ter feito uma renegociacao';


--
-- TOC entry 1259 (class 1255 OID 564259)
-- Name: excluir_cartao_negativacao_spc(numeric); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION excluir_cartao_negativacao_spc(vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

vl_qtde numeric := 0;
ct_tipo_exclusao_spc numeric := 13;
ct_tipo_exclusao numeric := 2;

begin

   select count(*) 
     into vl_qtde
   from sc_cci.tbl_cci
   where cd_crt = vp_cartao
     and fg_ngt_spc_cci = 'S';

   if vl_qtde > 0 then

     -- retirando a marcação da negativacao do SPC do cartao
     update sc_cci.tbl_cci
        set fg_ngt_spc_cci = 'N', 
            dt_ngt_spc_cci = null
     where cd_crt = vp_cartao;
     
     -- incluindo uma ocorrencia para registrar a exclusao do SPC
     insert into sc_opr.tbl_ocr (cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr)
              VALUES (nextval('sc_opr.sq_ocr'), ct_tipo_exclusao_spc, vp_cartao, null, 'CARTAO FOI EXCLUIDO DO SPC', 'N', 1, now());

     -- gerando remessa do arquivo de negativacao SPC
     perform sc_cci.gerar_remessa_spc(vp_cartao, ct_tipo_exclusao);
        
   end if;
  
end;$$;


ALTER FUNCTION sc_cci.excluir_cartao_negativacao_spc(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7762 (class 0 OID 0)
-- Dependencies: 1259
-- Name: FUNCTION excluir_cartao_negativacao_spc(vp_cartao numeric); Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON FUNCTION excluir_cartao_negativacao_spc(vp_cartao numeric) IS 'rotina que exclui o cartao da marcacao de negativacao do spc e grava um ocorrencia';


--
-- TOC entry 1260 (class 1255 OID 564260)
-- Name: gerar_arquivo_cobranca_tercerizada(); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION gerar_arquivo_cobranca_tercerizada() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare


rg_emc record;
rg_dct record;

ct_cobranca_spc numeric := 2;
ct_cobranca_tercerizada numeric := 4;
ct_situacao_cadastrado numeric := 1;
ct_situacao_gerado numeric := 2;

ct_tipo_residencial constant numeric := 1;
ct_tipo_celular constant numeric := 2;
ct_tipo_comercial constant numeric := 3;

separador varchar := ';';

vl_diretorio varchar;
vl_nome_arquivo varchar;
vl_local_arquivo varchar;
vl_ddd_telefone varchar;

vl_codigo_arquivo numeric;
vl_data_referencia date;

linha varchar;

vl_rg_edr sc_cad.vw_edr%rowtype;
vl_rg_tlf sc_cad.tbl_tlf%rowtype;
vl_rg_cel sc_cad.tbl_tlf%rowtype;
vl_rg_tlf_emp sc_cad.tbl_tlf%rowtype;

begin


for rg_emc in select * 
                from sc_cci.tbl_emc  
               where fg_atv_emc = 'S' 
                 and cd_tci = ct_cobranca_tercerizada loop 

    -- obtendo parametros do arquivo
    select act.cd_act, act.dt_grc_act, emc.nm_dir_arq
      into vl_codigo_arquivo, vl_data_referencia, vl_diretorio
    from sc_cci.tbl_act act
      inner join sc_cci.tbl_emc emc on emc.cd_emc = act.cd_emc    
    where act.cd_emc = rg_emc.cd_emc
      and act.st_act = ct_situacao_cadastrado;

    if vl_codigo_arquivo is not null then
      
      --definindo o nome do arquivo
      vl_nome_arquivo := rg_emc.nm_emc || to_char(current_date, 'yyyymmdd') || '.' || trim(to_char(vl_codigo_arquivo, repeat('0', 5))) || '.csv';

      --definindo onde o arquivo sera gravado
      vl_local_arquivo := vl_diretorio || E'\\' || vl_nome_arquivo;

      --gravando a linha de cabecalho
      linha := 'NUM TITULO;CPF;NOME_TITULAR;ENDERECO;BAIRRO;CIDADE;UF;CEP;FONE RESIDENCIAL;FONE COMERCIAL;VALOR;LOJISTA;VENCIMENTO;BORDERO;OBS1;OBS2;PAI;MAE;AVALISTA;BANCO;AGENCIA;CONTA CORRENTE;No.CHEQUE;ALINEA;RG;DATA NASC;CELULAR;DATA EMISSAO;NUM CONTRATO;COD REGIONAL;COD FILIAL;NOME FILIAL;VL CUSTAS;VL PROTESTO;VL NOTIFICACAO;VL DESP COBRANCA;FASE/NºTERCEIRIZACAO;MODALIDADE;PRODUTO;BASE;DE;DATA COMPRA;DATA DEVOLUÇÃO/FINAL;MARCA;MODELO;ANO FABRICACAO;ANO MODELO;PLACA;CHASSI;RENAVAN;COMBUSTIVEL;ENDERECO TRABALHO;BAIRRO TRABALHO;CIDADE TRABALHO;UF TRABALHO;CEP TRABALHO;CPF AVALISTA 1;ENDERECO AVALISTA 1;BAIRRO AVALISTA 1;CIDADE AVALISTA 1;UF AVALISTA 1;CEP AVALISTA 1;FONE AVALISTA 1;FONE2 AVALISTA 1;E-MAIL DEVEDOR';
      perform sc_arq.gravarlinha(vl_local_arquivo, linha);


       -- iterando nos registros do arquivo
      for rg_dct in select dct.*, crt.cd_fcr, cun.nr_cpf_cnpj_cun, 
                           cun.nm_cun, cun.eml_cun, cpf.*, emp.nm_emp, fcr.dt_vnc_fcr,
                           fem.nm_fem, fem.cd_cun as cun_filial, gem.nm_gem, 
                           cci.fg_ngt_spc_cci as flag_negat_spc, cci.dt_ngt_spc_cci as dt_negat_spc, fcr.dt_vnc_fcr as data_vencimento
                      from sc_cci.tbl_dct dct
                        inner join sc_opr.tbl_crt crt on crt.cd_crt = dct.cd_crt
                        inner join sc_cci.tbl_cci cci on cci.cd_crt = crt.cd_crt
                        inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
                        inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                        inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
                        inner join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
                        inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                        inner join sc_cad.tbl_gem gem on gem.cd_gem = emp.cd_gem
                        inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp and fem.cd_fem = fnc.cd_fem
                    where dct.cd_act = vl_codigo_arquivo
                    order by fcr.cd_fcr
                       loop
        
        --campo numero do titulo 
        linha := rg_dct.cd_fcr || separador;

        --campo CPF
        linha := linha || rg_dct.nr_cpf_cnpj_cun || separador;
        
	--campo NOME_TITULAR
        linha := linha || rg_dct.nm_cun || separador;


        --obtendo informacoes do endereco
	select * 
         into vl_rg_edr 
        from sc_aeo.get_endereco(rg_dct.cd_cun);

	--campo ENDERECO
	--linha := linha || vl_rg_edr.logradouro || ', ' || vl_rg_edr.nr_edr;
	if vl_rg_edr.logradouro is not null then
           linha := linha || vl_rg_edr.logradouro;
        else
           linha := linha || ' ';
        end if;

        if vl_rg_edr.nr_edr is not null then
           linha := linha || ', ' || vl_rg_edr.nr_edr;
        else
           linha := linha || ' ';
        end if;
        

	if vl_rg_edr.cpl_edr is not null then
	  linha := linha || ' - ' || vl_rg_edr.cpl_edr || separador;
	else
	  linha := linha || separador;
	end if;
        
        --campo BAIRRO
        linha := linha || vl_rg_edr.bairro || separador;
	
        --campo CIDADE
        linha := linha || vl_rg_edr.localidade || separador;
        
        --campo UF
        linha := linha || vl_rg_edr.uf || separador;
        
        --campo CEP
        linha := linha || vl_rg_edr.cep_edr || separador;
        
        --obtendo as informacoes do telefone residencial
	select *
         into vl_rg_tlf
        from sc_aeo.get_telefone(rg_dct.cd_cun, ct_tipo_residencial);
     
        --campo TELEFONE RESIDENCIAL
        if vl_rg_tlf.nr_ddd_tlf is not null and vl_rg_tlf.nr_tlf is not null then
          vl_ddd_telefone := vl_rg_tlf.nr_ddd_tlf::text || vl_rg_tlf.nr_tlf::text;
          linha := linha ||  vl_ddd_telefone || separador;
        else
          linha := linha || separador;
        end if;
        
	--obtendo as informacoes do telefone comercial
        select *
        into vl_rg_tlf_emp
        from sc_aeo.get_telefone(rg_dct.cun_filial, ct_tipo_comercial);
        
        --campo TELEFONE COMERCIAL
        if vl_rg_tlf_emp.nr_ddd_tlf is not null and vl_rg_tlf_emp.nr_tlf is not null then
          vl_ddd_telefone := vl_rg_tlf_emp.nr_ddd_tlf::text || vl_rg_tlf_emp.nr_tlf::text;
          linha := linha ||  vl_ddd_telefone || separador;
        else
          linha := linha || separador;
        end if;

        -- tratamento especifico para cliente FAMA
	-- solicita as informacoes em linhas separadas para valor principal e tarifa da operacao
 
	--campo VALOR PRINCIPAL
        linha := linha || sc_arq.formatar_moeda(rg_dct.vl_prc_dct, 13, 2, ',') || separador;

        --campo LOJISTA (EMPRESA DO CLIENTE)
        linha := linha || rg_dct.nm_gem || separador;

        --campo VENCIMENTO
        linha := linha || (current_date - interval '1 day' * rg_dct.nr_dia_atr_dct)::date || separador;

        --campo BORDERO (TIPO DE OPERACAO)
        linha := linha || separador;

        --campo OBS1 (FILIAL DO CLIENTE)
	linha := linha || rg_dct.nm_emp || ' - ' ||rg_dct.nm_fem || separador;

        --campo OBS2 (OUTRAS OBSERVACOES)  
	if rg_dct.flag_negat_spc = 'S' and rg_dct.dt_negat_spc is not null then		
	  linha := linha || 'NEGATIVADO NO SPC EM ' || rg_dct.dt_negat_spc || separador;
	else
	  linha := linha || separador;
	end if;

        --campo PAI
        linha := linha || separador;

        --campo MAE
        linha := linha || COALESCE(rg_dct.nm_mae_cpf, '') || separador;

        --campo AVALISTA
        linha := linha || separador;

        --campo BANCO
        linha := linha || separador;

        --campo AGENCIA
        linha := linha || separador;

	--campo CONTA CORRENTE
        linha := linha || separador;

        --campo NUMERO CHEQUE
        linha := linha || separador;

	--campo ALINEA
        linha := linha || separador;

        --campo RG
        linha := linha || COALESCE(rg_dct.nr_rg_cpf, '0') || separador;

        --campo DATA NASCIMENTO
        linha := linha || separador;

        --obtendo as informacoes do telefone celular
	select *
          into vl_rg_cel
        from sc_aeo.get_telefone(rg_dct.cd_cun, ct_tipo_celular);
        
        --campo TELEFONE CELULAR
        if vl_rg_cel.nr_ddd_tlf is not null and vl_rg_cel.nr_tlf is not null then
          vl_ddd_telefone := vl_rg_cel.nr_ddd_tlf::text || vl_rg_cel.nr_tlf::text;
          linha := linha || vl_ddd_telefone || separador;
        else
          linha := linha || separador;
        end if;
	
        --campo DATA EMISSAO
	linha := linha || current_date  || separador;

	--campo NUMERO CONTRATO
	linha := linha || rg_dct.cd_crt || separador;

	--campo NUMERO COD REGIONAL
	linha := linha || separador;

	--campo NUMERO COD FILIAL
	linha := linha || separador;

	--campo NUMERO NOME FILIAL
	linha := linha || separador;

	--campo NUMERO VL CUSTAS
	linha := linha || separador;

	--campo NUMERO VL PROTESTO
	linha := linha || separador;

	--campo NUMERO VL NOTIFICACAO
	linha := linha || separador;

	--campo NUMERO VL DESP COBRANCA
	linha := linha || separador;

        --campos nao utilizados
        --FASE/NºTERCEIRIZACAO;MODALIDADE;PRODUTO;BASE;DE;DATA COMPRA;DATA DEVOLUÇÃO/FINAL;MARCA;MODELO;ANO FABRICACAO;ANO MODELO;PLACA;CHASSI;RENAVAN;COMBUSTIVEL;ENDERECO TRABALHO;BAIRRO TRABALHO;CIDADE TRABALHO;UF TRABALHO;CEP TRABALHO;CPF AVALISTA 1;ENDERECO AVALISTA 1;BAIRRO AVALISTA 1;CIDADE AVALISTA 1;UF AVALISTA 1;CEP AVALISTA 1;FONE AVALISTA 1;FONE2 AVALISTA 1;
        -- nesse momento sao 32 campos nao utilizados
        -- caso deseje alterar observar esse numero 32
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;
        linha := linha || separador;

	--campo EMAIL DEVEDOR
	linha := linha || COALESCE(rg_dct.eml_cun, '') || separador;

	--campo VALOR CORRIGIDO (VALOR A COBRAR)
	linha := linha || sc_arq.formatar_moeda(rg_dct.vl_ttl_dct, 13, 2, ',') || separador;

	--campo DATA DA CORREÇÃO
	linha := linha || to_char(rg_dct.data_vencimento, 'dd/MM/yyyy');

	--raise notice 'linha: %',linha;	
        -- gravando a linha de registro
        if(linha is not null and linha <> '' and linha <> '<NULL>') then
	        perform sc_arq.gravarlinha(vl_local_arquivo, linha);
        ELSE 
           raise notice '**************** PROBLEMA *****************';	    
        end if;    

      end loop;

     

     --atualizando situacao do arquivo para gerado
     update sc_cci.tbl_act set st_act = 2 where cd_act = vl_codigo_arquivo;
 
     --inserindo registro na tabela de download
     insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_arquivo,now(),vl_data_referencia,4,1);

    
   end if;   

end loop;

exception 
when others then
  perform sc_arq.excluirArquivo(vl_nome_arquivo); 
  RAISE EXCEPTION 'Problema na geração do arquivo de emissão de plastico. NUM:%, DETAILS:%', SQLSTATE, SQLERRM;
end;
$$;


ALTER FUNCTION sc_cci.gerar_arquivo_cobranca_tercerizada() OWNER TO scan;

--
-- TOC entry 1500 (class 1255 OID 564263)
-- Name: gerar_arquivo_remessa_spc_OLD(numeric, numeric); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION "gerar_arquivo_remessa_spc_OLD"(vp_tipo numeric, vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  
  PRM_DIRETORIO_ARQUIVO VARCHAR := 'NM_DIR_ARQ_RMS_SPC';
  ct_sit_enviado numeric := 2;
  
  vl_nome_arquivo varchar;
  vl_diretorio varchar;
  vl_linha varchar;
  vl_criar_arquivo boolean := false;
BEGIN
    
    for rg in select case when ans.tp_ans = 1 then 'INCLUSAO' else 'EXCLUSAO' end as tipo,
			cun.nm_cun as nome, cun.nr_cpf_cnpj_cun as cpf, crt.cd_crt as cartao, 
			current_date - crt.dt_ini_atr_crt as dias_atraso,
			fcr.dt_vnc_fcr as data_vencimento, fcr.vl_sld_dvd_fcr as saldo_devedor, cd_ans
	      from sc_cci.tbl_ans ans
			inner join sc_opr.tbl_crt crt on crt.cd_crt = ans.cd_crt
			inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
			inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
			left join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr	
              where ans.st_ans = 1 -- cadastrado
                and ans.cd_crt = COALESCE(vp_cartao, ans.cd_crt)
                and ans.tp_ans = COALESCE(vp_tipo, ans.tp_ans)
	      order by tipo, saldo_devedor, nome
    loop
                
         if not vl_criar_arquivo then

           select prm.vl_prm
	      into vl_diretorio
	    from sc_cad.tbl_prm prm
	    where prm.nm_prm = PRM_DIRETORIO_ARQUIVO;
	    
	    vl_nome_arquivo := 'SPC_' || to_char(current_date,'yyyyMMdd') || '.csv';
	    vl_nome_arquivo := vl_diretorio || '/' || vl_nome_arquivo;
	    
	    vl_linha := 'TIPO;NOME;CPF;CARTAO;SALDO_DEVEDOR;DIAS_ATRASO;VENCIMENTO';
	    
	    perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

	    vl_criar_arquivo := true;
	    
         end if;

         vl_linha := rg.tipo || ';';
         
         vl_linha := vl_linha || rg.nome || ';';
         
         vl_linha := vl_linha || rg.cpf || ';';
         
         vl_linha := vl_linha || rg.cartao || ';';
         
	 vl_linha := vl_linha ||rg.saldo_devedor || ';';

         vl_linha := vl_linha ||rg.dias_atraso || ';';

         vl_linha := vl_linha ||rg.data_vencimento || ';';
         
         perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);           

         update sc_cci.tbl_ans
            set st_ans = ct_sit_enviado,
                dt_env_ans = now()
         where cd_ans = rg.cd_ans;
            
    end loop;             
END;  
$$;


ALTER FUNCTION sc_cci."gerar_arquivo_remessa_spc_OLD"(vp_tipo numeric, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1262 (class 1255 OID 564264)
-- Name: gerar_carga_cobranca_tercerizada(); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION gerar_carga_cobranca_tercerizada() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

begin

  perform sc_cci.marcar_empresa_cobranca_tercerizada();
  perform sc_cci.atualiza_arquivo_cobranca_tercerizada();
  perform sc_cci.gerar_arquivo_cobranca_tercerizada();
  
end;$$;


ALTER FUNCTION sc_cci.gerar_carga_cobranca_tercerizada() OWNER TO scan;

--
-- TOC entry 7763 (class 0 OID 0)
-- Dependencies: 1262
-- Name: FUNCTION gerar_carga_cobranca_tercerizada(); Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON FUNCTION gerar_carga_cobranca_tercerizada() IS 'Rotina que gerar carga para a empresa de cobrança tercerizada';


--
-- TOC entry 1264 (class 1255 OID 564265)
-- Name: gerar_remessa_spc(numeric, numeric); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION gerar_remessa_spc(vp_cartao numeric, vp_tipo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

vl_qtde numeric := 0;
ct_tipo_inclusao_spc numeric := 1;
ct_tipo_exclusao_spc numeric := 2;
vl_sucesso boolean := false;
begin

   select count(*) 
     into vl_qtde
   from sc_cci.tbl_ans
   where cd_crt = vp_cartao
     and tp_ans = vp_tipo
     and st_ans = 1; -- cadastrado

   if vl_qtde = 0 then
       
       if vp_tipo = ct_tipo_exclusao_spc then
	  -- EXCLUSAO
           select count(*) 
	     into vl_qtde
	   from sc_cci.tbl_ans
	   where cd_crt = vp_cartao
	     and tp_ans = ct_tipo_inclusao_spc
	     and st_ans = 1;
           
           if vl_qtde > 0 then
             delete from sc_cci.tbl_ans where cd_crt = vp_cartao and tp_ans = ct_tipo_inclusao_spc and st_ans = 1;
	   else
	     insert into sc_cci.tbl_ans(cd_ans, cd_crt, tp_ans, st_ans, dt_inc_usr)
                 values (nextval('sc_cci.sq_ans'), vp_cartao, vp_tipo, 1, now());
	   end if;
       else
           -- INCLUSAO 
	   select count(*) 
	     into vl_qtde
	   from sc_cci.tbl_ans
	   where cd_crt = vp_cartao
	     and tp_ans = ct_tipo_exclusao_spc
	     and st_ans = 1;
           
           if vl_qtde > 0 then
             delete from sc_cci.tbl_ans where cd_crt = vp_cartao and tp_ans = ct_tipo_exclusao_spc and st_ans = 1;
	   else
              insert into sc_cci.tbl_ans(cd_ans, cd_crt, tp_ans, st_ans, dt_inc_usr)
                   values (nextval('sc_cci.sq_ans'), vp_cartao, vp_tipo, 1, now());
           end if;
       end if;
        
   end if;
  
end;$$;


ALTER FUNCTION sc_cci.gerar_remessa_spc(vp_cartao numeric, vp_tipo numeric) OWNER TO scan;

--
-- TOC entry 7764 (class 0 OID 0)
-- Dependencies: 1264
-- Name: FUNCTION gerar_remessa_spc(vp_cartao numeric, vp_tipo numeric); Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON FUNCTION gerar_remessa_spc(vp_cartao numeric, vp_tipo numeric) IS 'rotina que gera remessa para o spc, tanto inclusao quanto exclusao';


--
-- TOC entry 1267 (class 1255 OID 564266)
-- Name: gravar_cartao_enviar_cobranca_tercerizada(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION gravar_cartao_enviar_cobranca_tercerizada(vp_cartao numeric, vp_empresa_cobranca numeric, vp_tipo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_tipo_ocorrencia_inclusao  numeric := 5;
ct_tipo_ocorrencia_alteracao numeric := 6;

vl_saldo  numeric := 0;
vl_tipo_ocorrencia numeric := 0;
vl_quantidade numeric := 0;

begin
  
  -- verificando o saldo devedor que devera ser enviado para cobranca externa
  select fcr.vl_sld_dvd_fcr
    into vl_saldo
  from sc_opr.tbl_crt crt
	inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
  where crt.cd_crt = vp_cartao;  
  
  -- verificando se o cartao ja foi enviado alguma vez para a cobranca externa
  select count(*) 
    into vl_quantidade
  from sc_cci.tbl_cct
  where cd_crt = vp_cartao;
  
  if vl_quantidade = 0 then
    -- primeira vez	
	vl_tipo_ocorrencia := ct_tipo_ocorrencia_inclusao;
	
	INSERT INTO sc_cci.tbl_cct(cd_crt, cd_emc, dt_inc_usr, vl_sld_cct, fg_env_cct, dt_env_cct, tp_cct)
            VALUES (vp_cartao, vp_empresa_cobranca, now(), vl_saldo, 'N', null, vp_tipo);

  else
    -- ja foi enviado pelo menos uma vez
	vl_tipo_ocorrencia := ct_tipo_ocorrencia_alteracao;
	
	UPDATE sc_cci.tbl_cct 
	   SET vl_sld_cct = vl_saldo,
	       fg_env_cct = 'N', 
		   dt_env_cct = null, 
		   cd_dct = null,
		   tp_cct = vp_tipo
	where cd_crt = vp_cartao;
	   
  end if;
  
  -- gravando a ocorrencia
  INSERT INTO sc_cci.tbl_hcc(cd_hcc, tp_hcc, cd_inc_usr, dt_inc_usr, cd_crt, obs_hcc)
		VALUES (nextval('sc_cci.sq_hcc'), vl_tipo_ocorrencia, 1, now(), vp_cartao, 'CARTAO SERA ENVIADO PARA COBRANCA TERCERIZADA');

end;$$;


ALTER FUNCTION sc_cci.gravar_cartao_enviar_cobranca_tercerizada(vp_cartao numeric, vp_empresa_cobranca numeric, vp_tipo numeric) OWNER TO scan;

--
-- TOC entry 7765 (class 0 OID 0)
-- Dependencies: 1267
-- Name: FUNCTION gravar_cartao_enviar_cobranca_tercerizada(vp_cartao numeric, vp_empresa_cobranca numeric, vp_tipo numeric); Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON FUNCTION gravar_cartao_enviar_cobranca_tercerizada(vp_cartao numeric, vp_empresa_cobranca numeric, vp_tipo numeric) IS 'rotina que grava o cartao que sera enviado para a cobranca externa e grava um historico de envio';


--
-- TOC entry 1268 (class 1255 OID 564267)
-- Name: incluir_cartao_cobranca_tercerizada(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION incluir_cartao_cobranca_tercerizada(vp_cartao numeric, vp_empresa_cobranca numeric, vp_codigo_historico_cobranca numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare


ct_cobranca_local numeric := 1;
ct_cobranca_spc numeric := 2;
ct_cobranca_tercerizada numeric := 4;
ct_tipo_inclusao numeric := 1;
ct_tipo_alteracao numeric := 2;

vl_valor_divida_principal numeric := 0;
vl_cod_historico_cobranca numeric;

begin

  -- verificando se o cliente possui valor principal maior do que 15 reais para ser enviado para cobranca
  select fcr.vl_sld_dvd_fcr - fcr.vl_rst_enc_fcr
    into vl_valor_divida_principal
  from sc_fcr.tbl_fcr fcr
     inner join sc_opr.tbl_crt crt on crt.cd_fcr = fcr.cd_fcr
  where crt.cd_crt = vp_cartao;
		
  if vl_valor_divida_principal > 15 then

     if vp_codigo_historico_cobranca is not null then
        vl_cod_historico_cobranca := vp_codigo_historico_cobranca;
     else
	select cd_hci
          into vl_cod_historico_cobranca
	from sc_cci.tbl_hci hci 
	where hci.dt_sai_hci is null
	  and hci.cd_crt = vp_cartao;    
     end if;
	
     -- atualizando a data de saida da cobranca local ou spc
     update sc_cci.tbl_hci set dt_sai_hci = current_date where cd_hci = vl_cod_historico_cobranca;

     -- inserindo uma ocorrencia de inicio de cobranca do tipo tercerizada
     insert into sc_cci.tbl_hci (cd_hci, cd_crt, cd_tci, dt_ent_hci, dt_sai_hci)
	   values (nextval('sc_cci.sq_hci'), vp_cartao, ct_cobranca_tercerizada, current_date, null);

     -- atualizando empresa de cobranca no controle individual e ultimo historico de tipo de cobranca individual
     update sc_cci.tbl_cci 
	set cd_emc = vp_empresa_cobranca,
	    cd_hci = currval('sc_cci.sq_hci')
     where cd_crt = vp_cartao;
	
     perform sc_cci.gravar_cartao_enviar_cobranca_tercerizada(vp_cartao, vp_empresa_cobranca, ct_tipo_inclusao);
  end if;

end;$$;


ALTER FUNCTION sc_cci.incluir_cartao_cobranca_tercerizada(vp_cartao numeric, vp_empresa_cobranca numeric, vp_codigo_historico_cobranca numeric) OWNER TO scan;

--
-- TOC entry 7766 (class 0 OID 0)
-- Dependencies: 1268
-- Name: FUNCTION incluir_cartao_cobranca_tercerizada(vp_cartao numeric, vp_empresa_cobranca numeric, vp_codigo_historico_cobranca numeric); Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON FUNCTION incluir_cartao_cobranca_tercerizada(vp_cartao numeric, vp_empresa_cobranca numeric, vp_codigo_historico_cobranca numeric) IS 'rotina que inclui os cartões na cobrança tercerizada';


--
-- TOC entry 1568 (class 1255 OID 564268)
-- Name: macar_desmarcar_cobranca_individual(); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION macar_desmarcar_cobranca_individual() RETURNS void
    LANGUAGE plpgsql
    AS $_$declare

rg record;

ct_cobranca_local numeric := 1;
ct_cobranca_spc numeric := 2;

ct_tipo_inclusao_spc numeric := 12;
ct_tipo_inclusao numeric := 1;

vl_valor_principal numeric := 0;
vl_saldo_devedor_atual numeric := 0;
begin


  -- incluindo cartoes na cobranca
  for rg in select crt.cd_crt
	    from sc_fcr.tbl_fcr fcr
		 inner join sc_opr.tbl_crt crt on fcr.cd_fcr = crt.cd_fcr
		 inner join sc_cci.tbl_cci cci on cci.cd_crt = crt.cd_crt
	    where crt.fg_ind_crt = 'S'
	      and cci.fg_pas_cbr_cci = 'S'
	      and current_date - crt.dt_ini_atr_crt >= 21
	      and cci.fg_atv_cci = 'N' 
  loop
       
       
       -- inserindo uma ocorrencia de inicio de cobranca
       insert into sc_cci.tbl_hci (cd_hci, cd_crt, cd_tci, dt_ent_hci, dt_sai_hci)
           values (nextval('sc_cci.sq_hci'),rg.cd_crt, ct_cobranca_local, current_date, null);

       -- atualizando status de cobranca
       update sc_cci.tbl_cci 
          set fg_atv_cci = 'S', cd_emc = 1, cd_alt_usr = 1, dt_alt_usr = now()  
        where cd_crt = rg.cd_crt;    
                      
  end loop;


  -- incluindo cartoes no spc
  for rg in select cci.cd_crt, crt.cd_fcr
		from sc_cci.tbl_cci cci
			 inner join sc_opr.tbl_crt crt on crt.cd_crt = cci.cd_crt
			 inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
		where fcr.st_fcr = 1
		  and cci.fg_pas_ngv_cci = 'S'
                  and cci.fg_atv_cci = 'S'
		  and cci.fg_ngt_spc_cci = 'N'
		  and crt.fg_ind_crt = 'S'
		  and current_date - crt.dt_ini_atr_crt >= 45 
	      --and exists (select 1 from sc_cci.tbl_hcc where cd_crt = cci.cd_crt and dt_inc_usr >= hci.dt_ent_hci)
   loop

      select sum(vl_rst_fcr_tlt)
        into vl_valor_principal
      from sc_fcr.tbl_fcr_tlt
      where cd_fcr = rg.cd_fcr;

      select COALESCE(vl_sld_dvd_fcr, 0)
        into vl_saldo_devedor_atual
      from sc_fcr.tbl_fcr
      where cd_fcr = rg.cd_fcr;

      -- só deverá enviar para o SPC os clientes com dívida principal acima de R$ 10,00 (DEZ REAIS)
      if vl_valor_principal > 10 and vl_saldo_devedor_atual > 10 then
         update sc_cci.tbl_cci 
           set fg_ngt_spc_cci = 'S', 
	       dt_ngt_spc_cci = now()
         where cd_crt = rg.cd_crt;

         -- gravando uma ocorrencia para registrar que o cliente foi negativado
         insert into sc_opr.tbl_ocr (cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr)
                  VALUES (nextval('sc_opr.sq_ocr'), ct_tipo_inclusao_spc, rg.cd_crt, null, 'CARTAO FOI INCLUIDO NO SPC', 'N', 1, now());

         -- gerando remessa do arquivo de negativacao SPC
         perform sc_cci.gerar_remessa_spc(rg.cd_crt, ct_tipo_inclusao);
      end if;
      	      
  end loop;      
                      

  --excluindo cartoes da cobranca
   for rg in select crt.cd_crt, hci.cd_hci, hci.cd_tci
             from sc_opr.tbl_crt crt
	        inner join sc_cci.tbl_cci cci on cci.cd_crt = crt.cd_crt
	        inner join sc_cci.tbl_hci hci on hci.cd_crt = cci.cd_crt
	     where crt.fg_ind_crt = 'N'
	       and cci.fg_atv_cci = 'S'
	       and hci.dt_sai_hci is null loop

       -- atualizando a data de saida da cobranca local 
       update sc_cci.tbl_hci set dt_sai_hci = current_date where cd_hci = rg.cd_hci;

       -- atualizando status de cobranca
       update sc_cci.tbl_cci 
          set fg_atv_cci = 'N', cd_alt_usr = 1, dt_alt_usr = now()  
        where cd_crt = rg.cd_crt;

        -- excluindo o cartao do SPC
        perform sc_cci.excluir_cartao_negativacao_spc(rg.cd_crt);

  end loop;      

end;$_$;


ALTER FUNCTION sc_cci.macar_desmarcar_cobranca_individual() OWNER TO scan;

--
-- TOC entry 1269 (class 1255 OID 564269)
-- Name: marcar_empresa_cobranca_tercerizada(); Type: FUNCTION; Schema: sc_cci; Owner: scan
--

CREATE FUNCTION marcar_empresa_cobranca_tercerizada() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg_emc record;
rg record;

ct_cobranca_local numeric := 1;
ct_cobranca_spc numeric := 2;
ct_cobranca_tercerizada numeric := 4;
ct_tipo_inclusao numeric := 1;
ct_tipo_alteracao numeric := 2;

vl_valor_divida_principal numeric := 0;

begin

-- para todas empresas de cobranca ativas
for rg_emc in select * 
                from sc_cci.tbl_emc 
               where fg_atv_emc = 'S' 
                 and cd_tci = ct_cobranca_tercerizada loop 

    -- obtendo cartoes que se encaixam nos criterios de cobranca da tercerizada 
	-- REGRA 1: Por Faixa de Atraso 
	for rg in select cci.cd_crt, hci.cd_hci
		    from sc_cci.tbl_cci cci
			 inner join sc_opr.tbl_crt crt on crt.cd_crt = cci.cd_crt
			 inner join sc_cci.tbl_hci hci on hci.cd_crt = crt.cd_crt
		    where cci.fg_atv_cci = 'S'
		      and hci.dt_sai_hci is null
		      and hci.cd_tci in (ct_cobranca_local,ct_cobranca_spc)
		      and current_date - crt.dt_ini_atr_crt >= rg_emc.nr_dia_ini_atr_emc
		      and current_date - crt.dt_ini_atr_crt < rg_emc.nr_dia_fim_atr_emc
		      and cci.cd_emc <> rg_emc.cd_emc  
		      and not exists (select 1 from sc_cci.tbl_hci where cd_crt = cci.cd_crt and dt_sai_hci is null and cd_tci = ct_cobranca_tercerizada) 
	loop

	   perform sc_cci.incluir_cartao_cobranca_tercerizada(rg.cd_crt, rg_emc.cd_emc, rg.cd_hci);
	   
	end loop;      

	/* COMENTADO POR RENATO JORGE - Pois agora a FAMA irá cadastrar as renegociações direto no nosso sistema e não precisará mais enviar a informação quando alterar o saldo devedor do cliente
	-- REGRA 2: Por Alteração no saldo devedor
	for rg in select crt.cd_crt as cartao
	          from sc_cci.tbl_cci cci
					inner join sc_cci.tbl_cct cct on cct.cd_crt = cci.cd_crt
					inner join sc_opr.tbl_crt crt on crt.cd_crt = cci.cd_crt
					inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
			  where cci.fg_atv_cci = 'S'
			    and cci.cd_emc = rg_emc.cd_emc
				and fcr.vl_sld_dvd_fcr <> cct.vl_sld_cct
	loop
	   -- perform sc_cci.gravar_cartao_enviar_cobranca_tercerizada(rg.cartao, rg_emc.cd_emc, ct_tipo_alteracao);
	   perform sc_cci.incluir_cartao_cobranca_tercerizada(rg.cd_crt, rg_emc.cd_emc, rg.cd_hci, ct_tipo_alteracao);
	end loop;
	*/
end loop;

end;$$;


ALTER FUNCTION sc_cci.marcar_empresa_cobranca_tercerizada() OWNER TO scan;

--
-- TOC entry 7767 (class 0 OID 0)
-- Dependencies: 1269
-- Name: FUNCTION marcar_empresa_cobranca_tercerizada(); Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON FUNCTION marcar_empresa_cobranca_tercerizada() IS 'rotina que identifica os cartões que estao atrasados ou que mudaram o saldo devedor para enviar para cobranca tercerizada';


SET search_path = sc_cnt, pg_catalog;

--
-- TOC entry 1270 (class 1255 OID 564270)
-- Name: arrendonda_saldo_conta_cartao(); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION arrendonda_saldo_conta_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;

  vl_arredondamento numeric(13, 2);
begin
  for rg in SELECT cnt_crt.cd_cnt, cnt.vl_sld_cnt
            FROM sc_opr.tbl_cnt_crt cnt_crt
		 inner join sc_cnt.tbl_cnt cnt on cnt_crt.cd_cnt = cnt.cd_cnt
            where cnt.vl_sld_cnt > 0
	      and mod(cnt.vl_sld_cnt+1, 50) < 1 loop
    --sc_cnt.lancsr_debito_credito(2854, rg.cd_cnt);
    vl_arredondamento := 50 - mod(rg.vl_sld_cnt, 50);
    perform sc_cnt.lancar_debito_credito(2854, rg.cd_cnt, 50, null, 'CREDITO DE ARREDONDAMENTO PARA PERMITIR SAQUE DE CEDULA 50', vl_arredondamento, CURRENT_DATE, 1, 7, nextval('sc_cnt.sq_arr'));
  end loop;
end;$$;


ALTER FUNCTION sc_cnt.arrendonda_saldo_conta_cartao() OWNER TO scan;

--
-- TOC entry 7768 (class 0 OID 0)
-- Dependencies: 1270
-- Name: FUNCTION arrendonda_saldo_conta_cartao(); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION arrendonda_saldo_conta_cartao() IS 'arredondando o saldo das contas do cartao para ser possivel sacar cedulas de 50';


--
-- TOC entry 1764 (class 1255 OID 1632762)
-- Name: atualiza_bloqueio_saque(); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION atualiza_bloqueio_saque() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   rg record;
begin
   for rg in select tc.cd_tbc_cnt,cnt.vl_sld_cnt
             from sc_cnt.tbl_cnt cnt
               inner join sc_cnt.tbl_tbc_cnt tc on tc.cd_cnt = cnt.cd_cnt
             where tc.cd_tbc = 9
               and tc.vl_blq_tbc_cnt > cnt.vl_sld_cnt loop
               
      update sc_cnt.tbl_tbc_cnt set vl_blq_tbc_cnt = rg.vl_sld_cnt where cd_tbc_cnt = rg.cd_tbc_cnt;

               
  end loop;             
                 
end$$;


ALTER FUNCTION sc_cnt.atualiza_bloqueio_saque() OWNER TO scan;

--
-- TOC entry 1605 (class 1255 OID 1012420)
-- Name: bloqueio_saldo_conta(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION bloqueio_saldo_conta(vp_conta numeric, vp_tipo_bloqueio numeric, vp_valor numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  
  vl_existe numeric;
  
begin

  select count(*)
    into vl_existe
  from sc_cnt.tbl_tbc_cnt
    where cd_cnt = vp_conta  
      and cd_tbc = vp_tipo_bloqueio;

  if vl_existe > 0 then
    update sc_cnt.tbl_tbc_cnt set vl_blq_tbc_cnt = vl_blq_tbc_cnt + vp_valor, cd_alt_usr = 1, dt_alt_usr = now() where cd_cnt = vp_conta and cd_tbc = vp_tipo_bloqueio;
  else
    insert into sc_cnt.tbl_tbc_cnt(cd_tbc_cnt,cd_tbc,cd_cnt,vl_blq_tbc_cnt,fg_atv_tbc_cnt,cd_inc_usr,cd_alt_usr,dt_inc_usr,dt_alt_usr) 
      values (nextval('sc_cnt.sq_tbc_cnt'),vp_tipo_bloqueio,vp_conta,vp_valor,'S',1,null,now(),null);
  end if;

end;$$;


ALTER FUNCTION sc_cnt.bloqueio_saldo_conta(vp_conta numeric, vp_tipo_bloqueio numeric, vp_valor numeric) OWNER TO scan;

--
-- TOC entry 1807 (class 1255 OID 1632755)
-- Name: bloqueio_saldo_conta_agendamento(numeric, numeric, numeric, timestamp without time zone); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION bloqueio_saldo_conta_agendamento(vp_conta numeric, vp_tipo_bloqueio numeric, vp_valor numeric, vp_data timestamp without time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_codigo_bloqueio numeric;
begin

  select max(cd_tbc_cnt)
  into vl_codigo_bloqueio
  from sc_cnt.tbl_tbc_cnt
  where cd_tbc = vp_tipo_bloqueio
    and dt_fin_blq_tbc_cnt is null
    and cd_cnt = vp_conta;


  if vl_codigo_bloqueio is null then

    insert into sc_cnt.tbl_tbc_cnt(cd_tbc_cnt,cd_tbc,cd_cnt,vl_blq_tbc_cnt,fg_atv_tbc_cnt,cd_inc_usr,cd_alt_usr,dt_inc_usr,dt_alt_usr, dt_fin_blq_tbc_cnt) 
      values (nextval('sc_cnt.sq_tbc_cnt'),vp_tipo_bloqueio,vp_conta,vp_valor,'S',1,null,now(),null,vp_data);
      
  else

    update sc_cnt.tbl_tbc_cnt 
       set vl_blq_tbc_cnt = vp_valor,
           dt_fin_blq_tbc_cnt = vp_data
    where cd_cnt = vp_conta 
      and cd_tbc_cnt = vl_codigo_bloqueio;
  
  
  end if;

    
end$$;


ALTER FUNCTION sc_cnt.bloqueio_saldo_conta_agendamento(vp_conta numeric, vp_tipo_bloqueio numeric, vp_valor numeric, vp_data timestamp without time zone) OWNER TO scan;

--
-- TOC entry 1271 (class 1255 OID 564271)
-- Name: cancelar_lancamento(numeric, numeric, numeric, character varying, numeric, numeric); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION cancelar_lancamento(vp_cd_sst numeric, vp_nsu numeric, vp_usuario numeric, vp_historico character varying, vp_tipo_lancamento numeric DEFAULT NULL::numeric, vp_cd_lcn numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  vl_rg_lcn sc_cnt.tbl_lcn%rowtype;
  vl_tipo_lancamento_estorno numeric;
  vl_cd_lcn numeric;
  vl_ctp_cd numeric;
  vl_valor_estorno_lancamento numeric;
  vl_quantidade_lancamento numeric;

begin

  -- tratamento caso tenha passado por parametro o codigo do lancamento
  if vp_cd_lcn is not null then

    -- validacoes
    begin
      select lcn.cd_ctp_lcn, lcn.vl_lcn
        into strict vl_ctp_cd, vl_valor_estorno_lancamento
      from sc_cnt.tbl_lcn lcn
      where lcn.cd_lcn = vp_cd_lcn;
    exception when others then
      RAISE 'Não existe este lançamento';
    end;
    
    if vl_ctp_cd is null then
      RAISE 'Não é possivel estornar um lançamento sem contra partida';
    end if;

    -- fazer o lancamento da contra partida
    select *
      into vl_rg_lcn
    from sc_cnt.tbl_lcn lcn
    where lcn.cd_lcn = vl_ctp_cd;

    select cd_est_tlc
      into vl_tipo_lancamento_estorno
    from sc_cnt.tbl_tlc tlc
    where tlc.cd_tlc = vl_rg_lcn.cd_tlc;

    select nextval('sc_cnt.sq_lcn') into vl_cd_lcn;
    
    update sc_cnt.tbl_lcn set
      cd_est_lcn = vl_cd_lcn
    where cd_lcn = vl_rg_lcn.cd_lcn;

    if vl_rg_lcn.fg_dcr_lcn = 'C' then
      perform sc_cnt.lancar_movimento(vl_cd_lcn, null, vl_tipo_lancamento_estorno, vl_rg_lcn.cd_cnt, 'D', vl_valor_estorno_lancamento, vl_rg_lcn.dt_ref_lcn, vp_usuario, null, vp_historico, vp_cd_sst, vp_nsu);
    else
      perform sc_cnt.lancar_movimento(vl_cd_lcn, null, vl_tipo_lancamento_estorno, vl_rg_lcn.cd_cnt, 'C', vl_valor_estorno_lancamento, vl_rg_lcn.dt_ref_lcn, vp_usuario, null, vp_historico, vp_cd_sst, vp_nsu);
    end if;
  end if;

  select count(*)
  into vl_quantidade_lancamento
  from sc_cnt.tbl_lcn lcn
  where lcn.cd_sst = vp_cd_sst
     and lcn.nsu_lcn = vp_nsu
     and lcn.cd_est_lcn is null 
     and (case when vp_tipo_lancamento is null then true else lcn.cd_tlc = vp_tipo_lancamento end)
     and (case when vp_cd_lcn is null then true else lcn.cd_lcn = vp_cd_lcn end);


  if vl_quantidade_lancamento > 2 then

     RAISE 'Não é possivel estornar um lançamento com partida dupla';
   
  end if;   
  
  for vl_rg_lcn in select *
                   from sc_cnt.tbl_lcn lcn
                   where lcn.cd_sst = vp_cd_sst
                     and lcn.nsu_lcn = vp_nsu
                     and lcn.cd_est_lcn is null 
                     and (case when vp_tipo_lancamento is null then true else lcn.cd_tlc = vp_tipo_lancamento end)
                     and (case when vp_cd_lcn is null then true else lcn.cd_lcn = vp_cd_lcn end) loop

    select cd_est_tlc
      into vl_tipo_lancamento_estorno
    from sc_cnt.tbl_tlc tlc
    where tlc.cd_tlc = vl_rg_lcn.cd_tlc;

    select nextval('sc_cnt.sq_lcn') into vl_cd_lcn;
    
    update sc_cnt.tbl_lcn set
      cd_est_lcn = vl_cd_lcn
    where cd_lcn = vl_rg_lcn.cd_lcn;

    if vl_rg_lcn.fg_dcr_lcn = 'C' then
      perform sc_cnt.lancar_movimento(vl_cd_lcn, null, vl_tipo_lancamento_estorno, vl_rg_lcn.cd_cnt, 'D', vl_rg_lcn.vl_lcn, vl_rg_lcn.dt_ref_lcn, vp_usuario, null, vp_historico, vp_cd_sst, vp_nsu);
    else
      perform sc_cnt.lancar_movimento(vl_cd_lcn, null, vl_tipo_lancamento_estorno, vl_rg_lcn.cd_cnt, 'C', vl_rg_lcn.vl_lcn, vl_rg_lcn.dt_ref_lcn, vp_usuario, null, vp_historico, vp_cd_sst, vp_nsu);
    end if;
  end loop;
end;$$;


ALTER FUNCTION sc_cnt.cancelar_lancamento(vp_cd_sst numeric, vp_nsu numeric, vp_usuario numeric, vp_historico character varying, vp_tipo_lancamento numeric, vp_cd_lcn numeric) OWNER TO scan;

--
-- TOC entry 1272 (class 1255 OID 564272)
-- Name: cobrar_arrendondamento(); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION cobrar_arrendondamento() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin
  for rg in SELECT lcn.cd_cnt, lcn.vl_lcn, lcn.nsu_lcn
            FROM sc_cnt.tbl_lcn lcn
            where lcn.cd_tlc = 50
              and lcn.cd_sst = 7
	      and lcn.cd_cnt <> 2854
	      and not exists (select 1 
	                      from sc_cnt.tbl_lcn lcn2
	                      where lcn.nsu_lcn = lcn2.nsu_lcn
	                        and lcn.cd_lcn <> lcn2.cd_lcn
	                        and lcn2.cd_cnt <> 2854
	                        and lcn2.cd_sst = 7) loop
    perform sc_cnt.lancar_debito_credito(rg.cd_cnt, 2854, 60, null, 'DESCONTO DE CREDITO DE ARREDONDAMENTO PARA PERMITIR SAQUE DE CEDULA 50', rg.vl_lcn, CURRENT_date, 1, 7, rg.nsu_lcn);
  end loop;
end;$$;


ALTER FUNCTION sc_cnt.cobrar_arrendondamento() OWNER TO scan;

--
-- TOC entry 7769 (class 0 OID 0)
-- Dependencies: 1272
-- Name: FUNCTION cobrar_arrendondamento(); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION cobrar_arrendondamento() IS 'cobrando valor adiantado para arredondamento de saldo das contas do cartao para ser possivel sacar cedulas de 50';


--
-- TOC entry 1273 (class 1255 OID 564273)
-- Name: correcao_saldo_diario_conta(); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION correcao_saldo_diario_conta() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;
  vl_saldo_final numeric;
  vl_saldo_atual_calculado numeric;
  vl_soma_debito numeric;
  vl_soma_credito numeric;
begin
  for vl_rg in select distinct lcn.cd_cnt, cnt.fg_ntr_cnt, cnt.vl_sld_cnt
               from sc_cnt.tbl_lcn lcn
                    inner join sc_cnt.tbl_cnt cnt on lcn.cd_cnt = cnt.cd_cnt
                    inner join sc_cad.tbl_ctr ctr on cnt.cd_cnt = ctr.cd_cnt
               where dt_ref_lcn < current_date
               limit 100 loop
    select vl_fin_sdc
    into vl_saldo_final
    from sc_cnt.tbl_sdc
    where cd_cnt = vl_rg.cd_cnt
      and dt_sdc = current_date - 1;

    select COALESCE(sum(case when fg_dcr_lcn = 'D' then vl_lcn else 0 end), 0),
           COALESCE(sum(case when fg_dcr_lcn = 'C' then vl_lcn else 0 end), 0)
    into vl_soma_debito, vl_soma_credito
    from sc_cnt.tbl_lcn
    where cd_cnt = vl_rg.cd_cnt
      and dt_ref_lcn >= current_date
      and dt_ref_lcn < current_date + 1;

    if vl_rg.fg_ntr_cnt = 'D' then
      vl_saldo_atual_calculado := vl_saldo_final + vl_soma_debito - vl_soma_credito;
    else
      vl_saldo_atual_calculado := vl_saldo_final - vl_soma_debito + vl_soma_credito;
    end if;

    if vl_saldo_atual_calculado <> vl_rg.vl_sld_cnt then
      perform sc_cnt.fecha_saldo_conta_periodo(vl_rg.cd_cnt, '2012-02-01', current_date-1);
    end if;
  end loop;
end;$$;


ALTER FUNCTION sc_cnt.correcao_saldo_diario_conta() OWNER TO scan;

--
-- TOC entry 7770 (class 0 OID 0)
-- Dependencies: 1273
-- Name: FUNCTION correcao_saldo_diario_conta(); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION correcao_saldo_diario_conta() IS 'verifica se tem alguma conta com saldo diario e gerar novamente os saldos diarios';


--
-- TOC entry 1274 (class 1255 OID 564274)
-- Name: corrige_saque_extra_duplo(); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION corrige_saque_extra_duplo() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare 

rg record;
rg_prc record;
rg_pgto record;

existe numeric;
parcela numeric;
valor_parcela numeric;
conta_cartao numeric;
valor_pagamento numeric;

begin

for rg in 
  
	select cd_crt,ds_prc, cd_fcr,  count(cd_opr) 
	  from sc_fcr.tbl_prc
	where dt_grc_prc::date = '05/11/2012' 
	group by cd_crt,ds_prc,cd_fcr having count(cd_opr) > 1

   loop	

     select count(*)
       into existe
     from sc_fcr.tbl_prc 
       where cd_fcr = rg.cd_fcr
         and st_prc = 3;

     if existe = 0 then

         parcela = 0;

         --
         select max(cd_prc), vl_prc
           into parcela, valor_parcela
         from sc_fcr.tbl_prc
         where cd_fcr = rg.cd_fcr
           group by vl_prc having count(vl_prc) > 1;
           


         if parcela > 0 then

		 --cancela todos os pagamentos
                 for rg_pgto in select cd_pfc 
                 from sc_fcr.tbl_pfc
                 where cd_fcr = rg.cd_Fcr
                   and st_pfc = 1 loop

			perform sc_fcr.estorno_pagamento(rg_pgto.cd_pfc, 1);

		   end loop;
                  
                  update sc_fcr.tbl_fcr 
                    set vl_fcr = vl_fcr - valor_parcela, 
                        vl_ttl_pgt_fcr = 0, 
                        vl_sld_dvd_fcr = vl_fcr - valor_parcela
                    where cd_fcr = rg.cd_fcr;

                  -- cancela a parcela
                  update sc_fcr.tbl_prc set st_prc = 3 where cd_prc = parcela;      
	  
	         		
         end if;
           

     end if;     


   end loop;            
 
-- cobra os cartoes no final
perform sc_fcr.cobrar_cartao();

end;

$$;


ALTER FUNCTION sc_cnt.corrige_saque_extra_duplo() OWNER TO scan;

--
-- TOC entry 1123 (class 1255 OID 1633082)
-- Name: desbloquear_saldo_agendado(); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION desbloquear_saldo_agendado() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin
   for rg in select cnt.cd_cnt,
                    cnt.vl_sld_cnt,
                    t.cd_tbc_cnt
             from sc_cnt.tbl_cnt cnt
               inner join sc_cnt.tbl_tbc_cnt t on t.cd_cnt = cnt.cd_cnt
             where t.cd_tbc = 9
               and t.dt_fin_blq_tbc_cnt < now() loop

             update sc_cnt.tbl_tbc_cnt set vl_blq_tbc_cnt = 0, dt_fin_blq_tbc_cnt = null where cd_tbc_cnt = rg.cd_tbc_cnt;

             
   end loop;          

end$$;


ALTER FUNCTION sc_cnt.desbloquear_saldo_agendado() OWNER TO scan;

--
-- TOC entry 1723 (class 1255 OID 1012435)
-- Name: desbloqueio_saldo_conta(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION desbloqueio_saldo_conta(vp_conta numeric, vp_tipo_bloqueio numeric, vp_valor numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  
  vl_existe numeric;
  
begin

  select count(*)
    into vl_existe
  from sc_cnt.tbl_tbc_cnt
    where cd_cnt = vp_conta  
      and cd_tbc = vp_tipo_bloqueio;

  if vl_existe > 0 then
    update sc_cnt.tbl_tbc_cnt set vl_blq_tbc_cnt = vl_blq_tbc_cnt - vp_valor, cd_alt_usr = 1, dt_alt_usr = now() where cd_cnt = vp_conta and cd_tbc = vp_tipo_bloqueio;
  end if;

end;$$;


ALTER FUNCTION sc_cnt.desbloqueio_saldo_conta(vp_conta numeric, vp_tipo_bloqueio numeric, vp_valor numeric) OWNER TO scan;

--
-- TOC entry 1566 (class 1255 OID 1667147)
-- Name: excluir_lancamento(numeric, text); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION excluir_lancamento(vp_codigo_lancamento numeric, vp_motivo text) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  CT_USUARIO_ADM constant integer := 1;

  vl_natureza_conta character;
  vl_natureza_lancamento character;
  vl_codigo_conta numeric;
  vl_valor_lancamento numeric;

  vl_rg record;
begin

  select cnt.fg_ntr_cnt, lcn.fg_dcr_lcn, cnt.cd_cnt, lcn.vl_lcn
    into vl_natureza_conta, vl_natureza_lancamento, vl_codigo_conta, vl_valor_lancamento
  from sc_cnt.tbl_cnt cnt
       inner join sc_cnt.tbl_lcn lcn on cnt.cd_cnt = lcn.cd_cnt
  where lcn.cd_lcn = vp_codigo_lancamento;

  if vl_natureza_conta is null or vl_natureza_lancamento is null then
    raise exception 'lancamento de código: % não foi encontrado', vp_codigo_lancamento;
  end if;
  
  insert into sc_cnt.tbl_lcn_exc
       select lcn.*, now(), CT_USUARIO_ADM, vp_motivo 
  from sc_cnt.tbl_lcn lcn 
  where cd_lcn = vp_codigo_lancamento;
  
  delete from sc_cnt.tbl_lcn where cd_lcn = vp_codigo_lancamento;

  if vl_natureza_conta = vl_natureza_lancamento then
    vl_valor_lancamento := vl_valor_lancamento * -1;
  end if;

  update sc_cnt.tbl_cnt 
     set vl_sld_cnt = vl_sld_cnt + vl_valor_lancamento
  where cd_cnt = vl_codigo_conta;

  for vl_rg in select cd_lcn 
               from sc_cnt.tbl_lcn 
               where cd_ctp_lcn = vp_codigo_lancamento loop
    perform sc_cnt.excluir_lancamento(vl_rg.cd_lcn, vp_motivo);
  end loop;
end;$$;


ALTER FUNCTION sc_cnt.excluir_lancamento(vp_codigo_lancamento numeric, vp_motivo text) OWNER TO scan;

--
-- TOC entry 7771 (class 0 OID 0)
-- Dependencies: 1566
-- Name: FUNCTION excluir_lancamento(vp_codigo_lancamento numeric, vp_motivo text); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION excluir_lancamento(vp_codigo_lancamento numeric, vp_motivo text) IS 'rotina que excluir um determinado lançamento';


--
-- TOC entry 1641 (class 1255 OID 564275)
-- Name: excluir_lancamento(character varying, numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION excluir_lancamento(vp_motivo character varying, vp_sistema numeric, vp_nsu numeric, vp_usuario numeric, cd_lancamento numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

 vl_credito numeric;
 vl_debito numeric;

 vl_lancamento_contra_partida numeric;
 vl_multi_contrapartida numeric;

 rg record;
begin

   if cd_lancamento is null then

	   select sum(case when fg_dcr_lcn = 'C' then l.vl_lcn else 0 end) valor_credito,
		  sum(case when fg_dcr_lcn = 'D' then l.vl_lcn else 0 end) valor_debito  
	   into vl_credito,vl_debito       
	   from sc_cnt.tbl_lcn l
	   where cd_sst = vp_sistema
	   and nsu_lcn = vp_nsu;

	   if vl_credito <> vl_debito then
	      raise exception 'VALOR DE CREDITO E DEBITO NÃO CONFEREM.';
	   end if;

	   for rg in select *
		     from sc_cnt.tbl_lcn l
		       inner join sc_cnt.tbl_cnt c on c.cd_cnt = l.cd_cnt
		     where cd_sst = vp_sistema
		       and nsu_lcn = vp_nsu loop

	       if rg.fg_dcr_lcn = rg.fg_ntr_cnt then
		  update sc_cnt.tbl_cnt set vl_sld_cnt = vl_sld_cnt - rg.vl_lcn where cd_cnt = rg.cd_cnt;          
	       else
		  update sc_cnt.tbl_cnt set vl_sld_cnt = vl_sld_cnt + rg.vl_lcn where cd_cnt = rg.cd_cnt;       
	       end if;
	       
	       insert into sc_cnt.tbl_lcn_exc(select lcn.*,now(),vp_usuario,vp_motivo from sc_cnt.tbl_lcn lcn where cd_lcn = rg.cd_lcn);
	       delete from sc_cnt.tbl_lcn where cd_lcn = rg.cd_lcn;
	       
  	       update sc_cnt.tbl_cnt 
	       set fg_rpc_cnt='S',
		   dt_rpc_cnt=case when rg.dt_ref_lcn::date < coalesce(dt_rpc_cnt,current_date) then rg.dt_ref_lcn::date else dt_rpc_cnt end
	       where cd_cnt=rg.cd_cnt; 	       
	       
	       
	      -- perform sc_cnt.fecha_saldo_conta_periodo(rg.cd_cnt,rg.dt_ref_lcn::date,(current_date - interval '1 day')::date);
	       
	   end loop;      
    else

     select lcn.cd_ctp_lcn
     into vl_lancamento_contra_partida
     from sc_cnt.tbl_lcn lcn
     where cd_lcn = cd_lancamento;

     if vl_lancamento_contra_partida is not null then

             select count(*)
             into vl_multi_contrapartida
             from sc_cnt.tbl_lcn
             where cd_ctp_lcn = vl_lancamento_contra_partida
               and cd_lcn <> cd_lancamento;

             if vl_multi_contrapartida > 0 then
                raise exception 'NAO FOI POSSIVEL EXCLUIR. O LANCAMENTO DE CONTRAPARTIDA É REFERENCIADO POR OUTROS LANCAMENTOS.';
             end if ;

	     for rg in select *
		       from sc_cnt.tbl_lcn lcn
			  inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = lcn.cd_cnt
		       where cd_lcn in(cd_lancamento, vl_lancamento_contra_partida) loop

	       if rg.fg_dcr_lcn = rg.fg_ntr_cnt then
		  update sc_cnt.tbl_cnt set vl_sld_cnt = vl_sld_cnt - rg.vl_lcn where cd_cnt = rg.cd_cnt;          
	       else
		  update sc_cnt.tbl_cnt set vl_sld_cnt = vl_sld_cnt + rg.vl_lcn where cd_cnt = rg.cd_cnt;       
	       end if;
	       
	       insert into sc_cnt.tbl_lcn_exc(select lcn.*,now(),vp_usuario,vp_motivo from sc_cnt.tbl_lcn lcn where cd_lcn = rg.cd_lcn);
	       delete from sc_cnt.tbl_lcn where cd_lcn = rg.cd_lcn;
	       

	       update sc_cnt.tbl_cnt 
	       set fg_rpc_cnt='S',
		   dt_rpc_cnt=case when rg.dt_ref_lcn::date < coalesce(dt_rpc_cnt,current_date) then rg.dt_ref_lcn::date else dt_rpc_cnt end
	       where cd_cnt=rg.cd_cnt; 	       
	       --perform sc_cnt.fecha_saldo_conta_periodo(rg.cd_cnt,rg.dt_ref_lcn::date,(current_date - interval '1 day')::date);
		       
	     end loop;
      else
         raise exception 'LANCAMENTO SEM CONTRAPARTIDA';
      end if;                 
	         	   
	   
    end if;	   
   
end$$;


ALTER FUNCTION sc_cnt.excluir_lancamento(vp_motivo character varying, vp_sistema numeric, vp_nsu numeric, vp_usuario numeric, cd_lancamento numeric) OWNER TO scan;

--
-- TOC entry 1793 (class 1255 OID 564276)
-- Name: fecha_saldo_conta(numeric, date); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION fecha_saldo_conta(vp_codigo_conta numeric, vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_saldo_inicial numeric;
  vl_total_debito numeric;
  vl_total_credito numeric;
  vl_saldo_final numeric;

  vl_existe numeric;
  vl_natureza_conta varchar(1);
begin
  --excluindo lancamento atual
  delete from sc_cnt.tbl_sdc where cd_cnt = vp_codigo_conta and dt_sdc = vp_data_referencia;
  
  --verificando se existe conta com o código passado como parâmetro
  select count(*)
  into vl_existe
  from sc_cnt.tbl_cnt
  where cd_cnt = vp_codigo_conta;

  --se existe a conta, obter a natureza da mesma
  if vl_existe = 1 then
    select fg_ntr_cnt
    into vl_natureza_conta
    from sc_cnt.tbl_cnt
    where cd_cnt = vp_codigo_conta;
  else
  --senao existir, retornar erro
    raise exception 'Não existe conta com o código: %', vp_codigo_conta;
  end if;


  --calculando o saldo inicial, que é igual ao saldo final do dia anterior, da data de referencia
  --verificando se existe saldo armazenado para o dia anterior
  select count(*)
  into vl_existe
  from sc_cnt.tbl_sdc
  where dt_sdc = vp_data_referencia - 1
    and cd_cnt = vp_codigo_conta;

  --se existir obter o valor do saldo final da data anterior
  if vl_existe = 1 then
    select vl_fin_sdc
    into vl_saldo_inicial
    from sc_cnt.tbl_sdc
    where dt_sdc = vp_data_referencia - 1
      and cd_cnt = vp_codigo_conta;
  else
     vl_saldo_inicial := 0;
     /*select coalesce(sum(case when c.fg_ntr_cnt = l.fg_dcr_lcn then l.vl_lcn else l.vl_lcn*-1 end),0)
     into vl_saldo_inicial
     from sc_cnt.tbl_lcn l
       inner join sc_cnt.tbl_cnt c on c.cd_cnt = l.cd_cnt
     where l.cd_cnt = vp_codigo_conta
       and l.dt_ref_lcn < vp_data_referencia;*/
  end if;

    

-- FIM DA ALTERACAO
  --calculando o total de débitos e creditos acontecidos para a conta em um determinado dia
  select coalesce(sum(case when fg_dcr_lcn = 'D' then vl_lcn else 0 end), 0),
         coalesce(sum(case when fg_dcr_lcn = 'C' then vl_lcn else 0 end), 0)
  into vl_total_debito,
       vl_total_credito
  from sc_cnt.tbl_lcn
  where cd_cnt = vp_codigo_conta
    and dt_ref_lcn >= vp_data_referencia
    and dt_ref_lcn < vp_data_referencia + 1;

  --calculando o valor do saldo final
  if vl_natureza_conta = 'D' then
    vl_saldo_final := vl_saldo_inicial + vl_total_debito - vl_total_credito;
  else
    vl_saldo_final := vl_saldo_inicial - vl_total_debito + vl_total_credito;
  end if;

  --verificando se deve ser armazenado o registro de saldo diario de conta
  if (vl_saldo_inicial <> 0) or (vl_total_debito <> 0) or (vl_total_credito <> 0) or (vl_saldo_final <> 0) then
    insert into sc_cnt.tbl_sdc(cd_cnt, dt_sdc, vl_ini_sdc, vl_dbt_sdc, vl_crd_sdc, vl_fin_sdc)
    values(vp_codigo_conta, vp_data_referencia, vl_saldo_inicial, vl_total_debito, vl_total_credito, vl_saldo_final);
  end if;
end;$$;


ALTER FUNCTION sc_cnt.fecha_saldo_conta(vp_codigo_conta numeric, vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7772 (class 0 OID 0)
-- Dependencies: 1793
-- Name: FUNCTION fecha_saldo_conta(vp_codigo_conta numeric, vp_data_referencia date); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION fecha_saldo_conta(vp_codigo_conta numeric, vp_data_referencia date) IS 'calcula o valor do saldo inicial, total de debitos, total de créditos e saldo final para uma determinada conta em uma determinada data';


--
-- TOC entry 1794 (class 1255 OID 1614125)
-- Name: fecha_saldo_conta_full(numeric, date); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION fecha_saldo_conta_full(vp_codigo_conta numeric, vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_saldo_inicial numeric;
  vl_total_debito numeric;
  vl_total_credito numeric;
  vl_saldo_final numeric;

  vl_existe numeric;
  vl_natureza_conta varchar(1);
begin
  --excluindo lancamento atual
  delete from sc_cnt.tbl_sdc where cd_cnt = vp_codigo_conta and dt_sdc = vp_data_referencia;
  
  --verificando se existe conta com o código passado como parâmetro
  select count(*)
  into vl_existe
  from sc_cnt.tbl_cnt
  where cd_cnt = vp_codigo_conta;

  --se existe a conta, obter a natureza da mesma
  if vl_existe = 1 then
    select fg_ntr_cnt
    into vl_natureza_conta
    from sc_cnt.tbl_cnt
    where cd_cnt = vp_codigo_conta;
  else
  --senao existir, retornar erro
    raise exception 'Não existe conta com o código: %', vp_codigo_conta;
  end if;

/*  COMENTADO DIA 07-05-2018 POR VITOR VASCONCELOS
    
  --calculando o saldo inicial, que é igual ao saldo final do dia anterior, da data de referencia
  --verificando se existe saldo armazenado para o dia anterior
  select count(*)
  into vl_existe
  from sc_cnt.tbl_sdc
  where dt_sdc = vp_data_referencia - 1
    and cd_cnt = vp_codigo_conta;

  --se existir obter o valor do saldo final da data anterior
  if vl_existe = 1 then
    select vl_fin_sdc
    into vl_saldo_inicial
    from sc_cnt.tbl_sdc
    where dt_sdc = vp_data_referencia - 1
      and cd_cnt = vp_codigo_conta;
  else
  --senao existir, setar o valor inicial como 0(zero)
    vl_saldo_inicial := 0;
  end if;
*/

-- ALTERACAO NA FORMA DE OBTER O SALDO INICIAL DIA 07-05-2018 VITOR VASCONCELOS

   select coalesce(sum(case when c.fg_ntr_cnt = l.fg_dcr_lcn then l.vl_lcn else l.vl_lcn*-1 end),0)
   into vl_saldo_inicial
   from sc_cnt.tbl_lcn l
     inner join sc_cnt.tbl_cnt c on c.cd_cnt = l.cd_cnt
   where l.cd_cnt = vp_codigo_conta
     and l.dt_ref_lcn < vp_data_referencia;
    

-- FIM DA ALTERACAO
  --calculando o total de débitos e creditos acontecidos para a conta em um determinado dia
  select coalesce(sum(case when fg_dcr_lcn = 'D' then vl_lcn else 0 end), 0),
         coalesce(sum(case when fg_dcr_lcn = 'C' then vl_lcn else 0 end), 0)
  into vl_total_debito,
       vl_total_credito
  from sc_cnt.tbl_lcn
  where cd_cnt = vp_codigo_conta
    and dt_ref_lcn >= vp_data_referencia
    and dt_ref_lcn < vp_data_referencia + 1;

  --calculando o valor do saldo final
  if vl_natureza_conta = 'D' then
    vl_saldo_final := vl_saldo_inicial + vl_total_debito - vl_total_credito;
  else
    vl_saldo_final := vl_saldo_inicial - vl_total_debito + vl_total_credito;
  end if;

  --verificando se deve ser armazenado o registro de saldo diario de conta
  if (vl_saldo_inicial <> 0) or (vl_total_debito <> 0) or (vl_total_credito <> 0) or (vl_saldo_final <> 0) then
    insert into sc_cnt.tbl_sdc(cd_cnt, dt_sdc, vl_ini_sdc, vl_dbt_sdc, vl_crd_sdc, vl_fin_sdc)
    values(vp_codigo_conta, vp_data_referencia, vl_saldo_inicial, vl_total_debito, vl_total_credito, vl_saldo_final);
  end if;

  update sc_cnt.tbl_cnt set dt_ult_fch_fll_cnt = vp_data_referencia,sld_ult_fch_cnt=coalesce(vl_saldo_final,0) where cd_cnt = vp_codigo_conta;
end;$$;


ALTER FUNCTION sc_cnt.fecha_saldo_conta_full(vp_codigo_conta numeric, vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1276 (class 1255 OID 564277)
-- Name: fecha_saldo_conta_periodo(numeric, date, date); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION fecha_saldo_conta_periodo(vp_codigo_conta numeric, vp_data_referencia_inicial date, vp_data_referencia_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_data_atual date;
begin
  vl_data_atual := vp_data_referencia_inicial;
  while vl_data_atual <= vp_data_referencia_final loop
    perform sc_cnt.fecha_saldo_conta(vp_codigo_conta, vl_data_atual);
    vl_data_atual := vl_data_atual + 1;
  end loop;
end;$$;


ALTER FUNCTION sc_cnt.fecha_saldo_conta_periodo(vp_codigo_conta numeric, vp_data_referencia_inicial date, vp_data_referencia_final date) OWNER TO scan;

--
-- TOC entry 7773 (class 0 OID 0)
-- Dependencies: 1276
-- Name: FUNCTION fecha_saldo_conta_periodo(vp_codigo_conta numeric, vp_data_referencia_inicial date, vp_data_referencia_final date); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION fecha_saldo_conta_periodo(vp_codigo_conta numeric, vp_data_referencia_inicial date, vp_data_referencia_final date) IS 'calcula o valor do saldo inicial, total de debitos, total de créditos e saldo final para uma determinada conta em um determinado período';


--
-- TOC entry 1277 (class 1255 OID 564278)
-- Name: fecha_saldo_contas(date); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION fecha_saldo_contas(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;
begin
  --executando para todas as contas que tiveram lancamento na data informada
  for vl_rg in select distinct cd_cnt
               from sc_cnt.tbl_lcn
               where dt_ref_lcn >= vp_data_referencia
                 and dt_ref_lcn < vp_data_referencia + 1 loop

    perform sc_cnt.fecha_saldo_conta(vl_rg.cd_cnt, vp_data_referencia);

  end loop;

  --executadno para todas as contas que tem saldo final do dia anterior maior do que zero e não tiveram lancamento no dia
  --for vl_rg in select cd_cnt
  --             from sc_cnt.tbl_sdc sdc
  --             where sdc.dt_sdc = vp_data_referencia - 1
  --               and sdc.vl_fin_sdc <> 0
  --               and not exists (select 1
  --                               from sc_cnt.tbl_sdc sdc2
  --                               where sdc.cd_cnt = sdc2.cd_cnt
  --                                 and sdc2.dt_sdc = vp_data_referencia) loop
  --  perform sc_cnt.fecha_saldo_conta(vl_rg.cd_cnt, vp_data_referencia);
  --end loop;

  -- atualizando todas as contas que tem saldo final do dia anterior maior do que zero e não tiveram lancamento no dia

  -- deletando os registros caso seja um reprocessamento; 
  delete from sc_cnt.tbl_sdc
    where dt_sdc = vp_data_referencia
      and cd_cnt in (select cd_cnt
		      from sc_cnt.tbl_sdc sdc
                      where sdc.dt_sdc = vp_data_referencia - 1
                        and sdc.vl_fin_sdc <> 0
                        and not exists (select 1
                                         from sc_cnt.tbl_sdc sdc2
                                         where sdc.cd_cnt = sdc2.cd_cnt
                                         and sdc2.dt_sdc = vp_data_referencia));

  -- inserindo novos registros
  insert 
     into sc_cnt.tbl_sdc(cd_cnt, dt_sdc, vl_ini_sdc, vl_dbt_sdc, vl_crd_sdc, vl_fin_sdc) 
  select cd_cnt, 
         vp_data_referencia as dt_sdc, 
         sdc.vl_fin_sdc as vl_ini_sdc, 
         0 as vl_dbt_sdc, 
         0 as vl_crd_sdc, 
         sdc.vl_fin_sdc as vl_fin_sdc
    from sc_cnt.tbl_sdc sdc
    where sdc.dt_sdc = vp_data_referencia - 1
      and sdc.vl_fin_sdc <> 0
      and not exists (select 1
                      from sc_cnt.tbl_sdc sdc2
                      where sdc.cd_cnt = sdc2.cd_cnt
                      and sdc2.dt_sdc = vp_data_referencia);
  

end;$$;


ALTER FUNCTION sc_cnt.fecha_saldo_contas(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7774 (class 0 OID 0)
-- Dependencies: 1277
-- Name: FUNCTION fecha_saldo_contas(vp_data_referencia date); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION fecha_saldo_contas(vp_data_referencia date) IS 'calcula o valor do saldo inicial, total de debitos, total de créditos e saldo final para todas as contas em uma determinada data';


--
-- TOC entry 1278 (class 1255 OID 564279)
-- Name: fecha_saldo_contas_periodo(date, date); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION fecha_saldo_contas_periodo(vp_data_referencia_inicial date, vp_data_referencia_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_data_atual date;
begin
  vl_data_atual := vp_data_referencia_inicial;
  while vl_data_atual <= vp_data_referencia_final loop
    perform sc_cnt.fecha_saldo_contas(vl_data_atual);
    vl_data_atual := vl_data_atual + 1;
  end loop;
end;$$;


ALTER FUNCTION sc_cnt.fecha_saldo_contas_periodo(vp_data_referencia_inicial date, vp_data_referencia_final date) OWNER TO scan;

--
-- TOC entry 7775 (class 0 OID 0)
-- Dependencies: 1278
-- Name: FUNCTION fecha_saldo_contas_periodo(vp_data_referencia_inicial date, vp_data_referencia_final date); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION fecha_saldo_contas_periodo(vp_data_referencia_inicial date, vp_data_referencia_final date) IS 'calcula o valor do saldo inicial, total de debitos, total de créditos e saldo final para todas as conta em um determinado período';


--
-- TOC entry 1279 (class 1255 OID 564280)
-- Name: fecha_saldo_subconta(numeric, date); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION fecha_saldo_subconta(vp_codigo_subconta numeric, vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_saldo_inicial numeric;
  vl_total_debito numeric;
  vl_total_credito numeric;
  vl_saldo_final numeric;

  vl_existe numeric;

  rg record;
begin
  --excluindo lancamento atual
  delete from sc_cnt.tbl_sds where cd_scn = vp_codigo_subconta and dt_sds = vp_data_referencia and dt_inc_usr<now();

  
  --verificando se existe sub-conta com o código passado como parâmetro
  select count(*)
  into vl_existe
  from sc_cnt.tbl_scn
  where cd_scn = vp_codigo_subconta;

  --se nao existe a sub-conta lancar excecao
  if vl_existe = 0 then
    raise exception 'Não existe sub-conta com o código: %', vp_codigo_subconta;
  end if;


   select vl_ini_sds,
          vl_crd_sds,
          vl_dbt_sds,
          vl_fin_sds
   into  vl_saldo_inicial,
         vl_total_credito,
         vl_total_debito,
         vl_saldo_final
   from sc_cnt.tbl_sds
   where dt_sds = vp_data_referencia
     and dt_inc_usr = now()
     and cd_scn = vp_codigo_subconta; 


  if vl_saldo_inicial is null then      
	  --calculando o saldo inicial, debitos, creditos e o saldo final que é igual ao saldo final do dia anterior, da data de referencia
	  select  a.vr_saldo_incial ,a.vr_debito, a.vr_credito, a.vr_saldo_final 
	  into vl_saldo_inicial, vl_total_debito, vl_total_credito, vl_saldo_final
	  from sc_cnt.get_saldo_subconta(vp_codigo_subconta, vp_data_referencia) as a;
  
	  --verificando se deve ser armazenado o registro de saldo diario de subconta
	  if (vl_saldo_inicial <> 0) or (vl_total_debito <> 0) or (vl_total_credito <> 0) or (vl_saldo_final <> 0) then
	    insert into sc_cnt.tbl_sds(cd_sds, cd_scn, dt_sds, vl_ini_sds, vl_dbt_sds, vl_crd_sds, vl_fin_sds, dt_inc_usr)
	    values(nextval('sc_cnt.sq_sds'), vp_codigo_subconta, vp_data_referencia, vl_saldo_inicial, vl_total_debito, vl_total_credito, vl_saldo_final, now());
	    


	  end if;	

  end if;	  

  --verificando o fechamento para os pais da subconta
  for rg in select pai_scn
            from sc_cnt.tbl_scn
            where cd_scn = vp_codigo_subconta loop

     if not rg.pai_scn is null then
	perform sc_cnt.fecha_saldo_subconta(rg.pai_scn,vp_data_referencia);
     end if;
            
  end loop;          
  
end;$$;


ALTER FUNCTION sc_cnt.fecha_saldo_subconta(vp_codigo_subconta numeric, vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7776 (class 0 OID 0)
-- Dependencies: 1279
-- Name: FUNCTION fecha_saldo_subconta(vp_codigo_subconta numeric, vp_data_referencia date); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION fecha_saldo_subconta(vp_codigo_subconta numeric, vp_data_referencia date) IS 'calcula o valor do saldo inicial, total de debitos, total de créditos e saldo final para uma determinada subconta em uma determinada data';


--
-- TOC entry 1280 (class 1255 OID 564281)
-- Name: fecha_saldo_subconta_periodo(numeric, date, date); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION fecha_saldo_subconta_periodo(vp_codigo_subconta numeric, vp_data_referencia_inicial date, vp_data_referencia_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_data_atual date;
begin
  vl_data_atual := vp_data_referencia_inicial;
  while vl_data_atual <= vp_data_referencia_final loop
    perform sc_cnt.fecha_saldo_subconta(vp_codigo_subconta, vl_data_atual);
    vl_data_atual := vl_data_atual + 1;
  end loop;
end;$$;


ALTER FUNCTION sc_cnt.fecha_saldo_subconta_periodo(vp_codigo_subconta numeric, vp_data_referencia_inicial date, vp_data_referencia_final date) OWNER TO scan;

--
-- TOC entry 7777 (class 0 OID 0)
-- Dependencies: 1280
-- Name: FUNCTION fecha_saldo_subconta_periodo(vp_codigo_subconta numeric, vp_data_referencia_inicial date, vp_data_referencia_final date); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION fecha_saldo_subconta_periodo(vp_codigo_subconta numeric, vp_data_referencia_inicial date, vp_data_referencia_final date) IS 'calcula o valor do saldo inicial, total de debitos, total de créditos e saldo final para uma determinada subconta em um determinado período';


--
-- TOC entry 1281 (class 1255 OID 564282)
-- Name: fecha_saldo_subcontas(date); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION fecha_saldo_subcontas(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;
begin
  --executando para todas as contas que tiveram lancamento na data informada
  for vl_rg in select distinct cnt.cd_scn 
               from sc_cnt.tbl_sdc sdc 
                 inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = sdc.cd_cnt
               where sdc.dt_sdc >= vp_data_referencia
                 and sdc.dt_sdc < vp_data_referencia + 1 loop
  
    perform sc_cnt.fecha_saldo_subconta(vl_rg.cd_scn, vp_data_referencia);

  end loop;

  -- atualizando todas as subcontas que tem saldo final do dia anterior maior do que zero e não tiveram lancamento no dia
  -- deletando os registros caso seja um reprocessamento; 
  delete from sc_cnt.tbl_sds
    where dt_sds = vp_data_referencia
      and cd_scn in (select cd_scn
		      from sc_cnt.tbl_sds sds
                      where sds.dt_sds = vp_data_referencia - 1
                        and sds.vl_fin_sds <> 0
                        and not exists (select 1
                                         from sc_cnt.tbl_sds sds2
                                         where sds.cd_scn = sds2.cd_scn
                                         and sds2.dt_sds = vp_data_referencia));

  -- inserindo novos registros
  insert 
     into sc_cnt.tbl_sds(cd_sds, cd_scn, dt_sds, vl_ini_sds, vl_dbt_sds, vl_crd_sds, vl_fin_sds, dt_inc_usr) 
  select nextval('sc_cnt.sq_sds') as cd_sds,
         cd_scn, 
         vp_data_referencia as dt_sds, 
         sds.vl_fin_sds as vl_ini_sds, 
         0 as vl_dbt_sds, 
         0 as vl_crd_sds, 
         sds.vl_fin_sds as vl_fin_sds,
         now() as dt_inc_usr
    from sc_cnt.tbl_sds sds
    where sds.dt_sds = vp_data_referencia - 1
      and sds.vl_fin_sds <> 0
      and not exists (select 1
                        from sc_cnt.tbl_sds sds2
                       where sds.cd_scn = sds2.cd_scn
                         and sds2.dt_sds = vp_data_referencia);
  

end;$$;


ALTER FUNCTION sc_cnt.fecha_saldo_subcontas(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7778 (class 0 OID 0)
-- Dependencies: 1281
-- Name: FUNCTION fecha_saldo_subcontas(vp_data_referencia date); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION fecha_saldo_subcontas(vp_data_referencia date) IS 'calcula o valor do saldo inicial, total de debitos, total de créditos e saldo final para todas as subcontas em uma determinada data';


--
-- TOC entry 1603 (class 1255 OID 564283)
-- Name: fecha_saldo_subcontas_periodo(date, date); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION fecha_saldo_subcontas_periodo(vp_data_referencia_inicial date, vp_data_referencia_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_data_atual date;
begin
  delete 
  from sc_cnt.tbl_sds 
  where dt_sds >= vp_data_referencia_inicial 
    and dt_sds <= vp_data_referencia_final;
    
  vl_data_atual := vp_data_referencia_inicial;
  while vl_data_atual <= vp_data_referencia_final loop
    perform sc_cnt.fecha_saldo_subcontas(vl_data_atual);
    vl_data_atual := vl_data_atual + 1;
  end loop;
end;$$;


ALTER FUNCTION sc_cnt.fecha_saldo_subcontas_periodo(vp_data_referencia_inicial date, vp_data_referencia_final date) OWNER TO scan;

--
-- TOC entry 7779 (class 0 OID 0)
-- Dependencies: 1603
-- Name: FUNCTION fecha_saldo_subcontas_periodo(vp_data_referencia_inicial date, vp_data_referencia_final date); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION fecha_saldo_subcontas_periodo(vp_data_referencia_inicial date, vp_data_referencia_final date) IS 'calcula o valor do saldo inicial, total de debitos, total de créditos e saldo final para todas as subconta em um determinado período';


--
-- TOC entry 1255 (class 1255 OID 564284)
-- Name: get_saldo_cartao(numeric, character varying, character varying); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION get_saldo_cartao(vp_cartao numeric, vp_fg_blq character varying, vp_fg_loc character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  vl_saldo double precision := 0;
BEGIN
  for rg in select cnt.cd_cnt as conta
	    from sc_opr.tbl_cnt_crt cnt_crt
	      inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
            where cnt_crt.cd_crt = vp_cartao loop

    vl_saldo := vl_saldo + COALESCE(sc_cnt.saldo_conta(rg.conta, vp_fg_blq, vp_fg_loc),0);
            
  end loop;
  
  return vl_saldo;
END;
$$;


ALTER FUNCTION sc_cnt.get_saldo_cartao(vp_cartao numeric, vp_fg_blq character varying, vp_fg_loc character varying) OWNER TO scan;

--
-- TOC entry 1786 (class 1255 OID 1632767)
-- Name: get_saldo_cartao_sem_bloqueio(numeric, integer[], character varying); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION get_saldo_cartao_sem_bloqueio(vp_cartao numeric, vp_tipo_bloqueio integer[], vp_fg_loc character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  vl_saldo double precision := 0;
BEGIN
  for rg in select cnt.cd_cnt as conta
	    from sc_opr.tbl_cnt_crt cnt_crt
	      inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
            where cnt_crt.cd_crt = vp_cartao loop

    vl_saldo := vl_saldo + COALESCE(sc_cnt.saldo_conta_liquido_bloqueio(rg.conta, vp_tipo_bloqueio, vp_fg_loc),0);
            
  end loop;
  
  return vl_saldo;
END;
$$;


ALTER FUNCTION sc_cnt.get_saldo_cartao_sem_bloqueio(vp_cartao numeric, vp_tipo_bloqueio integer[], vp_fg_loc character varying) OWNER TO scan;

--
-- TOC entry 1107 (class 1255 OID 1076598)
-- Name: get_saldo_incial(numeric, date); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION get_saldo_incial(vp_conta numeric, vp_data date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
begin
end$$;


ALTER FUNCTION sc_cnt.get_saldo_incial(vp_conta numeric, vp_data date) OWNER TO scan;

--
-- TOC entry 1282 (class 1255 OID 564285)
-- Name: get_saldo_subconta(numeric, date); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION get_saldo_subconta(vp_codigo_subconta numeric, vp_data date, OUT vr_saldo_incial numeric, OUT vr_debito numeric, OUT vr_credito numeric, OUT vr_saldo_final numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
  
  vl_saldo_inicial numeric;
  vl_debito numeric;
  vl_credito numeric;
  vl_saldo_final numeric;

  vl_saldo_inicial_aux numeric;
  vl_debito_aux numeric;
  vl_credito_aux numeric;
  vl_saldo_final_aux numeric;

  vl_natureza char;

  rg record;
  
begin

   select vl_ini_sds,
          vl_crd_sds,
          vl_dbt_sds,
          vl_fin_sds
   into  vr_saldo_incial,
         vr_credito,
         vr_debito,
         vr_saldo_final
   from sc_cnt.tbl_sds
   where dt_sds = vp_data
     and dt_inc_usr = now()
     and cd_scn = vp_codigo_subconta;

   if vr_saldo_incial is null then

	   select fg_ntr_scn
	     into vl_natureza
	   from sc_cnt.tbl_scn
	   where cd_scn = vp_codigo_subconta;

	   select sum(case when (scn.fg_ntr_scn is null or scn.fg_ntr_scn = cnt.fg_ntr_cnt or cnt.fg_ntr_cnt = 'C' and scn.fg_ntr_scn = '-') then sdc.vl_ini_sdc else sdc.vl_ini_sdc * -1 end), 
	       sum(sdc.vl_dbt_sdc),sum(sdc.vl_crd_sdc), 
	       sum(case when (scn.fg_ntr_scn = cnt.fg_ntr_cnt or cnt.fg_ntr_cnt = 'C' and scn.fg_ntr_scn = '-') then sdc.vl_fin_sdc else sdc.vl_fin_sdc * -1 end) 
	   into vl_saldo_inicial,vl_debito,vl_credito,vl_saldo_final
	   from sc_cnt.tbl_sdc sdc 
	      inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = sdc.cd_cnt
	      inner join sc_cnt.tbl_scn scn on scn.cd_scn = cnt.cd_scn
	   where cnt.cd_scn = vp_codigo_subconta
	     and sdc.dt_sdc = vp_data;


	     for rg in select scn.cd_scn, scn.fg_ntr_scn
		     from sc_cnt.tbl_scn scn
		     where scn.pai_scn = vp_codigo_subconta loop

		vl_saldo_inicial_aux := 0;
		vl_debito_aux := 0;
		vl_credito_aux := 0;
		vl_saldo_final_aux := 0;
		
		select  a.vr_saldo_incial ,a.vr_debito, a.vr_credito, a.vr_saldo_final 
		into vl_saldo_inicial_aux,vl_debito_aux,vl_credito_aux,vl_saldo_final_aux
		from sc_cnt.get_saldo_subconta(rg.cd_scn, vp_data) as a;


		if (vl_natureza is null) or (vl_natureza = rg.fg_ntr_scn) or (vl_natureza = '-' and rg.fg_ntr_scn = 'C') then
		  vl_saldo_inicial := coalesce(vl_saldo_inicial,0) + coalesce(vl_saldo_inicial_aux,0);
		  vl_saldo_final := coalesce(vl_saldo_final,0) + coalesce(vl_saldo_final_aux,0); 
		else
		  vl_saldo_inicial := coalesce(vl_saldo_inicial,0) - coalesce(vl_saldo_inicial_aux,0);
		  vl_saldo_final := coalesce(vl_saldo_final,0) - coalesce(vl_saldo_final_aux,0); 
		end if;
		
		vl_debito := coalesce(vl_debito,0) + coalesce(vl_debito_aux,0);
		vl_credito := coalesce(vl_credito,0) + coalesce(vl_credito_aux,0);
		
	     end loop;  

	     vr_saldo_incial := coalesce(vl_saldo_inicial,0);
	     vr_debito := coalesce(vl_debito,0);
	     vr_credito := coalesce(vl_credito,0);
	     vr_saldo_final := coalesce(vl_saldo_final,0);
     	     
     end if;	     
 
end$$;


ALTER FUNCTION sc_cnt.get_saldo_subconta(vp_codigo_subconta numeric, vp_data date, OUT vr_saldo_incial numeric, OUT vr_debito numeric, OUT vr_credito numeric, OUT vr_saldo_final numeric) OWNER TO scan;

--
-- TOC entry 1284 (class 1255 OID 564286)
-- Name: lancar_debito_cartao(numeric, numeric, numeric, numeric, character varying, character varying, timestamp without time zone, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION lancar_debito_cartao(vp_nr_lanc_ctpd numeric, vp_cartao numeric, vp_tp_lancamento numeric, vp_valor numeric, vp_historico character varying, vp_cpl_historico character varying, vp_data_ref timestamp without time zone, vp_cod_usr_inc numeric, vp_sistema numeric, vp_nsu_origem numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

   rg record;
   vl_valor_restante numeric(13,2);
   vl_debito sc_cnt.tbl_lcn.vl_lcn%type;
   vl_nr_lancamento sc_cnt.tbl_lcn.cd_lcn%type;
   
BEGIN
  
  -- Só segue o processamento se o existe saldo nas contas do cartao 
  -- maior que o valor que se deseja debitar
  if( sc_cnt.get_saldo_cartao(vp_cartao,'N','N') >= vp_valor ) then
      
      vl_valor_restante := vp_valor;
      
      for rg in select cnt.vl_sld_cnt,
                       cnt.cd_cnt 
                from sc_opr.tbl_cnt_crt cnt_crt
                  inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
                where cnt_crt.cd_crt = vp_cartao
                and cnt.vl_sld_cnt > 0
                order by cnt_crt.prp_cnt_crt for update loop
                
         if( rg.vl_sld_cnt > vl_valor_restante ) then
            vl_debito := vl_valor_restante;   
         else   
            vl_debito := rg.vl_sld_cnt;
         end if;
         
         vl_valor_restante := vl_valor_restante - vl_debito;
         
         vl_nr_lancamento := null;
         
         perform sc_cnt.lancar_movimento(vl_nr_lancamento,vp_nr_lanc_ctpd,vp_tp_lancamento,rg.cd_cnt,'D',
                                         vl_debito,vp_data_ref::timestamp,vp_cod_usr_inc,vp_historico,vp_cpl_historico,vp_sistema,vp_nsu_origem);
         
         exit when vl_valor_restante = 0;

                
      end loop;          
      
   else
   
     RAISE EXCEPTION 'Saldo insuficiente no cartao.';
     
   end if;  
         
END
$$;


ALTER FUNCTION sc_cnt.lancar_debito_cartao(vp_nr_lanc_ctpd numeric, vp_cartao numeric, vp_tp_lancamento numeric, vp_valor numeric, vp_historico character varying, vp_cpl_historico character varying, vp_data_ref timestamp without time zone, vp_cod_usr_inc numeric, vp_sistema numeric, vp_nsu_origem numeric) OWNER TO scan;

--
-- TOC entry 7780 (class 0 OID 0)
-- Dependencies: 1284
-- Name: FUNCTION lancar_debito_cartao(vp_nr_lanc_ctpd numeric, vp_cartao numeric, vp_tp_lancamento numeric, vp_valor numeric, vp_historico character varying, vp_cpl_historico character varying, vp_data_ref timestamp without time zone, vp_cod_usr_inc numeric, vp_sistema numeric, vp_nsu_origem numeric); Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON FUNCTION lancar_debito_cartao(vp_nr_lanc_ctpd numeric, vp_cartao numeric, vp_tp_lancamento numeric, vp_valor numeric, vp_historico character varying, vp_cpl_historico character varying, vp_data_ref timestamp without time zone, vp_cod_usr_inc numeric, vp_sistema numeric, vp_nsu_origem numeric) IS 'Rotina que realiza debitos nas contas vinculadas ao cartao de acordo com a prioridade';


--
-- TOC entry 1285 (class 1255 OID 564287)
-- Name: lancar_debito_credito(numeric, numeric, numeric, character varying, character varying, double precision, timestamp without time zone, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION lancar_debito_credito(cnt_dbt numeric, cnt_crd numeric, tipo_lancamento numeric, historico character varying, comp_hst character varying, valor double precision, dt_ref timestamp without time zone, cd_usr numeric, cd_sst numeric, nsu numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  NUMERO_LANCAMENTO_DEBITO SC_CNT.TBL_LCN.CD_LCN%TYPE;
  NUMERO_LANCAMENTO_CREDITO SC_CNT.TBL_LCN.CD_LCN%TYPE;

begin

  SELECT nextval('SC_CNT.SQ_LCN')
  INTO NUMERO_LANCAMENTO_DEBITO;

  -- PEGANDO O NUMERO DO LANCAMENTO DE CREDITO
  SELECT nextval('SC_CNT.SQ_LCN')
  INTO NUMERO_LANCAMENTO_CREDITO;

  perform sc_cnt.lancar_movimento(NUMERO_LANCAMENTO_DEBITO,NUMERO_LANCAMENTO_CREDITO,tipo_lancamento,cnt_dbt,'D',valor,dt_ref,cd_usr,historico,comp_hst, cd_sst, nsu);

  perform sc_cnt.lancar_movimento(NUMERO_LANCAMENTO_CREDITO,NUMERO_LANCAMENTO_DEBITO,tipo_lancamento,cnt_crd,'C',valor,dt_ref,cd_usr,historico,comp_hst, cd_sst, nsu);

end;
$$;


ALTER FUNCTION sc_cnt.lancar_debito_credito(cnt_dbt numeric, cnt_crd numeric, tipo_lancamento numeric, historico character varying, comp_hst character varying, valor double precision, dt_ref timestamp without time zone, cd_usr numeric, cd_sst numeric, nsu numeric) OWNER TO scan;

--
-- TOC entry 1876 (class 1255 OID 564288)
-- Name: lancar_movimento(numeric, numeric, numeric, numeric, character, double precision, timestamp without time zone, numeric, character varying, character varying, numeric, numeric); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION lancar_movimento(INOUT nr_lanc numeric, nr_lanc_ctptd numeric, tipo_lancamento numeric, cod_conta numeric, fg_debito_credito character, valor double precision, dt_ref timestamp without time zone, cd_inc_usr numeric, nm_hst_lcn character varying, cpl_hst_lcn character varying, cd_sst numeric, nsu numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
   saldo numeric(13,2);
   saldo_anterior numeric(13,2);
   natureza varchar(1);
   vl_nm_hist sc_cnt.tbl_lcn.nm_his_lcn%type;

   vl_qtd_dias_retroativo numeric := 10;

   vl_usuario numeric;
   vl_data_minima_lancamento date;
begin
  --nrctprt :=0;
  select vl_sld_cnt,fg_ntr_cnt
  into saldo_anterior,natureza
  from sc_cnt.tbl_cnt
  where cd_cnt = cod_conta
  for update;

  if(fg_debito_credito <> 'C' and fg_debito_credito <> 'D') then
    RAISE NOTICE 'Error: Flag de déibito/crédito inválido';
  end if;

  if(valor < 0) then
    RAISE NOTICE 'Error: Valor negativo não permitido';
  end if;

  if(natureza = fg_debito_credito) then
    saldo = saldo_anterior + valor;
  else
    saldo = saldo_anterior - valor;
  end if;

  if(nr_lanc is null) then
     select nextval('sc_cnt.sq_lcn') into nr_lanc;
  end if;

  if(nm_hst_lcn is null) then
     select ds_tlc
     into vl_nm_hist
     from sc_cnt.tbl_tlc
     where cd_tlc = tipo_lancamento;
  else
     vl_nm_hist  := nm_hst_lcn;  
  end if;

  insert into sc_cnt.tbl_lcn(cd_lcn,
			     cd_ctp_lcn,
			     cd_tlc,
			     dt_lcn,
  			     dt_ref_lcn,
			     fg_dcr_lcn,
			     nm_his_lcn,
			     nm_cpl_his_lcn,
			     cd_cnt,
			     cd_inc_usr,
			     dt_inc_usr,
			     vl_lcn,
                             vl_sld_ant_cnt_lcn,
                             cd_sst,
                             nsu_lcn)
 values(nr_lanc,
        nr_lanc_ctptd,
        tipo_lancamento,
        now(),
        dt_ref,
        fg_debito_credito,
        vl_nm_hist,
        cpl_hst_lcn,
        cod_conta,
        cd_inc_usr,
        now(),
        valor,
        saldo_anterior,
        cd_sst,
        nsu);

    update sc_cnt.tbl_cnt set vl_sld_cnt=saldo where cd_cnt = cod_conta;   

     if dt_ref < current_date then
       vl_data_minima_lancamento := (current_date - interval '1000 days')::date;
       if dt_ref < vl_data_minima_lancamento and cd_inc_usr <> 90  and cd_inc_usr <> 41 and cd_inc_usr <> 2 then
         raise exception 'NAO É POSSIVEL REALIZAR LANCAMENTO COM ESTA DATA DE REFERENCIA, %', dt_ref;
       end if;

       update sc_cnt.tbl_cnt 
       set fg_rpc_cnt='S',
           dt_rpc_cnt=case when dt_ref::date < coalesce(dt_rpc_cnt,current_date) then dt_ref::date else dt_rpc_cnt end
       where cd_cnt=cod_conta; 
       vl_usuario := cd_inc_usr; 	
       update sc_ctb.tbl_arq_ctb set st_arq_ctb=2,dt_alt_usr=now(),cd_alt_usr=vl_usuario where dt_arq_ctb=dt_ref::date and st_arq_ctb=1;

       --perform sc_cnt.fecha_saldo_conta_periodo(cod_conta, dt_ref::date, (current_date - interval '1 day')::date);
       
    end if;    
  
end;
$$;


ALTER FUNCTION sc_cnt.lancar_movimento(INOUT nr_lanc numeric, nr_lanc_ctptd numeric, tipo_lancamento numeric, cod_conta numeric, fg_debito_credito character, valor double precision, dt_ref timestamp without time zone, cd_inc_usr numeric, nm_hst_lcn character varying, cpl_hst_lcn character varying, cd_sst numeric, nsu numeric) OWNER TO scan;

--
-- TOC entry 1423 (class 1255 OID 1656464)
-- Name: obter_saldo_conta_periodo(numeric, date, date); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION obter_saldo_conta_periodo(vp_codigo_conta numeric, vp_data_inicial date, vp_data_final date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_saldo numeric;
begin

  select sum(case when l.fg_dcr_lcn = c.fg_ntr_cnt then l.vl_lcn else l.vl_lcn*-1 end)
  into vl_saldo
  from sc_cnt.tbl_lcn l
    inner join sc_cnt.tbl_cnt c on c.cd_cnt = l.cd_cnt
  where dt_ref_lcn >= coalesce(vp_data_inicial,'01-01-2000')
    and dt_ref_lcn < coalesce(vp_data_final,current_date) +1
    and l.cd_cnt = vp_codigo_conta; 

  return coalesce(vl_saldo,0);
end$$;


ALTER FUNCTION sc_cnt.obter_saldo_conta_periodo(vp_codigo_conta numeric, vp_data_inicial date, vp_data_final date) OWNER TO scan;

--
-- TOC entry 1593 (class 1255 OID 927401)
-- Name: reprocessar_contas(); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION reprocessar_contas() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  _conn text;  
begin 

   _conn:='hostaddr=127.0.0.1 port=5432 dbname=scan user=scan password=scan';

   for rg in select *
             from sc_cnt.tbl_cnt
             where fg_rpc_cnt = 'S' loop
             
        perform * from dblink(_conn,'select sc_cnt.fecha_saldo_conta_periodo('||rg.cd_cnt||','''||rg.dt_rpc_cnt::date||''',current_date-1);update sc_cnt.tbl_cnt set fg_rpc_cnt=''N'',dt_rpc_cnt = null where cd_cnt ='|| rg.cd_cnt||';') as x (x text);

--        perform sc_cnt.fecha_saldo_conta_periodo(rg.cd_cnt,rg.dt_rpc_cnt,current_date-1);
  --      update sc_cnt.tbl_cnt set fg_rpc_cnt='N',dt_rpc_cnt = null where cd_cnt = rg.cd_cnt;
             
   end loop;          
end$$;


ALTER FUNCTION sc_cnt.reprocessar_contas() OWNER TO scan;

--
-- TOC entry 1286 (class 1255 OID 564289)
-- Name: restaurar_lancamento(numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION restaurar_lancamento(vp_sistema numeric, vp_nsu numeric, vp_usuario numeric, cd_lancamento numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

 vl_credito numeric;
 vl_debito numeric;

 vl_lancamento_contra_partida numeric;

 rg record;
begin

   if cd_lancamento is null then

	   select sum(case when fg_dcr_lcn = 'C' then l.vl_lcn else 0 end) valor_credito,
		  sum(case when fg_dcr_lcn = 'D' then l.vl_lcn else 0 end) valor_debito  
	   into vl_credito,vl_debito       
	   from sc_cnt.tbl_lcn_exc l
	   where cd_sst = vp_sistema
	   and nsu_lcn = vp_nsu;

	   if vl_credito <> vl_debito then
	      raise exception 'VALOR DE CREDITO E DEBITO NÃO CONFEREM.';
	   end if;

	   for rg in select *
		     from sc_cnt.tbl_lcn_exc l
		       inner join sc_cnt.tbl_cnt c on c.cd_cnt = l.cd_cnt
		     where cd_sst = vp_sistema
		       and nsu_lcn = vp_nsu loop

	       if rg.fg_dcr_lcn = rg.fg_ntr_cnt then
		  update sc_cnt.tbl_cnt set vl_sld_cnt = vl_sld_cnt + rg.vl_lcn where cd_cnt = rg.cd_cnt;          
	       else
		  update sc_cnt.tbl_cnt set vl_sld_cnt = vl_sld_cnt - rg.vl_lcn where cd_cnt = rg.cd_cnt;       
	       end if;
	       
	       insert into sc_cnt.tbl_lcn(select cd_lcn,cd_ctp_lcn,cd_tlc,dt_lcn,dt_ref_lcn,fg_dcr_lcn,nm_his_lcn,nm_cpl_his_lcn,cd_cnt,cd_inc_usr,cd_alt_usr,now(),null,vl_lcn,vl_sld_ant_cnt_lcn,cd_sst,nsu_lcn,cd_est_lcn from sc_cnt.tbl_lcn_exc lcn where cd_lcn = rg.cd_lcn);
	       delete from sc_cnt.tbl_lcn_exc where cd_lcn = rg.cd_lcn;
	       perform sc_cnt.fecha_saldo_conta_periodo(rg.cd_cnt,rg.dt_ref_lcn::date,(current_date - interval '1 day')::date);
	       
	   end loop;      
    else

     select lcn.cd_ctp_lcn
     into vl_lancamento_contra_partida
     from sc_cnt.tbl_lcn_exc lcn
     where cd_lcn = cd_lancamento;

     if vl_lancamento_contra_partida is not null then

	     for rg in select *
		       from sc_cnt.tbl_lcn_exc lcn
			  inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = lcn.cd_cnt
		       where cd_lcn in(cd_lancamento, vl_lancamento_contra_partida) loop

	       if rg.fg_dcr_lcn = rg.fg_ntr_cnt then
		  update sc_cnt.tbl_cnt set vl_sld_cnt = vl_sld_cnt - rg.vl_lcn where cd_cnt = rg.cd_cnt;          
	       else
		  update sc_cnt.tbl_cnt set vl_sld_cnt = vl_sld_cnt + rg.vl_lcn where cd_cnt = rg.cd_cnt;       
	       end if;

	       insert into sc_cnt.tbl_lcn(select cd_lcn,cd_ctp_lcn,cd_tlc,dt_lcn,dt_ref_lcn,fg_dcr_lcn,nm_his_lcn,nm_cpl_his_lcn,cd_cnt,cd_inc_usr,cd_alt_usr,now(),null,vl_lcn,vl_sld_ant_cnt_lcn,cd_sst,nsu_lcn,cd_est_lcn from sc_cnt.tbl_lcn_exc lcn where cd_lcn = rg.cd_lcn);
	       delete from sc_cnt.tbl_lcn_exc where cd_lcn = rg.cd_lcn;
	       perform sc_cnt.fecha_saldo_conta_periodo(rg.cd_cnt,rg.dt_ref_lcn::date,(current_date - interval '1 day')::date);
	       		       
	     end loop;
      else
         raise exception 'LANCAMENTO SEM CONTRAPARTIDA';
      end if;                 
	         	   
	   
    end if;	   
   
end$$;


ALTER FUNCTION sc_cnt.restaurar_lancamento(vp_sistema numeric, vp_nsu numeric, vp_usuario numeric, cd_lancamento numeric) OWNER TO scan;

--
-- TOC entry 1821 (class 1255 OID 564290)
-- Name: saldo_conta(numeric, character varying, character varying); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION saldo_conta(vp_cnt numeric, vp_fg_blq character varying, vp_fg_loc character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$declare
  vl_somatorio_bloqueio numeric(13,2) := 0;
  vl_saldo numeric(13,2);
  vl_resultado numeric(13,2);
begin

  -- somatorio bloqueado
  if vp_fg_blq = 'S' then
    select COALESCE(sum(vl_blq_tbc_cnt), 0)
      into vl_somatorio_bloqueio
    from sc_cnt.tbl_tbc_cnt
    where cd_cnt = vp_cnt;
  end if;

  -- saldo da conta
  if vp_fg_loc = 'S' then
    select vl_sld_cnt
      into vl_saldo
    from sc_cnt.tbl_cnt
    where cd_cnt = vp_cnt for update nowait;
  else
    select vl_sld_cnt
      into vl_saldo
    from sc_cnt.tbl_cnt
    where cd_cnt = vp_cnt;
  end if;

  if vl_somatorio_bloqueio < 0 then
    vl_somatorio_bloqueio := 0;
  end if;

  vl_resultado := vl_saldo - vl_somatorio_bloqueio;
  
  return vl_resultado;

end;$$;


ALTER FUNCTION sc_cnt.saldo_conta(vp_cnt numeric, vp_fg_blq character varying, vp_fg_loc character varying) OWNER TO scan;

--
-- TOC entry 1834 (class 1255 OID 564291)
-- Name: saldo_conta_liquido_bloqueio(numeric, integer[], character varying); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION saldo_conta_liquido_bloqueio(vp_cnt numeric, vp_tipo_bloqueio integer[], vp_fg_loc character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$declare
  vl_somatorio_bloqueio double precision := 0;
  vl_bloqueado double precision := 0;
  vl_saldo double precision;
  vl_bloqueado_total double precision := 0;
begin

  select coalesce(sum(vl_blq_tbc_cnt),0)
  into vl_bloqueado_total
  from sc_cnt.tbl_tbc_cnt
  where cd_cnt = vp_cnt; 

  -- somatorio bloqueado
  if not vp_tipo_bloqueio is null then
 
	  for i in 1..array_length(vp_tipo_bloqueio,1) loop

	      select COALESCE(sum(vl_blq_tbc_cnt), 0)
		into vl_bloqueado
	      from sc_cnt.tbl_tbc_cnt
	      where cd_cnt = vp_cnt
	        and cd_tbc = vp_tipo_bloqueio[i];

	      vl_somatorio_bloqueio = vl_somatorio_bloqueio + vl_bloqueado;    
	  end loop;

  end if;

  -- saldo da conta
  if vp_fg_loc = 'S' then
    select vl_sld_cnt
      into vl_saldo
    from sc_cnt.tbl_cnt
    where cd_cnt = vp_cnt for update nowait;
  else
    select vl_sld_cnt
      into vl_saldo
    from sc_cnt.tbl_cnt
    where cd_cnt = vp_cnt;
  end if;

  if vl_bloqueado_total < 0 then
     vl_bloqueado_total := 0;
  end if;

  if vl_somatorio_bloqueio < 0 then
     vl_somatorio_bloqueio := 0;
  end if;

  return vl_saldo - vl_bloqueado_total + vl_somatorio_bloqueio;

end;$$;


ALTER FUNCTION sc_cnt.saldo_conta_liquido_bloqueio(vp_cnt numeric, vp_tipo_bloqueio integer[], vp_fg_loc character varying) OWNER TO scan;

--
-- TOC entry 1287 (class 1255 OID 564292)
-- Name: transfere_entre_cartao(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION transfere_entre_cartao(vp_cartao_origem numeric, vp_cartao_destino numeric, vp_cod_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare 

vl_conta_origem numeric;
vl_conta_destino numeric;
vl_saldo_conta_origem numeric(13,2);

ct_tipo_lanc_transferencia_entre_cartao constant numeric := 84;
ct_sistema_manual constant numeric := 4;
ct_tipo_ocorrencia_inativacao_cartao constant numeric := 6;
ct_sit_funcionario_inativo constant numeric := 6;

ct_tipo_bloqueio_plastico_exlcusao constant numeric := 4;

vl_historico text;
vl_existe numeric := 0;

begin

  -- buscando conta do cartao de origem
  select cnt.cd_cnt 
    into vl_conta_origem
  from sc_opr.tbl_cnt_crt cnt_crt
       inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
  where cnt_crt.cd_crt = vp_cartao_origem;

  -- buscando conta de destino
  select cnt.cd_cnt 
    into vl_conta_destino
  from sc_opr.tbl_cnt_crt cnt_crt
       inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
  where cnt_crt.cd_crt = vp_cartao_destino;

  -- retornando o saldo da conta de origem
  select sc_cnt.saldo_conta(vl_conta_origem, 'S', 'S') into vl_saldo_conta_origem;


  -- validando se o valor a ser transferido existe em algum arquivo de depósito
  -- validacao para garantir o estorno
  select coalesce(count(*),0)
    into vl_existe
    from sc_cnt.tbl_lcn
  where cd_cnt = vl_conta_destino;

  if vl_existe > 0 then
    raise exception 'O cartão de destino não é um cartão novo. A transferência só pode ser realizada pra um cartão que ainda não foi utilizado.';
  end if;
  

  if vl_saldo_conta_origem > 0 then

    if vl_saldo_conta_origem < 30 then
	raise 'Valor a ser transferido é menor que o permitido.';
    end if;
    
    -- efetuando lancamento nas contas
    perform sc_cnt.lancar_debito_credito(vl_conta_origem, vl_conta_destino, ct_tipo_lanc_transferencia_entre_cartao, null, 'TRANSFERENCIA ENTRE CARTAO POR INATIVACAO', vl_saldo_conta_origem, current_timestamp::timestamp , vp_cod_usuario, ct_sistema_manual, null);

    -- inativando cartao de origem 
    update sc_opr.tbl_crt 
       set fg_atv_crt = 'N' 
    where cd_crt = vp_cartao_origem and fg_atv_crt = 'S';

    -- bloqueando plastico do cartao de origem
    update sc_opr.tbl_pls 
      set fg_blq_pls = 'S', cd_tbl = ct_tipo_bloqueio_plastico_exlcusao
    where cd_crt = vp_cartao_origem;

    -- inserindo ocorrencia no cartao de origem
    vl_historico := 'INATIVACAO POR TRANSFERENCIA DE SALDO PARA CARTAO ' ||  vp_cartao_destino;

    
    insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, 
                               nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		     values (nextval('sc_opr.sq_ocr'), ct_tipo_ocorrencia_inativacao_cartao, vp_cartao_origem, null, 
				 vl_historico, 'N', 1, now());
    
    -- inativando funcionario do cartao de origem
    update sc_cad.tbl_fnc 
       set st_fnc = ct_sit_funcionario_inativo 
     where cd_fnc = (select cd_fnc from sc_opr.tbl_crt where cd_crt = vp_cartao_origem);
    
  end if;

end;

$$;


ALTER FUNCTION sc_cnt.transfere_entre_cartao(vp_cartao_origem numeric, vp_cartao_destino numeric, vp_cod_usuario numeric) OWNER TO scan;

--
-- TOC entry 1289 (class 1255 OID 564293)
-- Name: transfere_entre_cartao(integer[], numeric, numeric, numeric); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION transfere_entre_cartao(vp_registro integer[], vp_cartao_origem numeric, vp_cartao_destino numeric, vp_cod_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare 

vl_conta_origem numeric;
vl_conta_destino numeric;
vl_saldo_conta_origem numeric(13,2);
vl_valor_deposito numeric(13,2) := 0;
vl_soma_valor_deposito numeric(13,2) := 0;

ct_tipo_lanc_transferencia_entre_cartao constant numeric := 84;
ct_sistema_manual constant numeric := 4;
ct_tipo_ocorrencia_inativacao_cartao constant numeric := 6;
ct_sit_funcionario_inativo constant numeric := 6;

ct_tipo_bloqueio_plastico_exlcusao constant numeric := 4;

vl_historico text;

begin

  

  -- buscando conta do cartao de origem
  select cnt.cd_cnt 
    into vl_conta_origem
  from sc_opr.tbl_cnt_crt cnt_crt
       inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
  where cnt_crt.cd_crt = vp_cartao_origem;

  -- buscando conta de destino
  select cnt.cd_cnt 
    into vl_conta_destino
  from sc_opr.tbl_cnt_crt cnt_crt
       inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
  where cnt_crt.cd_crt = vp_cartao_destino;

  -- retornando o saldo da conta de origem
  select sc_cnt.saldo_conta(vl_conta_origem, 'S', 'S') into vl_saldo_conta_origem;

  if vl_saldo_conta_origem > 0 then


    for i in 1..array_length(vp_registro,1) loop

      select vl_dep_rdp
	into vl_valor_deposito
      from sc_adp.tbl_rdp
      where cd_rdp = vp_registro[i];

      vl_soma_valor_deposito = vl_soma_valor_deposito + vl_valor_deposito;    
    end loop;
  
    
    if vl_soma_valor_deposito > vl_saldo_conta_origem then
	raise 'O valor a ser transferido é maior do que o saldo da conta';
    end if;
    
    -- efetuando lancamento nas contas
    perform sc_cnt.lancar_debito_credito(vl_conta_origem, vl_conta_destino, ct_tipo_lanc_transferencia_entre_cartao, null, 'TRANSFERENCIA ENTRE CARTAO POR INATIVACAO', vl_soma_valor_deposito, current_timestamp::timestamp , vp_cod_usuario, ct_sistema_manual, null);

    -- inativando cartao de origem 
    update sc_opr.tbl_crt 
       set fg_atv_crt = 'N' 
    where cd_crt = vp_cartao_origem and fg_atv_crt = 'S';

    -- bloqueando plastico do cartao de origem
    update sc_opr.tbl_pls 
      set fg_blq_pls = 'S', cd_tbl = ct_tipo_bloqueio_plastico_exlcusao
    where cd_crt = vp_cartao_origem;

    -- inserindo ocorrencia no cartao de origem
    vl_historico := 'INATIVACAO POR TRANSFERENCIA DE SALDO PARA CARTAO ' ||  vp_cartao_destino;

    
    insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, 
                               nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		     values (nextval('sc_opr.sq_ocr'), ct_tipo_ocorrencia_inativacao_cartao, vp_cartao_origem, null, 
				 vl_historico, 'N', 1, now());
    
    -- inativando funcionario do cartao de origem
    update sc_cad.tbl_fnc 
       set st_fnc = ct_sit_funcionario_inativo 
     where cd_fnc = (select cd_fnc from sc_opr.tbl_crt where cd_crt = vp_cartao_origem);
    
  end if;

end;

$$;


ALTER FUNCTION sc_cnt.transfere_entre_cartao(vp_registro integer[], vp_cartao_origem numeric, vp_cartao_destino numeric, vp_cod_usuario numeric) OWNER TO scan;

--
-- TOC entry 1291 (class 1255 OID 564294)
-- Name: transferencia_entre_contas(numeric); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION transferencia_entre_contas(vp_codigo numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare 

vl_rg sc_fin.tbl_tec%rowtype;
vl_rg_ttc sc_fin.tbl_ttc%rowtype;

vl_retorno numeric;

ct_st_processada numeric:= 2;
ct_st_cancelada numeric:= 3;

ct_prc_sucesso numeric:= 0;
ct_err_prc_rotina numeric:= 3;
ct_err_prc_lancamento_contabil numeric:= 4;

begin

  -- supondo que sera executado com sucesso
  vl_retorno := ct_prc_sucesso;

  -- buscando a transferencia
  select * 
    into vl_rg
  from sc_fin.tbl_tec
  where cd_tec = vp_codigo
  for update nowait;

  if vl_rg is null then
	vl_retorno := ct_err_prc_rotina;
	return vl_retorno;
  end if;

  -- se a data de referencia for igual a data atual entao executa o processamento

  if vl_rg.dt_ref_tec <= current_date then
  
    select *
      into vl_rg_ttc
    from sc_fin.tbl_ttc
    where cd_ttc = vl_rg.cd_ttc;  

    -- efetuando a regra de negocio da transferencia
    begin

      execute 'select ' || vl_rg_ttc.rot_prc_ttc into vl_retorno USING vl_rg;

    exception when others then

      vl_retorno := ct_err_prc_rotina;

    end;  


    if vl_retorno = ct_prc_sucesso then

      -- realizando o lancamento contabil
      begin

        perform sc_cnt.lancar_debito_credito(vl_rg.cd_cnt_org, vl_rg.cd_cnt_dst, vl_rg_ttc.cd_tlc, null, vl_rg.obs_tec, vl_rg.vl_tec, clock_timestamp()::timestamp, 1, 23, vl_rg.cd_tec);  

        update sc_fin.tbl_tec
          set st_tec = ct_st_processada
        where cd_tec = vp_codigo;

      exception when others then

        vl_retorno := ct_err_prc_lancamento_contabil;

      end;   

    end if;
   

    if vl_retorno <> ct_prc_sucesso then

      update sc_fin.tbl_tec
        set st_tec = ct_st_cancelada,
            err_prc_tec = vl_retorno,
            dt_cnc_tec = clock_timestamp(),
            cd_cnc_usr = 1
      where cd_tec = vp_codigo;     
      
    end if;
  

  end if;

  return vl_retorno;
  
end;

$$;


ALTER FUNCTION sc_cnt.transferencia_entre_contas(vp_codigo numeric) OWNER TO scan;

--
-- TOC entry 1292 (class 1255 OID 564295)
-- Name: transferencia_entre_contas_job(); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION transferencia_entre_contas_job() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare 

rg record;
ct_situacao_agendada numeric:= 1;

begin


  for rg in select cd_tec
            from sc_fin.tbl_tec
            where st_tec = ct_situacao_agendada
              and dt_ref_tec <= current_date loop

      perform sc_cnt.transferencia_entre_contas(rg.cd_tec);

  end loop;           
  
end;

$$;


ALTER FUNCTION sc_cnt.transferencia_entre_contas_job() OWNER TO scan;

SET search_path = sc_fin, pg_catalog;

--
-- TOC entry 227 (class 1259 OID 564296)
-- Name: tbl_tec; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_tec (
    cd_tec numeric(10,0) NOT NULL,
    cd_cnt_org numeric(10,0) NOT NULL,
    cd_cnt_dst numeric(10,0) NOT NULL,
    dt_ref_tec date NOT NULL,
    cd_ttc numeric(5,0) NOT NULL,
    st_tec numeric(5,0) NOT NULL,
    fnl_tec numeric(5,0),
    vl_tec numeric(13,2) NOT NULL,
    cd_cnc_usr numeric(10,0),
    dt_cnc_tec timestamp without time zone,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    obs_tec character varying(40),
    err_prc_tec numeric(5,0)
);


ALTER TABLE tbl_tec OWNER TO scan;

--
-- TOC entry 7781 (class 0 OID 0)
-- Dependencies: 227
-- Name: TABLE tbl_tec; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON TABLE tbl_tec IS 'tabela de transferencia entre contas';


SET search_path = sc_cnt, pg_catalog;

--
-- TOC entry 1592 (class 1255 OID 988995)
-- Name: transferencia_tipo_entre_cartoes(sc_fin.tbl_tec); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION transferencia_tipo_entre_cartoes(vp_transferencia sc_fin.tbl_tec) RETURNS numeric
    LANGUAGE plpgsql
    AS $$

DECLARE

	cd_cnt_crd numeric;
	cd_cnt_dbt numeric;

	vl_saldo_conta_debito numeric:= 0;
	vl_valor_transferencia numeric:= 0;
	
	vl_prc_rtn numeric:= 0;
	ct_prc_sucesso numeric:= 0;
	
	ct_err_saldo_insuficiente numeric:= 1;
	ct_err_cartoes_iguais numeric:= 6;

BEGIN
	vl_prc_rtn = ct_prc_sucesso;
	
	SELECT sc_cnt.saldo_conta(vp_transferencia.cd_cnt_org, 'S', 'S') INTO vl_saldo_conta_debito;

	if vp_transferencia.vl_tec > vl_saldo_conta_debito THEN
		vl_prc_rtn = ct_err_saldo_insuficiente;
	end if;
	
	return vl_prc_rtn;
END;
$$;


ALTER FUNCTION sc_cnt.transferencia_tipo_entre_cartoes(vp_transferencia sc_fin.tbl_tec) OWNER TO scan;

--
-- TOC entry 1293 (class 1255 OID 564299)
-- Name: transferencia_tipo_entre_contas_de_empresa(sc_fin.tbl_tec); Type: FUNCTION; Schema: sc_cnt; Owner: scan
--

CREATE FUNCTION transferencia_tipo_entre_contas_de_empresa(vp_transferencia sc_fin.tbl_tec) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare 

rg_bloqueio record;
rg_distribuicao record;

vl_cd_empresa_destino numeric;
vl_cd_contrato_destino numeric;

vl_cd_empresa_origem numeric;
vl_cd_contrato_origem numeric;

vl_saldo_conta numeric (13,2);
vl_saldo_liquido numeric (13,2);
vl_saldo_bloqueado_transferivel numeric (13,2) := 0;
vl_saldo_bloqueado_intransferivel numeric (13,2) := 0;

vl_saldo_a_transferir numeric(13,2);
vl_saldo_distribuicao numeric(13,2);

ct_tipo_blq_receb_recurso numeric := 1;
ct_st_recebimento_cadastrado numeric := 1;
ct_st_distribuicao_cadastrado numeric := 1;

ct_prc_sucesso numeric := 0;
ct_err_prc_saldo_insuficiente numeric := 1;
ct_err_prc_inconsistencia_bloqueio numeric := 2;
ct_err_prc_rotina numeric := 3;
ct_err_conta_grupo_divergente numeric := 5;

vl_retorno numeric;

vl_cont numeric;

begin

  -- supondo que sera executado com sucesso
  vl_retorno := ct_prc_sucesso;

  -- validando se as contas pertencem ao mesmo grupo empresarial
  select count(distinct emp.cd_gem)
    into vl_cont
  from sc_cad.tbl_ctr ctr
    inner join sc_cad.tbl_emp emp on emp.cd_emp = ctr.cd_emp
  where ctr.cd_cnt in (vp_transferencia.cd_cnt_org, vp_transferencia.cd_cnt_dst);  

  if vl_cont > 1 or vl_cont = 0 then

    vl_retorno := ct_err_conta_grupo_divergente;
    return vl_retorno;

  end if; 

  -- bloqueando o registro da conta de origem
  select vl_sld_cnt
    into vl_saldo_conta
  from sc_cnt.tbl_cnt
  where cd_cnt =  vp_transferencia.cd_cnt_org
  for update nowait;

  -- retornando os valores bloqueados
  for rg_bloqueio in select *
              from sc_cnt.tbl_tbc_cnt
            where cd_cnt = vp_transferencia.cd_cnt_org loop

       if rg_bloqueio.cd_tbc = ct_tipo_blq_receb_recurso then
         vl_saldo_bloqueado_transferivel := vl_saldo_bloqueado_transferivel + rg_bloqueio.vl_blq_tbc_cnt;
       else
         vl_saldo_bloqueado_intransferivel := vl_saldo_bloqueado_intransferivel + rg_bloqueio.vl_blq_tbc_cnt;
       end if;

  end loop;            
    
  vl_saldo_liquido := vl_saldo_conta - (vl_saldo_bloqueado_transferivel + vl_saldo_bloqueado_intransferivel);

  vl_saldo_a_transferir := vp_transferencia.vl_tec - vl_saldo_liquido;

  if vl_saldo_liquido + vl_saldo_bloqueado_transferivel < vp_transferencia.vl_tec then
	vl_retorno := ct_err_prc_saldo_insuficiente;
	return vl_retorno;
  end if;

  -- tratamento entre as distribuicoes de recebimento de recurso para manter a regra de negocio da antecipacao
  if vl_saldo_bloqueado_transferivel > 0 then

   --retornando o codigo da empresa e contrato da conta de origem
    select cd_emp, cd_ctr
      into vl_cd_empresa_origem, vl_cd_contrato_origem
    from sc_cad.tbl_ctr 
      where cd_cnt = vp_transferencia.cd_cnt_org; 

    --retornando o codigo da empresa e contrato da conta de destino
    select cd_emp, cd_ctr
      into vl_cd_empresa_destino, vl_cd_contrato_destino
    from sc_cad.tbl_ctr 
      where cd_cnt = vp_transferencia.cd_cnt_dst;  

    for rg_distribuicao 
       in select drr.*, drr.vl_drr - (drr.vl_lbr_ant_drr + drr.vl_lbr_prz_drr) as saldo
          from sc_fin.tbl_drr drr
           inner join sc_fin.tbl_rrc rrc on rrc.cd_rrc = drr.cd_rrc
          where drr.cd_emp = vl_cd_empresa_origem
            and drr.cd_ctr = vl_cd_contrato_origem
            and rrc.st_rrc = ct_st_recebimento_cadastrado
            and drr.st_drr = ct_st_distribuicao_cadastrado
            and drr.vl_drr - (drr.vl_lbr_ant_drr + drr.vl_lbr_prz_drr) > 0
          order by rrc.dt_prv_lbr_rrc, saldo DESC loop


           if vl_saldo_a_transferir > 0 then

             if rg_distribuicao.saldo >= vl_saldo_a_transferir then
	       vl_saldo_distribuicao := vl_saldo_a_transferir;
	     else
	       vl_saldo_distribuicao := rg_distribuicao.saldo;  
             end if;

             -- alterando o valor da distribuicao
             update sc_fin.tbl_drr set vl_drr = vl_drr - vl_saldo_distribuicao where cd_drr = rg_distribuicao.cd_drr;

             -- inserindo uma nova distribuicao referenciando a conta de destino
             insert into sc_fin.tbl_drr (cd_drr, cd_rrc, cd_emp, cd_ctr, vl_drr, st_drr, dt_inc_usr, cd_inc_usr, vl_lbr_ant_drr, vl_lbr_prz_drr) 
                    values (nextval('sc_fin.sq_drr'), rg_distribuicao.cd_rrc, vl_cd_empresa_destino, vl_cd_contrato_destino, vl_saldo_distribuicao, 
                            ct_st_distribuicao_cadastrado, clock_timestamp(), 1, 0, 0);       

             -- desbloqueando o saldo da empresa de origem
             update sc_cnt.tbl_tbc_cnt 
               set vl_blq_tbc_cnt = vl_blq_tbc_cnt - vl_saldo_distribuicao 
             where cd_cnt = vp_transferencia.cd_cnt_org 
               and cd_tbc = ct_tipo_blq_receb_recurso;

             -- bloqueando o saldo da empresa de destino
             update sc_cnt.tbl_tbc_cnt 
               set vl_blq_tbc_cnt = vl_blq_tbc_cnt + vl_saldo_distribuicao 
             where cd_cnt = vp_transferencia.cd_cnt_dst 
               and cd_tbc = ct_tipo_blq_receb_recurso;

             vl_saldo_a_transferir := vl_saldo_a_transferir - vl_saldo_distribuicao;

           end if;

    end loop;

    if vl_saldo_a_transferir > 0 then
	vl_retorno := ct_err_prc_inconsistencia_bloqueio;
    end if;        
                          
  end if;

  return vl_retorno;

end;

$$;


ALTER FUNCTION sc_cnt.transferencia_tipo_entre_contas_de_empresa(vp_transferencia sc_fin.tbl_tec) OWNER TO scan;

SET search_path = sc_ctb, pg_catalog;

--
-- TOC entry 1294 (class 1255 OID 564300)
-- Name: contabilizar(numeric, numeric, date, public.valor_evento[]); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION contabilizar(vp_codigo_arquivo numeric, vp_codigo_evento numeric, vp_data_referencia date, vp_valores public.valor_evento[]) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_existe numeric;
  vl_valor_contabilizacao numeric;
  vl_sequencia numeric;

  vl_rg record;

  vl_conta_debito varchar;
  vl_conta_credito varchar;
begin
  perform sc_ctb.contabilizar(vp_codigo_arquivo, vp_codigo_evento, vp_data_referencia, vp_valores, null);
end;$$;


ALTER FUNCTION sc_ctb.contabilizar(vp_codigo_arquivo numeric, vp_codigo_evento numeric, vp_data_referencia date, vp_valores public.valor_evento[]) OWNER TO scan;

--
-- TOC entry 7782 (class 0 OID 0)
-- Dependencies: 1294
-- Name: FUNCTION contabilizar(vp_codigo_arquivo numeric, vp_codigo_evento numeric, vp_data_referencia date, vp_valores public.valor_evento[]); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION contabilizar(vp_codigo_arquivo numeric, vp_codigo_evento numeric, vp_data_referencia date, vp_valores public.valor_evento[]) IS 'rotina que contabiliza um evento, para um conjunto de valores passados';


--
-- TOC entry 1295 (class 1255 OID 564301)
-- Name: contabilizar(numeric, numeric, date, public.valor_evento[], character varying); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION contabilizar(vp_codigo_arquivo numeric, vp_codigo_evento numeric, vp_data_referencia date, vp_valores public.valor_evento[], vp_complemento_historico character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_existe numeric;
  vl_valor_contabilizacao numeric;
  vl_sequencia numeric;

  vl_rg record;

  vl_conta_debito varchar;
  vl_conta_credito varchar;
begin
  select count(*)
  into vl_existe
  from sc_ctb.tbl_evt
  where cd_evt = vp_codigo_evento
    and fg_atv_evt = 'S';

  if vl_existe = 1 then
    for vl_rg in select tve.ds_tve, cte.cnt_dbt_cte, cte.cnt_crd_cte, cte.hst_cte
                 from sc_ctb.tbl_cte cte
                      inner join sc_ctb.tbl_tve tve on cte.cd_tve = tve.cd_tve
                 where cte.cd_evt = vp_codigo_evento
                   and tve.fg_atv_tve = 'S'
                   and cte.fg_atv_cte = 'S' loop
      select sc_ctb.get_valor_contabilizacao(vl_rg.ds_tve, vp_valores)
      into vl_valor_contabilizacao;

      if vl_valor_contabilizacao is null then
        raise exception 'NAO FOI PASSADO O TIPO DE VALOR: %', vl_rg.ds_tve; 
      else
        if vl_valor_contabilizacao > 0 then
          select count(*) + 1
          into vl_sequencia
          from sc_ctb.tbl_daec
          where cd_aec = vp_codigo_arquivo
            and dt_rfr_daec = vp_data_referencia;

          if vl_sequencia is null then
            vl_sequencia := 1;
          end if;

          vl_conta_debito := vl_rg.cnt_dbt_cte;
          if position('#' in vl_conta_debito) = 1 then
            vl_conta_debito := substr(vl_conta_debito, 2);
            
            select trim(to_char(sc_ctb.get_valor_contabilizacao(vl_conta_debito, vp_valores), '0000000000'))
            into vl_conta_debito;

            if vl_conta_debito is null then
              raise exception 'NAO FOI PASSADO A CONTA DE DEBITO: %', substr(vl_rg.cnt_dbt_cte, 2);
            end if;
          end if;
          
          vl_conta_credito := vl_rg.cnt_crd_cte;
          if position('#' in vl_conta_credito) = 1 then
            vl_conta_credito := substr(vl_conta_credito, 2);
            
            select trim(to_char(sc_ctb.get_valor_contabilizacao(vl_conta_credito, vp_valores), '0000000000'))
            into vl_conta_credito;

            if vl_conta_credito is null then
              raise exception 'NAO FOI PASSADO A CONTA DE CREDITO: %', substr(vl_rg.cnt_crd_cte, 2);
            end if;
          end if;
          
          insert into sc_ctb.tbl_daec(cd_daec, cd_aec, cnt_dbt_daec, cnt_crd_daec, hst_daec, vl_daec, dt_rfr_daec, sq_dia_daec, ds_cmp_hst_daec)
          values(nextval('sc_ctb.sq_daec'), vp_codigo_arquivo, vl_conta_debito, vl_conta_credito, vl_rg.hst_cte, vl_valor_contabilizacao, vp_data_referencia, vl_sequencia, vp_complemento_historico);
        end if;
      end if;
    end loop;
  else
    raise exception 'NAO EXISTE EVENTO ATIVO COM O CODIGO: %', vp_codigo_evento; 
  end if;
end;$$;


ALTER FUNCTION sc_ctb.contabilizar(vp_codigo_arquivo numeric, vp_codigo_evento numeric, vp_data_referencia date, vp_valores public.valor_evento[], vp_complemento_historico character varying) OWNER TO scan;

--
-- TOC entry 7783 (class 0 OID 0)
-- Dependencies: 1295
-- Name: FUNCTION contabilizar(vp_codigo_arquivo numeric, vp_codigo_evento numeric, vp_data_referencia date, vp_valores public.valor_evento[], vp_complemento_historico character varying); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION contabilizar(vp_codigo_arquivo numeric, vp_codigo_evento numeric, vp_data_referencia date, vp_valores public.valor_evento[], vp_complemento_historico character varying) IS 'rotina que contabiliza um evento, para um conjunto de valores passados';


--
-- TOC entry 1517 (class 1255 OID 853747)
-- Name: excluir_zerados(numeric); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION excluir_zerados(vp_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin

	delete 
	from sc_ctb.tbl_daec_cpl 
	where cd_daec_cpl in (select c.cd_daec_cpl 
			  from sc_ctb.tbl_daec_cpl c
			     inner join sc_ctb.tbl_daec_lcn l on l.cd_daec_lcn = c.cd_daec_lcn
			  where c.vl_daec_cpl = 0
			    and l.cd_aec = vp_arquivo);    
	   delete 
	from sc_ctb.tbl_daec_lcn l
	where not exists (select 1 from sc_ctb.tbl_daec_cpl c where c.cd_daec_lcn = l.cd_daec_lcn)
	  and l.cd_aec = vp_arquivo;

end$$;


ALTER FUNCTION sc_ctb.excluir_zerados(vp_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1675 (class 1255 OID 564302)
-- Name: existe_lancamento(date, numeric, numeric); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION existe_lancamento(vp_data_referencia date, vp_codigo_arquivo numeric, vp_sequencial numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

rg record;
rg_cpl record;

vl_codigo_lancamento_credito numeric[];
vl_codigo_lancamento_debito numeric[];
vl_cont_lancamento_credito numeric[];
vl_cont_lancamento_debito numeric[];

vl_codigo_lancamento numeric := 0;

vl_ext_cont_lancamento numeric := 0;
vl_cont_credito numeric := 1;
vl_cont_debito numeric := 1;

consulta_lancamento boolean := false;

cont_lancamento numeric := 0;

begin
   raise notice 'vp_data_referencia: %, vp_codigo_arquivo: %, vp_sequencial: %', vp_data_referencia, vp_codigo_arquivo, vp_sequencial;

   for rg in select lcn.*, ext.cd_cnt_ctb
	from sc_ctb.tbl_ext_lcn ext
	 inner join sc_cnt.tbl_lcn lcn on lcn.cd_lcn = ext.cd_lcn
	where lcn.dt_ref_lcn >= vp_data_referencia
	  and lcn.dt_ref_lcn < vp_data_referencia + 1
	  and ext.nr_seq_ext_lcn = vp_sequencial
          order by ext.cd_cnt_ctb::numeric loop

            
            vl_ext_cont_lancamento := vl_ext_cont_lancamento + 1;
            consulta_lancamento := false;

            for rg_cpl in 
                select lcn.cd_daec_lcn
	    from sc_ctb.tbl_daec_cpl cpl
	      inner join sc_ctb.tbl_daec_lcn lcn on lcn.cd_daec_lcn = cpl.cd_daec_lcn
	      where lcn.cd_aec = vp_codigo_arquivo
                and cpl.fg_dcr_daec_cpl = rg.fg_dcr_lcn
                and cpl.cnt_daec_cpl = rg.cd_cnt_ctb
                and cpl.cd_hst_daec_cpl = rg.cd_tlc loop

                consulta_lancamento := true; 
 
                if (rg.fg_dcr_lcn = 'C') then
                  vl_codigo_lancamento_credito[vl_cont_credito] := rg_cpl.cd_daec_lcn;
                  vl_cont_lancamento_credito[rg_cpl.cd_daec_lcn] := coalesce(vl_cont_lancamento_credito[rg_cpl.cd_daec_lcn],0) + 1;
                  vl_cont_credito := vl_cont_credito + 1;
                else
                  vl_codigo_lancamento_debito[vl_cont_debito] := rg_cpl.cd_daec_lcn;
                  vl_cont_lancamento_debito[rg_cpl.cd_daec_lcn] := coalesce(vl_cont_lancamento_debito[rg_cpl.cd_daec_lcn],0) + 1;
                  vl_cont_debito := vl_cont_debito + 1;
                end if; 
             
             end loop;


         if not consulta_lancamento then
	   return 0;
         end if;

    end loop;


    if array_length(vl_codigo_lancamento_credito,1) > 0 then
      for i in 1..array_length(vl_codigo_lancamento_credito,1) loop

        select count(*)
          into cont_lancamento 
        from sc_ctb.tbl_daec_cpl
        where cd_daec_lcn = vl_codigo_lancamento_credito[i]
         and fg_dcr_daec_cpl = 'C';

        if cont_lancamento = vl_cont_lancamento_credito[vl_codigo_lancamento_credito[i]] then

          for j in 1..array_length(vl_codigo_lancamento_debito,1) loop
          
           select count(*)
           into cont_lancamento 
         from sc_ctb.tbl_daec_cpl
           where cd_daec_lcn = vl_codigo_lancamento_debito[j]
         and fg_dcr_daec_cpl = 'D';

         if  vl_codigo_lancamento_credito[i] = vl_codigo_lancamento_debito[j] then 

           if cont_lancamento = vl_cont_lancamento_debito[vl_codigo_lancamento_debito[j]]
              and vl_ext_cont_lancamento = vl_cont_lancamento_credito[vl_codigo_lancamento_credito[i]] + vl_cont_lancamento_debito[vl_codigo_lancamento_debito[j]]
           then
             vl_codigo_lancamento := vl_codigo_lancamento_credito[i];

           end if;

         end if;

        end loop;

       end if;   

      end loop;
    end if;
    
    return vl_codigo_lancamento;
    
exception when others then

  raise exception 'num % erro % contador %', SQLSTATE, SQLERRM, vl_codigo_lancamento;

end;$$;


ALTER FUNCTION sc_ctb.existe_lancamento(vp_data_referencia date, vp_codigo_arquivo numeric, vp_sequencial numeric) OWNER TO scan;

--
-- TOC entry 7784 (class 0 OID 0)
-- Dependencies: 1675
-- Name: FUNCTION existe_lancamento(vp_data_referencia date, vp_codigo_arquivo numeric, vp_sequencial numeric); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION existe_lancamento(vp_data_referencia date, vp_codigo_arquivo numeric, vp_sequencial numeric) IS 'retorna um lacamento existente no criterio do sequencial';


--
-- TOC entry 1878 (class 1255 OID 564303)
-- Name: gerar_arquivo_dia(date); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION gerar_arquivo_dia(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_arquivo numeric;
  vl_codigo_download numeric;
begin
--   perform sc_ctb.gerar_extensao_lancamento(vp_data);
--   perform sc_ctb.gerar_arquivo_fortes_contabil(sc_ctb.gerar_dados_arquivo(vp_data));
   raise notice 'iniciando sc_ctb.popula_contrapartidas';
   perform sc_ctb.popula_contrapartidas(vp_data,vp_data+1);

   raise notice 'iniciando sc_ctb.gerar_extensao_lancamento';
   perform sc_ctb.gerar_extensao_lancamento(vp_data);

   raise notice 'iniciando sc_ctb.gerar_dados_arquivo';
   vl_arquivo := sc_ctb.gerar_dados_arquivo(vp_data);

   raise notice 'iniciando sc_ctb.limpar_repetidos';
   perform sc_ctb.limpar_repetidos(vl_arquivo);

   raise notice 'iniciando sc_ctb.excluir_zerados';
   perform sc_ctb.excluir_zerados(vl_arquivo);

   raise notice 'iniciando sc_ctb.gerar_arquivo_fortes_contabil';
   select sc_ctb.gerar_arquivo_fortes_contabil(vl_arquivo) into vl_codigo_download; 

   update sc_ctb.tbl_arq_ctb 
      set st_arq_ctb = 2,
          cd_alt_usr = 1,
          dt_alt_usr = now()
    where dt_arq_ctb = vp_data 
      and st_arq_ctb = 1;

    insert into sc_ctb.tbl_arq_ctb values(nextval('sc_ctb.sq_arq_ctb'), vp_data,1,1,now(),null,null, vl_codigo_download);
   
end$$;


ALTER FUNCTION sc_ctb.gerar_arquivo_dia(vp_data date) OWNER TO scan;

--
-- TOC entry 1879 (class 1255 OID 564304)
-- Name: gerar_arquivo_exportacao_periodo(date, date); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION gerar_arquivo_exportacao_periodo(vp_data_inicial date, vp_data_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  vl_arquivo numeric;
  _conn varchar :='hostaddr=127.0.0.1 port=5432 dbname=scan user=scan password=scan';
begin

   perform * from dblink(_conn,   'delete 
				   from sc_ctb.tbl_ext_lcn
				   where cd_lcn in (select cd_lcn
						    from sc_cnt.tbl_lcn 
						    where dt_ref_lcn >='''|| vp_data_inicial||''' 
						        and dt_ref_lcn <''' || vp_data_final+1||''');') as x (x text);
   /*delete 
   from sc_ctb.tbl_ext_lcn
   where cd_lcn in (select cd_lcn
                    from sc_cnt.tbl_lcn 
                    where dt_ref_lcn >= vp_data_inicial 
                      and dt_ref_lcn < vp_data_final);*/
                          
   for rg in select distinct dt_ref_lcn::date
             from sc_cnt.tbl_lcn
             where dt_ref_lcn >= vp_data_inicial
               and dt_ref_lcn < vp_data_final + interval '1 day'
             order by dt_ref_lcn  loop

         raise notice 'select sc_ctb.gerar_arquivo_dia(''%'');', rg.dt_ref_lcn;
         
         --perform * from dblink(_conn,   'select sc_ctb.gerar_arquivo_dia('''||rg.dt_ref_lcn::date||''');') as x (x text);
         perform sc_ctb.gerar_arquivo_dia(rg.dt_ref_lcn);
             

               /*perform sc_ctb.gerar_extensao_lancamento(rg.dt_ref_lcn::date);
               vl_arquivo := sc_ctb.gerar_dados_arquivo(rg.dt_ref_lcn::date);
               perform sc_ctb.limpar_repetidos(vl_arquivo);
               perform sc_ctb.excluir_zerados(vl_arquivo);
               perform sc_ctb.gerar_arquivo_fortes_contabil(vl_arquivo);*/
   end loop;            
             

end$$;


ALTER FUNCTION sc_ctb.gerar_arquivo_exportacao_periodo(vp_data_inicial date, vp_data_final date) OWNER TO scan;

--
-- TOC entry 1663 (class 1255 OID 976599)
-- Name: gerar_arquivo_fortes_contabil(numeric); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION gerar_arquivo_fortes_contabil(vp_codigo_arquivo numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_arquivo sc_ctb.tbl_aec;
  vl_detalhe_lcn sc_ctb.tbl_daec_lcn;
  vl_detalhe_cpl sc_ctb.tbl_daec_cpl;

  vl_diretorio varchar;
  vl_nome_arquivo varchar;
  vl_nome_download_arquivo varchar;
  vl_linha varchar;

  vl_numero_linhas numeric := 0;
  
  vl_valor_total numeric := 0;

  ct_diretorio_arq_contabilidade constant varchar := 'DIRETORIO_ARQUIVO_CONTABILIDADE';

  ct_tipo_download_contabilidade constant numeric := 3;
  ct_situacao_gerado constant numeric := 1;
begin
  select *
  into vl_arquivo
  from sc_ctb.tbl_aec
  where cd_aec = vp_codigo_arquivo;

  if vl_arquivo.cd_aec is not null then
    -- Obtendo os parametros
    select prm.vl_prm
    into vl_diretorio
    from sc_cad.tbl_prm prm
    where prm.nm_prm = ct_diretorio_arq_contabilidade;
  
    --definindo o nome do arquivo
    vl_nome_download_arquivo := 'SAQPAG.' || trim(to_char(vp_codigo_arquivo, repeat('0', 5))) ||'.'||to_char(vl_arquivo.dt_rfr_ini_aec,'ddmmyyyy')|| '.CT';
    vl_nome_arquivo := vl_diretorio || E'\\' || vl_nome_download_arquivo;
      
    vl_linha := sc_ctb.gerar_header_arquivo(vl_arquivo);
    perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
    vl_numero_linhas := vl_numero_linhas + 1;

    for vl_detalhe_lcn in select *
                 from sc_ctb.tbl_daec_lcn
                 where cd_aec = vp_codigo_arquivo
                 order by nr_seq_daec_lcn loop
      vl_linha := sc_ctb.gerar_registro_lancamento(vl_detalhe_lcn);
      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
      --raise notice '%', vl_linha;
      vl_numero_linhas := vl_numero_linhas + 1;

      if vl_detalhe_lcn.ds_cmp_hst_daec_lcn is not null and length(vl_detalhe_lcn.ds_cmp_hst_daec_lcn) > 40 then

        vl_numero_linhas := vl_numero_linhas + sc_ctb.gerar_registro_complemento_historico_lancamento(vl_nome_arquivo, substr(vl_detalhe_lcn.ds_cmp_hst_daec_lcn, 41));
        
      end if;

      for vl_detalhe_cpl in select *
                 from sc_ctb.tbl_daec_cpl
                 where cd_daec_lcn = vl_detalhe_lcn.cd_daec_lcn
                 order by nr_seq_daec_cpl loop

      vl_linha := sc_ctb.gerar_registro_complementar_lancamento(vl_detalhe_cpl);
      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
      --raise notice '%', vl_linha;
      vl_numero_linhas := vl_numero_linhas + 1;

        if vl_detalhe_cpl.ds_cmp_hst_daec_cpl is not null and length(vl_detalhe_cpl.ds_cmp_hst_daec_cpl) > 40 then

          vl_numero_linhas := vl_numero_linhas + sc_ctb.gerar_registro_complemento_historico_complementar_lancamento(vl_nome_arquivo, substr(vl_detalhe_cpl.ds_cmp_hst_daec_cpl, 41));
        
        end if;

      end loop;

      vl_valor_total := vl_valor_total + vl_detalhe_lcn.vl_daec_lcn;
    end loop;

    vl_numero_linhas := vl_numero_linhas + 1;
    vl_linha := sc_ctb.gerar_trailler_arquivo(vl_numero_linhas, vl_valor_total);
    perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
    --raise notice '%', vl_linha;

    -- inserindo registro na tabela de download de arquivo
    insert into sc_dwn.tbl_dwa values (nextval('sc_dwn.sq_dwa'),vl_nome_download_arquivo,now(),now(),ct_tipo_download_contabilidade,ct_situacao_gerado);

    return currval('sc_dwn.sq_dwa');
  else
    raise exception 'ARQUIVO DE CODIGO: % NAO FOI ENCONTRADO', vp_codigo_arquivo;
  end if;
end;$$;


ALTER FUNCTION sc_ctb.gerar_arquivo_fortes_contabil(vp_codigo_arquivo numeric) OWNER TO scan;

--
-- TOC entry 7785 (class 0 OID 0)
-- Dependencies: 1663
-- Name: FUNCTION gerar_arquivo_fortes_contabil(vp_codigo_arquivo numeric); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION gerar_arquivo_fortes_contabil(vp_codigo_arquivo numeric) IS 'rotina que obtem todos os dados gerados e cria um arquivo texto no layout entendido pelo sistema forte contabilidade';


--
-- TOC entry 1649 (class 1255 OID 564306)
-- Name: gerar_dados_arquivo(date); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION gerar_dados_arquivo(vp_data_referencia date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

rg record;

ct_situacao_gerado constant numeric := 1;
ct_estabelecimento constant numeric := 1;
ct_centro_resultado constant numeric := 1;

vl_existe_caracteristica numeric := 0;
vl_cont numeric;

vl_codigo_arquivo numeric;
vl_seq_lancamento numeric := 0;
vl_seq_complementar_lancamento numeric := 0;

vl_codigo_lancamento numeric := 0;
vl_cd_historico_lancamento numeric := 0;
vl_lancamento numeric := 0;
vl_codigo_complementar_lancamento numeric := 0;
vl_debito_credito varchar;

begin

  select max(nr_seq_ext_lcn) 
    into vl_cont 
  from sc_ctb.tbl_ext_lcn ext 
    inner join sc_cnt.tbl_lcn lcn on lcn.cd_lcn = ext.cd_lcn
  where lcn.dt_ref_lcn >= vp_data_referencia
    and lcn.dt_ref_lcn <  vp_data_referencia + 1;


  if vl_cont <= 0 then
    raise exception 'NAO EXISTE LANCAMENTOS NESTA DATA';
  end if;

  select nextval('sc_ctb.sq_aec')
  into vl_codigo_arquivo;

  insert into sc_ctb.tbl_aec(cd_aec, dt_grc_aec, dt_rfr_ini_aec, dt_rfr_fin_aec, st_aec)
  values (vl_codigo_arquivo, current_timestamp, vp_data_referencia, vp_data_referencia, ct_situacao_gerado);
  

  while vl_cont > 0 loop

        vl_codigo_complementar_lancamento := 0;
        vl_seq_complementar_lancamento := 0;
        vl_lancamento := 0;
        vl_codigo_lancamento := 0;
        vl_existe_caracteristica := 0;

        raise notice 'passo 1';

        select sc_ctb.existe_lancamento(vp_data_referencia, vl_codigo_arquivo, vl_cont)
          into vl_codigo_lancamento;

       raise notice 'passo 2';

	for rg in 
		/*select lcn.*, ext.cd_cnt_ctb
		from sc_ctb.tbl_ext_lcn ext
		 inner join sc_cnt.tbl_lcn lcn on lcn.cd_lcn = ext.cd_lcn
		where lcn.dt_ref_lcn >= vp_data_referencia
		  and lcn.dt_ref_lcn < vp_data_referencia + 1
		  and ext.nr_seq_ext_lcn = vl_cont
		  order by ext.cd_cnt_ctb::numeric */

		select abs(sum(case when fg_dcr_lcn = 'C' then vl_lcn else vl_lcn*-1 end)) as vl_lcn,
		       case when sum(case when fg_dcr_lcn = 'C' then vl_lcn else 0 end)>sum(case when fg_dcr_lcn = 'D' then vl_lcn else 0 end) then 'C' else 'D' end as fg_dcr_lcn,
		       cd_cnt_ctb,lcn.cd_tlc,max(lcn.cd_lcn) as cd_lcn
		from sc_ctb.tbl_ext_lcn ext
		   inner join sc_cnt.tbl_lcn lcn on lcn.cd_lcn = ext.cd_lcn
		where lcn.dt_ref_lcn >= vp_data_referencia
		  and lcn.dt_ref_lcn < vp_data_referencia + 1
		  and ext.nr_seq_ext_lcn = vl_cont
		  group by cd_cnt_ctb,lcn.cd_tlc
		  having abs(sum(case when fg_dcr_lcn = 'C' then vl_lcn else vl_lcn*-1 end)) > 0
		  order by ext.cd_cnt_ctb::numeric		  

          loop


            raise notice 'passo 3';
	    begin 
	      
              select cpl.cd_daec_cpl
	      into strict vl_codigo_complementar_lancamento
	    from sc_ctb.tbl_daec_cpl cpl
	      inner join sc_ctb.tbl_daec_lcn lcn on lcn.cd_daec_lcn = cpl.cd_daec_lcn
	      where lcn.cd_aec = vl_codigo_arquivo
                and cpl.cd_daec_lcn = vl_codigo_lancamento
                and cpl.fg_dcr_daec_cpl = rg.fg_dcr_lcn
                and cpl.cnt_daec_cpl = rg.cd_cnt_ctb
                and cpl.cd_hst_daec_cpl = rg.cd_tlc;

           exception when others then

              vl_codigo_complementar_lancamento := 0;
              
           end;
	          
           raise notice 'passo 4';
           if vl_codigo_complementar_lancamento > 0 then
                  
                update sc_ctb.tbl_daec_cpl set vl_daec_cpl = vl_daec_cpl + rg.vl_lcn where cd_daec_cpl = vl_codigo_complementar_lancamento;

           else

              vl_cd_historico_lancamento := rg.cd_tlc;
              vl_seq_complementar_lancamento = vl_seq_complementar_lancamento + 1;
 
              if vl_codigo_lancamento = 0 then
                 select nextval('sc_ctb.sq_daec_lcn') into vl_codigo_lancamento;

                 vl_seq_lancamento := vl_seq_lancamento + 1;

                 insert into sc_ctb.tbl_daec_lcn (cd_daec_lcn,cd_aec,dt_rfr_daec_lcn,nr_seq_daec_lcn,nr_lote_daec_lcn,vl_daec_lcn,cd_hst_daec_lcn,ds_cmp_hst_daec_lcn)
                                    VALUES (vl_codigo_lancamento,vl_codigo_arquivo,vp_data_referencia,vl_seq_lancamento,vl_codigo_arquivo,vl_lancamento,vl_cd_historico_lancamento,null);
              end if;

              insert into sc_ctb.tbl_daec_cpl (cd_daec_cpl,cd_daec_lcn,fg_dcr_daec_cpl,nr_seq_daec_cpl,cnt_daec_cpl,est_daec_cpl,
                                               cto_res_daec_cpl,cd_hst_daec_cpl,vl_daec_cpl)
                                    VALUES (nextval('sc_ctb.sq_daec_cpl'),vl_codigo_lancamento,rg.fg_dcr_lcn,vl_seq_complementar_lancamento,rg.cd_cnt_ctb,ct_estabelecimento,
                                               ct_centro_resultado,rg.cd_tlc,rg.vl_lcn);

           end if;

           raise notice 'passo 5';

	   if rg.fg_dcr_lcn = 'C' then
		vl_lancamento := vl_lancamento + rg.vl_lcn;
	   end if; 

	 end loop;

         if vl_codigo_lancamento > 0 then

            update sc_ctb.tbl_daec_lcn set vl_daec_lcn = vl_daec_lcn + vl_lancamento  where cd_daec_lcn = vl_codigo_lancamento;

         end if;

     raise notice 'passo 6';
     vl_cont := vl_cont - 1;



  end loop;

  raise notice 'passo 7';
  return vl_codigo_arquivo;

exception when others then

  raise exception 'num % erro % contador %', SQLSTATE, SQLERRM, vl_cont;

end;$$;


ALTER FUNCTION sc_ctb.gerar_dados_arquivo(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7786 (class 0 OID 0)
-- Dependencies: 1649
-- Name: FUNCTION gerar_dados_arquivo(vp_data_referencia date); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION gerar_dados_arquivo(vp_data_referencia date) IS 'gerar os dados do arquivo de exportação de contabilidade';


--
-- TOC entry 1631 (class 1255 OID 564307)
-- Name: gerar_extensao_lancamento(date); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION gerar_extensao_lancamento(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg_lcn record;
rg_contra_lcn record;
vl_existe_lancamento numeric;
vl_cnt_ctb_lancamento varchar(50);
vl_cnt_contra_ctb_lancamento varchar(50);
vl_seq_lancamento numeric := 0;
vl_qtd_err numeric := 0;
vl_cd_lcn_err numeric := 0;
i numeric :=0;
begin

  for rg_lcn in select *
              from sc_cnt.tbl_lcn 
            where dt_ref_lcn >=  vp_data_referencia
              and dt_ref_lcn < vp_data_referencia + 1
            order by cd_lcn
  loop

     begin

       -- retornando a conta contabil do lancamento
       select coalesce(cnt.cd_cnt_ctb,scn.cd_cnt_ctb)
         into vl_cnt_ctb_lancamento
         from sc_cnt.tbl_cnt cnt
          inner join sc_cnt.tbl_scn scn on scn.cd_scn = cnt.cd_scn
       where cnt.cd_cnt = rg_lcn.cd_cnt;   

       -- verifica se lancamento ja existe na tabela de extensao
       select count(*)
         into vl_existe_lancamento
         from sc_ctb.tbl_ext_lcn
       where cd_lcn = rg_lcn.cd_lcn;

       if  vl_existe_lancamento = 0 then

	  vl_seq_lancamento := vl_seq_lancamento + 1;

          insert into sc_ctb.tbl_ext_lcn (cd_ext_lcn,nr_seq_ext_lcn,cd_lcn,cd_cnt_ctb)
          values (nextval('sc_ctb.sq_ext_lcn'),vl_seq_lancamento,rg_lcn.cd_lcn,replace(vl_cnt_ctb_lancamento,'.',''));              
          
          -- verifica se lancamento possui contra partida
          if (coalesce(rg_lcn.cd_ctp_lcn,0) > 0) then

            select count(*)
             into vl_existe_lancamento
            from sc_ctb.tbl_ext_lcn
            where cd_lcn = rg_lcn.cd_ctp_lcn; 

            if (vl_existe_lancamento = 0) then

              -- verfica se contra partida possui codigo de conta contabil
              select coalesce(cnt.cd_cnt_ctb,scn.cd_cnt_ctb)
                into vl_cnt_contra_ctb_lancamento
              from sc_cnt.tbl_lcn lcn
                inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = lcn.cd_cnt
                inner join sc_cnt.tbl_scn scn on scn.cd_scn = cnt.cd_scn
              where lcn.cd_lcn = rg_lcn.cd_ctp_lcn;

              insert into sc_ctb.tbl_ext_lcn (cd_ext_lcn,nr_seq_ext_lcn,cd_lcn,cd_cnt_ctb)
              values (nextval('sc_ctb.sq_ext_lcn'),vl_seq_lancamento,rg_lcn.cd_ctp_lcn,replace(vl_cnt_contra_ctb_lancamento,'.',''));
 
            end if;

          else
          -- iterar sobre os lancamentos que possuem este como contra partida
             for rg_contra_lcn in 
             select * 
             from sc_cnt.tbl_lcn 
             where cd_ctp_lcn = rg_lcn.cd_lcn loop

		 -- retornando a conta contabil do lancamento
		 select coalesce(cnt.cd_cnt_ctb,scn.cd_cnt_ctb)
		   into vl_cnt_ctb_lancamento
		 from sc_cnt.tbl_cnt cnt
		   inner join sc_cnt.tbl_scn scn on scn.cd_scn = cnt.cd_scn
		 where cnt.cd_cnt = rg_contra_lcn.cd_cnt;   

                 -- verifica se lancamento ja existe na tabela de extensao
                 select count(*)
                   into vl_existe_lancamento
                 from sc_ctb.tbl_ext_lcn
                 where cd_lcn = rg_contra_lcn.cd_lcn;

                 if  vl_existe_lancamento = 0 then

                    insert into sc_ctb.tbl_ext_lcn (cd_ext_lcn,nr_seq_ext_lcn,cd_lcn,cd_cnt_ctb)
                    values (nextval('sc_ctb.sq_ext_lcn'),vl_seq_lancamento,rg_contra_lcn.cd_lcn,replace(vl_cnt_ctb_lancamento,'.','')); 

                 end if;   

             end loop;    
                        
          end if;
       
       end if;

   exception when others then
      raise 'Erro ao processar rotina  codigo conta %, codigo lancamento %, msg error %', rg_lcn.cd_cnt, rg_lcn.cd_lcn, SQLERRM;
   end;
         
  end loop; 

    select coalesce(nr_seq_ext_lcn,0)
       into vl_qtd_err
     from sc_ctb.tbl_ext_lcn exl
       inner join sc_cnt.tbl_lcn lcn on lcn.cd_lcn = exl.cd_lcn
     where lcn.dt_ref_lcn>= vp_data_referencia 
        and lcn.dt_ref_lcn < vp_data_referencia + 1
     group by nr_seq_ext_lcn
     having count(*) < 2;

    if vl_qtd_err > 0 then

       select lcn.cd_lcn
       into vl_cd_lcn_err
     from sc_ctb.tbl_ext_lcn exl
       inner join sc_cnt.tbl_lcn lcn on lcn.cd_lcn = exl.cd_lcn
     where lcn.dt_ref_lcn>= vp_data_referencia 
       and lcn.dt_ref_lcn< vp_data_referencia+1
       and nr_seq_ext_lcn = vl_qtd_err;
    
       raise 'Erro ao processar rotina data % codigo lancamento %',vp_data_referencia, vl_cd_lcn_err;
    end if;

end;$$;


ALTER FUNCTION sc_ctb.gerar_extensao_lancamento(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7787 (class 0 OID 0)
-- Dependencies: 1631
-- Name: FUNCTION gerar_extensao_lancamento(vp_data_referencia date); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION gerar_extensao_lancamento(vp_data_referencia date) IS 'gerar as extensoes de lancamentos para exportacao do arquivo contabil';


--
-- TOC entry 228 (class 1259 OID 564308)
-- Name: tbl_aec; Type: TABLE; Schema: sc_ctb; Owner: scan
--

CREATE TABLE tbl_aec (
    cd_aec numeric(10,0) NOT NULL,
    dt_rfr_ini_aec date NOT NULL,
    dt_rfr_fin_aec date NOT NULL,
    dt_grc_aec timestamp without time zone NOT NULL,
    st_aec numeric(2,0) NOT NULL,
    cd_dwn_usr numeric(5,0),
    dt_dwn_usr timestamp without time zone
);


ALTER TABLE tbl_aec OWNER TO scan;

--
-- TOC entry 7788 (class 0 OID 0)
-- Dependencies: 228
-- Name: TABLE tbl_aec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON TABLE tbl_aec IS 'tabela de arquivo de exportacao de contabilidade';


--
-- TOC entry 7789 (class 0 OID 0)
-- Dependencies: 228
-- Name: COLUMN tbl_aec.cd_aec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_aec.cd_aec IS 'codigo';


--
-- TOC entry 7790 (class 0 OID 0)
-- Dependencies: 228
-- Name: COLUMN tbl_aec.dt_rfr_ini_aec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_aec.dt_rfr_ini_aec IS 'data de referencia inicial';


--
-- TOC entry 7791 (class 0 OID 0)
-- Dependencies: 228
-- Name: COLUMN tbl_aec.dt_rfr_fin_aec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_aec.dt_rfr_fin_aec IS 'data de referencia final';


--
-- TOC entry 7792 (class 0 OID 0)
-- Dependencies: 228
-- Name: COLUMN tbl_aec.dt_grc_aec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_aec.dt_grc_aec IS 'data de geracao';


--
-- TOC entry 7793 (class 0 OID 0)
-- Dependencies: 228
-- Name: COLUMN tbl_aec.st_aec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_aec.st_aec IS 'situacao';


--
-- TOC entry 7794 (class 0 OID 0)
-- Dependencies: 228
-- Name: COLUMN tbl_aec.cd_dwn_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_aec.cd_dwn_usr IS 'usuario de download';


--
-- TOC entry 7795 (class 0 OID 0)
-- Dependencies: 228
-- Name: COLUMN tbl_aec.dt_dwn_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_aec.dt_dwn_usr IS 'data de download';


--
-- TOC entry 1875 (class 1255 OID 564311)
-- Name: gerar_header_arquivo(tbl_aec); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION gerar_header_arquivo(vp_arquivo tbl_aec) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
    vl_linha text;
  
  ct_codigo_empresa constant numeric := 2036;
  
  ct_a_esquerda constant numeric := 1;
  ct_a_direita constant numeric := 2;
  ct_centralizado constant numeric := 3;

  vl_dt_ref_ini date;
begin
  --Identificação do registro header
  vl_linha := '0';
  
  --versão do layout
  vl_linha := vl_linha || '5';
  
  --nome do sistema destino
  vl_linha := vl_linha || sc_arq.preencher(10, 'AC', ' ', ct_a_esquerda);
  
  --nome do sistema origem
  vl_linha := vl_linha || 'APTARESCAN';
  
  --codigo da empresa no sistema destino
  vl_linha := vl_linha || sc_arq.preencher(4, ct_codigo_empresa, '0', ct_a_direita);
  
  --data do inicio dos lancamentos
  --vl_dt_ref_ini := sc_grl.get_anterior_dia_util(vp_arquivo.dt_rfr_ini_aec);
  vl_linha := vl_linha || to_char(vp_arquivo.dt_rfr_ini_aec, 'YYYYMMDD');
  
  --data final dos lancamentos
  vl_linha := vl_linha || to_char(vp_arquivo.dt_rfr_fin_aec, 'YYYYMMDD');
  
  --comentarios
  vl_linha := vl_linha || sc_arq.preencher(40, 'Arquivo nsu '|| vp_arquivo.cd_aec ||' dtref '|| to_char(vp_arquivo.dt_rfr_ini_aec, 'DD/MM/YYYY'),' ', ct_a_esquerda);
  
  return vl_linha;
end$$;


ALTER FUNCTION sc_ctb.gerar_header_arquivo(vp_arquivo tbl_aec) OWNER TO scan;

--
-- TOC entry 7796 (class 0 OID 0)
-- Dependencies: 1875
-- Name: FUNCTION gerar_header_arquivo(vp_arquivo tbl_aec); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION gerar_header_arquivo(vp_arquivo tbl_aec) IS 'rotina que gera a linha de header do arquivo de exportacao de dados para a contabilidade';


--
-- TOC entry 229 (class 1259 OID 564312)
-- Name: tbl_daec_cpl; Type: TABLE; Schema: sc_ctb; Owner: scan
--

CREATE TABLE tbl_daec_cpl (
    cd_daec_cpl numeric(10,0) NOT NULL,
    cd_daec_lcn numeric(10,0) NOT NULL,
    fg_dcr_daec_cpl character varying(1) NOT NULL,
    nr_seq_daec_cpl numeric(10,0) NOT NULL,
    cnt_daec_cpl character varying(15) NOT NULL,
    est_daec_cpl numeric(4,0) NOT NULL,
    cto_res_daec_cpl numeric(15,0) NOT NULL,
    cd_hst_daec_cpl numeric(10,0) NOT NULL,
    cmp_hst_daec_cpl character varying(40),
    vl_daec_cpl numeric(13,2) NOT NULL,
    ds_cmp_hst_daec_cpl character varying(4000)
);


ALTER TABLE tbl_daec_cpl OWNER TO scan;

--
-- TOC entry 1297 (class 1255 OID 564318)
-- Name: gerar_registro_complementar_lancamento(tbl_daec_cpl); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION gerar_registro_complementar_lancamento(vp_detalhe tbl_daec_cpl) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
  vl_linha text;
  
  ct_a_esquerda constant numeric := 1;
  ct_a_direita constant numeric := 2;
  ct_centralizado constant numeric := 3;
begin
  --Registro de Dados
  vl_linha := '1';
  
  --Identificação do registro
  vl_linha := vl_linha || '0050';
  
  --Crédito ou Débito
  vl_linha := vl_linha || vp_detalhe.fg_dcr_daec_cpl;
  
  --Sequencial
  vl_linha := vl_linha || sc_arq.preencher(10, vp_detalhe.nr_seq_daec_cpl, ' ', ct_a_esquerda);
  
  --Numero da Conta
  vl_linha := vl_linha || sc_arq.preencher(15, vp_detalhe.cnt_daec_cpl, ' ', ct_a_esquerda);

  --Estabelecimento
  vl_linha := vl_linha || sc_arq.preencher(4, vp_detalhe.est_daec_cpl, '0', ct_a_direita);
  
  --Centro de Resultado
--  vl_linha := vl_linha || sc_arq.preencher(15, vp_detalhe.cto_res_daec_cpl, '0', ct_a_direita);
  vl_linha := vl_linha || sc_arq.preencher(15, '001', ' ', ct_a_esquerda);
	
   --Código do Histórico
  vl_linha := vl_linha || sc_arq.preencher(10, '0', ' ', ct_a_esquerda);
  
  --Complemento do Histórico
  if vp_detalhe.ds_cmp_hst_daec_cpl is not null then
    vl_linha := vl_linha || sc_arq.preencher(40, regexp_replace(vp_detalhe.cmp_hst_daec_cpl, E'[\\n\\r]+', ' ', 'g'), ' ', ct_a_esquerda);
  else
    vl_linha := vl_linha || sc_arq.preencher(40, ' ', ' ', ct_a_esquerda);
  end if;

  --Valor total movimentado
  vl_linha := vl_linha || sc_arq.preencher(12, trunc(vp_detalhe.vl_daec_cpl), ' ', ct_a_direita) || '.' || sc_arq.preencher(2, trunc((vp_detalhe.vl_daec_cpl - trunc(vp_detalhe.vl_daec_cpl)) * 100), '0', ct_a_direita);
  
  return vl_linha;
end$$;


ALTER FUNCTION sc_ctb.gerar_registro_complementar_lancamento(vp_detalhe tbl_daec_cpl) OWNER TO scan;

--
-- TOC entry 7797 (class 0 OID 0)
-- Dependencies: 1297
-- Name: FUNCTION gerar_registro_complementar_lancamento(vp_detalhe tbl_daec_cpl); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION gerar_registro_complementar_lancamento(vp_detalhe tbl_daec_cpl) IS 'rotina que gera a linha de registro do complementar do lancamento do arquivo de exportacao de dados para a contabilidade';


--
-- TOC entry 1298 (class 1255 OID 564319)
-- Name: gerar_registro_complemento_historico(character varying, text); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION gerar_registro_complemento_historico(vp_nome_arquivo character varying, vp_complemento_historico text) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_linha text;
  vl_qtd_linha numeric := 0;
  
  ct_a_esquerda constant numeric := 1;
  ct_a_direita constant numeric := 2;
  ct_centralizado constant numeric := 3;

  vl_aux_complemento text;

begin
  
  vl_aux_complemento := regexp_replace(vp_complemento_historico, E'[\\n\\r]+', ' ', 'g');
  vl_linha := '';

  while length(vl_aux_complemento) > 0 loop

     --Registro de dados
     vl_linha := vl_linha || '1';
  
     --Identificador do Registro
     vl_linha := vl_linha || '0041';
  
     --complemento da descricao do historico
     vl_linha := vl_linha || sc_arq.preencher(40, vl_aux_complemento, ' ', ct_a_esquerda);

     --gravando a linha
     perform sc_arq.gravarlinha(vp_nome_arquivo,vl_linha); 

     vl_linha := '';     
     vl_aux_complemento := substr(vl_aux_complemento,41, length(vl_aux_complemento));

     vl_qtd_linha := vl_qtd_linha + 1;

  end loop;

  return vl_qtd_linha;
   
end;$$;


ALTER FUNCTION sc_ctb.gerar_registro_complemento_historico(vp_nome_arquivo character varying, vp_complemento_historico text) OWNER TO scan;

--
-- TOC entry 7798 (class 0 OID 0)
-- Dependencies: 1298
-- Name: FUNCTION gerar_registro_complemento_historico(vp_nome_arquivo character varying, vp_complemento_historico text); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION gerar_registro_complemento_historico(vp_nome_arquivo character varying, vp_complemento_historico text) IS 'rotina que gera a linha de registro de complemento de historico de exportacao de dados para a contabilidade';


--
-- TOC entry 1234 (class 1255 OID 564320)
-- Name: gerar_registro_complemento_historico_complementar_lancamento(character varying, text); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION gerar_registro_complemento_historico_complementar_lancamento(vp_nome_arquivo character varying, vp_complemento_historico text) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_linha text;
  vl_qtd_linha numeric := 0;
  
  ct_a_esquerda constant numeric := 1;
  ct_a_direita constant numeric := 2;
  ct_centralizado constant numeric := 3;

  vl_aux_complemento text;

begin
  
  vl_aux_complemento := regexp_replace(vp_complemento_historico, E'[\\n\\r]+', ' ', 'g');
  vl_linha := '';

  while length(vl_aux_complemento) > 0 loop

     --Registro de dados
     vl_linha := vl_linha || '1';
  
     --Identificador do Registro
     vl_linha := vl_linha || '0051';
  
     --complemento da descricao do historico
     vl_linha := vl_linha || sc_arq.preencher(40, vl_aux_complemento, ' ', ct_a_esquerda);

     --gravando a linha
     perform sc_arq.gravarlinha(vp_nome_arquivo,vl_linha); 

     vl_linha := '';     
     vl_aux_complemento := substr(vl_aux_complemento,41, length(vl_aux_complemento));

     vl_qtd_linha := vl_qtd_linha + 1;

  end loop;

  return vl_qtd_linha;
   
end;$$;


ALTER FUNCTION sc_ctb.gerar_registro_complemento_historico_complementar_lancamento(vp_nome_arquivo character varying, vp_complemento_historico text) OWNER TO scan;

--
-- TOC entry 7799 (class 0 OID 0)
-- Dependencies: 1234
-- Name: FUNCTION gerar_registro_complemento_historico_complementar_lancamento(vp_nome_arquivo character varying, vp_complemento_historico text); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION gerar_registro_complemento_historico_complementar_lancamento(vp_nome_arquivo character varying, vp_complemento_historico text) IS 'rotina que gera a linha de registro de complemento de historico de exportacao de dados para a contabilidade';


--
-- TOC entry 1235 (class 1255 OID 564321)
-- Name: gerar_registro_historico(numeric, text); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION gerar_registro_historico(vp_cod_historico numeric, vp_des_historico text) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
  vl_linha text;
  
  ct_a_esquerda constant numeric := 1;
  ct_a_direita constant numeric := 2;
  ct_centralizado constant numeric := 3;
begin
  --Registro de dados
  vl_linha := '1';
  
  --Identificador do Registro
  vl_linha := vl_linha || '0010';
  
  --codigo do historico
  vl_linha := vl_linha || sc_arq.preencher(10, vp_cod_historico, ' ', ct_a_esquerda);
  
  --descricao do historico
  vl_linha := vl_linha || sc_arq.preencher(40, vp_des_historico, ' ', ct_a_esquerda);
  
    
  return vl_linha;
end$$;


ALTER FUNCTION sc_ctb.gerar_registro_historico(vp_cod_historico numeric, vp_des_historico text) OWNER TO scan;

--
-- TOC entry 7800 (class 0 OID 0)
-- Dependencies: 1235
-- Name: FUNCTION gerar_registro_historico(vp_cod_historico numeric, vp_des_historico text); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION gerar_registro_historico(vp_cod_historico numeric, vp_des_historico text) IS 'rotina que gera a linha de registro de historico de exportacao de dados para a contabilidade';


--
-- TOC entry 230 (class 1259 OID 564322)
-- Name: tbl_daec_lcn; Type: TABLE; Schema: sc_ctb; Owner: scan
--

CREATE TABLE tbl_daec_lcn (
    cd_daec_lcn numeric(10,0) NOT NULL,
    cd_aec numeric(10,0) NOT NULL,
    dt_rfr_daec_lcn date NOT NULL,
    nr_seq_daec_lcn numeric(10,0),
    nr_lote_daec_lcn numeric(10,0),
    vl_daec_lcn numeric(13,2) NOT NULL,
    cd_hst_daec_lcn numeric(10,0) NOT NULL,
    cmp_hst_daec_lcn character varying(40),
    ds_cmp_hst_daec_lcn character varying(4000)
);


ALTER TABLE tbl_daec_lcn OWNER TO scan;

--
-- TOC entry 1299 (class 1255 OID 564328)
-- Name: gerar_registro_lancamento(tbl_daec_lcn); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION gerar_registro_lancamento(vp_detalhe tbl_daec_lcn) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
    vl_linha text;
  
  ct_codigo_empresa constant numeric := 1;
  
  ct_a_esquerda constant numeric := 1;
  ct_a_direita constant numeric := 2;
  ct_centralizado constant numeric := 3;
begin
  --Registro de Dados
  vl_linha := '1';
  
  --Identificação do registro
  vl_linha := vl_linha || '0040';
  
  --Data do fato contabil
  vl_linha := vl_linha || to_char(vp_detalhe.dt_rfr_daec_lcn, 'YYYYMMDD');
  
  --Sequencia do lancamento na data
  vl_linha := vl_linha || sc_arq.preencher(10, vp_detalhe.nr_seq_daec_lcn, '0', ct_a_direita);
  
  --Numero de arquivo
  vl_linha := vl_linha || sc_arq.preencher(10, vp_detalhe.cd_aec, '0', ct_a_direita);
  
  --Numero do lote
  vl_linha := vl_linha || sc_arq.preencher(10, vp_detalhe.nr_lote_daec_lcn, '0', ct_a_direita);
  
  --Valor total movimentado
  vl_linha := vl_linha || sc_arq.preencher(12, trunc(vp_detalhe.vl_daec_lcn), ' ', ct_a_direita) || '.' || sc_arq.preencher(2, trunc((vp_detalhe.vl_daec_lcn - trunc(vp_detalhe.vl_daec_lcn)) * 100), '0', ct_a_direita);
  
  --Código do Histórico
  vl_linha := vl_linha || sc_arq.preencher(10, vp_detalhe.cd_hst_daec_lcn, ' ', ct_a_esquerda);
  
  --Complemento do Histórico
  if vp_detalhe.ds_cmp_hst_daec_lcn is not null then
    vl_linha := vl_linha || sc_arq.preencher(40, regexp_replace(vp_detalhe.cmp_hst_daec_lcn, E'[\\n\\r]+', ' ', 'g'), ' ', ct_a_esquerda);
  else
    vl_linha := vl_linha || sc_arq.preencher(40, ' ', ' ', ct_a_esquerda);
  end if;
  
  return vl_linha;
end$$;


ALTER FUNCTION sc_ctb.gerar_registro_lancamento(vp_detalhe tbl_daec_lcn) OWNER TO scan;

--
-- TOC entry 7801 (class 0 OID 0)
-- Dependencies: 1299
-- Name: FUNCTION gerar_registro_lancamento(vp_detalhe tbl_daec_lcn); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION gerar_registro_lancamento(vp_detalhe tbl_daec_lcn) IS 'rotina que gera a linha de registro de lancamento do arquivo de exportacao de dados para a contabilidade';


--
-- TOC entry 1300 (class 1255 OID 564329)
-- Name: gerar_trailler_arquivo(numeric, numeric); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION gerar_trailler_arquivo(vp_numero_linhas numeric, vp_valor_total numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
    vl_linha text;
  
  ct_a_esquerda constant numeric := 1;
  ct_a_direita constant numeric := 2;
  ct_centralizado constant numeric := 3;
begin
  --Identificacao do registro de trailer
  vl_linha := '9';
  
  --Quantidade de linhas no arquivo (inclusive esta)
  vl_linha := vl_linha || sc_arq.preencher(10, vp_numero_linhas, '0', ct_a_direita);
  
  --Valor total dos lancamentos
  vl_linha := vl_linha || sc_arq.preencher(12, trunc(vp_valor_total), ' ', ct_a_direita) || '.' || sc_arq.preencher(2, trunc((vp_valor_total - trunc(vp_valor_total)) * 100), '0', ct_a_direita);
  
  return vl_linha;
end$$;


ALTER FUNCTION sc_ctb.gerar_trailler_arquivo(vp_numero_linhas numeric, vp_valor_total numeric) OWNER TO scan;

--
-- TOC entry 7802 (class 0 OID 0)
-- Dependencies: 1300
-- Name: FUNCTION gerar_trailler_arquivo(vp_numero_linhas numeric, vp_valor_total numeric); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION gerar_trailler_arquivo(vp_numero_linhas numeric, vp_valor_total numeric) IS 'rotina que gera a linha de registro de trailler do arquivo de exportacao de dados para a contabilidade';


--
-- TOC entry 1301 (class 1255 OID 564330)
-- Name: get_valor_contabilizacao(character varying, public.valor_evento[]); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION get_valor_contabilizacao(vp_nome_valor character varying, vp_valores public.valor_evento[]) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_valor valor_evento;

  indice numeric;
begin
  --raise notice 'procurando pelo valor de nome: %', upper(trim(vp_nome_valor));
  for indice in 1..array_length(vp_valores, 1) loop
    --raise notice 'nome do valor atual: %', vp_valores[indice].nome;
    --raise notice 'valor do valor atual: %', vp_valores[indice].valor;
    if upper(trim(vp_valores[indice].nome)) = upper(trim(vp_nome_valor)) then
      return vp_valores[indice].valor;
    end if;
  end loop;

  return null;
end;$$;


ALTER FUNCTION sc_ctb.get_valor_contabilizacao(vp_nome_valor character varying, vp_valores public.valor_evento[]) OWNER TO scan;

--
-- TOC entry 7803 (class 0 OID 0)
-- Dependencies: 1301
-- Name: FUNCTION get_valor_contabilizacao(vp_nome_valor character varying, vp_valores public.valor_evento[]); Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON FUNCTION get_valor_contabilizacao(vp_nome_valor character varying, vp_valores public.valor_evento[]) IS 'retorna o valor referente a descricao passada como parametros na lista de valores que tambem é passada como parametro';


--
-- TOC entry 1303 (class 1255 OID 564331)
-- Name: limpar_repetidos(numeric); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION limpar_repetidos(vp_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin

delete 
from sc_ctb.tbl_daec_cpl 
where cd_daec_cpl in (
		select c1.cd_daec_cpl
		from sc_ctb.tbl_daec_cpl c1
		  inner join sc_ctb.tbl_daec_lcn l on l.cd_daec_lcn = c1.cd_daec_lcn
		where exists(select 1 
			     from sc_ctb.tbl_daec_cpl c2 
			     where c2.cd_daec_cpl<>c1.cd_daec_cpl 
			       and c1.cd_daec_lcn=c2.cd_daec_lcn 
			       and c1.cnt_daec_cpl = c2.cnt_daec_cpl
			     )
		  and l.cd_aec = vp_arquivo);     

delete 
from sc_ctb.tbl_daec_lcn l
where not exists (select 1 from sc_ctb.tbl_daec_cpl c where c.cd_daec_lcn = l.cd_daec_lcn)
  and l.cd_aec = vp_arquivo;

   
end$$;


ALTER FUNCTION sc_ctb.limpar_repetidos(vp_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1645 (class 1255 OID 934016)
-- Name: popula_contrapartidas(date, date); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION popula_contrapartidas(vp_data_inicial date, vp_data_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   rg record;
   codigo_lancamento numeric;
begin

	   for rg in    select *
			from sc_cnt.tbl_lcn l
			where dt_ref_lcn >= vp_data_inicial
			  and dt_ref_lcn < vp_data_final
			  and cd_ctp_lcn is null
			  and not exists(select 1 from sc_cnt.tbl_lcn where cd_ctp_lcn = l.cd_lcn)
			order by l.cd_lcn  loop

         select cd_lcn
         into codigo_lancamento
         from sc_cnt.tbl_lcn
         where cd_lcn in(rg.cd_lcn + 1,rg.cd_lcn -1)   
           and vl_lcn = rg.vl_lcn
           and nsu_lcn = rg.nsu_lcn
           and cd_sst = rg.cd_sst
           and fg_dcr_lcn <> rg.fg_dcr_lcn;  

        if codigo_lancamento is null then
          raise exception 'nao encontrato para o lancamento nr %', rg.cd_lcn;
        end if;  

        update sc_cnt.tbl_lcn set cd_ctp_lcn = codigo_lancamento where cd_lcn = rg.cd_lcn;   
        update sc_cnt.tbl_lcn set cd_ctp_lcn = rg.cd_lcn where cd_lcn = codigo_lancamento;   

   end loop;            
end$$;


ALTER FUNCTION sc_ctb.popula_contrapartidas(vp_data_inicial date, vp_data_final date) OWNER TO scan;

--
-- TOC entry 1737 (class 1255 OID 1021423)
-- Name: regerar_arquivos_cancelados(); Type: FUNCTION; Schema: sc_ctb; Owner: scan
--

CREATE FUNCTION regerar_arquivos_cancelados() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   rg record;
begin

    for rg in select *
              from sc_ctb.tbl_arq_ctb a
              where dt_arq_ctb >= current_date - interval '10 days'
                and st_arq_ctb = 2
                and not exists(select 1 
                               from sc_ctb.tbl_arq_ctb ac 
                               where ac.dt_arq_ctb = a.dt_arq_ctb 
                                 and ac.st_arq_ctb = 1) 
              order by a.dt_arq_ctb loop

         if date_part('hour', clock_timestamp()) > 4 then
            return;
         end if;

        perform sc_ctb.gerar_arquivo_exportacao_periodo(rg.dt_arq_ctb, (rg.dt_arq_ctb + interval '1 day')::date);

                                 
    end loop;                             

end$$;


ALTER FUNCTION sc_ctb.regerar_arquivos_cancelados() OWNER TO scan;

SET search_path = sc_dgt, pg_catalog;

--
-- TOC entry 1686 (class 1255 OID 996456)
-- Name: enviar_imagens(numeric, numeric); Type: FUNCTION; Schema: sc_dgt; Owner: scan
--

CREATE FUNCTION enviar_imagens(vp_cod_empresa numeric, vp_cpf numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_cun_aux numeric;
  vl_nm_diretorio varchar;
  rg record;
  vl_nm_arquivo varchar;
  vl_arquivos varchar;
  COD_FTP_ANDBANK numeric := 0;
  vl_diretorio_arquivo varchar;
begin

   select vl_prm
   into vl_diretorio_arquivo
   from sc_cad.tbl_prm
   where nm_prm = 'PATH_ARQ_FNC' ;

   vl_cun_aux := 0;
   vl_arquivos := null;
   
   for rg in select distinct cun.nr_cpf_cnpj_cun 
             from sc_dgt.tbl_arq arq
               inner join sc_cad.tbl_fnc fnc on fnc.cd_cun = arq.cd_cun
               inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
             where arq.fg_env_arq = 'N'
               and arq.fg_atv_arq = 'S'
               and (fnc.cd_emp = vp_cod_empresa or vp_cod_empresa is null) loop

  --    select * from dblink('dbname=scan port=5432 host=localhost user=scan password=scan', 'select sc_dgt.enviar_imagens_cpf('||rg.nr_cpf_cnpj_cun||')'	,null) as t(a varchar);
               
      begin
         perform sc_dgt.enviar_imagens_cpf(rg.nr_cpf_cnpj_cun);
         raise notice 'cpf %',rg.nr_cpf_cnpj_cun;
      exception when others then
         raise notice 'ERRO NO CPF %',rg.nr_cpf_cnpj_cun;
      end;   
             
   end loop;


end$$;


ALTER FUNCTION sc_dgt.enviar_imagens(vp_cod_empresa numeric, vp_cpf numeric) OWNER TO scan;

--
-- TOC entry 1687 (class 1255 OID 996455)
-- Name: enviar_imagens_cpf(numeric); Type: FUNCTION; Schema: sc_dgt; Owner: scan
--

CREATE FUNCTION enviar_imagens_cpf(vp_cpf numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_cun_aux numeric;
  vl_nm_diretorio varchar;
  rg record;
  vl_nm_arquivo varchar;
  vl_arquivos varchar;
  COD_FTP_ANDBANK numeric := 0;
  vl_diretorio_arquivo varchar;
begin

   select vl_prm
   into vl_diretorio_arquivo
   from sc_cad.tbl_prm
   where nm_prm = 'PATH_ARQ_FNC' ;

   vl_cun_aux := 0;
   vl_arquivos := null;
   for rg in select *
             from sc_dgt.tbl_arq arq
               inner join sc_cad.tbl_cun cun on cun.cd_cun = arq.cd_cun
               inner join sc_dgt.tbl_tar tar on tar.cd_tar = arq.cd_tar
             where cun.nr_cpf_cnpj_cun = vp_cpf
               and fg_env_arq = 'N'
             order by cun.cd_cun,tar.cd_tar,arq.cd_arq loop

         if vl_cun_aux <> rg.nr_cpf_cnpj_cun then
           vl_cun_aux := rg.nr_cpf_cnpj_cun;   
         end if;

         vl_nm_diretorio := rg.nr_cpf_cnpj_cun;
         vl_nm_arquivo := 'C:\\'||vl_diretorio_arquivo||'\\'||rg.cd_arq||'.'||rg.ex_arq;

         if vl_arquivos is null then
            vl_arquivos := vl_nm_arquivo;
         else
            vl_arquivos := vl_arquivos || '|' ||vl_nm_arquivo;
         end if; 
             
   end loop;
   
   if vl_arquivos is not null then
     perform sc_pbl.enviar_varios_arquivos_ftp(4,vl_nm_diretorio,vl_arquivos);
   end if;
   
     update sc_dgt.tbl_arq
       set fg_env_arq = 'S'
     where cd_arq in(select arq.cd_arq
		     from sc_dgt.tbl_arq arq
		       inner join sc_cad.tbl_cun cun on cun.cd_cun = arq.cd_cun
		       inner join sc_dgt.tbl_tar tar on tar.cd_tar = arq.cd_tar
		     where cun.nr_cpf_cnpj_cun = vp_cpf
		       and fg_env_arq = 'N');   

end$$;


ALTER FUNCTION sc_dgt.enviar_imagens_cpf(vp_cpf numeric) OWNER TO scan;

--
-- TOC entry 1330 (class 1255 OID 996547)
-- Name: informar_digitalizacao(); Type: FUNCTION; Schema: sc_dgt; Owner: scan
--

CREATE FUNCTION informar_digitalizacao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  texto text;
  rg record;
  assunto varchar;
  count numeric := 1;
  vl_qtd_cartao_ativo numeric := 0;
  vl_qtd_cartao_com_imagem numeric := 0;
  vl_qtd_cartao_com_imagem_enviada numeric := 0;
  vl_qtd_cartao_ativo_com_imagem numeric := 0;
  
begin

	texto := '<html xmlns="http://www.w3.org/1999/xhtml">
			<head>
			<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
			<title>DigiSoma</title>

			<style>

			.tabela{
				width: 100%;
				font-family:Arial;
				border:1px solid #999;
				border-collapse: collapse;
			}

			.tabela th{
				background:#03F;
			    color:#FFF;
				text-align:center;
				border:1px solid #999;
			}

			.tabela tr td{
				border:1px solid #999;
			}

			.impar{
				background:#CCC;
			}

			</style>

			</head>

			<body>
			   Emitido em '||to_char(now(),'dd/mm/yyyy hh24:mi:SS')||
			'<table class="tabela">
				<tr>
					<th>Empresa</th>
					<th>Qtd. Cartões Ativos</th>
					<th>Qtd. Cartões Ativos com Imagem</th>
					<th>Qtd. Cartões com Imagem</th>
					<th>Qtd. Cartões com Imagem Enviada</th>
					
			       </tr>';


	for rg in 
		select emp.cd_emp ||' - '||emp.nm_emp empresa,
		       coalesce(crt_atv.q,0) cartoes_ativos,
		       coalesce(crt_atv_img.q,0) cartoes_ativos_com_imagem,
		       coalesce(crt_img.q,0) cartoes_com_imagem,
		       coalesce(img_env.q,0) cartoes_com_imagem_enviada
		from sc_cad.tbl_emp emp
		  inner join (select count(*) as q,
				     fnc.cd_emp 
			      from sc_opr.tbl_crt crt
				inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
			      where crt.fg_atv_crt = 'S' 
			        and crt.dt_ult_dps_crt >= current_date - 90 
			      group by fnc.cd_emp) crt_atv on crt_atv.cd_emp = emp.cd_emp
		  left join (select count(*) q,
				     fnc.cd_emp 
			      from sc_opr.tbl_crt crt
				inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
			      where exists(select 1 from sc_dgt.tbl_arq a where a.cd_cun = fnc.cd_cun and a.fg_atv_arq = 'S' and a.st_arq <> 3)
			        and crt.fg_atv_crt = 'S'
			        and crt.dt_ult_dps_crt >= current_date - 90 
			      group by fnc.cd_emp) crt_atv_img on crt_atv_img.cd_emp = emp.cd_emp
		  left join (select count(*) q,
				     fnc.cd_emp 
			      from sc_opr.tbl_crt crt
				inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
			      where exists(select 1 from sc_dgt.tbl_arq a where a.cd_cun = fnc.cd_cun and a.fg_atv_arq = 'S' and a.st_arq <> 3)
			      group by fnc.cd_emp) crt_img on crt_img.cd_emp = emp.cd_emp
		  left join (select count(*) q,
				     fnc.cd_emp 
			      from sc_opr.tbl_crt crt
				inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
			      where exists(select 1 from sc_dgt.tbl_arq a where a.cd_cun = fnc.cd_cun and a.fg_env_arq = 'S')
			      group by fnc.cd_emp) img_env on img_env.cd_emp = emp.cd_emp
		where exists(select 1
		             from sc_adp.tbl_hfe h
		             where dt_dps_hfe > current_date -90
		             and h.cd_emp = emp.cd_emp)	      
		order by emp.cd_emp loop
		
	  texto := texto || '<tr class="' || case when mod(count,2) = 0 then '' else 'impar' end || '">';
	  texto := texto || '<td>'|| rg.empresa ||'</td>';
	  texto := texto || '<td>'|| rg.cartoes_ativos ||'</td>';
	  texto := texto || '<td>'|| rg.cartoes_ativos_com_imagem ||'</td>';
	  texto := texto || '<td>'|| rg.cartoes_com_imagem ||'</td>';
	  texto := texto || '<td>'|| rg.cartoes_com_imagem_enviada ||'</td>';

	  texto := texto || '</tr>';

	  count := count + 1;
	  vl_qtd_cartao_ativo := vl_qtd_cartao_ativo + rg.cartoes_ativos;
	  vl_qtd_cartao_ativo_com_imagem := vl_qtd_cartao_ativo_com_imagem + rg.cartoes_ativos_com_imagem;
	  vl_qtd_cartao_com_imagem := vl_qtd_cartao_com_imagem + rg.cartoes_com_imagem;
	  vl_qtd_cartao_com_imagem_enviada := vl_qtd_cartao_com_imagem_enviada + rg.cartoes_com_imagem_enviada;
	
     end loop;	

     
     texto := texto || '<tr><td>TOTAL:</td><td>'||vl_qtd_cartao_ativo||'</td><td>'||vl_qtd_cartao_ativo_com_imagem||'</td><td>'||vl_qtd_cartao_com_imagem||'</td><td>'||vl_qtd_cartao_com_imagem_enviada||'</td></tr>';
     texto := texto || '</table></body></html>';

     --raise notice '%',texto;
     assunto := 'Informativo DigiSoma';

     raise notice '%',texto;
     perform sc_pbl.enviar_email_saqpag('tecnologia@somacontadigital.com.br;edliany@somacontadigital.com.br',assunto,texto,null);
     
     
     --perform sc_pbl.enviar_email_saqpag('tecnologia@somacontadigital.com.br',assunto,texto,null);
end$$;


ALTER FUNCTION sc_dgt.informar_digitalizacao() OWNER TO scan;

--
-- TOC entry 1660 (class 1255 OID 988660)
-- Name: informar_digitalizacao_old(); Type: FUNCTION; Schema: sc_dgt; Owner: scan
--

CREATE FUNCTION informar_digitalizacao_old() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  texto text;
  rg record;
  assunto varchar;
  count numeric := 1;
  vl_qtd_total numeric := 0;
begin

	texto := '<html xmlns="http://www.w3.org/1999/xhtml">
			<head>
			<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
			<title>DigiSoma</title>

			<style>

			.tabela{
				width: 100%;
				font-family:Arial;
				border:1px solid #999;
				border-collapse: collapse;
			}

			.tabela th{
				background:#03F;
			    color:#FFF;
				text-align:center;
				border:1px solid #999;
			}

			.tabela tr td{
				border:1px solid #999;
			}

			.impar{
				background:#CCC;
			}

			</style>

			</head>

			<body>
			   Emitido em '||to_char(now(),'dd/mm/yyyy hh24:mi:SS')||
			'<table class="tabela">
				<tr>
					<th>Empresa</th>
					<th>Qtd</th>
			       </tr>';


	for rg in select emp.nm_emp empresa,
		         count(distinct cun.cd_cun) qtd
		from sc_opr.tbl_lmt lmt
		    inner join sc_opr.tbl_crt crt on crt.cd_crt = lmt.cd_crt
		    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
		    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
		    inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
		    inner join sc_cad.tbl_gem gem on gem.cd_gem = emp.cd_gem
		    left join (select a.cd_cun,
				      SUM(CASE WHEN A.ST_ARQ=1 THEN 1 ELSE 0 END) qtd_cdt,
				      SUM(CASE WHEN A.ST_ARQ=2 THEN 1 ELSE 0 END) qtd_vld
			       from sc_dgt.tbl_arq a
			       group by a.cd_cun) arq on arq.cd_cun = fnc.cd_cun 
		where /*crt.fg_atv_crt = 'S'
		  and*/ arq.qtd_cdt > 0     
		group by emp.nm_emp
		having count(distinct cun.cd_cun) > 0
		order by empresa loop
		
	  texto := texto || '<tr class="' || case when mod(count,2) = 0 then '' else 'impar' end || '">';
	  texto := texto || '<td>'|| rg.empresa ||'</td>';
	  texto := texto || '<td>'|| rg.qtd ||'</td>';

	  texto := texto || '</tr>';

	  count := count + 1;
	  vl_qtd_total := vl_qtd_total + rg.qtd; 
	
     end loop;	

     
     texto := texto || '<tr><td>TOTAL:</td><td>'||vl_qtd_total||'</td></tr>';
     texto := texto || '</table></body></html>';

     --raise notice '%',texto;
     assunto := 'Informativo DigiSoma';

     
     perform sc_pbl.enviar_email_saqpag('tecnologia@somacontadigital.com.br;ricardo@somacontadigital.com.br;edliany@somacontadigital.com.br',assunto,texto,null);
     
     
     --perform sc_pbl.enviar_email_saqpag('joaovictor@somacontadigital.com.br;tecnologia@somacontadigital.com.br',assunto,texto,null);
end$$;


ALTER FUNCTION sc_dgt.informar_digitalizacao_old() OWNER TO scan;

SET search_path = sc_dsp, pg_catalog;

--
-- TOC entry 1304 (class 1255 OID 564332)
-- Name: atualiza_disponibilidade_ate_hoje(); Type: FUNCTION; Schema: sc_dsp; Owner: scan
--

CREATE FUNCTION atualiza_disponibilidade_ate_hoje() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   data date;
   
begin

  data := to_date('01-10-2014','dd-mm-yyyy');

 while data < current_date - 1 loop

    perform sc_dsp.processar_variavel(data,11);
    perform sc_dsp.processar_disponibilidade(data);

    data = data + interval '1 day';

 end loop;
 

	


end$$;


ALTER FUNCTION sc_dsp.atualiza_disponibilidade_ate_hoje() OWNER TO scan;

--
-- TOC entry 1841 (class 1255 OID 1651392)
-- Name: dados_avaliacao(numeric, numeric, date); Type: FUNCTION; Schema: sc_dsp; Owner: scan
--

CREATE FUNCTION dados_avaliacao(vp_tipo numeric, vp_gerente numeric, vp_data_referencia date DEFAULT NULL::date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

  vr_retorno numeric;

  vl_dt_ref_inicial date;
  vl_dt_ref_final date;
  vl_variavel_incremento numeric;
  vl_variavel_inativacao numeric;
  
  
begin

  vl_dt_ref_final := coalesce(vp_data_referencia,current_date);

  -- somente retornar resultado dia 10 de cada mes
  if to_char(vl_dt_ref_final,'dd')::numeric <> 10 then
    return null;
  end if;

  vl_dt_ref_inicial := vl_dt_ref_final - interval '1 month' - interval '1 day';

  if vp_tipo = 10 then
    select count(*) 
    from sc_fep.tbl_fep fep 
     into vr_retorno
    where st_fep = 2 
    and exists (select 1 from sc_fep.tbl_pfe where cd_fep = fep.cd_fep and dt_pgt_pfe >= vl_dt_ref_inicial and dt_pgt_pfe < vl_dt_ref_final);
  end if;

  if vp_tipo = 20 then
     
    select --sc_pbl.valor_formato_ptbr(sum(s.vl_ttl_fep_sfe)) as valor, sum(s.qtd_fep_sfe) as qtd
      sum(s.qtd_fep_sfe) as qtd
      into vr_retorno
    from sc_fep.tbl_fep f 
      inner join sc_fep.tbl_fep_sfe s on s.cd_fep = f.cd_fep
      inner join sc_fep.tbl_pfe p on p.cd_fep = f.cd_fep and p.st_pfe = 1
      inner join sc_cad.tbl_ctr c on c.cd_ctr = f.cd_ctr
      inner join sc_cad.tbl_grt g on g.cd_grt = c.cd_grt
      where c.cd_grt = coalesce(vp_gerente,c.cd_grt)
        and s.cd_sfe = 1
        and f.st_fep = 2
        and p.st_pfe= 1
        and p.dt_pgt_pfe = (select max(dt_pgt_pfe) from sc_fep.tbl_pfe where cd_fep = f.cd_fep and st_pfe = 1 and dt_pgt_pfe >= vl_dt_ref_inicial and dt_pgt_pfe < vl_dt_ref_final)
        and p.dt_pgt_pfe >= vl_dt_ref_inicial
        and p.dt_pgt_pfe < vl_dt_ref_final
        and not exists (select 1 from sc_fep.tbl_pfe where cd_fep = f.cd_fep and st_pfe = 1 and cd_tpe = 1 and dt_pgt_pfe >= vl_dt_ref_inicial and dt_pgt_pfe < vl_dt_ref_final);

  end if;

  if vp_tipo = 21 then

    select --sc_pbl.valor_formato_ptbr(sum(s.vl_ttl_fep_sfe)) as valor, sum(s.qtd_fep_sfe) as qtd
      sum(s.vl_ttl_fep_sfe) as valor
      into vr_retorno
    from sc_fep.tbl_fep f 
      inner join sc_fep.tbl_fep_sfe s on s.cd_fep = f.cd_fep
      inner join sc_fep.tbl_pfe p on p.cd_fep = f.cd_fep and p.st_pfe = 1
      inner join sc_cad.tbl_ctr c on c.cd_ctr = f.cd_ctr
      inner join sc_cad.tbl_grt g on g.cd_grt = c.cd_grt
      where c.cd_grt = coalesce(vp_gerente,c.cd_grt)
        and s.cd_sfe = 1
        and f.st_fep = 2
        and p.st_pfe= 1
        and p.dt_pgt_pfe = (select max(dt_pgt_pfe) from sc_fep.tbl_pfe where cd_fep = f.cd_fep and st_pfe = 1 and dt_pgt_pfe >= vl_dt_ref_inicial and dt_pgt_pfe < vl_dt_ref_final)
        and p.dt_pgt_pfe >= vl_dt_ref_inicial
        and p.dt_pgt_pfe < vl_dt_ref_final
        and not exists (select 1 from sc_fep.tbl_pfe where cd_fep = f.cd_fep and st_pfe = 1 and cd_tpe = 1 and dt_pgt_pfe >= vl_dt_ref_inicial and dt_pgt_pfe < vl_dt_ref_final);     

  end if;

  if vp_tipo = 30 then

   select sum(qtd)
    into vr_retorno
    from (
   select g.nm_grt , count(rdp.cd_rdp) as qtd, count(rdp.cd_rdp) * s1.vl_und_fep_sfe as valor
   from sc_adp.tbl_rdp rdp
    inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
    inner join sc_fep.tbl_fep fep on fep.cd_fep = hfe.cd_fep
    inner join sc_fep.tbl_pfe p on p.cd_fep = fep.cd_fep
    inner join sc_fep.tbl_fep_sfe s1 on s1.cd_fep = hfe.cd_fep and s1.cd_emp = hfe.cd_emp and hfe.cd_fem = s1.cd_fem
    inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
    inner join sc_cad.tbl_ctr c on c.cd_ctr = fep.cd_ctr
    inner join sc_cad.tbl_grt g on g.cd_grt = c.cd_grt
   where g.cd_grt = coalesce(vp_gerente,g.cd_grt)
     and hfe.st_hfe = 5
     and rdp.st_rdp = 5
     and rdp.cd_rdp = (select min(cd_rdp) from sc_adp.tbl_rdp where cd_crt = rdp.cd_crt)
     and fep.st_fep = 2
     and rdp.fg_dps_um_dia_rdp = 'S' 
     and s1.cd_sfe = 3 
     and crt.dt_pri_dps_crt::date = hfe.dt_dps_hfe::date
     and p.st_pfe = 1
     and p.dt_pgt_pfe >= vl_dt_ref_inicial
     and p.dt_pgt_pfe < vl_dt_ref_final
     and not exists (select 1 from sc_fep.tbl_pfe where cd_fep = fep.cd_fep and st_pfe = 1 and cd_tpe = 1 and dt_pgt_pfe >= vl_dt_ref_inicial and dt_pgt_pfe < vl_dt_ref_final)
    group by g.nm_grt, s1.vl_und_fep_sfe
   union all
    select g.nm_grt , count(rdp.cd_rdp) as qtd, count(rdp.cd_rdp) * s1.vl_und_fep_sfe as valor
   from sc_adp.tbl_rdp rdp
    inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
    inner join sc_fep.tbl_fep fep on fep.cd_fep = hfe.cd_fep
    inner join sc_fep.tbl_pfe p on p.cd_fep = fep.cd_fep
    inner join sc_fep.tbl_fep_sfe s1 on s1.cd_fep = hfe.cd_fep and s1.cd_emp = hfe.cd_emp and hfe.cd_fem = s1.cd_fem
    inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
    inner join sc_cad.tbl_ctr c on c.cd_ctr = fep.cd_ctr
    inner join sc_cad.tbl_grt g on g.cd_grt = c.cd_grt
   where g.cd_grt = coalesce(vp_gerente,g.cd_grt)
     and hfe.st_hfe = 5
     and rdp.st_rdp = 5
     and fep.st_fep = 2
     and rdp.cd_rdp = (select min(cd_rdp) from sc_adp.tbl_rdp where cd_crt = rdp.cd_crt)
     and rdp.fg_dps_um_dia_rdp = 'N' 
     and s1.cd_sfe = 9 
     and crt.dt_pri_dps_crt::date = hfe.dt_dps_hfe::date
     and p.st_pfe = 1
     and p.dt_pgt_pfe >= vl_dt_ref_inicial
     and p.dt_pgt_pfe < vl_dt_ref_final
     and not exists (select 1 from sc_fep.tbl_pfe where cd_fep = fep.cd_fep and st_pfe = 1 and cd_tpe = 1 and dt_pgt_pfe >= vl_dt_ref_inicial and dt_pgt_pfe < vl_dt_ref_final)
    group by g.nm_grt, s1.vl_und_fep_sfe ) X;

   end if; 

   if vp_tipo = 31 then

   select sum(valor) 
     into vr_retorno
   from (
   select g.nm_grt , count(rdp.cd_rdp) as qtd, count(rdp.cd_rdp) * s1.vl_und_fep_sfe as valor
   from sc_adp.tbl_rdp rdp
    inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
    inner join sc_fep.tbl_fep fep on fep.cd_fep = hfe.cd_fep
    inner join sc_fep.tbl_pfe p on p.cd_fep = fep.cd_fep
    inner join sc_fep.tbl_fep_sfe s1 on s1.cd_fep = hfe.cd_fep and s1.cd_emp = hfe.cd_emp and hfe.cd_fem = s1.cd_fem
    inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
    inner join sc_cad.tbl_ctr c on c.cd_ctr = fep.cd_ctr
    inner join sc_cad.tbl_grt g on g.cd_grt = c.cd_grt
   where g.cd_grt = coalesce(vp_gerente,g.cd_grt)
     and hfe.st_hfe = 5
     and rdp.st_rdp = 5
     and rdp.cd_rdp = (select min(cd_rdp) from sc_adp.tbl_rdp where cd_crt = rdp.cd_crt)
     and fep.st_fep = 2
     and rdp.fg_dps_um_dia_rdp = 'S' 
     and s1.cd_sfe = 3 
     and crt.dt_pri_dps_crt::date = hfe.dt_dps_hfe::date
     and p.st_pfe = 1
     and p.dt_pgt_pfe >= vl_dt_ref_inicial
     and p.dt_pgt_pfe < vl_dt_ref_final
     and not exists (select 1 from sc_fep.tbl_pfe where cd_fep = fep.cd_fep and st_pfe = 1 and cd_tpe = 1 and dt_pgt_pfe >= vl_dt_ref_inicial and dt_pgt_pfe < vl_dt_ref_final)
    group by g.nm_grt, s1.vl_und_fep_sfe
   union all
    select g.nm_grt , count(rdp.cd_rdp) as qtd, count(rdp.cd_rdp) * s1.vl_und_fep_sfe as valor
   from sc_adp.tbl_rdp rdp
    inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
    inner join sc_fep.tbl_fep fep on fep.cd_fep = hfe.cd_fep
    inner join sc_fep.tbl_pfe p on p.cd_fep = fep.cd_fep
    inner join sc_fep.tbl_fep_sfe s1 on s1.cd_fep = hfe.cd_fep and s1.cd_emp = hfe.cd_emp and hfe.cd_fem = s1.cd_fem
    inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
    inner join sc_cad.tbl_ctr c on c.cd_ctr = fep.cd_ctr
    inner join sc_cad.tbl_grt g on g.cd_grt = c.cd_grt
   where g.cd_grt = coalesce(vp_gerente,g.cd_grt)
     and hfe.st_hfe = 5
     and rdp.st_rdp = 5
     and fep.st_fep = 2
     and rdp.cd_rdp = (select min(cd_rdp) from sc_adp.tbl_rdp where cd_crt = rdp.cd_crt)
     and rdp.fg_dps_um_dia_rdp = 'N' 
     and s1.cd_sfe = 9 
     and crt.dt_pri_dps_crt::date = hfe.dt_dps_hfe::date
     and p.st_pfe = 1
     and p.dt_pgt_pfe >= vl_dt_ref_inicial
     and p.dt_pgt_pfe < vl_dt_ref_final
     and not exists (select 1 from sc_fep.tbl_pfe where cd_fep = fep.cd_fep and st_pfe = 1 and cd_tpe = 1 and dt_pgt_pfe >= vl_dt_ref_inicial and dt_pgt_pfe < vl_dt_ref_final)
    group by g.nm_grt, s1.vl_und_fep_sfe ) X;

   end if;  

   if vp_tipo = 40 then
   
   -- BONUS 20
   select count(crt.cd_crt)
     into vr_retorno
    from sc_opr.tbl_crt crt
    inner join sc_srv.tbl_tsc tsc on tsc.cd_crt = crt.cd_crt
    inner join sc_cad.tbl_ctr c on c.cd_ctr = crt.cd_ctr
    inner join sc_cad.tbl_emp e on e.cd_emp = c.cd_emp
    inner join sc_cad.tbl_grt g on g.cd_grt = c.cd_grt
   where g.cd_grt = coalesce(vp_gerente,g.cd_grt)
     and sc_cad.get_pacote_servico_cartao(crt.cd_crt) = 5
     and tsc.cd_srv = 12
     and tsc.st_tsc = 2
     and e.cd_gem not in (249,240,440,216)
     and tsc.dt_pgto_tsc >= vl_dt_ref_inicial
     and tsc.dt_pgto_tsc < vl_dt_ref_final
     and tsc.cd_tsc = (select min(cd_tsc) from sc_srv.tbl_tsc where cd_crt = crt.cd_crt and cd_srv = 12)
     and not exists (select 1 from sc_srv.tbl_tsc where cd_crt = crt.cd_crt and cd_srv = 12 and dt_pgto_tsc < vl_dt_ref_inicial);

   end if;

   if vp_tipo = 41 then
   
   -- BONUS 10
   select count(crt.cd_crt)
     into vr_retorno
   from sc_opr.tbl_crt crt
    inner join sc_srv.tbl_tsc tsc on tsc.cd_crt = crt.cd_crt
    inner join sc_cad.tbl_ctr c on c.cd_ctr = crt.cd_ctr
    inner join sc_cad.tbl_emp e on e.cd_emp = c.cd_emp
    inner join sc_cad.tbl_grt g on g.cd_grt = c.cd_grt
   where g.cd_grt = coalesce(vp_gerente,g.cd_grt)
     and sc_cad.get_pacote_servico_cartao(crt.cd_crt) = 4
     and tsc.cd_srv = 12
     and tsc.st_tsc = 2
     and e.cd_gem not in (249,240,440,216)
     and tsc.dt_pgto_tsc >= vl_dt_ref_inicial
     and tsc.dt_pgto_tsc < vl_dt_ref_final
     and tsc.cd_tsc = (select min(cd_tsc) from sc_srv.tbl_tsc where cd_crt = crt.cd_crt and cd_srv = 12)
     and not exists (select 1 from sc_srv.tbl_tsc where cd_crt = crt.cd_crt and cd_srv = 12 and dt_pgto_tsc < vl_dt_ref_inicial);
   
  end if;

  if vp_tipo = 50 then

  --INCREMENTO DE PRIMEIRO DEPOSITO
    select count(crt.cd_crt)
     into vr_retorno
  from sc_opr.tbl_crt crt
   inner join sc_cad.tbl_ctr c on c.cd_ctr = crt.cd_ctr
   inner join sc_cad.tbl_grt g on g.cd_grt = c.cd_grt
  where g.cd_grt = coalesce(vp_gerente,g.cd_grt)
    and crt.dt_pri_dps_crt >= vl_dt_ref_inicial
    and crt.dt_pri_dps_crt < vl_dt_ref_final;

  end if;

  if vp_tipo = 51 then

  --INATIVACAO APOS PRIMEIRO DEPOSITO
    select count(crt.cd_crt)
      into vr_retorno
      from sc_opr.tbl_ocr o
    inner join sc_opr.tbl_crt crt on crt.cd_crt = o.cd_crt
    inner join sc_cad.tbl_ctr c on c.cd_ctr = crt.cd_ctr
    inner join sc_cad.tbl_grt g on g.cd_grt = c.cd_grt
   where g.cd_grt = coalesce(vp_gerente,g.cd_grt)
     and o.cd_toc = 6 
     and o.dt_inc_usr >= vl_dt_ref_inicial
     and o.dt_inc_usr < vl_dt_ref_final
     and crt.dt_pri_dps_crt is not null;

  end if;

  if vp_tipo = 60 then

    --TOTAL DE INCREMENTO
    if vp_gerente = 3 then
      vl_variavel_incremento := 80;
      vl_variavel_inativacao := 82;
    end if;

    if vp_gerente = 7 then
      vl_variavel_incremento := 81;
      vl_variavel_inativacao := 83;
    end if;
    
    select 
      (select coalesce(vl_fvd::numeric,0) from sc_dsp.tbl_fvd where cd_vds = vl_variavel_incremento and dt_fvd = vl_dt_ref_final)
      -
      (select coalesce(vl_fvd::numeric,0) from sc_dsp.tbl_fvd where cd_vds = vl_variavel_inativacao and dt_fvd = vl_dt_ref_final)
    into vr_retorno;  
  
  end if;

  return vr_retorno;

end$$;


ALTER FUNCTION sc_dsp.dados_avaliacao(vp_tipo numeric, vp_gerente numeric, vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1240 (class 1255 OID 564333)
-- Name: processar_disponibilidade(date); Type: FUNCTION; Schema: sc_dsp; Owner: scan
--

CREATE FUNCTION processar_disponibilidade(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin

   insert into sc_dsp.tbl_dsp values(nextval('sc_dsp.sq_dsp'),vp_data,(select coalesce(sum(case when v.fg_dcr_vds = 'C' then coalesce(f.vl_fvd,0) else coalesce(f.vl_fvd,0)*-1 end),0) 
                                                                      from sc_dsp.tbl_fvd f
                                                                         inner join sc_dsp.tbl_vds v on v.cd_vds = f.cd_vds
                                                                      where f.dt_fvd = vp_data));
end$$;


ALTER FUNCTION sc_dsp.processar_disponibilidade(vp_data date) OWNER TO scan;

--
-- TOC entry 1561 (class 1255 OID 564334)
-- Name: processar_variaveis(date); Type: FUNCTION; Schema: sc_dsp; Owner: scan
--

CREATE FUNCTION processar_variaveis(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_tipo_resultado_variavel_moeda constant numeric := 1;
  ct_tipo_resultado_variavel_numero constant numeric := 2;

  vl_sql varchar;
  rg record;
  vl_sql_insert varchar;
  resultado varchar;
begin

   for rg in select vds.sql_vds,vds.cd_vds, vds.tp_res_vds, mdp.cd_mdp
             from sc_dsp.tbl_vds vds
             inner join sc_dsp.tbl_mdp mdp on mdp.cd_mdp = vds.cd_mdp
             where fg_atv_vds = 'S'
	     order by mdp.col_mdp, mdp.nr_ord_mdp, vds.nr_ord_vds loop

     vl_sql := rg.sql_vds;        
     
     select replace(vl_sql,'?','to_date(''' || to_char(vp_data,'dd/mm/yyyy') || ''',''dd/mm/yyyy'')') into vl_sql;
     delete from sc_dsp.tbl_fvd f where f.cd_vds = rg.cd_vds and f.dt_fvd = vp_data;

     execute vl_sql into resultado;

     if resultado is null then
       resultado := '0';
     end if;

     if rg.cd_mdp in (8,14) then
       resultado := resultado::numeric * 0.95;
     end if;

     if rg.tp_res_vds = ct_tipo_resultado_variavel_moeda then
        resultado := sc_pbl.valor_formato_ptbr(resultado::numeric);
     end if;

     vl_sql_insert := 'insert into sc_dsp.tbl_fvd(cd_fvd,cd_vds,dt_fvd,vl_fvd) values(nextval(''sc_dsp.sq_fvd''),'||rg.cd_vds||',to_date(''' || to_char(vp_data,'dd/mm/yyyy') || ''',''dd/mm/yyyy''),'''|| resultado ||''')';
     execute vl_sql_insert;
             
   end loop;          


end$$;


ALTER FUNCTION sc_dsp.processar_variaveis(vp_data date) OWNER TO scan;

--
-- TOC entry 1831 (class 1255 OID 564335)
-- Name: processar_variavel(date, numeric); Type: FUNCTION; Schema: sc_dsp; Owner: scan
--

CREATE FUNCTION processar_variavel(vp_data date, vp_variavel numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_sql varchar;
  rg record;
  vl_sql_insert varchar;
begin

     select sql_vds into vl_sql         
     from sc_dsp.tbl_vds
     where cd_vds = vp_variavel;
     
     select replace(vl_sql,'?','to_date(''' || to_char(vp_data,'dd/mm/yyyy') || ''',''dd/mm/yyyy'')') into vl_sql;
     
     delete from sc_dsp.tbl_fvd f where f.cd_vds = vp_variavel and f.dt_fvd = vp_data;
     
     vl_sql_insert := 'insert into sc_dsp.tbl_fvd(cd_fvd,cd_vds,dt_fvd,vl_fvd) values(nextval(''sc_dsp.sq_fvd''),'||vp_variavel||',to_date(''' || to_char(vp_data,'dd/mm/yyyy') || ''',''dd/mm/yyyy''),coalesce(('||vl_sql||'),0))';

    
     execute vl_sql_insert;
                      


end$$;


ALTER FUNCTION sc_dsp.processar_variavel(vp_data date, vp_variavel numeric) OWNER TO scan;

SET search_path = sc_fcr, pg_catalog;

--
-- TOC entry 1305 (class 1255 OID 564336)
-- Name: antecipar_fatura(date, numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION antecipar_fatura(vp_data_vencimento date, vp_grupo_empresarial numeric, vp_empresa numeric, vp_filial_empresa numeric, vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg_fcr record;
  vl_cd_fcr numeric;
  vl_sucesso boolean;

begin

  for rg_fcr in select *
                from sc_opr.tbl_crt crt
                  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                  inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                where case when vp_grupo_empresarial is null then true else emp.cd_gem = vp_grupo_empresarial end
                  and case when vp_empresa is null then true else emp.cd_emp = vp_empresa end
                  and case when vp_empresa is null or vp_filial_empresa is null then true else fnc.cd_emp = vp_empresa and fnc.cd_fem = vp_filial_empresa end 
                  and case when vp_cartao is null then true else crt.cd_crt = vp_cartao end loop

    -- gerar fatura
    vl_sucesso := true;
    begin
      perform sc_fcr.gerar_fatura_cartao(rg_fcr.cd_crt, null, null);
    exception when others then
      vl_sucesso := false;
    end;

    if vl_sucesso then
    -- atualizar data de antecipacao
      begin
        select crt.cd_fcr
          into strict vl_cd_fcr
        from sc_opr.tbl_crt crt
          inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
        where crt.cd_crt = rg_fcr.cd_crt
          and fcr.dt_ems_fcr >= current_date;
      exception when others then
        vl_cd_fcr := null;
      end;

      if vl_cd_fcr is not null then
        update sc_fcr.tbl_fcr set
          dt_vnc_fcr = vp_data_vencimento
        where cd_fcr = vl_cd_fcr;
      end if;

    else
      insert into sc_opr.tbl_crt_aux values (rg_fcr.cd_crt);
    end if;

  end loop;

end;$$;


ALTER FUNCTION sc_fcr.antecipar_fatura(vp_data_vencimento date, vp_grupo_empresarial numeric, vp_empresa numeric, vp_filial_empresa numeric, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7804 (class 0 OID 0)
-- Dependencies: 1305
-- Name: FUNCTION antecipar_fatura(vp_data_vencimento date, vp_grupo_empresarial numeric, vp_empresa numeric, vp_filial_empresa numeric, vp_cartao numeric); Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON FUNCTION antecipar_fatura(vp_data_vencimento date, vp_grupo_empresarial numeric, vp_empresa numeric, vp_filial_empresa numeric, vp_cartao numeric) IS 'antecipar fatura';


--
-- TOC entry 1306 (class 1255 OID 564337)
-- Name: atualiza_fatura_operacao(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION atualiza_fatura_operacao(vp_fatura_atual numeric, vp_fatura_anterior numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE

rg_top record;
existe_operacao numeric;
vl_total_pagamento numeric;
vl_restituir numeric;

BEGIN


   --herdar restituicoes anteriores
   if vp_fatura_anterior is not null then	

     insert into sc_fcr.tbl_fcr_top
      select vp_fatura_atual as cd_fcr,
	   cd_top,
	   vl_ttl_fcr_top,
	   vl_rst_fcr_top,
	   vl_rct_fcr_top
      from sc_fcr.tbl_fcr_top	   
     where cd_fcr = vp_fatura_anterior
	and vl_rst_fcr_top > 0;
	
   end if;     

   --inserir novas operacoes ou atualizando existentes
   for rg_top in 

      select opr.cd_top, sum(opr.vl_opr) as total,
          case when cd_top = 5 then 
                 sum(opr.vl_jrs_opr + opr.vl_iof_opr + opr.vl_trf_opr) 
               else
                 sum(opr.vl_opr)
               end 
           as receita      
         from sc_opr.tbl_opr opr
       inner join sc_fcr.tbl_prc prc on prc.cd_opr = opr.cd_opr
     where prc.cd_fcr = vp_fatura_atual   
     group by opr.cd_top 

   loop

      select count(*)
       into existe_operacao
      from sc_fcr.tbl_fcr_top
        where cd_top = rg_top.cd_top
          and cd_fcr = vp_fatura_atual;		

     if existe_operacao > 0 then

	update sc_fcr.tbl_fcr_top 
	   set vl_rst_fcr_top = vl_rst_fcr_top + rg_top.total,
	       vl_ttl_fcr_top = vl_ttl_fcr_top + rg_top.total,
	       vl_rct_fcr_top = vl_rct_fcr_top + rg_top.receita
	 where cd_top = rg_top.cd_top 
	   and cd_fcr = vp_fatura_atual;
	
     else

	insert into sc_fcr.tbl_fcr_top (cd_fcr,cd_top,vl_ttl_fcr_top,vl_rst_fcr_top,vl_rct_fcr_top)
	values (vp_fatura_atual,rg_top.cd_top,rg_top.total,rg_top.total,rg_top.receita);

     end if;	


   end loop;

   --atualizando conforme pagamentos

   vl_total_pagamento := 0;


   select coalesce(sum(vl_pfc),0)
    into vl_total_pagamento
   from sc_fcr.tbl_pfc
    where cd_fcr = vp_fatura_atual
      and st_pfc = 1;

   if vl_total_pagamento > 0 then

   for rg_top in
     select * 
       from sc_fcr.tbl_fcr_top
     where cd_fcr = vp_fatura_atual
     order by cd_top
   loop     

     if vl_total_pagamento > 0 then

       if vl_total_pagamento >= rg_top.vl_rst_fcr_top then

          vl_restituir = rg_top.vl_rst_fcr_top;

       else

          vl_restituir = vl_total_pagamento;
          
       end if;

       update sc_fcr.tbl_fcr_top 
            set vl_rst_fcr_top = vl_rst_fcr_top - vl_restituir
            where cd_fcr = rg_top.cd_fcr
              and cd_top = rg_top.cd_top;

        vl_total_pagamento := vl_total_pagamento - vl_restituir;
     else

       exit;       	

     end if;

   		
   end loop;
	
   
   end if;   
 
END;

$$;


ALTER FUNCTION sc_fcr.atualiza_fatura_operacao(vp_fatura_atual numeric, vp_fatura_anterior numeric) OWNER TO scan;

--
-- TOC entry 1307 (class 1255 OID 564338)
-- Name: calcula_dias_atraso_cartao(date, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION calcula_dias_atraso_cartao(OUT nr_dias_atraso numeric, vp_data_referencia date, vp_cartao numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$DECLARE

BEGIN

  begin  
   select vp_data_referencia - dt_ini_atr_crt
      into nr_dias_atraso
     from sc_opr.tbl_crt
       where cd_crt = vp_cartao
         and fg_ind_crt = 'S';  

  exception when others then
    nr_dias_atraso := 0;
  end;

  nr_dias_atraso := coalesce(nr_dias_atraso,0);

END;$$;


ALTER FUNCTION sc_fcr.calcula_dias_atraso_cartao(OUT nr_dias_atraso numeric, vp_data_referencia date, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7805 (class 0 OID 0)
-- Dependencies: 1307
-- Name: FUNCTION calcula_dias_atraso_cartao(OUT nr_dias_atraso numeric, vp_data_referencia date, vp_cartao numeric); Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON FUNCTION calcula_dias_atraso_cartao(OUT nr_dias_atraso numeric, vp_data_referencia date, vp_cartao numeric) IS 'funcao que calcula o numero de dias de atraso do cartao tendo como referencia uma data passada como parametro';


--
-- TOC entry 1659 (class 1255 OID 933058)
-- Name: calcula_valor_alterar_vencimento(numeric, date); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION calcula_valor_alterar_vencimento(vp_codigo numeric, vp_data_vencimento date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_total_encargos numeric := 0;
  vl_data_vencimento date;
  rg record;
  vl_atual_fatura numeric;

  vl_maximo_dias_apos_vencimento numeric := 15;
  vl_maximo_vencimento date;
begin

    select dt_vnc_fcr,vl_sld_dvd_fcr
    into vl_data_vencimento,vl_atual_fatura
    from sc_fcr.tbl_fcr
    where cd_fcr = vp_codigo;

    vl_maximo_vencimento := vl_data_vencimento + interval '1 day' * vl_maximo_dias_apos_vencimento;

    if vp_data_vencimento <= vl_data_vencimento then
       raise exception 'A Fatura só pode ser prorrogada para uma data maior do que a atual.';
    end if;

    if vp_data_vencimento >  vl_maximo_vencimento then
       raise exception 'A Fatura só pode ser prorrogada para no máximo 15 dias após o vencimento.';  
    end if;

    for rg in select cd_ccb
	      from sc_ccb.tbl_ccb ccb
	         inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
	         inner join sc_fcr.tbl_prc prc on prc.cd_opr = opr.cd_opr
	      where prc.cd_fcr_atu_prc = vp_codigo
	        and ccb.dt_vnc_ccb <= vp_data_vencimento loop

	vl_total_encargos := vl_total_encargos + sc_ccb.simular_prorrogacao_ccb(rg.cd_ccb, vp_data_vencimento + 3);
	  
    end loop;	         

    
   return vl_atual_fatura + vl_total_encargos;
   
end$$;


ALTER FUNCTION sc_fcr.calcula_valor_alterar_vencimento(vp_codigo numeric, vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 1584 (class 1255 OID 564339)
-- Name: calcular_juros(numeric, numeric, date); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION calcular_juros(vp_cartao numeric, vp_fatura numeric, vp_dt_novo_vencimento date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare

  vl_saldo_devedor sc_fcr.tbl_fcr.vl_sld_dvd_fcr%type := 0;
  vl_juros numeric(13,2) := 0;
  
  vl_total_pagamento numeric(13,2);
  vl_data_vencimento date;
  vl_dt_aux date;
  vl_pagamento_minimo sc_fcr.tbl_fcr.vl_mnm_fcr%type;
  vl_nr_dias numeric(5);
  vl_perentual_juros numeric(13,2);

  TP_OPERACAO_JUROS_MORA sc_opr.tbl_top.cd_top%type := 7;
begin

  -- Obtendo os dados da fatura atual
  select fcr.dt_vnc_fcr,
         --fcr.vl_fcr,
         fcr.vl_mnm_fcr
  into vl_data_vencimento,
       --vl_saldo_devedor,
       vl_pagamento_minimo       
  from sc_fcr.tbl_fcr fcr
  where fcr.cd_fcr = vp_fatura
    and fcr.st_fcr not in (3,4,5);

  -- Obtendo o valor de pagamento total até a data de vencimento da fatura
  select COALESCE(sum(pfc.vl_pfc),0)
  into vl_total_pagamento
  from sc_fcr.tbl_pfc pfc
  where pfc.cd_fcr = vp_fatura
    and pfc.st_pfc = 1 
    and pfc.dt_pgt_pfc <= vl_data_vencimento;


  -- obtendo o saldo devedor
  -- devido a CCB as operacaoes de saque extra tem calculo diferente
  select coalesce(sum(prc.vl_prc - coalesce(prc.vl_pgt_prc,0)),0)
   into vl_saldo_devedor
   from sc_fcr.tbl_prc prc 
   inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
  where prc.cd_fcr_atu_prc = vp_fatura   
   and prc.st_prc = 2
   AND opr.cd_top <> 5; -- diferente de saque extra alteracao CCB
   

  -- Só sera cobrado juros de mora se o cliente nao estiver efetuado o pagamento acima ou igual ao mínimo até a data de vencimento
  if (vl_total_pagamento < vl_pagamento_minimo) then 

     -- Obtendo o percentual de juros de acordo com a tabela de tarifas do cartao
     select (dtv.vl_dtv)
     into vl_perentual_juros
     from sc_opr.tbl_dtv dtv
        inner join sc_opr.tbl_crt crt on crt.cd_tvt = dtv.cd_tvt
     where dtv.cd_top = TP_OPERACAO_JUROS_MORA
       and crt.cd_crt = vp_cartao;
  
     vl_saldo_devedor := vl_saldo_devedor - vl_total_pagamento;
     

     -- Para cada pagamento efetuado na fatura será calculado juros sobre o intervalo de dias entre um pagamento e outro
     -- até a data do novo vencimento
     while vl_saldo_devedor > 0 and vl_data_vencimento < vp_dt_novo_vencimento loop

       vl_dt_aux := vl_data_vencimento;
       
       select min(pfc.dt_pgt_pfc)
       into vl_data_vencimento
       from sc_fcr.tbl_pfc pfc
       where pfc.dt_pgt_pfc > vl_data_vencimento
         and pfc.st_pfc = 1
         and pfc.cd_fcr = vp_fatura;
         
       if (vl_data_vencimento is not null) then
       
          select COALESCE(sum(pfc.vl_pfc),0)
          into vl_total_pagamento
          from sc_fcr.tbl_pfc pfc
          where pfc.dt_pgt_pfc = vl_data_vencimento
            and pfc.st_pfc = 1
            and pfc.cd_Fcr = vp_fatura;
            
       else
       
         vl_data_vencimento := vp_dt_novo_vencimento;
         
       end if;     
 	
       vl_nr_dias := vl_data_vencimento - vl_dt_aux; 

       -- Calculo do Juros no período
       vl_juros := vl_juros + (vl_nr_dias / 30) * vl_saldo_devedor * (vl_perentual_juros / 100);
       
       vl_saldo_devedor := vl_saldo_devedor - vl_total_pagamento;
         
     end loop;

     return vl_juros;
     
  else
  
    return 0;
    
  end if;
  
end
$$;


ALTER FUNCTION sc_fcr.calcular_juros(vp_cartao numeric, vp_fatura numeric, vp_dt_novo_vencimento date) OWNER TO scan;

--
-- TOC entry 1311 (class 1255 OID 564340)
-- Name: calcular_multa(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION calcular_multa(vp_cartao numeric, vp_fatura_atual numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare

   TP_OPERACAO_MULTA sc_opr.tbl_opr.cd_top%type := 6;

   vl_multa sc_opr.tbl_opr.vl_opr%type := 0;
   vl_prc_multa sc_opr.tbl_dtv.vl_dtv%type := 0;
   vl_plastico sc_opr.tbl_pls.cd_pls%type;
   vl_minimo sc_fcr.tbl_fcr.vl_mnm_fcr%type;
   vl_dt_vencimento sc_fcr.tbl_fcr.dt_vnc_fcr%type;
   vl_cod_operacao sc_opr.tbl_opr.cd_opr%type;
   vl_total_pagamento sc_fcr.tbl_pfc.vl_pfc%type;
   vl_fatura sc_fcr.tbl_fcr.vl_fcr%type;
   vl_saldo_devedor sc_fcr.tbl_fcr.vl_sld_dvd_fcr%type;
   
begin

  -- Obtendo informacoes sobre a fatura atual
  select fcr.dt_vnc_fcr,
         fcr.vl_mnm_fcr,
         fcr.vl_fcr
  into vl_dt_vencimento,
       vl_minimo,
       vl_fatura 
  from sc_fcr.tbl_fcr fcr
  where cd_fcr = vp_fatura_atual
    and st_fcr not in (3,4,5);

  -- Obtendo o valor total de pagamento efetuados até a data de vencimento
  select COALESCE(sum(pfc.vl_pfc),0)
  into vl_total_pagamento
  from sc_fcr.tbl_pfc pfc
  where pfc.cd_fcr = vp_fatura_atual
    and pfc.dt_pgt_pfc <= vl_dt_vencimento
    and pfc.st_pfc = 1;


 -- obtendo o saldo devedor
  -- devido a CCB as operacaoes de saque extra tem calculo diferente
  select coalesce(sum(prc.vl_prc - coalesce(prc.vl_pgt_prc,0)),0)
   into vl_saldo_devedor
   from sc_fcr.tbl_prc prc 
   inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
  where prc.cd_fcr_atu_prc = vp_fatura_atual   
   and prc.st_prc = 2
   AND opr.cd_top <> 5; -- diferente de saque extra alteracao CCB
   

  -- Verificando se o valor do pagamento até a data de vencimento é menor que o valor mínimo 
  if( vl_total_pagamento < vl_minimo ) then

    vl_saldo_devedor := vl_saldo_devedor - vl_total_pagamento;
  
    select dtv.vl_dtv
    into vl_prc_multa
    from sc_opr.tbl_dtv dtv
       inner join sc_opr.tbl_crt crt on crt.cd_tvt = dtv.cd_tvt
    where dtv.cd_top = TP_OPERACAO_MULTA
      and crt.cd_crt = vp_cartao;

    vl_multa := vl_saldo_devedor * (vl_prc_multa / 100);
    
    return vl_multa;
    	     
  else
  
    return 0;  
    
  end if;    


end
$$;


ALTER FUNCTION sc_fcr.calcular_multa(vp_cartao numeric, vp_fatura_atual numeric) OWNER TO scan;

--
-- TOC entry 1309 (class 1255 OID 564341)
-- Name: cancelar_fatura(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION cancelar_fatura(vp_fatura numeric, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_st_pgto_cadastrado numeric := 1;
ct_st_parcela_a_faturar numeric := 1;
ct_st_parcela_faturado numeric := 2;
ct_st_parcela_cancelada numeric := 3; 

ct_tipo_operacao_multa_fatura numeric := 6;
ct_tipo_operacao_juros_fatura numeric := 7;

ct_st_fatura_aberta numeric := 1; 
ct_st_fatura_cancelada numeric := 3; 

vl_cartao numeric;
vl_fatura_anterior numeric;
rg_pgto record;
vl_saldo_devedor_fatura_anterior numeric;

begin

  -- chama rotina de cancelar os pagamentos
  for rg_pgto in select cd_pfc 
                 from sc_fcr.tbl_pfc
                 where cd_fcr = vp_fatura
                   and st_pfc = ct_st_pgto_cadastrado loop

       perform sc_fcr.estorno_pagamento(rg_pgto.cd_pfc, vp_usuario);

  end loop;

  -- cancelando as parcelas de juros e multa 
  update sc_fcr.tbl_prc set cd_fcr = null, st_prc = ct_st_parcela_cancelada 
   where cd_fcr = vp_fatura
     and st_prc = ct_st_parcela_faturado
     and cd_opr in (select prc.cd_opr 
                      from sc_fcr.tbl_prc prc
                      inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr   
                        where prc.cd_fcr = vp_fatura
                          and opr.cd_top in (ct_tipo_operacao_multa_fatura,ct_tipo_operacao_juros_fatura));

  -- alterando a situacao das demais parcelas
  update sc_fcr.tbl_prc set cd_fcr = null, st_prc = ct_st_parcela_a_faturar 
   where cd_fcr = vp_fatura
     and st_prc = ct_st_parcela_faturado;

  -- cancelando a fatura
  update sc_fcr.tbl_fcr 
    set st_fcr = ct_st_fatura_cancelada,
        dt_ult_pgt_fcr = null,
        cd_ant_fcr = null
  where cd_fcr = vp_fatura;    

  -- atualizando a ultima fatura
  select fcr.cd_crt
    into vl_cartao
  from sc_fcr.tbl_fcr fcr
  where fcr.cd_fcr = vp_fatura;

  begin
    select max(fcr.cd_fcr)
      into vl_fatura_anterior
    from sc_fcr.tbl_fcr fcr
    where fcr.cd_fcr <> vp_fatura
      and fcr.cd_crt = vl_cartao
      and fcr.st_fcr not in (3,4,5);
  exception when others then
    vl_fatura_anterior := null;
  end;

  if vl_fatura_anterior is not null then
    select vl_sld_dvd_fcr
      into vl_saldo_devedor_fatura_anterior
    from sc_fcr.tbl_fcr fcr 
    where fcr.cd_fcr = vl_fatura_anterior;

    if vl_saldo_devedor_fatura_anterior > 0 then
      update sc_fcr.tbl_fcr set 
        st_fcr = ct_st_fatura_aberta
      where cd_fcr = vl_fatura_anterior;
    end if;
  end if;

  update sc_opr.tbl_crt set 
    cd_fcr = vl_fatura_anterior 
  where cd_crt = vl_cartao;

end;$$;


ALTER FUNCTION sc_fcr.cancelar_fatura(vp_fatura numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 7806 (class 0 OID 0)
-- Dependencies: 1309
-- Name: FUNCTION cancelar_fatura(vp_fatura numeric, vp_usuario numeric); Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON FUNCTION cancelar_fatura(vp_fatura numeric, vp_usuario numeric) IS 'rotina que cancela uma fatura de cartao';


--
-- TOC entry 1312 (class 1255 OID 564342)
-- Name: carga_atualiza_fatura_operacao(); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION carga_atualiza_fatura_operacao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg_crt record;
rg_fcr record;

begin


for rg_crt in
  select cd_crt 
   from sc_opr.tbl_crt crt
     where exists (select 1 from sc_fcr.tbl_fcr where cd_crt = crt.cd_crt)
  order by cd_crt
loop     


  for rg_fcr in
   select fcr.cd_fcr as fatura_atual, fcr.cd_ant_fcr as fatura_anterior
     from sc_fcr.tbl_fcr fcr
   where fcr.cd_crt = rg_crt.cd_crt
   order by fcr.cd_fcr 
  loop

   perform sc_fcr.atualiza_fatura_operacao(rg_fcr.fatura_atual,rg_fcr.fatura_anterior);

  end loop;    
end loop;

end;$$;


ALTER FUNCTION sc_fcr.carga_atualiza_fatura_operacao() OWNER TO scan;

--
-- TOC entry 1313 (class 1255 OID 564343)
-- Name: carga_inicial_tad_tmc(); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION carga_inicial_tad_tmc() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_top_tmc numeric := 13;
  ct_top_tad numeric := 14; 

  rg_tmc record;
  rg_tad record;
  vl_opr numeric;
  vl_plastico numeric;
  vl_fatura numeric;
  vl_valor_tmc numeric;
  vl_valor_tad numeric;
  vl_data_emissao timestamp := to_date('25/05/2012','dd/mm/yyyy');
  vl_data_vencimento timestamp := to_date('30/05/2012','dd/mm/yyyy');

begin

  -- atualizar tmc
  for rg_tmc in select distinct crt.cd_crt as cartao, pce_ctr.vl_pce_ctr as valor, pce.nm_pce as nome_parametro
                from sc_cad.tbl_pce_ctr pce_ctr
                  inner join sc_cad.tbl_pce pce on pce.cd_pce = pce_ctr.cd_pce
                  inner join sc_cad.tbl_fem_ctr fem_ctr on fem_ctr.cd_ctr = pce_ctr.cd_ctr
                  inner join sc_opr.tbl_crt crt on crt.cd_ctr = pce_ctr.cd_ctr
                  inner join sc_adp.tbl_rdp rdp on rdp.cd_crt = crt.cd_crt
                  inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe and hfe.st_hfe = 5
                where pce_ctr.cd_pce in (15) 
                  and pce_ctr.vl_pce_ctr <> '0,00'
                   and fem_ctr.fg_atv_fem_ctr = 'S' loop

    select cd_pls
      into vl_plastico
    from sc_opr.tbl_pls pls
    where cd_crt = rg_tmc.cartao 
      and pls.dt_inc_usr = (select max(dt_inc_usr)
                            from sc_opr.tbl_pls
                            where cd_crt = rg_tmc.cartao);

    begin
      select fcr.cd_fcr 
        into strict vl_fatura
      from sc_fcr.tbl_fcr fcr
      where fcr.st_fcr = 1 -- aberta
        and fcr.cd_crt = rg_tmc.cartao;
    exception when others then
      vl_fatura := 0;
    end;

    vl_valor_tmc := replace((replace(rg_tmc.valor, '.','')), ',','.');

    if vl_fatura = 0 then
      select nextval('sc_fcr.sq_fcr') into vl_fatura;

      insert into sc_fcr.tbl_fcr(cd_fcr, cd_crt, vl_fcr, dt_vnc_fcr, vl_sld_dvd_fcr, dt_ems_fcr, st_fcr, nr_dia_atr_fcr,
                                 vl_jrs_fcr, vl_trf_fcr, vl_mlt_fcr, vl_rst_enc_fcr, vl_mnm_fcr) 
        values(vl_fatura, rg_tmc.cartao, vl_valor_tmc, vl_data_vencimento, vl_valor_tmc, vl_data_emissao, 1, 0, 
              0, vl_valor_tmc, 0, 0, 0);
    else
      update sc_fcr.tbl_fcr set
        vl_trf_fcr = coalesce(vl_trf_fcr, 0) + vl_valor_tmc,
        vl_fcr = coalesce(vl_fcr, 0) + vl_valor_tmc,
        vl_sld_dvd_fcr = coalesce(vl_sld_dvd_fcr, 0) + vl_valor_tmc
      where cd_fcr = vl_fatura;
    end if;

    select nextval('sc_opr.sq_opr') into vl_opr;
    
    insert into sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, vl_trf_opr,
                               nr_nsu_org_opr, nr_prc_opr, vl_prc_opr, vl_iof_opr, st_opr,dt_prc_opr)
             values(vl_opr, ct_top_tmc, vl_plastico, null, vl_data_emissao, vl_valor_tmc, 0, 0, 
                    vl_fatura, 1, vl_valor_tmc, 0, 2, null);

    insert into sc_fcr.tbl_prc(cd_prc, cd_crt, cd_fcr, vl_prc, fg_dcr_prc, st_prc,
                               cd_opr, ds_prc, dt_vnc_prc, dt_grc_prc)
      values(nextval('sc_fcr.sq_prc'), rg_tmc.cartao, vl_fatura, vl_valor_tmc, 'D', 2,
             vl_opr, rg_tmc.nome_parametro, vl_data_vencimento, vl_data_emissao);

  end loop;

  for rg_tad in select distinct crt.cd_crt as cartao, pce_ctr.vl_pce_ctr as valor, pce.nm_pce as nome_parametro
                from sc_cad.tbl_pce_ctr pce_ctr
                  inner join sc_cad.tbl_pce pce on pce.cd_pce = pce_ctr.cd_pce
                  inner join sc_cad.tbl_fem_ctr fem_ctr on fem_ctr.cd_ctr = pce_ctr.cd_ctr
                  inner join sc_opr.tbl_crt crt on crt.cd_ctr = pce_ctr.cd_ctr
                  inner join sc_opr.tbl_pls pls on pls.cd_crt = crt.cd_crt
                  inner join sc_opr.tbl_opr opr on opr.cd_pls = pls.cd_pls
                where pce_ctr.cd_pce in (14)
                  and opr.cd_top = 5
                  and opr.st_opr = 2
                  and pce_ctr.vl_pce_ctr <> '0,00'
                  and fem_ctr.fg_atv_fem_ctr = 'S' loop

    select cd_pls
      into vl_plastico
    from sc_opr.tbl_pls pls
    where cd_crt = rg_tad.cartao 
      and pls.dt_inc_usr = (select max(dt_inc_usr)
                            from sc_opr.tbl_pls
                            where cd_crt = rg_tad.cartao);

    begin
      select fcr.cd_fcr 
        into strict vl_fatura
      from sc_fcr.tbl_fcr fcr
      where fcr.st_fcr = 1 -- aberta
        and fcr.cd_crt = rg_tmc.cartao;
    exception when others then
      vl_fatura := 0;
    end;

    vl_valor_tad := replace((replace(rg_tad.valor, '.','')), ',','.');

    if vl_fatura = 0 then
      select nextval('sc_fcr.sq_fcr') into vl_fatura;

      insert into sc_fcr.tbl_fcr(cd_fcr, cd_crt, vl_fcr, dt_vnc_fcr, vl_sld_dvd_fcr, dt_ems_fcr, st_fcr, nr_dia_atr_fcr,
                                 vl_jrs_fcr, vl_trf_fcr, vl_mlt_fcr, vl_rst_enc_fcr, vl_mnm_fcr) 
        values(vl_fatura, rg_tad.cartao, vl_valor_tad, vl_data_vencimento, vl_valor_tad, vl_data_emissao, 1, 0, 
              0, vl_valor_tad, 0, 0, 0);
    else
      update sc_fcr.tbl_fcr set
        vl_trf_fcr = coalesce(vl_trf_fcr, 0) + vl_valor_tad,
        vl_fcr = coalesce(vl_fcr, 0) + vl_valor_tad,
        vl_sld_dvd_fcr = coalesce(vl_sld_dvd_fcr, 0) + vl_valor_tad
      where cd_fcr = vl_fatura;
    end if;

    select nextval('sc_opr.sq_opr') into vl_opr;
    
    insert into sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, vl_trf_opr,
                               nr_nsu_org_opr, nr_prc_opr, vl_prc_opr, vl_iof_opr, st_opr,dt_prc_opr)
             values(vl_opr, ct_top_tad, vl_plastico, null, vl_data_emissao, vl_valor_tad, 0, 0, 
                    vl_fatura, 1, vl_valor_tad, 0, 2, null);

    insert into sc_fcr.tbl_prc(cd_prc, cd_crt, cd_fcr, vl_prc, fg_dcr_prc, st_prc,
                               cd_opr, ds_prc, dt_vnc_prc, dt_grc_prc)
      values(nextval('sc_fcr.sq_prc'), rg_tmc.cartao, vl_fatura, vl_valor_tad, 'D', 2,
             vl_opr, rg_tad.nome_parametro, vl_data_vencimento, vl_data_emissao);

  end loop;

end;$$;


ALTER FUNCTION sc_fcr.carga_inicial_tad_tmc() OWNER TO scan;

--
-- TOC entry 1314 (class 1255 OID 564344)
-- Name: cobrar_cartao(); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION cobrar_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

begin

perform sc_fcr.cobrar_fatura_cartao();
perform sc_srv.cobrar_tarifa_servico(current_date);

end;$$;


ALTER FUNCTION sc_fcr.cobrar_cartao() OWNER TO scan;

--
-- TOC entry 1336 (class 1255 OID 564345)
-- Name: cobrar_fatura_cartao(); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION cobrar_fatura_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$

DECLARE
  rg record;
 
  CT_PARAM_DEBITA_ANTES_VENCIMENTO constant numeric := 47;
BEGIN
  for rg in select fcr.vl_sld_dvd_fcr AS saldo_devedor, cnt.vl_sld_cnt AS saldo_conta, 
                   crt.cd_crt AS cartao, fcr.dt_vnc_fcr AS data_vencimento,
                   coalesce(sc_cad.get_parametro_contrato(CT_PARAM_DEBITA_ANTES_VENCIMENTO, crt.cd_ctr, fnc.cd_fem), 'SIM') AS debita_antes_venc
	         from sc_opr.tbl_crt crt
		           inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
		           inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = fcr.cd_crt and cnt_crt.prp_cnt_crt = 1
		           inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
		           inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
	         where fcr.vl_sld_dvd_fcr > 0
		        and cnt.vl_sld_cnt > 0
		        and fcr.st_fcr = 1
		        --and crt.cd_crt in (62015583042671)
		        --and fcr.dt_vnc_fcr <= current_date
  loop    
  
	   if not sc_cbe.existe_acordo_vigente(1, rg.cartao) AND (rg.debita_antes_venc = 'SIM' OR rg.data_vencimento <= current_date) then

	      begin
	         perform sc_fcr.efetuar_baixa_cartao(rg.cartao,null,1,now()::timestamp,1,null,false);
	      exception when others then
	         perform sc_pbl.enviar_email_saqpag('tecnologia@somacontadigital.com.br','ALERTA','PROBLEMA NO JOB DE COBRAR CARTAO: '||rg.cartao,null);
	      end;  

	   end if;  

   end loop;

END;
$$;


ALTER FUNCTION sc_fcr.cobrar_fatura_cartao() OWNER TO scan;

--
-- TOC entry 1315 (class 1255 OID 564346)
-- Name: cobrar_juros(numeric, numeric, numeric, date); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION cobrar_juros(vp_cartao numeric, vp_cod_fatura_atual numeric, vp_cod_nova_fatura numeric, vp_data_vencimento date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE

  TP_OPERACAO_JUROS sc_opr.tbl_top.cd_top%type := 7;
  
  vl_cod_operacao sc_opr.tbl_opr.cd_opr%type;  
  vl_nm_operacao sc_opr.tbl_top.nm_top%type;
  vl_juros sc_opr.tbl_opr.vl_opr%type := 0;
  vl_plastico sc_opr.tbl_pls.cd_pls%type;
  
BEGIN
   
   
  if sc_fcr.eh_pra_cobrar_juros_multa(vp_cod_fatura_atual) then 
    
     vl_juros := sc_fcr.calcular_juros(vp_cartao, 
                                       vp_cod_fatura_atual, 
                                       vp_data_vencimento);
     
     if vl_juros > 0 then
     
        -- Obtendo o numero do plastico para gravar a operacao
        select cd_pls
        into vl_plastico
        from sc_opr.tbl_pls pls
        where cd_crt = vp_cartao 
          and pls.dt_inc_usr = (select max(dt_inc_usr)
                                from sc_opr.tbl_pls
                                where cd_crt = vp_cartao);
        
        -- Obtendo numero da proxima operacao
        select nextval('sc_opr.sq_opr') 
        into vl_cod_operacao;
		
        -- Obtendo descricao a ser exibida na parcela
        select top.nm_top
        into vl_nm_operacao
        from sc_opr.tbl_top top
        where top.cd_top = TP_OPERACAO_JUROS;
     
        -- Gravando operacao de Juros
        insert into sc_opr.tbl_opr(cd_opr,cd_top,cd_pls,cd_atm,dt_opr,vl_opr,vl_jrs_opr,vl_trf_opr,
                       nr_nsu_org_opr,nr_prc_opr,vl_prc_opr,vl_iof_opr,st_opr,dt_prc_opr)
             values(vl_cod_operacao,TP_OPERACAO_JUROS,vl_plastico,null,now(),vl_juros,0,0,vp_cod_fatura_atual,1,vl_juros,0,2,null);
    		     
    		     
        -- Gravando parcela referente a operacao de multa
        insert into sc_fcr.tbl_prc(cd_prc,
                                   cd_crt,
                                   cd_fcr,
                                   vl_prc,
                                   fg_dcr_prc,
                                   st_prc,
                                   cd_opr,
                                   ds_prc,
                                   dt_vnc_prc,
                                   dt_grc_prc,
                                   cd_fcr_atu_prc)
              values(nextval('sc_fcr.sq_prc'),
                     vp_cartao,
                     vp_cod_nova_fatura,
                     vl_juros,
                     'D',
                     2,
                     vl_cod_operacao,
                     vl_nm_operacao,
                     vp_data_vencimento,
                     now(),
                     vp_cod_nova_fatura);

     
     end if;                                  
    
   end if;
   
   return vl_juros;
   
END;
$$;


ALTER FUNCTION sc_fcr.cobrar_juros(vp_cartao numeric, vp_cod_fatura_atual numeric, vp_cod_nova_fatura numeric, vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 1316 (class 1255 OID 564347)
-- Name: cobrar_multa(numeric, numeric, numeric, date, date); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION cobrar_multa(vp_cartao numeric, vp_cod_fatura_atual numeric, vp_cod_nova_fatura numeric, vp_data_fim_atraso date, vp_data_vencimento date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  TP_OPERACAO_MULTA sc_opr.tbl_top.cd_top%type := 6;
  
  vl_multa sc_opr.tbl_opr.vl_opr%type := 0;
  vl_cod_operacao sc_opr.tbl_opr.cd_opr%type;  
  vl_nm_operacao sc_opr.tbl_top.nm_top%type;
  vl_plastico sc_opr.tbl_pls.cd_pls%type;

  vl_existe_operacao_multa numeric := 0;

BEGIN

   if sc_fcr.eh_pra_cobrar_juros_multa(vp_cod_fatura_atual) then     

	 -- Só será cobrado multa uma única vez a cada atraso
	select count(*)
	 into vl_existe_operacao_multa
	 from sc_opr.tbl_opr opr
	   inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
	   inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
	  where opr.cd_top = TP_OPERACAO_MULTA
	    and opr.st_opr = 2
	    and crt.cd_crt = vp_cartao
	    and opr.dt_opr >= vp_data_fim_atraso;
 
	if vl_existe_operacao_multa = 0 then
        
        vl_multa := sc_fcr.calcular_multa(vp_cartao, vp_cod_fatura_atual);
        
        if vl_multa > 0 then
          
           -- Obtendo o numero do plastico para gravar a operacao
           select cd_pls
           into vl_plastico
           from sc_opr.tbl_pls pls
           where cd_crt = vp_cartao 
             and pls.dt_inc_usr = (select max(dt_inc_usr)
                                   from sc_opr.tbl_pls
                                   where cd_crt = vp_cartao);        
        
  		    -- Obtendo numero da proxima operacao
	        select nextval('sc_opr.sq_opr') 
	        into vl_cod_operacao;
		
	        -- Obtendo descricao a ser exibida na parcela
	        select top.nm_top
	        into vl_nm_operacao
	        from sc_opr.tbl_top top
	        where top.cd_top = TP_OPERACAO_MULTA;
	
            -- Gravando operacao de multa
            insert into sc_opr.tbl_opr(cd_opr,cd_top,cd_pls,cd_atm,dt_opr,vl_opr,vl_jrs_opr,vl_trf_opr,
                           nr_nsu_org_opr,nr_prc_opr,vl_prc_opr,vl_iof_opr,st_opr,dt_prc_opr)
                 values(vl_cod_operacao,TP_OPERACAO_MULTA,vl_plastico,null,now(),vl_multa,0,0,vp_cod_fatura_atual,1,vl_multa,0,2,null);
		     
		     
            -- Gravando parcela referente a operacao de multa
            insert into sc_fcr.tbl_prc(cd_prc,
                                       cd_crt,
                                       cd_fcr,
                                       vl_prc,
                                       fg_dcr_prc,
                                       st_prc,
                                       cd_opr,
                                       ds_prc,
                                       dt_vnc_prc,
                                       dt_grc_prc,
                                       cd_fcr_atu_prc)
                  values(nextval('sc_fcr.sq_prc'),
                         vp_cartao,
                         vp_cod_nova_fatura,
                         vl_multa,
                         'D',
                         2,
                         vl_cod_operacao,
                         vl_nm_operacao,
                         vp_data_vencimento,
                         now(),
                         vp_cod_nova_fatura);
                         
        end if;
        
      end if;
      
   end if;
   
   return vl_multa;   
	

END;
$$;


ALTER FUNCTION sc_fcr.cobrar_multa(vp_cartao numeric, vp_cod_fatura_atual numeric, vp_cod_nova_fatura numeric, vp_data_fim_atraso date, vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 1560 (class 1255 OID 564348)
-- Name: cobrar_tarifa(numeric, numeric, date); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION cobrar_tarifa(vp_cartao numeric, vp_cd_fatura numeric, vp_data_apuracao date) RETURNS double precision
    LANGUAGE plpgsql
    AS $$declare
  ct_pce_tad numeric := 14;
  ct_pce_tmc numeric := 15;

  ct_top_tmc numeric := 13;
  ct_top_tad numeric := 14; 

  ct_tp_pgt_funcionario numeric := 2; 
 
  vl_retorno numeric := 0;
  vl_tarifa_via_cartao numeric;
  vl_qnt_deposito numeric;
  vl_qnt_saque_extra numeric;
  vl_valor_tmc numeric;
  vl_valor_tad numeric;
  vl_plastico numeric;
  vl_opr numeric;
  vl_nm_pce varchar;

  vl_data_apuracao date;
begin

  -- obtendo a data de apuracao
  select dt_prx_apr_crt
    into vl_data_apuracao
  from sc_opr.tbl_crt
  where cd_crt = vp_cartao;

  -- cobrar tarifa via cartao
  select sum(prc.vl_prc)
    into vl_tarifa_via_cartao
  from sc_fcr.tbl_prc prc
    inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
    inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
  where prc.st_prc = 1
    and opr.cd_top in (10,11,17)
    and pls.cd_crt = vp_cartao
    and prc.dt_vnc_prc <= vl_data_apuracao + interval '60 day';

  -- plastico
  select cd_pls
    into vl_plastico
  from sc_opr.tbl_pls pls
  where cd_crt = vp_cartao 
    and pls.dt_inc_usr = (select max(dt_inc_usr)
                          from sc_opr.tbl_pls
                          where cd_crt = vp_cartao);

  --RETIRADO EM 20/07/2016
  -- SPRINT 18
  -- TMC PASSOU A SER DEBITO EM CONTA
  -- cobrar tarifa de manutencao de cartão - tmc
  /*
  select count(*)
    into vl_qnt_deposito
  from sc_adp.tbl_rdp rdp
    inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
    inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
  where rdp.st_rdp = 5
    and rdp.cd_crt = vp_cartao
    and crt.fg_atv_crt = 'S'
    and hfe.dt_dps_hfe > vl_data_apuracao - interval '3 month'
    and not exists (select 1 
                    from sc_opr.tbl_opr opr
                      inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
                    where pls.cd_crt = vp_cartao
                      and opr.dt_opr >= vl_data_apuracao - interval '1 month'
                      and opr.dt_opr < vl_data_apuracao
                      and opr.cd_top = ct_top_tmc);

  if vl_qnt_deposito > 0 then
    begin
      select replace(replace(pce_ctr.vl_pce_ctr, '.', ''), ',', '.'), pce.nm_pce
        into strict vl_valor_tmc, vl_nm_pce
      from sc_opr.tbl_crt crt
        inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = crt.cd_ctr
        inner join sc_cad.tbl_pce pce on pce.cd_pce = pce_ctr.cd_pce
      where crt.cd_crt = vp_cartao
        and pce.cd_pce = ct_pce_tmc
        and pce_ctr.tp_pgt_pce_ctr = ct_tp_pgt_funcionario;
    exception when others then
      vl_valor_tmc := 0;
    end;

    if vl_valor_tmc > 0 then
      select nextval('sc_opr.sq_opr') into vl_opr;
      
      insert into sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, vl_trf_opr,
                       nr_nsu_org_opr, nr_prc_opr, vl_prc_opr, vl_iof_opr, st_opr,dt_prc_opr)
             values(vl_opr, ct_top_tmc, vl_plastico, null, vl_data_apuracao - interval '5 day', vl_valor_tmc, 0, vl_valor_tmc, 
                    vp_cd_fatura, 1, vl_valor_tmc, 0, 2, null);

      insert into sc_fcr.tbl_prc(cd_prc, cd_crt, cd_fcr, vl_prc, fg_dcr_prc, st_prc,
                                 cd_opr, ds_prc, dt_vnc_prc, dt_grc_prc, cd_fcr_atu_prc)
        values(nextval('sc_fcr.sq_prc'), vp_cartao, vp_cd_fatura, vl_valor_tmc, 'D', 2,
               vl_opr, vl_nm_pce, vl_data_apuracao, vl_data_apuracao - interval '5 day',vp_cd_fatura);
    end if;
  end if;
  */

  -- cobrar tarifa de administração - tad
  select count(*)
    into vl_qnt_saque_extra
  from sc_opr.tbl_opr opr
    inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
  where opr.cd_top = 5 -- saque extra
    and opr.st_opr = 2 -- confirmada
    and crt.fg_atv_crt = 'S'
    and pls.cd_crt = vp_cartao
    and opr.dt_opr >= vl_data_apuracao - interval '1 month' 
    and opr.dt_opr < vl_data_apuracao
    and not exists (select 1 
                    from sc_opr.tbl_opr opr
                      inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
                    where pls.cd_crt = vp_cartao
                      and opr.dt_opr >= vl_data_apuracao - interval '1 month'
                      and opr.dt_opr < vl_data_apuracao
                      and opr.cd_top = ct_top_tad);

  if vl_qnt_saque_extra > 0 then
    begin

      select replace(replace(sc_cad.get_parametro_contrato_cartao(ct_pce_tad, vp_cartao), '.', ''),',','.')::numeric(13,2)
      into vl_valor_tad;

      select nm_pce
        into vl_nm_pce
      from sc_cad.tbl_pce
      where cd_pce = ct_pce_tad;
        
    exception when others then
      vl_valor_tad := 0;
      vl_nm_pce = 'Taxa de Administracao - TAD';
    end;

    if vl_valor_tad > 0 then
      select nextval('sc_opr.sq_opr') into vl_opr;
      
      insert into sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, vl_trf_opr,
                       nr_nsu_org_opr, nr_prc_opr, vl_prc_opr, vl_iof_opr, st_opr,dt_prc_opr)
             values(vl_opr, ct_top_tad, vl_plastico, null, vl_data_apuracao - interval '5 day', vl_valor_tad, 0, vl_valor_tad, 
                    vp_cd_fatura, 1, vl_valor_tad, 0, 2, null);

      insert into sc_fcr.tbl_prc(cd_prc, cd_crt, cd_fcr, vl_prc, fg_dcr_prc, st_prc,
                                 cd_opr, ds_prc, dt_vnc_prc, dt_grc_prc, cd_fcr_atu_prc)
        values(nextval('sc_fcr.sq_prc'), vp_cartao, vp_cd_fatura, vl_valor_tad, 'D', 2,
               vl_opr, vl_nm_pce, vl_data_apuracao, vl_data_apuracao - interval '5 day', vp_cd_fatura);
    end if;
  end if; 
 
  -- retorno
  --vl_retorno := coalesce(vl_tarifa_via_cartao, 0) + coalesce(vl_valor_tmc, 0) + coalesce(vl_valor_tad, 0);
  vl_retorno := coalesce(vl_tarifa_via_cartao, 0) + coalesce(vl_valor_tad, 0);
  return vl_retorno;
end;$$;


ALTER FUNCTION sc_fcr.cobrar_tarifa(vp_cartao numeric, vp_cd_fatura numeric, vp_data_apuracao date) OWNER TO scan;

--
-- TOC entry 1318 (class 1255 OID 564349)
-- Name: contabilizar_baixa_por_tipo(numeric, double precision, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION contabilizar_baixa_por_tipo(vp_cartao numeric, vp_valor double precision, vp_tipo_baixa numeric, vp_cod_usuario numeric, INOUT vp_conta_origem numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE

  TIPO_BAIXA_CONTA_CARTAO sc_fcr.tbl_tpc.cd_tpc%type := 1;
  TIPO_BAIXA_CONTA_EMPRESA sc_fcr.tbl_tpc.cd_tpc%type := 2;
  TIPO_BAIXA_CONTA_ESTORNO sc_fcr.tbl_tpc.cd_tpc%type := 4;
  TIPO_BAIXA_RENEGOCIACAO_EXTERNA sc_fcr.tbl_tpc.cd_tpc%type := 5;
  
  COD_SISTEMA_BAIXA sc_cnt.tbl_sst.cd_sst%type := 5;
  
  vl_cnt_org_baixa sc_cnt.tbl_cnt.cd_cnt%type;
  vl_tipo_lanc_org_baixa sc_cnt.tbl_tlc.cd_tlc%type;
  vl_sld_cnt_org_baixa sc_cnt.tbl_cnt.vl_sld_cnt%type;
  
  vl_cnt_prioridade_1 sc_cnt.tbl_cnt.cd_cnt%type;  

BEGIN

  -- Obtendo informacoes do tipo de baixa
  begin

    select tpc.cd_cnt, tpc.cd_tlc
    into vl_cnt_org_baixa, vl_tipo_lanc_org_baixa
    from sc_fcr.tbl_tpc tpc
    where tpc.cd_tpc = vp_tipo_baixa;

  exception when others then

	raise exception 'Não é possivel efetuar a baixa. Tipo de pagamento não encontrado.' ;

  end;
  
  if vp_conta_origem is null then
    vp_conta_origem := vl_cnt_org_baixa;
  else
    vl_cnt_org_baixa := vp_conta_origem;
  end if;

  --Obtendo a conta do cartao de prioridade 1
  select cnt_crt.cd_cnt
  into vl_cnt_prioridade_1
  from sc_opr.tbl_cnt_crt cnt_crt
  where cnt_crt.cd_crt = vp_cartao
  and cnt_crt.prp_cnt_crt = 1;

  -- Definindo a conta de origem caso esta seja nula
  if (vl_cnt_org_baixa is null) then

    if (vp_tipo_baixa = TIPO_BAIXA_CONTA_EMPRESA) then

      select ctr.cd_cnt
      into vl_cnt_org_baixa
      from sc_cad.tbl_ctr ctr
      where ctr.cd_ctr = (select cd_ctr from sc_opr.tbl_crt where cd_crt = vp_cartao);

    else

      vl_cnt_org_baixa := vl_cnt_prioridade_1;

    end if;

  end if;
  
    -- verificando saldo da conta de origem caso o tipo de baixa nao seja conta cartao
  if (vp_tipo_baixa <> TIPO_BAIXA_CONTA_CARTAO) then

      select COALESCE(vl_sld_cnt,0)
      into vl_sld_cnt_org_baixa
      from sc_cnt.tbl_cnt cnt
      where cnt.cd_cnt = vl_cnt_org_baixa;

      if (vl_sld_cnt_org_baixa < vp_valor AND vp_tipo_baixa not in (TIPO_BAIXA_CONTA_ESTORNO, TIPO_BAIXA_RENEGOCIACAO_EXTERNA)) then

        raise exception 'Não é possivel efetuar a baixa. Saldo da conta de origem insuficiente.' ;

      else
      -- efetua lancamento na conta do cartao de prioridade 1

          perform sc_cnt.lancar_debito_credito(vl_cnt_org_baixa,
  											  vl_cnt_prioridade_1,
                                              vl_tipo_lanc_org_baixa,
                                              null,
                                              'TRANSFERENCIA PARA BAIXA DE FATURA',
                                              vp_valor::double precision,
                                              now()::timestamp,
                                              vp_cod_usuario,
                                              COD_SISTEMA_BAIXA::numeric,
                                              (to_char(now(),'yyyymmdd'))::numeric);

      end if;

  end if;

END;
$$;


ALTER FUNCTION sc_fcr.contabilizar_baixa_por_tipo(vp_cartao numeric, vp_valor double precision, vp_tipo_baixa numeric, vp_cod_usuario numeric, INOUT vp_conta_origem numeric) OWNER TO scan;

--
-- TOC entry 1319 (class 1255 OID 564350)
-- Name: contabilizar_baixar_cartao(numeric, double precision, numeric, timestamp without time zone, numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION contabilizar_baixar_cartao(vp_cartao numeric, vp_valor double precision, vp_tipo_baixa numeric, vp_data_pagamento timestamp without time zone, vp_cod_usuario numeric, vp_conta_origem numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  vl_conta_origem sc_cnt.tbl_cnt.cd_cnt%type;
BEGIN

  select sc_fcr.contabilizar_baixa_por_tipo(vp_cartao,vp_valor,vp_tipo_baixa,vp_cod_usuario,vp_conta_origem) into vl_conta_origem;
  
  perform sc_fcr.efetuar_baixa_cartao(vp_cartao,vp_valor,vp_tipo_baixa,vp_data_pagamento, vp_cod_usuario, vl_conta_origem);

END;
$$;


ALTER FUNCTION sc_fcr.contabilizar_baixar_cartao(vp_cartao numeric, vp_valor double precision, vp_tipo_baixa numeric, vp_data_pagamento timestamp without time zone, vp_cod_usuario numeric, vp_conta_origem numeric) OWNER TO scan;

--
-- TOC entry 1620 (class 1255 OID 564351)
-- Name: contabilizar_fatura_cartao(numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION contabilizar_fatura_cartao(vp_cod_fatura numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   rg record;

   ct_tipo_operacao_juros numeric := 7;
   ct_tipo_operacao_multa numeric := 6;
   ct_tipo_operacao_enc_ccb numeric := 23;
   
begin

   for rg in select prc.fg_dcr_prc,
                    top.cd_top,
                    top.cd_cnt conta_tipo_operacao,
                    top.cd_tlc,
                    crt.cd_cnt conta_cartao,
                    fcr.dt_ems_fcr,
                    fcr.dt_ctb_fcr,
                    sum(prc.vl_prc) valor 
             from sc_fcr.tbl_prc prc
                inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
                inner join sc_opr.tbl_top top on top.cd_top = opr.cd_top
		inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = prc.cd_fcr                
                inner join sc_opr.tbl_crt crt on crt.cd_crt = fcr.cd_crt
             where fcr.cd_fcr = vp_cod_fatura
               and top.cd_top not in(ct_tipo_operacao_multa,ct_tipo_operacao_juros,ct_tipo_operacao_enc_ccb)
               and not exists(select 1 from sc_ccb.tbl_ccb c where c.cd_opr = prc.cd_opr)
             group by prc.fg_dcr_prc,
                    top.cd_top,
                    top.cd_cnt,
                    top.cd_tlc,
                    crt.cd_cnt,
                    fcr.dt_ctb_fcr,
                    fcr.dt_ems_fcr  loop

        if rg.dt_ctb_fcr is not null then
          raise exception 'FATURA % JA CONTABILIZADA',vp_cod_fatura;
        end if;            
                    
        if rg.fg_dcr_prc = 'D' then
        
	   perform sc_cnt.lancar_debito_credito(rg.conta_cartao,rg.conta_tipo_operacao,rg.cd_tlc,null,'REF A CONTABILIZACAO DA FATURA NR '||vp_cod_fatura,rg.valor,rg.dt_ems_fcr,1,20,vp_cod_fatura);		
	   
	else
           if rg.cd_tlc is not null then
	     perform sc_cnt.lancar_debito_credito(rg.conta_tipo_operacao,rg.conta_cartao,rg.cd_tlc,null,'REF A CONTABILIZACAO DA FATURA NR '||vp_cod_fatura,rg.valor,rg.dt_ems_fcr,1,20,vp_cod_fatura);
           end if;
	end if;     
   end loop;
   update sc_fcr.tbl_fcr 
     set dt_ctb_fcr = now() 
   where cd_fcr = vp_cod_fatura;
   
end;$$;


ALTER FUNCTION sc_fcr.contabilizar_fatura_cartao(vp_cod_fatura numeric) OWNER TO scan;

--
-- TOC entry 1265 (class 1255 OID 564352)
-- Name: contabilizar_fatura_cartao(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: postgres
--

CREATE FUNCTION contabilizar_fatura_cartao(vp_empresa numeric, vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin
   for rg in select fcr.cd_fcr
             from sc_fcr.tbl_fcr fcr
               inner join sc_opr.tbl_crt crt on crt.cd_crt = fcr.cd_crt
               inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
             where (fnc.cd_emp = vp_empresa or vp_empresa is null)  
               and (fcr.cd_crt = vp_cartao  or vp_cartao is null)
               and fcr.dt_ctb_fcr is null loop

        perform sc_fcr.contabilizar_fatura_cartao(rg.cd_fcr);
   
               
   end loop;            
end$$;


ALTER FUNCTION sc_fcr.contabilizar_fatura_cartao(vp_empresa numeric, vp_cartao numeric) OWNER TO postgres;

--
-- TOC entry 1770 (class 1255 OID 882630)
-- Name: contabilizar_juros_multa(); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION contabilizar_juros_multa() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   rg record;
begin

   for rg in select prc.fg_dcr_prc,
                    top.cd_top,
                    top.cd_cnt conta_tipo_operacao,
                    top.cd_tlc,
                    crt.cd_cnt conta_cartao,
                    pfc.dt_rcb_pfc,
                    pfc_prc.vl_pfc_prc valor,
                    prc.cd_prc codigo_parcela,
                    pfc.cd_pfc codigo_pagamento
             from sc_fcr.tbl_pfc_prc pfc_prc
                inner join sc_fcr.tbl_prc prc on prc.cd_prc = pfc_prc.cd_prc
                inner join sc_opr.tbl_crt crt on prc.cd_crt = crt.cd_crt
                inner join sc_fcr.tbl_pfc pfc on pfc.cd_pfc = pfc_prc.cd_pfc
                inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
                inner join sc_opr.tbl_top top on top.cd_top = opr.cd_top
             where pfc_prc.dt_ctb_pfc_prc is null
               and top.cd_top in(6,7)
               and pfc.dt_rcb_pfc >= '01-08-2016'
               --and pfc.dt_rcb_pfc < '01-02-2016' 
               and pfc.st_pfc = 1 loop
          
                    
        if rg.fg_dcr_prc = 'D' then

           raise notice 'contabilizando a parcela de código: %', rg.codigo_parcela;
        
	   perform sc_cnt.lancar_debito_credito(rg.conta_cartao,rg.conta_tipo_operacao,rg.cd_tlc,null,'REF A CONTABILIZACAO DA PARCELA NR '||rg.codigo_parcela,rg.valor,rg.dt_rcb_pfc,1,28,rg.codigo_parcela);		
	   
	   update sc_fcr.tbl_pfc_prc 
	     set dt_ctb_pfc_prc = now() 
	   where cd_pfc = rg.codigo_pagamento
	     and cd_prc = rg.codigo_parcela;
	   
	else
	   raise exception 'FLAG DE DEBITO_CREDITO DA TABELA DE PARCELAS ESTA COM CREDITO. ROTINA DE CONTABILIZAOCAO NAO PREPARADA';   
	end if;   
                    
   end loop;
end;$$;


ALTER FUNCTION sc_fcr.contabilizar_juros_multa() OWNER TO scan;

--
-- TOC entry 1266 (class 1255 OID 564353)
-- Name: corrigir_limite_cancelamento_fatura(numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION corrigir_limite_cancelamento_fatura(vp_crt numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  vl_ult_fcr numeric;
  vl_pult_fcr numeric;
  vl_rst_pult_fcr numeric;
  vl_opr_saq_extra numeric;
  vl_rst_fcr_errado numeric;
  vl_valor_pago numeric;
begin

  -- cancelando todas as fatura que so tem pagamento cancelado
  for rg in select *
            from sc_fcr.tbl_fcr fcr
              inner join (select sum(pfc.vl_pfc) as vl_pfc, pfc.cd_fcr as cd_fcr 
                          from sc_fcr.tbl_pfc pfc 
                          where pfc.st_pfc = 2 
                            and not exists (select 1 from sc_fcr.tbl_pfc pfc2 where pfc2.cd_fcr = pfc.cd_fcr and pfc2.st_pfc = 1)
                          group by pfc.cd_fcr) as pfc on pfc.cd_fcr = fcr.cd_fcr
            where fcr.st_fcr <> 3
              and case when vp_crt is null then true else fcr.cd_crt = vp_crt end loop

    update sc_fcr.tbl_fcr set
      st_fcr = 3
    where cd_fcr = rg.cd_fcr;

    -- atualizar a ultima fatura do cartao
    begin
      select max(fcr.cd_fcr)
        into strict vl_ult_fcr
      from sc_opr.tbl_crt crt
        inner join sc_fcr.tbl_fcr fcr on fcr.cd_crt = crt.cd_crt
      where fcr.st_fcr <> 3
        and fcr.cd_crt = rg.cd_crt;
    exception when others then
      vl_ult_fcr := null;
    end;

    update sc_opr.tbl_crt set
      cd_fcr = vl_ult_fcr
    where cd_crt = rg.cd_crt;

    -- pegar a maior fatura que nao está cancelada e que nao é a mesma
    begin
      select max(fcr.cd_fcr)
        into strict vl_pult_fcr
      from sc_fcr.tbl_fcr fcr
        inner join sc_fcr.tbl_fcr fcr2 on fcr2.cd_crt = fcr.cd_crt
      where case when vl_ult_fcr is not null then fcr.cd_fcr < vl_ult_fcr and fcr2.cd_fcr = vl_ult_fcr else true end
        and fcr.st_fcr <> 3;
    exception when others then
      vl_pult_fcr := null;
    end;

    vl_rst_pult_fcr := 0;

    if vl_pult_fcr is not null then
      begin
        select coalesce(vl_rst_fcr_tlt,0)
          into strict vl_rst_pult_fcr
        from sc_fcr.tbl_fcr_tlt
        where cd_fcr = vl_pult_fcr
          and cd_tlt = 1;
      exception when others then
        vl_rst_pult_fcr := 0;
      end;
    end if;

    vl_opr_saq_extra := 0;
    vl_rst_fcr_errado := 0;
    vl_valor_pago := 0;

    if vl_ult_fcr is not null then
      begin
        select sum(coalesce(opr.vl_opr,0))
          into strict vl_opr_saq_extra
        from sc_opr.tbl_opr opr
          inner join sc_fcr.tbl_prc prc on prc.cd_opr = opr.cd_opr
        where prc.cd_fcr = vl_ult_fcr
          and prc.st_prc = 2
          and opr.cd_top = 5;
      exception when others then
        vl_opr_saq_extra := 0;
      end;

      begin
        select coalesce(vl_ttl_fcr_tlt,0)
          into strict vl_rst_fcr_errado
        from sc_fcr.tbl_fcr_tlt
        where cd_fcr = vl_ult_fcr
          and cd_tlt = 1; 
      exception when others then
        vl_rst_fcr_errado := 0;
      end;

      begin
        select sum(pfc.vl_pfc) as vl_pfc
          into strict vl_valor_pago
        from sc_fcr.tbl_pfc pfc 
        where pfc.st_pfc = 1
          and pfc.cd_fcr = vl_ult_fcr;
      exception when others then
        vl_valor_pago := 0;
      end;
    end if;

    select (coalesce(vl_rst_pult_fcr,0) + coalesce(vl_opr_saq_extra,0)) - coalesce(vl_valor_pago,0) into vl_rst_fcr_errado;

    if vl_rst_fcr_errado < 0 then
      vl_rst_fcr_errado := 0;
    end if;

    update sc_fcr.tbl_fcr_tlt set
      vl_rst_fcr_tlt = vl_rst_fcr_errado,
      vl_ttl_fcr_tlt = coalesce(vl_rst_pult_fcr,0) + coalesce(vl_opr_saq_extra,0)
    where cd_fcr = vl_ult_fcr
      and cd_tlt = 1;
  
  end loop;
end;$$;


ALTER FUNCTION sc_fcr.corrigir_limite_cancelamento_fatura(vp_crt numeric) OWNER TO scan;

--
-- TOC entry 1564 (class 1255 OID 564354)
-- Name: descontabilizar_fatura_cartao(numeric, numeric, character varying); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION descontabilizar_fatura_cartao(vp_cod_fatura numeric, vp_cod_usuario numeric, vp_observacao character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   rg record;
   vl_observacao varchar;
   ct_tipo_operacao_juros numeric := 7;
   ct_tipo_operacao_multa numeric := 6;
   ct_tipo_operacao_enc_ccb numeric := 23;
begin

   for rg in select prc.fg_dcr_prc,
                    top.cd_top,
                    top.cd_cnt conta_tipo_operacao,
                    tlc.cd_est_tlc,
                    crt.cd_cnt conta_cartao,
                    fcr.dt_ems_fcr,
                    sum(prc.vl_prc) valor 
             from sc_fcr.tbl_prc prc
                inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
                inner join sc_opr.tbl_top top on top.cd_top = opr.cd_top
                inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = prc.cd_fcr
                inner join sc_opr.tbl_crt crt on crt.cd_crt = fcr.cd_crt
                left join sc_cnt.tbl_tlc tlc on tlc.cd_tlc = top.cd_tlc
             where fcr.cd_fcr = vp_cod_fatura
               and fcr.dt_ctb_fcr is not null
               and top.cd_top not in(ct_tipo_operacao_juros,ct_tipo_operacao_multa,ct_tipo_operacao_enc_ccb)
             group by prc.fg_dcr_prc,
                    top.cd_top,
                    top.cd_cnt,
                    tlc.cd_est_tlc,
                    crt.cd_cnt,
                    fcr.dt_ems_fcr  loop

        if rg.cd_est_tlc is null then
           raise exception 'NAO CADASTRADO TIPO DE LANCAMENTO DE ESTORNO PARA O TIPO DE LANCAMENTO FATURA NR %',vp_cod_fatura;
        end if;             
                    
        if rg.fg_dcr_prc = 'D' then
        
           if vp_observacao is null then
           
              vl_observacao := 'REF A DESCONTABILIZACAO DA FATURA NR '||vp_cod_fatura;
              
           end if;
           
	   perform sc_cnt.lancar_debito_credito(rg.conta_tipo_operacao,rg.conta_cartao,rg.cd_est_tlc,null,vl_observacao,rg.valor,rg.dt_ems_fcr,vp_cod_usuario,20,vp_cod_fatura);
	   
	   update sc_fcr.tbl_fcr set dt_ctb_fcr = null where cd_fcr = vp_cod_fatura;		
	   
	else
	
	   raise exception 'FLAG DE DEBITO_CREDITO DA TABELA DE PARCELAS ESTA COM CREDITO. ROTINA DE DESCONTABILIZAOCAO NAO PREPARADA';   
	   
	end if;   
                    
   end loop;
end;$$;


ALTER FUNCTION sc_fcr.descontabilizar_fatura_cartao(vp_cod_fatura numeric, vp_cod_usuario numeric, vp_observacao character varying) OWNER TO scan;

--
-- TOC entry 1109 (class 1255 OID 564355)
-- Name: efetuar_baixa_cartao(numeric, double precision, numeric, timestamp without time zone, numeric, numeric, boolean); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION efetuar_baixa_cartao(vp_cartao numeric, vp_valor double precision, vp_tipo_baixa numeric, vp_data_pagamento timestamp without time zone, vp_cod_usuario numeric, vp_conta_origem numeric, vp_eh_rescisao boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  PRM_TIPO_LANCAMENTO_BAIXA sc_cad.tbl_prm.nm_prm%type := 'TL_BAIXA';
  PRM_CONTA_CONTRA_PARTIDA_BAIXA sc_cad.tbl_prm.nm_prm%type := 'CNT_CTPD_BAIXA';
  COD_SISTEMA_BAIXA sc_cnt.tbl_sst.cd_sst%type := 5;
  TIPO_BAIXA_CONTA_CARTAO sc_fcr.tbl_tpc.cd_tpc%type := 1;
  TIPO_BAIXA_CONTA_EMPRESA sc_fcr.tbl_tpc.cd_tpc%type := 2;
  SITUACAO_FATURA_ABERTA sc_fcr.tbl_fcr.st_fcr%type := 1;
  SITUACAO_FATURA_FECHADA sc_fcr.tbl_fcr.st_fcr%type := 2;

  vl_situacao_fatura sc_fcr.tbl_fcr.st_fcr%type;

  vl_tipo_lanc_baixa sc_cnt.tbl_tlc.cd_tlc%type;
  vl_cnt_ctpd_baixa sc_cnt.tbl_cnt.cd_cnt%type;

  vl_cnt_prioridade_1 sc_cnt.tbl_cnt.cd_cnt%type;

  vl_cnt_org_baixa sc_cnt.tbl_cnt.cd_cnt%type;
  vl_tipo_lanc_org_baixa sc_cnt.tbl_tlc.cd_tlc%type;
  vl_sld_cnt_org_baixa sc_cnt.tbl_cnt.vl_sld_cnt%type;

  vl_saldo_devedor sc_fcr.tbl_fcr.vl_sld_dvd_fcr%type;
  vl_saldo_cartao sc_cnt.tbl_cnt.vl_sld_cnt%type;
  vl_minimo_fatura sc_fcr.tbl_fcr.vl_mnm_fcr%type;
  vl_situacao_inadimplencia sc_opr.tbl_crt.fg_ind_crt%type;
  vl_baixa sc_fcr.tbl_pfc.vl_pfc%type;

  vl_nr_lancamento_credito sc_cnt.tbl_lcn.cd_lcn%type;

  vl_cod_pagamento sc_fcr.tbl_pfc.cd_pfc%type;

  vl_restante_restituir sc_fcr.tbl_fcr.vl_rst_enc_fcr%type;
  vl_a_restituir_enc sc_fcr.tbl_fcr.vl_rst_enc_fcr%type;
  vl_restituido_enc sc_fcr.tbl_fcr.vl_rst_enc_fcr%type;
  vl_credito_prox_fat sc_fcr.tbl_fcr.vl_crd_fcr%type := 0;

  vl_restituido_tlt sc_fcr.tbl_fcr.vl_rst_enc_fcr%type;

  vl_cod_fatura_atual sc_fcr.tbl_fcr.cd_fcr%type;
  
  vl_baixa_rescisao sc_rsc.tbl_rsc.vl_pgt_rsc%type;

  vl_qtd_rescisao numeric;
  vl_qtd_parcelas_a_vencer numeric;
  vl_data_apuracao date;

  vl_valor_fatura_atual numeric;
  vl_saldo_devedor_atual numeric;
  
  rg_tlt record;

  vl_pago numeric;
  vl_restante numeric;
  rg_prc record;

begin

  -- Consolidando a divida caso exista rescisao
  select count(*)
  into vl_qtd_rescisao
  from sc_rsc.tbl_rsc rsc
  where rsc.cd_crt = vp_cartao
    and rsc.st_rsc <> 2; -- Cancelada
    
  if vp_eh_rescisao then
  
     -- Verificando se existe parcelas a vencer
      select count(*)
      into vl_qtd_parcelas_a_vencer
      from sc_fcr.tbl_prc prc
      where st_prc = 1
        and prc.cd_crt = vp_cartao;
      
      -- Se existe parcelas a vencer consolida a dívida  
      if vl_qtd_parcelas_a_vencer > 0 then
      
         vl_data_apuracao := (now() + interval '24 month')::date;
         perform sc_fcr.gerar_fatura_cartao(vp_cartao, vl_data_apuracao, current_date,false);
         
      end if;
    
  end if;

  -- Obtendo informacoes da fatura atual
  begin

    select fcr.vl_sld_dvd_fcr,
           COALESCE(fcr.vl_rst_enc_fcr,0),
           fcr.cd_fcr,
           fcr.vl_mnm_fcr,
           crt.fg_ind_crt,
           fcr.vl_fcr
    into strict vl_saldo_devedor,
         vl_a_restituir_enc,
         vl_cod_fatura_atual,
         vl_minimo_fatura,
         vl_situacao_inadimplencia,
         vl_valor_fatura_atual
    from sc_fcr.tbl_fcr fcr
       inner join sc_opr.tbl_crt crt on crt.cd_fcr = fcr.cd_fcr
    where crt.cd_crt = vp_cartao
      and fcr.st_fcr in (1, 6);

  exception when others then 

    vl_saldo_devedor := 0;
    vl_a_restituir_enc := 0;

  end;
  
  if vl_saldo_devedor > 0 then 

    --Obtendo a conta do cartao de prioridade 1
    select cnt_crt.cd_cnt,crt.cd_cnt
    into vl_cnt_prioridade_1,vl_cnt_ctpd_baixa
    from sc_opr.tbl_cnt_crt cnt_crt
      inner join sc_opr.tbl_crt crt on crt.cd_crt = cnt_crt.cd_crt
    where cnt_crt.cd_crt = vp_cartao
    and cnt_crt.prp_cnt_crt = 1;


    -- Obtendo o codigo do pagamento a ser cadastrado
    select nextval('sc_fcr.sq_pfc') into vl_cod_pagamento;

    select sc_cnt.get_saldo_cartao(vp_cartao, 'S', 'S') into vl_saldo_cartao;

    -- Obtendo parametros

    select prm.vl_prm
    into vl_tipo_lanc_baixa
    from sc_cad.tbl_prm prm
    where prm.nm_prm = PRM_TIPO_LANCAMENTO_BAIXA;

/*
    select prm.vl_prm
    into vl_cnt_ctpd_baixa
    from sc_cad.tbl_prm prm
    where prm.nm_prm = PRM_CONTA_CONTRA_PARTIDA_BAIXA;
*/

    if( vp_valor is not null ) then

       if( vl_saldo_cartao >= vp_valor ) then

          vl_baixa := vp_valor;

       else

         raise notice 'Não é possivel efetuar a baixa. Saldo insuficiente.' ;

       end if;

    else
      if vl_saldo_devedor >= vl_saldo_cartao then
         vl_baixa := vl_saldo_cartao;
      else
         vl_baixa := vl_saldo_devedor;
      end if;   

    end if;

    if( vl_baixa > 0 ) then

        vl_restante_restituir := vl_baixa;

         -- Efetuado restituicao de limites seguindo a seguinte ordem:
         -- 1 - Encargos
         -- 2 - Valor Principal (compra, saque ....)

         -- XX INICIO: RESTITUICAO DE LIMITE

        -- Verificando o valor a restituir de encargos
        if( vl_baixa >= vl_a_restituir_enc ) then
           vl_restituido_enc := vl_a_restituir_enc;
        else
           vl_restituido_enc := vl_baixa;
        end if;

        vl_restante_restituir := vl_restante_restituir - vl_restituido_enc;

        -- Caso ainda exista valor para restituir os outros limites( Principal )
        if( vl_restante_restituir > 0 )then

            -- Obtendo tipo de limite da última fatura que ainda não foram restituídos
            for rg_tlt in select fcr_tlt.vl_rst_fcr_tlt,
                                 fcr_tlt.cd_tlt,
                                 fcr_tlt.cd_fcr
                      from sc_fcr.tbl_fcr fcr
                        inner join sc_fcr.tbl_fcr_tlt fcr_tlt on fcr_tlt.cd_fcr = fcr.cd_fcr
                        inner join sc_opr.tbl_tlt tlt on tlt.cd_tlt = fcr_tlt.cd_tlt
                      where fcr.cd_fcr = vl_cod_fatura_atual
                        and fcr_tlt.vl_rst_fcr_tlt > 0
                      order by tlt.nr_pri_tlt loop

               -- Verificando o valor a restituir do tipo de limite
               if( vl_restante_restituir >= rg_tlt.vl_rst_fcr_tlt ) then

                 vl_restituido_tlt := rg_tlt.vl_rst_fcr_tlt;

               else

                 vl_restituido_tlt := vl_restante_restituir;

               end if;

               -- Diminuindo o valor a ser restituido do tipo de limite na fatura atual
               update sc_fcr.tbl_fcr_tlt
               set vl_rst_fcr_tlt = vl_rst_fcr_tlt - vl_restituido_tlt
               where cd_fcr = rg_tlt.cd_fcr
                 and cd_tlt = rg_tlt.cd_tlt;

               -- Gravando o detalhe da restituicao
               insert into sc_fcr.tbl_pfc_tlt(cd_pfc,cd_tlt,vl_pfc_tlt)
                  values(vl_cod_pagamento,rg_tlt.cd_tlt,vl_restituido_tlt);

               -- Efetivando a restituicao de limite
               update sc_opr.tbl_lmt
               set vl_utl_lmt = vl_utl_lmt - vl_restituido_tlt
               where cd_crt = vp_cartao
                 and cd_tlt = rg_tlt.cd_tlt;

               -- Calculando o valor que sobrou para utilizar como restituicao
               vl_restante_restituir = vl_restante_restituir - vl_restituido_tlt;

               exit when vl_restante_restituir = 0;

            end loop;

        end if;

        -- Depois de restituido todos os limites o valor restante ficara de credito
        -- para o proximo faturamento.
        if( vl_restante_restituir > 0 ) then
          vl_credito_prox_fat := vl_restante_restituir;
        end if;

        -- Atualizando a fatura atual
        vl_situacao_fatura := null;

        if (vl_saldo_devedor - vl_baixa <= 0) then

          vl_situacao_fatura := SITUACAO_FATURA_FECHADA;

        end if;

        update sc_fcr.tbl_fcr
        set vl_rst_enc_fcr = vl_rst_enc_fcr - vl_restituido_enc,
            vl_sld_dvd_fcr = vl_sld_dvd_fcr - vl_baixa,
            vl_crd_fcr = vl_credito_prox_fat,
            vl_ttl_pgt_fcr = vl_ttl_pgt_fcr + vl_baixa,
            dt_ult_pgt_fcr = now(),
            st_fcr = coalesce(vl_situacao_fatura,st_fcr)
        where cd_fcr = vl_cod_fatura_atual;

       
        vl_saldo_devedor_atual := vl_saldo_devedor - vl_baixa;
        -- Liberando a inadimplencia
        if( vl_situacao_inadimplencia = 'S' and vl_valor_fatura_atual - vl_saldo_devedor_atual >= vl_minimo_fatura) then

          update sc_opr.tbl_crt
          set fg_ind_crt = 'N',
              dt_fim_atr_crt = vp_data_pagamento
          where cd_crt = vp_cartao;

          -- excluindo do spc, caso esteja
          perform sc_cci.excluir_cartao_negativacao_spc(vp_cartao);

        end if;
        
        -- Efetua baixa em rescisão, se necessário.
        vl_baixa_rescisao = sc_rsc.efetuar_baixa_cartao_rescisao(vp_cartao,vl_baixa,vp_eh_rescisao);

        -- Inserindo pagamento
        insert into sc_fcr.tbl_pfc(cd_pfc, cd_fcr, cd_crt, nr_dia_atr_pfc,dt_pgt_pfc,dt_rcb_pfc,
                                    vl_pfc,st_pfc,cnt_org_pfc,vl_rst_enc_pfc, cd_tpc, cd_inc_usr, vl_pgt_rsc_pfc)
                    values(vl_cod_pagamento,vl_cod_fatura_atual,vp_cartao,0,vp_data_pagamento,now(),
                            vl_baixa,1,coalesce(vp_conta_origem,vl_cnt_prioridade_1),vl_restituido_enc,vp_tipo_baixa, vp_cod_usuario, vl_baixa_rescisao);

        -- Efetuando os lancamentos
        select sc_cnt.lancar_movimento(vl_nr_lancamento_credito,null,vl_tipo_lanc_baixa,
                                 vl_cnt_ctpd_baixa,'C',vl_baixa,now()::timestamp without time zone,vp_cod_usuario,null,
                                 'Baixa nr '||vl_cod_pagamento,COD_SISTEMA_BAIXA,vl_cod_pagamento) into vl_nr_lancamento_credito;

        perform sc_cnt.lancar_debito_cartao(vl_nr_lancamento_credito,vp_cartao,vl_tipo_lanc_baixa,
                                 vl_baixa,null,'Baixa nr '||vl_cod_pagamento::varchar,
                                 now()::timestamp without time zone,vp_cod_usuario,COD_SISTEMA_BAIXA,vl_cod_pagamento);

        -- Efetuando baixa das parcelas
        vl_restante := vl_baixa;
        
        for rg_prc in select prc.vl_prc - coalesce(vl_pgt_prc,0) valor_a_pagar,
			     prc.cd_prc
		      from sc_fcr.tbl_prc prc
			inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
			inner join sc_opr.tbl_top top on top.cd_top = opr.cd_top
		      where prc.cd_fcr_atu_prc = vl_cod_fatura_atual
			and vl_prc - vl_pgt_prc > 0
		      order by coalesce(top.ord_pri_rst_top,999),prc.cd_fcr, valor_a_pagar loop
			
		if vl_restante > rg_prc.valor_a_pagar then
		   vl_pago := rg_prc.valor_a_pagar;
		else
		   vl_pago := vl_restante;
		end if;	

		vl_restante := vl_restante - vl_pago;

		insert into sc_fcr.tbl_pfc_prc(cd_pfc,cd_prc,vl_pfc_prc) values(vl_cod_pagamento,rg_prc.cd_prc,vl_pago);

		update sc_fcr.tbl_prc 
		set vl_pgt_prc = vl_pgt_prc + vl_pago 
		where cd_prc = rg_prc.cd_prc;
		
		if vl_restante = 0 then
		  exit;
		end if;
		
	end loop;                           

    end if;
    
  end if;  

end
$$;


ALTER FUNCTION sc_fcr.efetuar_baixa_cartao(vp_cartao numeric, vp_valor double precision, vp_tipo_baixa numeric, vp_data_pagamento timestamp without time zone, vp_cod_usuario numeric, vp_conta_origem numeric, vp_eh_rescisao boolean) OWNER TO scan;

--
-- TOC entry 7807 (class 0 OID 0)
-- Dependencies: 1109
-- Name: FUNCTION efetuar_baixa_cartao(vp_cartao numeric, vp_valor double precision, vp_tipo_baixa numeric, vp_data_pagamento timestamp without time zone, vp_cod_usuario numeric, vp_conta_origem numeric, vp_eh_rescisao boolean); Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON FUNCTION efetuar_baixa_cartao(vp_cartao numeric, vp_valor double precision, vp_tipo_baixa numeric, vp_data_pagamento timestamp without time zone, vp_cod_usuario numeric, vp_conta_origem numeric, vp_eh_rescisao boolean) IS 'Rotina responsável por baixar faturas de cartao';


--
-- TOC entry 1695 (class 1255 OID 564358)
-- Name: efetuar_baixa_outros_cartoes(numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION efetuar_baixa_outros_cartoes(vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  rg record;
  vl_max_descontar numeric;
  vl_descontado numeric;  
  vl_saldo_restante numeric;
  vl_a_transferir numeric;
  vl_conta_credito numeric;
  vl_conta_debito numeric;
  vl_percentual numeric;
  vl_grupo_empresarial numeric;
  
  PRM_PERCENTUAL_DESCONTO sc_cad.tbl_prm.nm_prm%TYPE = 'PRC_DESCONTO_DIV_OUTRO_CARTAO';

  ct_st_fatura_cancelada numeric := 3;
  ct_st_fatura_renegociada numeric := 4;
  ct_st_fatura_trans_divida numeric := 5;
  ct_st_fatura_em_cobranca numeric := 6;
  
BEGIN

  select prm.vl_prm
  into vl_percentual
  from sc_cad.tbl_prm prm
  where nm_prm = PRM_PERCENTUAL_DESCONTO;

  select emp.cd_gem
  into vl_grupo_empresarial
  from sc_opr.tbl_crt crt
    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
  where crt.cd_crt = vp_cartao;


  -- Verificar parcelas de acordos de outros cartoes
  perform sc_scan_cbe.cobrar_parcela_divida_outro_cartao(vp_cartao);

  -- Verifica as dividas de cartoes do mesmo grupo empresarial

  vl_saldo_restante = sc_cnt.get_saldo_cartao(vp_cartao,'S','S');
  
  if(vl_saldo_restante > 0) then
  	
      vl_max_descontar = vl_saldo_restante;  -- 100% do saldo

      
      for rg in select fcr.vl_sld_dvd_fcr saldo_devedor,
                       crt.cd_crt cartao,
                       emp.cd_gem
                from sc_opr.tbl_crt crt 
                  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc 
                  inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
                  inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                where fcr.vl_sld_dvd_fcr > 0
                  and fcr.st_fcr not in (ct_st_fatura_cancelada,ct_st_fatura_renegociada,ct_st_fatura_trans_divida,ct_st_fatura_em_cobranca)
                  and emp.cd_gem = vl_grupo_empresarial
                  and exists(select 1 
                             from sc_opr.tbl_crt crt2 
                                inner join sc_cad.tbl_fnc fnc2 on fnc2.cd_fnc = crt2.cd_fnc
                             where fnc2.cd_cun = fnc.cd_cun
                               and crt2.cd_crt <> crt.cd_crt
                               and crt2.cd_crt = vp_cartao
                               and crt2.cd_prd <> 3) loop
                               
		vl_a_transferir = 0;	
               
               if(vl_max_descontar >= rg.saldo_devedor) then
                  vl_a_transferir = rg.saldo_devedor;
               else
                  vl_a_transferir = vl_max_descontar;   
               end if;
               
               vl_max_descontar = vl_max_descontar - vl_a_transferir;
               
               --realizando a transferencia para o cartao devedor
               
                 -- obtendo a conta de debito
                 select cnt_crt.cd_cnt
                 into vl_conta_debito
                 from sc_opr.tbl_cnt_crt cnt_crt
                 where cnt_crt.cd_crt = vp_cartao
                   and cnt_crt.fg_pdr_cnt_crt = 'S';
                   
                 -- obtendo a conta de credito
                 select cnt_crt.cd_cnt
                 into vl_conta_credito
                 from sc_opr.tbl_cnt_crt cnt_crt
                 where cnt_crt.cd_crt = rg.cartao
                   and cnt_crt.fg_pdr_cnt_crt = 'S';
  
                   
		perform sc_cnt.lancar_debito_credito(vl_conta_debito,vl_conta_credito,175,null,'TRANSF. PARA QUITAR DIVIDA DE OUTRO CARTAO'::varchar,vl_a_transferir,now()::timestamp,1,5,1000);
                perform sc_fcr.efetuar_baixa_cartao(rg.cartao,null,1,now()::timestamp,1,null,false);  
                
               if vl_max_descontar = 0 then
                 return;
               end if;
               
     end loop;
                
  end if;

  -- Verifica as dividas de cartoes do mesmo grupo empresarial diferente

  vl_saldo_restante = sc_cnt.get_saldo_cartao(vp_cartao,'S','S');
  
  if(vl_saldo_restante > 0) then
  	
      vl_max_descontar = vl_saldo_restante * vl_percentual / 100;  

      
      for rg in select fcr.vl_sld_dvd_fcr saldo_devedor,
                       crt.cd_crt cartao,
                       emp.cd_gem
                from sc_opr.tbl_crt crt 
                  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc 
                  inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
                  inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                where fcr.vl_sld_dvd_fcr > 0
                  and fcr.st_fcr not in (ct_st_fatura_cancelada,ct_st_fatura_renegociada,ct_st_fatura_trans_divida,ct_st_fatura_em_cobranca)
                  and emp.cd_gem <> vl_grupo_empresarial
                  and exists(select 1 
                             from sc_opr.tbl_crt crt2 
                                inner join sc_cad.tbl_fnc fnc2 on fnc2.cd_fnc = crt2.cd_fnc
                             where fnc2.cd_cun = fnc.cd_cun
                               and crt2.cd_crt <> crt.cd_crt
                               and crt2.cd_crt = vp_cartao
                               and crt2.cd_prd <> 3) loop
                               
		vl_a_transferir = 0;	
               
               if(vl_max_descontar >= rg.saldo_devedor) then
                  vl_a_transferir = rg.saldo_devedor;
               else
                  vl_a_transferir = vl_max_descontar;   
               end if;
               
               vl_max_descontar = vl_max_descontar - vl_a_transferir;
               
               --realizando a transferencia para o cartao devedor
               
                 -- obtendo a conta de debito
                 select cnt_crt.cd_cnt
                 into vl_conta_debito
                 from sc_opr.tbl_cnt_crt cnt_crt
                 where cnt_crt.cd_crt = vp_cartao
                   and cnt_crt.fg_pdr_cnt_crt = 'S';
                   
                 -- obtendo a conta de credito
                 select cnt_crt.cd_cnt
                 into vl_conta_credito
                 from sc_opr.tbl_cnt_crt cnt_crt
                 where cnt_crt.cd_crt = rg.cartao
                   and cnt_crt.fg_pdr_cnt_crt = 'S';
  
                   
		perform sc_cnt.lancar_debito_credito(vl_conta_debito,vl_conta_credito,175,null,'TRANSF. PARA QUITAR DIVIDA DE OUTRO CARTAO'::varchar,vl_a_transferir,now()::timestamp,1,5,1000);
                perform sc_fcr.efetuar_baixa_cartao(rg.cartao,null,1,now()::timestamp,1,null,false);  
                
               if vl_max_descontar = 0 then
                 return;
               end if;
               
     end loop;
                
  end if;
  
END;
$$;


ALTER FUNCTION sc_fcr.efetuar_baixa_outros_cartoes(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1308 (class 1255 OID 564359)
-- Name: eh_pra_cobrar_juros_multa(numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION eh_pra_cobrar_juros_multa(vp_fatura_atual numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE

  PRM_QTD_DIAS_CARENCIA sc_cad.tbl_prm.nm_prm%type := 'QTD_DIAS_JRS_MLT';
  
  vl_qtd_dias_carencia numeric;
  vl_total_pagamento numeric;
  vl_fatura numeric;
  
BEGIN

  if (vp_fatura_atual is not null) then
  
    -- Obtendo a quantitade de dias de carencia
    select prm.vl_prm::numeric
    into vl_qtd_dias_carencia
    from sc_cad.tbl_prm prm 
    where prm.nm_prm = PRM_QTD_DIAS_CARENCIA;

    
    select COALESCE(sum(pfc.vl_pfc),0),
           coalesce(fcr.vl_fcr,0)
    into vl_total_pagamento,
         vl_fatura
    from sc_fcr.tbl_pfc pfc
      inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = pfc.cd_fcr
    where pfc.cd_fcr = vp_fatura_atual
      and pfc.st_pfc = 1 
      and pfc.dt_pgt_pfc <= (fcr.dt_vnc_fcr + vl_qtd_dias_carencia::integer)
    group by fcr.vl_fcr;
      
    if (vl_total_pagamento > 0) then
      if ( vl_total_pagamento >= vl_fatura ) then
        return false;
      else   
        return true;
      end if;  
    else
      return true;
    end if; 
  else
    return false;
  end if;     

END;
$$;


ALTER FUNCTION sc_fcr.eh_pra_cobrar_juros_multa(vp_fatura_atual numeric) OWNER TO scan;

--
-- TOC entry 1180 (class 1255 OID 564360)
-- Name: estorno_pagamento(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION estorno_pagamento(vp_cd_pfc numeric, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_cd_sst_baixa_fatura numeric := 5;
  ct_cd_tlt_saque_extra numeric := 1;

  ct_tp_operacao_saque_extra numeric := 5;
  ct_tp_operacao_renegociacao numeric := 15;
  ct_tp_operacao_transf_divida numeric := 16;

  ct_st_parcela_faturada numeric := 2;

  vl_valor_pago numeric;
  vl_cd_fcr numeric;
  vl_cd_crt numeric;
  vl_valor_limite_utilizado numeric;
  vl_valor_limite_utilizado_sc numeric;
  vl_cartao numeric;
  vl_encargos numeric;
  rg_prc record;
  rg_tlt record;
  vl_tipo_pagamento numeric;
  vl_conta_cartao numeric;
  vl_conta_baixa numeric;
  vl_tipo_lancamento_estorno numeric;
  vl_data_pagamento timestamp;
  vl_cod_pagamento numeric;

begin

  select pfc.vl_pfc, fcr.cd_fcr, fcr.cd_crt, pfc.cd_tpc
    into vl_valor_pago, vl_cd_fcr, vl_cd_crt, vl_tipo_pagamento
  from sc_fcr.tbl_pfc pfc
    inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr  = pfc.cd_fcr
  where pfc.cd_pfc = vp_cd_pfc;

  -- estorno dos lancamentos
  perform sc_cnt.cancelar_lancamento(ct_cd_sst_baixa_fatura, vp_cd_pfc, vp_usuario, 'ESTORNO DE PAGAMENTO DA FATURA ' || vl_cd_fcr, null, null);

  -- caso o tipo de pagamento seja ESTORNO
  -- estornar também o crédito dado ao cliente no cartão
  if vl_tipo_pagamento = 4 then

    select pfc.dt_pgt_pfc, pfc.cd_pfc, cc.cd_cnt, tpc.cd_cnt, tlc.cd_est_tlc
    into vl_data_pagamento, vl_cod_pagamento, vl_conta_cartao, vl_conta_baixa, vl_tipo_lancamento_estorno
    from sc_fcr.tbl_pfc pfc
      inner join sc_fcr.tbl_tpc tpc on tpc.cd_tpc = pfc.cd_tpc
      inner join sc_cnt.tbl_tlc tlc on tlc.cd_tlc = tpc.cd_tlc
      inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr  = pfc.cd_fcr
      inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = fcr.cd_crt
    where pfc.cd_pfc = vp_cd_pfc;

    perform sc_cnt.lancar_debito_credito(vl_conta_cartao,
  					      vl_conta_baixa,
                                              vl_tipo_lancamento_estorno,
                                              null,
                                              'ESTORNO TRANSFERENCIA PARA BAIXA DE FATURA',
                                              vl_valor_pago::double precision,
                                              vl_data_pagamento::timestamp,
                                              vp_usuario,
                                              ct_cd_sst_baixa_fatura,
                                              vl_cod_pagamento);
  
  end if; 

  --atualizar o limite a ser restituido por pagamento
  for rg_tlt in select *
                from sc_fcr.tbl_pfc_tlt
                where cd_pfc = vp_cd_pfc loop
                
      update sc_fcr.tbl_fcr_tlt 
      set vl_rst_fcr_tlt = coalesce(vl_rst_fcr_tlt,0) + rg_tlt.vl_pfc_tlt 
      where cd_fcr = vl_cd_fcr
        and cd_tlt = rg_tlt.cd_tlt;
                
  end loop;              
                  
  
  -- atualizar pagamento para estornado
  update sc_fcr.tbl_pfc set st_pfc = 2 where cd_pfc = vp_cd_pfc;

  -- retirando o valor do pagamento nos valores pagos de parcela
  for rg_prc in select *
                from sc_fcr.tbl_pfc_prc
                where cd_pfc = vp_cd_pfc loop

        update sc_fcr.tbl_prc set vl_pgt_prc = coalesce(vl_pgt_prc,0) - rg_prc.vl_pfc_prc where cd_prc = rg_prc.cd_prc;        
  end loop;  

  -- reprocessando pagamentos de parcela da fatura
  perform sc_fcr.reprocessar_pagamentos_parcela(vl_cd_crt);

  -- calculando os encargos
  select sum( p.vl_prc - coalesce(p.vl_pgt_prc,0))
  into vl_encargos
  from sc_opr.tbl_crt c
     inner join sc_fcr.tbl_prc p on p.cd_crt = c.cd_crt
     inner join sc_opr.tbl_opr o on o.cd_opr = p.cd_opr
  where p.st_prc = 2    
     and o.cd_top <> 5
     and p.vl_prc - coalesce(p.vl_pgt_prc,0) > 0 
     and p.cd_fcr_atu_prc = vl_cd_fcr;

  -- atualizar saldo devedor da fatura e valor pago da fatura
  update sc_fcr.tbl_fcr set
    vl_sld_dvd_fcr = vl_sld_dvd_fcr + vl_valor_pago,
    vl_ttl_pgt_fcr = vl_ttl_pgt_fcr - vl_valor_pago,
    vl_rst_enc_fcr = vl_encargos,
    st_fcr = 1
  where cd_fcr = vl_cd_fcr;

  -- atualizar limite de saque extra do cartao 
  update sc_opr.tbl_lmt set vl_utl_lmt = ( 
     (select coalesce(sum(vl_prc-coalesce(vl_pgt_prc,0)), 0)
               from sc_fcr.tbl_prc p 
                          inner join sc_opr.tbl_opr o on o.cd_opr=p.cd_opr
                       where o.cd_top = 5
                         and p.cd_crt = vl_cd_crt) 
      +                    

      (select coalesce(sum(vl_opr),0)  
               from sc_opr.tbl_opr o 
                         inner join sc_opr.tbl_pls p on p.cd_pls = o.cd_pls
                         where  o.cd_top = 5
                         and o.st_opr in (1,2)
                         and o.dt_prc_opr is null
                         and p.cd_crt = vl_cd_crt)
	  +
       coalesce((select coalesce(vl_utl_lmt,0)
              from sc_mgr.tbl_lmt
                   where cd_crt = vl_cd_crt),0))

      where cd_crt = vl_cd_crt
        and cd_tlt = 1;  

  -- atualizar limite de compra do cartao
  update sc_opr.tbl_lmt  set vl_utl_lmt = ( 
     (select coalesce(sum(vl_prc-coalesce(vl_pgt_prc,0)),0)
               from sc_fcr.tbl_prc p 
                          inner join sc_opr.tbl_opr o on o.cd_opr=p.cd_opr
                       where o.cd_top = 27
                         and p.cd_crt = vl_cd_crt) 
      +                    

      (select coalesce(sum(coalesce(vl_crd_opr,0)),0)  
               from sc_opr.tbl_opr o 
                         inner join sc_opr.tbl_pls p on p.cd_pls = o.cd_pls
                         where  o.cd_top = 27
                         and o.st_opr in (2)
                         and o.dt_prc_opr is null
                         and p.cd_crt = vl_cd_crt))

      where cd_crt = vl_cd_crt
        and cd_tlt = 2;

end;$$;


ALTER FUNCTION sc_fcr.estorno_pagamento(vp_cd_pfc numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 7808 (class 0 OID 0)
-- Dependencies: 1180
-- Name: FUNCTION estorno_pagamento(vp_cd_pfc numeric, vp_usuario numeric); Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON FUNCTION estorno_pagamento(vp_cd_pfc numeric, vp_usuario numeric) IS 'estorno de pagamento de fatura';


--
-- TOC entry 1261 (class 1255 OID 1665024)
-- Name: estorno_pagamento_arquivo(integer, date); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION estorno_pagamento_arquivo(vp_codigo_arquivo_pagamento integer, vp_data_vencimento date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;
  
  CT_TIPO_PAGTO_CONTA_CARTAO constant integer := 1;
  CT_SITUACAO_CADASTRADO constant integer := 1;
begin
  for vl_rg in select pfc.cd_pfc, pfc.cd_inc_usr as usuario
               from sc_adp.tbl_rdp rdp
                    inner join sc_opr.tbl_crt crt on rdp.cd_crt = crt.cd_crt
                    inner join sc_fcr.tbl_fcr fcr on crt.cd_crt = fcr.cd_crt and fcr.dt_vnc_fcr = vp_data_vencimento
                    inner join sc_fcr.tbl_pfc pfc on fcr.cd_fcr = pfc.cd_fcr and pfc.cd_tpc = CT_TIPO_PAGTO_CONTA_CARTAO and pfc.st_pfc = CT_SITUACAO_CADASTRADO
               where rdp.cd_hfe = vp_codigo_arquivo_pagamento loop
    raise notice 'cancelando pagamento de código: %', vl_rg.cd_pfc;
    perform sc_fcr.estorno_pagamento(vl_rg.cd_pfc, vl_rg.usuario);    
  end loop;
end;$$;


ALTER FUNCTION sc_fcr.estorno_pagamento_arquivo(vp_codigo_arquivo_pagamento integer, vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 7809 (class 0 OID 0)
-- Dependencies: 1261
-- Name: FUNCTION estorno_pagamento_arquivo(vp_codigo_arquivo_pagamento integer, vp_data_vencimento date); Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON FUNCTION estorno_pagamento_arquivo(vp_codigo_arquivo_pagamento integer, vp_data_vencimento date) IS 'rotina que estorno todos os pagamentos gerados a partir da liberação de um determinado arquivo de depósito, e que foram realizados em uma fatura de cartão com um determinado vencimento';


--
-- TOC entry 1596 (class 1255 OID 989108)
-- Name: excluir_fatura(numeric, character varying, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION excluir_fatura(vp_fatura numeric, vp_motivo character varying, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_existe numeric;

begin

 select count(*)
   into vl_existe
   from sc_opr.tbl_crt
   where cd_fcr = vp_fatura;
   

 if vl_existe > 0 then
   raise exception 'Não é possivel excluir a fatura atual do cartão';
 else

   ALTER TABLE sc_fcr.tbl_fcr DISABLE TRIGGER ALL;
 
   insert into sc_fcr.tbl_fcr_exc(select fcr.*,now(),vp_usuario,vp_motivo from sc_fcr.tbl_fcr fcr where cd_fcr = vp_fatura);
   delete from sc_fcr.tbl_fcr where cd_fcr = vp_fatura;

   ALTER TABLE sc_fcr.tbl_fcr ENABLE TRIGGER ALL;
 end if;	       
  	       
   
end$$;


ALTER FUNCTION sc_fcr.excluir_fatura(vp_fatura numeric, vp_motivo character varying, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1320 (class 1255 OID 564361)
-- Name: gerar_boleto_fatura(numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_boleto_fatura(vp_qnt_dias_atraso numeric DEFAULT (3)::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin

  for rg in select *
            from sc_fcr.tbl_fcr fcr
              inner join sc_opr.tbl_crt crt on crt.cd_fcr = fcr.cd_fcr
            where fcr.st_fcr = 1
              and fcr.vl_sld_dvd_fcr > 0
              and current_date - dt_ini_atr_crt > vp_qnt_dias_atraso
              and not exists (select 1 from sc_cbr.tbl_blt blt where blt.nr_nsu_org_blt = fcr.cd_fcr and blt.tp_org_blt = 2) loop

    perform sc_cbr.gerar_boleto(2, 2, rg.cd_fcr);
    
  end loop;
  
end;$$;


ALTER FUNCTION sc_fcr.gerar_boleto_fatura(vp_qnt_dias_atraso numeric) OWNER TO scan;

--
-- TOC entry 1325 (class 1255 OID 564362)
-- Name: gerar_fatura_cartao(numeric, date, date, boolean, boolean); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_fatura_cartao(vp_cartao numeric, vp_data_apuracao date, vp_data_vencimento date, vp_alterar_prx_vnc boolean DEFAULT true, vp_cobrar_juros_multa boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg_prc record;
  vl_cod_fatura_atual sc_fcr.tbl_fcr.cd_fcr%type;
  vl_saldo_devedor_atual sc_fcr.tbl_fcr.vl_fcr%type := 0;
  vl_total_pagamento_atual sc_fcr.tbl_fcr.vl_fcr%type := 0;
  vl_a_ser_restituido_enc sc_fcr.tbl_fcr.vl_rst_enc_fcr%type := 0;
  vl_qtd_parcelas numeric(2,0) := 0;
  vl_cod_nova_fatura sc_fcr.tbl_fcr.cd_fcr%type;
  vl_data_fim_atraso sc_opr.tbl_crt.dt_fim_atr_crt%type;
  vl_valor_nova_fatura sc_fcr.tbl_fcr.vl_fcr%type := 0;
  vl_dt_novo_vencimento sc_opr.tbl_crt.dt_prx_vnc_crt%type;
  vl_multa numeric(13,2) := 0;
  vl_juros numeric(13,2) := 0;
  vl_st_fcr numeric(5,0);
  vl_st_cartao varchar(2);
  vl_cod_contrato numeric;
  
  vl_valor_tipo_limite sc_fcr.tbl_fcr_tlt.vl_ttl_fcr_tlt%type;
  
  vl_cod_operacao_mlt sc_opr.tbl_opr.cd_opr%type;
  vl_nm_operacao_mlt sc_opr.tbl_top.nm_top%type;
  
  vl_cod_operacao_jrs sc_opr.tbl_opr.cd_opr%type;
  vl_nm_operacao_jrs sc_opr.tbl_top.nm_top%type;

  TP_OPERACAO_MULTA sc_opr.tbl_top.cd_top%type := 5;
  TP_OPERACAO_JUROS sc_opr.tbl_top.cd_top%type := 6;

  PRM_NM_PRC_MNM_FCR sc_cad.tbl_prm.nm_prm%type := 'PRC_VL_MNM_FCR';
  vl_prc_vl_mnm_fcr numeric(13,2);
  vl_valor_minimo sc_fcr.tbl_fcr.vl_mnm_fcr%type;

  vl_valor_tarifa numeric := 0;

  vl_dia_venc_contrato varchar(2);

  vl_data_prox_vencimento date;
  vl_data_prox_apuracao date;
  
begin
   
   -- Obtendo informacoes atual do cartao
   select crt.cd_fcr,
         coalesce(fcr.vl_sld_dvd_fcr,0),
         coalesce(fcr.vl_ttl_pgt_fcr,0),
         coalesce(fcr.vl_rst_enc_fcr,0),
         case when crt.dt_fim_atr_crt is null then crt.dt_ini_atr_crt else dt_fim_atr_crt end,
         crt.dt_prx_vnc_crt,
         fcr.st_fcr,
         crt.fg_atv_crt,
         crt.cd_ctr
   into vl_cod_fatura_atual,
        vl_saldo_devedor_atual,
        vl_total_pagamento_atual,
        vl_a_ser_restituido_enc,
        vl_data_fim_atraso,
        vl_dt_novo_vencimento,
        vl_st_fcr,
        vl_st_cartao,
        vl_cod_contrato
   from sc_opr.tbl_crt crt
     left join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
   where crt.cd_crt = vp_cartao;

  if vl_st_fcr in (3,4,5) then
    vl_saldo_devedor_atual := 0;
  end if;
     
   select nextval('sc_fcr.sq_fcr') into vl_cod_nova_fatura;
   
   -- Para cada parcela a ser faturada com a data de vencimento dentro do período de apuracao
   for rg_prc in select top_tlt.cd_tlt,
			sum(case when prc.fg_dcr_prc = 'D' then prc.vl_prc else prc.vl_prc*-1 end) valor_nova_fatura
		 from sc_fcr.tbl_prc prc
		   inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
		   inner join sc_opr.tbl_crt crt on crt.cd_crt = prc.cd_crt
		   inner join sc_opr.tbl_top_tlt top_tlt on top_tlt.cd_top = opr.cd_top
		   left join sc_fcr.tbl_fcr_tlt fcr_tlt on fcr_tlt.cd_tlt = top_tlt.cd_tlt and fcr_tlt.cd_fcr = crt.cd_fcr
		 where prc.st_prc = 1 -- Situacao cadastrada
		   and prc.cd_crt = vp_cartao
		   and prc.dt_vnc_prc <= coalesce(vp_data_apuracao,vl_dt_novo_vencimento)
		 group by top_tlt.cd_tlt loop

     insert into sc_fcr.tbl_fcr_tlt(cd_fcr,cd_tlt,vl_ttl_fcr_tlt,vl_rst_fcr_tlt)
	   values(vl_cod_nova_fatura, rg_prc.cd_tlt, rg_prc.valor_nova_fatura, rg_prc.valor_nova_fatura);
   
     vl_valor_nova_fatura := vl_valor_nova_fatura + rg_prc.valor_nova_fatura;
	
   end loop;

   if vl_valor_nova_fatura > 0 or coalesce(vl_st_fcr,0) <> 6 then 

	    
	   -- Rotina que atualiza os limites a serem restituidos na fatura atual herdando o "a restituir" da fatura anterior 
	   perform sc_fcr.herdar_fatura_anterior(vl_cod_fatura_atual,vl_cod_nova_fatura);
	   
	   vl_valor_tarifa := sc_fcr.cobrar_tarifa(vp_cartao, vl_cod_nova_fatura, vp_data_apuracao);
	   --vl_valor_tarifa := 0;

	   -- se o cartao estiver inativo e nao possuir saldo devedor nao eh necessario a cobranca de juros e multa
	   -- pois o valor principal jah foi recebido
	   if (vl_st_cartao = 'N' and vl_saldo_devedor_atual = 0) then
		vp_cobrar_juros_multa := false;
	   end if;	
	   
	  
	   if (vp_cobrar_juros_multa) then

	   vl_juros := 0;/*sc_fcr.cobrar_juros(vp_cartao,
					   vl_cod_fatura_atual,
					   vl_cod_nova_fatura,
					   coalesce(vp_data_vencimento,vl_dt_novo_vencimento)); */
	   vl_multa := 0;/*sc_fcr.cobrar_multa(vp_cartao,
					   vl_cod_fatura_atual,
					   vl_cod_nova_fatura,
					   vl_data_fim_atraso,
					   coalesce(vp_data_vencimento,vl_dt_novo_vencimento));*/
	   end if;                                          
		
	   -- Obtendo o valor a ser restituido de encargos
	   vl_a_ser_restituido_enc := vl_a_ser_restituido_enc + coalesce(vl_multa,0) + coalesce(vl_juros,0) + coalesce(vl_valor_tarifa,0);
	   
	   -- Calculando o valor total da fatura
	   vl_valor_nova_fatura := vl_valor_nova_fatura +
				    coalesce(vl_saldo_devedor_atual,0) + 
				    coalesce(vl_multa,0) + 
				    coalesce(vl_juros,0) + 
				    coalesce(vl_valor_tarifa, 0);
	   
	    -- Calculando o valor minimo da fatura
	    select prm.vl_prm
	    into vl_prc_vl_mnm_fcr
	    from sc_cad.tbl_prm prm
	    where prm.nm_prm = PRM_NM_PRC_MNM_FCR;
	   
	    vl_valor_minimo := vl_valor_nova_fatura * ( vl_prc_vl_mnm_fcr / 100 );
		
	    if (vl_valor_nova_fatura > 0) then
	      -- Inserindo a fatura
	      insert into sc_fcr.tbl_fcr(cd_fcr,cd_crt,vl_fcr,dt_vnc_fcr,vl_sld_dvd_fcr,dt_ems_fcr,st_fcr,nr_dia_atr_fcr,
					 vl_jrs_fcr,vl_trf_fcr,vl_mlt_fcr,vl_rst_enc_fcr,vl_mnm_fcr,cd_ant_fcr, dt_vnc_org_fcr) 
	      values(vl_cod_nova_fatura,vp_cartao,vl_valor_nova_fatura,coalesce(vp_data_vencimento,vl_dt_novo_vencimento),
		     vl_valor_nova_fatura,now(),1,sc_fcr.calcula_dias_atraso_cartao(current_date,vp_cartao),vl_juros,vl_valor_tarifa,vl_multa,vl_a_ser_restituido_enc,vl_valor_minimo,vl_cod_fatura_atual, coalesce(vp_data_vencimento,vl_dt_novo_vencimento));

		  -- Marcando as parcelas como faturadas
	      update sc_fcr.tbl_prc set 
		cd_fcr = vl_cod_nova_fatura,
		cd_fcr_atu_prc = vl_cod_nova_fatura,
		st_prc = 2
	      where cd_prc in (select prc.cd_prc
			       from sc_fcr.tbl_prc prc
			       where prc.st_prc = 1 -- Situacao cadastrada
				 and prc.cd_crt = vp_cartao
				 and prc.dt_vnc_prc <= COALESCE(vp_data_apuracao,vl_dt_novo_vencimento)); 
				
	      -- Informando o código da ultima fatura do cartao
	      update sc_opr.tbl_crt set 
		cd_fcr = vl_cod_nova_fatura 
	      where cd_crt = vp_cartao;
		
	      -- Alterando a situacao da fatura atual para fechada
	      if (vl_cod_fatura_atual is not null) then
		update sc_fcr.tbl_fcr set 
		  st_fcr = 2
		where cd_fcr = vl_cod_fatura_atual
		  and st_fcr not in (3,4,5);
	      end if;   

	      -- controlando operacoes da fatura para ajudar na receita
	      perform sc_fcr.atualiza_fatura_operacao(vl_cod_nova_fatura, vl_cod_fatura_atual);

	       -- Herdando parcelas nao pagas
	      update sc_fcr.tbl_prc 
		 set cd_fcr_atu_prc = vl_cod_nova_fatura 
	      where cd_fcr_atu_prc = vl_cod_fatura_atual 
		and (vl_prc - coalesce(vl_pgt_prc,0)) > 0;


	    end if;
    end if;	    

    if vp_alterar_prx_vnc then

      if vl_st_cartao = 'S' then

          select trim(to_char(vl_pce_ctr::numeric,'00'))
          into vl_dia_venc_contrato
           from sc_cad.tbl_pce_ctr
            where cd_ctr = vl_cod_contrato 
              and cd_pce = 1;

          vl_data_prox_vencimento := vl_dt_novo_vencimento + INTERVAL '1 month';

          if vl_dia_venc_contrato::numeric > sc_pbl.ultimo_dia_mes(vl_data_prox_vencimento) then

             vl_dia_venc_contrato := trim(to_char(sc_pbl.ultimo_dia_mes(vl_data_prox_vencimento),'00'));

          end if;

          vl_data_prox_vencimento := to_date(vl_dia_venc_contrato || '/' || to_char(vl_data_prox_vencimento,'mm/yyyy'),'dd/mm/yyyy');
          
      else

          vl_data_prox_vencimento := vl_dt_novo_vencimento + INTERVAL '1 month';

      end if;

     -- Regra para desconsiderar o dia 31 da data de corte 

      vl_data_prox_apuracao := vl_data_prox_vencimento - INTERVAL '5 day';

      if(to_char(vl_data_prox_apuracao,'dd') = '31') then
	  vl_data_prox_apuracao := vl_data_prox_apuracao - INTERVAL '1 day';
      end if;

      -- 
      update sc_opr.tbl_crt set 
        dt_prx_vnc_crt = vl_data_prox_vencimento,
        dt_prx_apr_crt = vl_data_prox_apuracao
      where cd_crt = vp_cartao;
    end if;
               
end;$$;


ALTER FUNCTION sc_fcr.gerar_fatura_cartao(vp_cartao numeric, vp_data_apuracao date, vp_data_vencimento date, vp_alterar_prx_vnc boolean, vp_cobrar_juros_multa boolean) OWNER TO scan;

--
-- TOC entry 7810 (class 0 OID 0)
-- Dependencies: 1325
-- Name: FUNCTION gerar_fatura_cartao(vp_cartao numeric, vp_data_apuracao date, vp_data_vencimento date, vp_alterar_prx_vnc boolean, vp_cobrar_juros_multa boolean); Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON FUNCTION gerar_fatura_cartao(vp_cartao numeric, vp_data_apuracao date, vp_data_vencimento date, vp_alterar_prx_vnc boolean, vp_cobrar_juros_multa boolean) IS 'Rotina que gera as faturas de cartao';


--
-- TOC entry 1321 (class 1255 OID 564365)
-- Name: gerar_fatura_data_apuracao(date); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_fatura_data_apuracao(vp_data_apuracao date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg_cartao record;
begin

   for rg_cartao in select crt.dt_prx_vnc_crt,
                           crt.dt_prx_apr_crt,
                           crt.cd_crt
                    from sc_opr.tbl_crt crt
                    where crt.dt_prx_apr_crt <= vp_data_apuracao loop 

	-- a data de apuracao passada no segundo parametro se refere a chamada data de CORTE	

         perform sc_fcr.gerar_fatura_cartao(rg_cartao.cd_crt,rg_cartao.dt_prx_vnc_crt,rg_cartao.dt_prx_vnc_crt);

       --  raise notice '% - gerou fatura cartao: %', clock_timestamp(),rg_cartao.cd_crt;

    end loop;                
end;

$$;


ALTER FUNCTION sc_fcr.gerar_fatura_data_apuracao(vp_data_apuracao date) OWNER TO scan;

--
-- TOC entry 7811 (class 0 OID 0)
-- Dependencies: 1321
-- Name: FUNCTION gerar_fatura_data_apuracao(vp_data_apuracao date); Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON FUNCTION gerar_fatura_data_apuracao(vp_data_apuracao date) IS 'Funcao que gera as faturas dos cartoes cuja data de apuracao é igual a data passada como parametro';


--
-- TOC entry 1322 (class 1255 OID 564366)
-- Name: gerar_fatura_data_apuracao(date, numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_fatura_data_apuracao(vp_data_apuracao date, vp_empresa numeric, vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg_cartao record;
begin

   for rg_cartao in select crt.dt_prx_vnc_crt,
                           crt.dt_prx_apr_crt,
                           crt.cd_crt
                    from sc_opr.tbl_crt crt
                      inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                    where crt.dt_prx_apr_crt = vp_data_apuracao 
                      and (fnc.cd_emp = vp_empresa or vp_empresa is null)
                      and (crt.cd_crt = vp_cartao or vp_cartao is null) loop 

	-- a data de apuracao passada no segundo parametro se refere a chamada data de CORTE	

         perform sc_fcr.gerar_fatura_cartao(rg_cartao.cd_crt,rg_cartao.dt_prx_vnc_crt,rg_cartao.dt_prx_vnc_crt);

         raise notice '% - gerou fatura cartao: %', clock_timestamp(),rg_cartao.cd_crt;

    end loop;                
end;

$$;


ALTER FUNCTION sc_fcr.gerar_fatura_data_apuracao(vp_data_apuracao date, vp_empresa numeric, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7812 (class 0 OID 0)
-- Dependencies: 1322
-- Name: FUNCTION gerar_fatura_data_apuracao(vp_data_apuracao date, vp_empresa numeric, vp_cartao numeric); Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON FUNCTION gerar_fatura_data_apuracao(vp_data_apuracao date, vp_empresa numeric, vp_cartao numeric) IS 'Funcao que gera as faturas dos cartoes cuja data de apuracao é igual a data passada como parametro';


--
-- TOC entry 1317 (class 1255 OID 564367)
-- Name: gerar_fatura_data_apuracao(date, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_fatura_data_apuracao(vp_data_apuracao date, vp_empresa numeric, vp_filial numeric, vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg_cartao record;
begin

   for rg_cartao in select crt.dt_prx_vnc_crt,
                           crt.dt_prx_apr_crt,
                           crt.cd_crt
                    from sc_opr.tbl_crt crt
                      inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                    where crt.dt_prx_apr_crt = vp_data_apuracao 
                      and (fnc.cd_emp = vp_empresa or vp_empresa is null)
                      and (crt.cd_crt = vp_cartao or vp_cartao is null)
                      and ((fnc.cd_emp = vp_empresa and fnc.cd_fem=vp_filial) or vp_empresa is null or vp_filial is null) loop 

	-- a data de apuracao passada no segundo parametro se refere a chamada data de CORTE	

         perform sc_fcr.gerar_fatura_cartao(rg_cartao.cd_crt,rg_cartao.dt_prx_vnc_crt,rg_cartao.dt_prx_vnc_crt);

         raise notice '% - gerou fatura cartao: %', clock_timestamp(),rg_cartao.cd_crt;

    end loop;                
end;

$$;


ALTER FUNCTION sc_fcr.gerar_fatura_data_apuracao(vp_data_apuracao date, vp_empresa numeric, vp_filial numeric, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1323 (class 1255 OID 564368)
-- Name: gerar_fatura_inconsistencia_data(); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_fatura_inconsistencia_data() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin

  for rg in
  select prc.vl_prc, prc.dt_vnc_prc,  crt.dt_prx_vnc_crt, crt.cd_crt, vl_sld_cnt, fcr.dt_vnc_fcr
from sc_fcr.tbl_prc prc
  inner join sc_opr.tbl_crt crt on crt.cd_crt = prc.cd_crt
  inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt
  inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cc.cd_cnt
  inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
where prc.dt_vnc_prc < crt.dt_prx_vnc_crt
  and prc.st_prc = 1  loop

  perform sc_fcr.gerar_fatura_cartao(rg.cd_crt, '10/12/2012', '10/12/2012', false);

end loop;

end;$$;


ALTER FUNCTION sc_fcr.gerar_fatura_inconsistencia_data() OWNER TO scan;

--
-- TOC entry 1801 (class 1255 OID 564369)
-- Name: gerar_parcelas(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_parcelas(vp_cartao numeric, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

begin

  perform sc_arq.gravarlinha('c:\\arquivo_scan\\log_job.txt',clock_timestamp() || ' - parcela via cartao');
  perform sc_fcr.gerar_parcelas_via_cartao_funcionario(vp_cartao, vp_empresa);
 
  perform sc_arq.gravarlinha('c:\\arquivo_scan\\log_job.txt',clock_timestamp() || ' - saque extra');
  perform sc_fcr.gerar_parcelas_saque_credito(vp_cartao, vp_empresa);
 
  perform sc_arq.gravarlinha('c:\\arquivo_scan\\log_job.txt',clock_timestamp() || ' - renegociacao');
  perform sc_fcr.gerar_parcelas_renegociacao(vp_cartao, vp_empresa);
 
  perform sc_arq.gravarlinha('c:\\arquivo_scan\\log_job.txt',clock_timestamp() || ' - transferencia divida');
  perform sc_fcr.gerar_parcelas_transferencia_divida(vp_cartao, vp_empresa);
 
  perform sc_arq.gravarlinha('c:\\arquivo_scan\\log_job.txt',clock_timestamp() || ' - solicitacao senha');
  perform sc_fcr.gerar_parcelas_solicitacao_senha(vp_cartao, vp_empresa);
 
  perform sc_arq.gravarlinha('c:\\arquivo_scan\\log_job.txt',clock_timestamp() || ' - compra');
  perform sc_fcr.gerar_parcelas_compra_avista(vp_cartao, vp_empresa);
 
  perform sc_arq.gravarlinha('c:\\arquivo_scan\\log_job.txt',clock_timestamp() || ' - cancelamento de compra');
  perform sc_fcr.gerar_parcelas_cancelamento_compra(vp_cartao, vp_empresa);

end;$$;


ALTER FUNCTION sc_fcr.gerar_parcelas(vp_cartao numeric, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1608 (class 1255 OID 1664116)
-- Name: gerar_parcelas_cancelamento_compra(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_parcelas_cancelamento_compra(vp_cartao numeric, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE

  CT_TP_OPR_CANCELAMENTO_COMPRA constant numeric(2,0) := 26;
  CT_ST_OPR_CONFIRMADA constant numeric(2,0) := 2;
  CT_ST_PRC_CADASTRADA constant numeric(2,0) := 1;

  CT_DATA_INICIAL_STATIX constant date := '2019-05-06';

  vl_descricao varchar(50);
  rg record;
BEGIN

   for rg in select crt.cd_crt,
		    crt.dt_prx_vnc_crt,
                    opr.vl_crd_opr,
                    opr.cd_opr,
                    opr.cd_top,
                    fet.nm_fet
             from sc_opr.tbl_opr opr
               inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
               inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
               inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
               inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
               inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
             where opr.cd_top IN (CT_TP_OPR_CANCELAMENTO_COMPRA)
               and opr.dt_prc_opr is null
               and opr.st_opr = CT_ST_OPR_CONFIRMADA
               and opr.dt_opr >= CT_DATA_INICIAL_STATIX
               and (crt.cd_crt = vp_cartao or vp_cartao is null) 
               and (fnc.cd_emp = vp_empresa or vp_empresa is null)
               and coalesce(opr.vl_crd_opr,0) > 0 loop

        vl_descricao := 'CANCELAMENTO ' || substring(rg.nm_fet,0,36);

	insert into sc_fcr.tbl_prc(cd_prc,cd_crt,vl_prc,fg_dcr_prc,st_prc,cd_opr,ds_prc,dt_grc_prc,dt_vnc_prc,nr_prc)
	values(nextval('sc_fcr.sq_prc'),rg.cd_crt,rg.vl_crd_opr,'C',CT_ST_PRC_CADASTRADA,rg.cd_opr,vl_descricao,now(),rg.dt_prx_vnc_crt,1);

	update sc_opr.tbl_opr set dt_prc_opr = clock_timestamp() where cd_opr = rg.cd_opr;
               
   end loop;
   
END;$$;


ALTER FUNCTION sc_fcr.gerar_parcelas_cancelamento_compra(vp_cartao numeric, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1847 (class 1255 OID 1037602)
-- Name: gerar_parcelas_compra_avista(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_parcelas_compra_avista(vp_cartao numeric, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE

  VL_TIPO_OPERACAO_COMPRA_AVISTA numeric(2,0) := 27;
  VL_SITUACAO_OPERACAO_CONFIRMADA numeric(2,0) := 2;
  VL_SITUACAO_PARCELA_CADASTRADA numeric(2,0) := 1;

  vl_descricao varchar(50);
  rg record;
BEGIN

   for rg in select crt.cd_crt,
		    crt.dt_prx_vnc_crt,
                    opr.vl_crd_opr,
                    opr.cd_opr,
                    opr.cd_top,
                    fet.nm_fet
             from sc_opr.tbl_opr opr
               inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
               inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
               inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
               inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
               inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
             where opr.cd_top IN (VL_TIPO_OPERACAO_COMPRA_AVISTA)
               and opr.dt_prc_opr is null
               and opr.st_opr = 2
               and (crt.cd_crt = vp_cartao or vp_cartao is null) 
               and (fnc.cd_emp = vp_empresa or vp_empresa is null)
               and coalesce(opr.vl_crd_opr,0) > 0 loop

        if (rg.cd_top = VL_TIPO_OPERACAO_COMPRA_AVISTA) then
          vl_descricao := 'COMPRA A VISTA ' || substring(rg.nm_fet,0,36);
        end if;

	insert into sc_fcr.tbl_prc(cd_prc,cd_crt,vl_prc,fg_dcr_prc,st_prc,cd_opr,ds_prc,dt_grc_prc,dt_vnc_prc,nr_prc)
	values(nextval('sc_fcr.sq_prc'),rg.cd_crt,rg.vl_crd_opr,'D',VL_SITUACAO_PARCELA_CADASTRADA,rg.cd_opr,vl_descricao,now(),rg.dt_prx_vnc_crt,1);

	update sc_opr.tbl_opr set dt_prc_opr = clock_timestamp() where cd_opr = rg.cd_opr;
               
   end loop;
   
END;$$;


ALTER FUNCTION sc_fcr.gerar_parcelas_compra_avista(vp_cartao numeric, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1324 (class 1255 OID 564370)
-- Name: gerar_parcelas_e_cobrar_servicos(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_parcelas_e_cobrar_servicos(vp_cartao numeric, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

begin

  perform sc_fcr.gerar_parcelas(vp_cartao, vp_empresa);
  perform sc_srv.cobrar_servico_saque_arredondado(vp_cartao, current_date);
  
end;$$;


ALTER FUNCTION sc_fcr.gerar_parcelas_e_cobrar_servicos(vp_cartao numeric, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1789 (class 1255 OID 564371)
-- Name: gerar_parcelas_renegociacao(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_parcelas_renegociacao(vp_cartao numeric, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE

  VL_TIPO_OPERACAO_RENEGOCIACAO numeric(2,0) := 15;
  VL_SITUACAO_OPERACAO_CONFIRMADA numeric(2,0) := 2;
  VL_SITUACAO_PARCELA_CADASTRADA numeric(2,0) := 1;

  vl_descricao varchar(50);
  rg record;

  cont numeric;
  data_vencimento date;
BEGIN

   for rg in select crt.cd_crt,
		    crt.dt_prx_vnc_crt,
                    opr.vl_opr,
                    opr.cd_opr,
                    opr.cd_top,
                    opr.nr_prc_opr,
                    opr.vl_prc_opr
             from sc_opr.tbl_opr opr
               inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
               inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
               inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
               inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
             where opr.cd_top IN (VL_TIPO_OPERACAO_RENEGOCIACAO)
               and opr.dt_prc_opr is null
               and opr.st_opr = VL_SITUACAO_OPERACAO_CONFIRMADA
               and (crt.cd_crt = vp_cartao or vp_cartao is null) 
               and (fnc.cd_emp = vp_empresa or vp_empresa is null) loop

        data_vencimento := rg.dt_prx_vnc_crt;
	cont := 1;
	
        while cont <= rg.nr_prc_opr loop 

          vl_descricao := 'PARCELA RENEGOCIACAO ' || cont || '/' || rg.nr_prc_opr;
        
	  insert into sc_fcr.tbl_prc(cd_prc,cd_crt,vl_prc,fg_dcr_prc,st_prc,cd_opr,ds_prc,dt_grc_prc,dt_vnc_prc,nr_prc)
	  values(nextval('sc_fcr.sq_prc'),rg.cd_crt,rg.vl_prc_opr,'D',VL_SITUACAO_PARCELA_CADASTRADA,rg.cd_opr,vl_descricao,now(),data_vencimento,cont);

          cont := cont + 1;
          data_vencimento := data_vencimento + interval '1 months';
        end loop;

	update sc_opr.tbl_opr set dt_prc_opr = clock_timestamp() where cd_opr = rg.cd_opr;
               
   end loop;
   
END;$$;


ALTER FUNCTION sc_fcr.gerar_parcelas_renegociacao(vp_cartao numeric, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1327 (class 1255 OID 564372)
-- Name: gerar_parcelas_saque_credito(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_parcelas_saque_credito(vp_cartao numeric, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE

  VL_TIPO_OPERACAO_SAQUE_CREDITO numeric(2,0) := 5;
  VL_TIPO_OPERACAO_ENCARGOS_SAQUE_CREDITO numeric(2,0) := 9;
  VL_SITUACAO_OPERACAO_CONFIRMADA numeric(2,0) := 2;
  VL_SITUACAO_PARCELA_CADASTRADA numeric(2,0) := 1;

  vl_descricao varchar(50);
  rg record;
BEGIN

   for rg in select crt.cd_crt,
		    crt.dt_prx_vnc_crt,
                    opr.vl_opr,
                    opr.cd_opr,
                    atm.nm_atm,
                    opr.cd_top
             from sc_opr.tbl_opr opr
               inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
               inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
               inner join sc_rds.tbl_atm atm on atm.cd_atm = opr.cd_atm
               inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
               inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
             where opr.cd_top IN (VL_TIPO_OPERACAO_SAQUE_CREDITO,VL_TIPO_OPERACAO_ENCARGOS_SAQUE_CREDITO)
               and opr.dt_prc_opr is null
               and opr.st_opr = VL_SITUACAO_OPERACAO_CONFIRMADA
               and (crt.cd_crt = vp_cartao or vp_cartao is null) 
               and (fnc.cd_emp = vp_empresa or vp_empresa is null) loop

        if (rg.cd_top = VL_TIPO_OPERACAO_SAQUE_CREDITO) then
          vl_descricao := 'SAQUE CREDITO - ATM ' || rg.nm_atm;
        else
          vl_descricao := 'ENCARGOS SAQUE CREDITO - ATM ' || rg.nm_atm;
        end if;

	insert into sc_fcr.tbl_prc(cd_prc,cd_crt,vl_prc,fg_dcr_prc,st_prc,cd_opr,ds_prc,dt_grc_prc,dt_vnc_prc,nr_prc)
	values(nextval('sc_fcr.sq_prc'),rg.cd_crt,rg.vl_opr,'D',VL_SITUACAO_PARCELA_CADASTRADA,rg.cd_opr,vl_descricao,now(),rg.dt_prx_vnc_crt,1);

	update sc_opr.tbl_opr set dt_prc_opr = clock_timestamp() where cd_opr = rg.cd_opr;
               
   end loop;
   
END;$$;


ALTER FUNCTION sc_fcr.gerar_parcelas_saque_credito(vp_cartao numeric, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1328 (class 1255 OID 564373)
-- Name: gerar_parcelas_solicitacao_senha(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_parcelas_solicitacao_senha(vp_cartao numeric, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_tipo_operacao_solicitacao_senha numeric(2,0) := 17;
  vl_situacao_operacao_confirmada numeric(2,0) := 2;
  vl_situacao_parcela_cadastrada numeric(2,0) := 1;

  rg record;
begin

   for rg in select crt.cd_crt,
		    crt.dt_prx_vnc_crt,
                    opr.vl_opr,
                    opr.cd_opr,
                    opr.cd_top
             from sc_opr.tbl_opr opr
               inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
               inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
               inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
               inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
               inner join sc_ssp.tbl_ssp ssp on ssp.cd_pls = pls.cd_pls
             where opr.cd_top in (vl_tipo_operacao_solicitacao_senha)
               and opr.dt_prc_opr is null
               and opr.st_opr = vl_situacao_operacao_confirmada
               and ssp.fg_cbr_emi_ssp = 'S'
               and ssp.tp_ssp = 2
               and (crt.cd_crt = vp_cartao or vp_cartao is null) 
               and (fnc.cd_emp = vp_empresa or vp_empresa is null) loop

	insert into sc_fcr.tbl_prc(cd_prc,cd_crt,vl_prc,fg_dcr_prc,st_prc,cd_opr,ds_prc,dt_grc_prc,dt_vnc_prc,nr_prc)
	values(nextval('sc_fcr.sq_prc'),rg.cd_crt,rg.vl_opr,'D',vl_situacao_parcela_cadastrada,rg.cd_opr,'SOLICITACAO DE SENHA',now(),rg.dt_prx_vnc_crt,1);

	update sc_opr.tbl_opr set dt_prc_opr = clock_timestamp() where cd_opr = rg.cd_opr;
               
   end loop;
   
end;$$;


ALTER FUNCTION sc_fcr.gerar_parcelas_solicitacao_senha(vp_cartao numeric, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1334 (class 1255 OID 564374)
-- Name: gerar_parcelas_transferencia_divida(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_parcelas_transferencia_divida(vp_cartao numeric, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_top_transferecia_divida numeric(2,0) := 16;
  ct_st_opr_confirmada numeric(2,0) := 2;
  ct_st_prc_cadastrada numeric(2,0) := 1;
  rg_opr record;
  vl_descricao varchar(50);

begin
  
  for rg_opr in select *
                from sc_opr.tbl_opr opr
                  inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
                  inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
                  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                  inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                  inner join sc_fcr.tbl_tfc tfc on tfc.cd_tfc = opr.nr_nsu_org_opr
                where opr.cd_top = ct_top_transferecia_divida
                  and opr.dt_prc_opr is null
                  and opr.st_opr = ct_st_opr_confirmada
                  and (crt.cd_crt = vp_cartao or vp_cartao is null) 
                  and (fnc.cd_emp = vp_empresa or vp_empresa is null) loop

    vl_descricao := 'TRANSF. DIVIDA CARTAO ' || rg_opr.cd_ant_crt;

    insert into sc_fcr.tbl_prc(cd_prc, cd_crt, vl_prc, fg_dcr_prc, st_prc, cd_opr, ds_prc, dt_grc_prc, dt_vnc_prc, nr_prc)
	  values(nextval('sc_fcr.sq_prc'), rg_opr.cd_crt, rg_opr.vl_prc_opr, 'D', ct_st_prc_cadastrada, rg_opr.cd_opr, vl_descricao, now(), rg_opr.dt_opr, 1);
	  
	update sc_opr.tbl_opr set dt_prc_opr = clock_timestamp() where cd_opr = rg_opr.cd_opr;

  end loop;

end;$$;


ALTER FUNCTION sc_fcr.gerar_parcelas_transferencia_divida(vp_cartao numeric, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1788 (class 1255 OID 564375)
-- Name: gerar_parcelas_via_cartao_funcionario(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION gerar_parcelas_via_cartao_funcionario(vp_cartao numeric, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_tipo_operacao_1_via_cartao numeric(2,0) := 10;
  vl_tipo_operacao_2_via_cartao numeric(2,0) := 11;
  vl_situacao_operacao_confirmada numeric(2,0) := 2;
  vl_situacao_parcela_cadastrada numeric(2,0) := 1;

  vl_descricao varchar(50);
  rg record;
begin

   for rg in select crt.cd_crt,
		    crt.dt_prx_vnc_crt,
                    opr.vl_opr,
                    opr.cd_opr,
                    opr.cd_top
             from sc_opr.tbl_opr opr
               inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
               inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
               inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
               inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
               inner join sc_ssp.tbl_ssp ssp on ssp.cd_pls = pls.cd_pls
             where opr.cd_top in (vl_tipo_operacao_1_via_cartao,vl_tipo_operacao_2_via_cartao)
               and opr.dt_prc_opr is null
               and opr.st_opr = vl_situacao_operacao_confirmada
               and ssp.fg_cbr_emi_ssp = 'S'
               and ssp.tp_ssp = 1 -- tipo plastico
               and (crt.cd_crt = vp_cartao or vp_cartao is null) 
               and (fnc.cd_emp = vp_empresa or vp_empresa is null) loop

        if (rg.cd_top = vl_tipo_operacao_1_via_cartao) then
          vl_descricao := 'PRIMEIRA VIA CARTAO';
        else
          vl_descricao := 'SEGUNDA VIA CARTAO';
        end if;

	insert into sc_fcr.tbl_prc(cd_prc,cd_crt,vl_prc,fg_dcr_prc,st_prc,cd_opr,ds_prc,dt_grc_prc,dt_vnc_prc,nr_prc)
	values(nextval('sc_fcr.sq_prc'),rg.cd_crt,rg.vl_opr,'D',vl_situacao_parcela_cadastrada,rg.cd_opr,vl_descricao,now(),rg.dt_prx_vnc_crt,1);

	update sc_opr.tbl_opr set dt_prc_opr = clock_timestamp() where cd_opr = rg.cd_opr;
               
   end loop;
   
end;$$;


ALTER FUNCTION sc_fcr.gerar_parcelas_via_cartao_funcionario(vp_cartao numeric, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1814 (class 1255 OID 1668905)
-- Name: get_valor_principal_ccb(numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION get_valor_principal_ccb(vp_fatura numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
   vl_principal numeric := 0;
   
   CT_TP_OPR_SAQUE_EXTRA constant numeric := 5;
begin
    -- Obtendo valor principal
    select sum(prc.vl_prc - coalesce(prc.vl_pgt_prc))
      into vl_principal
    from sc_fcr.tbl_prc prc
         inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
    where prc.cd_fcr_atu_prc = vp_fatura
      and opr.cd_top = CT_TP_OPR_SAQUE_EXTRA;

    return vl_principal;
end$$;


ALTER FUNCTION sc_fcr.get_valor_principal_ccb(vp_fatura numeric) OWNER TO scan;

--
-- TOC entry 1817 (class 1255 OID 1668906)
-- Name: get_valor_principal_compra(numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION get_valor_principal_compra(vp_fatura numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
   vl_principal numeric := 0;
   
   CT_TP_OPR_COMPRA constant numeric := 27;
begin
    -- Obtendo valor principal
    select sum(prc.vl_prc - coalesce(prc.vl_pgt_prc))
      into vl_principal
    from sc_fcr.tbl_prc prc
         inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
    where prc.cd_fcr_atu_prc = vp_fatura
      and opr.cd_top = CT_TP_OPR_COMPRA;

    return vl_principal;
end$$;


ALTER FUNCTION sc_fcr.get_valor_principal_compra(vp_fatura numeric) OWNER TO scan;

--
-- TOC entry 1509 (class 1255 OID 844348)
-- Name: get_valor_principal_devedor(numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION get_valor_principal_devedor(vp_fatura numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
   vl_principal numeric := 0;
begin

           -- Obtendo valor principal
        select sum(prc.vl_prc - coalesce(prc.vl_pgt_prc))
        into vl_principal
        from sc_fcr.tbl_prc prc
          inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
        where prc.cd_fcr_atu_prc = vp_fatura
          and opr.cd_top = 5;

        return vl_principal;  

          
end$$;


ALTER FUNCTION sc_fcr.get_valor_principal_devedor(vp_fatura numeric) OWNER TO scan;

--
-- TOC entry 1388 (class 1255 OID 564376)
-- Name: herdar_fatura_anterior(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION herdar_fatura_anterior(vp_fatura_atual numeric, vp_nova_fatura numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  ja_existe numeric;
BEGIN

  if vp_fatura_atual is not null then
  
    for rg in select fcr_tlt.cd_tlt,
                     fcr_tlt.vl_rst_fcr_tlt
              from sc_fcr.tbl_fcr_tlt fcr_tlt 
              where fcr_tlt.cd_fcr = vp_fatura_atual
                and coalesce(fcr_tlt.vl_rst_fcr_tlt,0) > 0 loop
                
                
        select count(*)
        into ja_existe
        from sc_fcr.tbl_fcr_tlt fcr_tlt
        where fcr_tlt.cd_tlt = rg.cd_tlt
          and fcr_tlt.cd_fcr = vp_nova_fatura;        
        
        if( ja_existe > 0 ) then
        
          update sc_fcr.tbl_fcr_tlt 
          set vl_rst_fcr_tlt = vl_rst_fcr_tlt + rg.vl_rst_fcr_tlt,
              vl_ttl_fcr_tlt = vl_ttl_fcr_tlt + rg.vl_rst_fcr_tlt
          where cd_tlt = rg.cd_tlt
            and cd_fcr = vp_nova_fatura;
        
        else
          
          insert into sc_fcr.tbl_fcr_tlt(cd_fcr,cd_tlt,vl_ttl_fcr_tlt,vl_rst_fcr_tlt)
		    values(vp_nova_fatura, rg.cd_tlt, rg.vl_rst_fcr_tlt, rg.vl_rst_fcr_tlt);
         
        end if;        
                

    end loop;

    
  end if;  
              
END;
$$;


ALTER FUNCTION sc_fcr.herdar_fatura_anterior(vp_fatura_atual numeric, vp_nova_fatura numeric) OWNER TO scan;

--
-- TOC entry 1524 (class 1255 OID 857971)
-- Name: insere_pagamento_parcela(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION insere_pagamento_parcela(vp_cod_parcela numeric, vp_cod_pagamento numeric, vp_valor numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

vl_parcela numeric;
vl_pago_parcela numeric;
vl_encargos_parcela numeric;
vl_pago_principal numeric;
vl_a_pagar_encargos numeric;

begin

    select prc.vl_prc, coaelsce(vl_pgt_prc,0),coalesce(opr.vl_jrs_opr,0) + coalesce(opr.vl_iof_opr,0) + coalesce(opr.vl_trf_opr,0)
    into vl_parcela,vl_pago_parcela,vl_encargos_parcela
    from sc_fcr.tbl_prc prc
      inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
    where cd_prc = vp_cod_parcela;

    -- Calculando quanto ainda falta pagar de encargos daquela parcela
    if vl_pago_parcela >= vl_encargos_parcela then
       vl_a_pagar_encargos := 0;
    else
       vl_a_pagar_encargos := vl_encargos_parcela - vl_pago_parcela; 
    end if;
    --
    

    if vl_a_pagar_encargos = 0 then
       vl_pago_principal := vp_valor;
    else
       vl_pago_principal := vp_valor - vl_a_pagar_encargos;
    end if;

    if vl_pago_principal < 0 then
       vl_pago_principal := 0;
    end if;

    insert into sc_fcr.tbl_pfc_prc(cd_pfc,cd_prc,vl_pfc_prc,vl_prn_pfc_prc) values(vp_cod_pagamento,vp_cod_parcela,vp_valor,vl_pago_principal);


end$$;


ALTER FUNCTION sc_fcr.insere_pagamento_parcela(vp_cod_parcela numeric, vp_cod_pagamento numeric, vp_valor numeric) OWNER TO scan;

--
-- TOC entry 1515 (class 1255 OID 564377)
-- Name: marcar_cartao_inadimplente(); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION marcar_cartao_inadimplente() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg_fcr sc_fcr.tbl_fcr%rowtype;
begin
  for vl_rg_fcr in select fcr.*
                    from sc_fcr.tbl_fcr fcr
                         inner join sc_opr.tbl_crt crt on fcr.cd_fcr = crt.cd_fcr
                    where dt_vnc_fcr < current_date
                      and vl_sld_dvd_fcr > 0 
                      and crt.fg_ind_crt = 'N' 
                      and fcr.st_fcr not in (3,4,5)
                      and sc_fcr.get_valor_principal_devedor(fcr.cd_fcr) > 0 -- cancelada, renegociada, transferencia de divida
  loop
    update sc_opr.tbl_crt
       set fg_ind_crt = 'S',
           dt_ini_atr_crt = vl_rg_fcr.dt_vnc_fcr
    where cd_crt = vl_rg_fcr.cd_crt;
  end loop;
end;$$;


ALTER FUNCTION sc_fcr.marcar_cartao_inadimplente() OWNER TO scan;

--
-- TOC entry 7813 (class 0 OID 0)
-- Dependencies: 1515
-- Name: FUNCTION marcar_cartao_inadimplente(); Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON FUNCTION marcar_cartao_inadimplente() IS 'rotina que marca os cartoes com fatura em aberto e atrasada como inadimplentes';


--
-- TOC entry 1647 (class 1255 OID 932402)
-- Name: prorrogar_fatura_cartao(numeric, date); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION prorrogar_fatura_cartao(vp_codigo_fatura numeric, vp_data_vencimento date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_data_vencimento date;
  rg record;
begin
    select dt_vnc_fcr
    into vl_data_vencimento
    from sc_fcr.tbl_fcr
    where cd_fcr = vp_codigo_fatura;

    if vp_data_vencimento <= vl_data_vencimento then
       raise exception 'A Fatura só pode ser prorrogada para uma data maior do que a atual.';
    end if;

    for rg in select cd_ccb
	      from sc_ccb.tbl_ccb ccb
	         inner join sc_opr.tbl_opr opr on opr.cd_opr = ccb.cd_opr
	         inner join sc_fcr.tbl_prc prc on prc.cd_opr = opr.cd_opr
	      where prc.cd_fcr_atu_prc = vp_codigo_fatura
	        and ccb.dt_vnc_ccb <= vp_data_vencimento loop

	perform sc_ccb.atualizar_ccb(rg.cd_ccb,vp_data_vencimento + 3);        
	      
    end loop;	         

    update sc_fcr.tbl_fcr set dt_vnc_fcr = vp_data_vencimento,cd_blt=null where cd_fcr = vp_codigo_fatura;
    
end$$;


ALTER FUNCTION sc_fcr.prorrogar_fatura_cartao(vp_codigo_fatura numeric, vp_data_vencimento date) OWNER TO scan;

--
-- TOC entry 1557 (class 1255 OID 564378)
-- Name: reprocessar_pagamentos_parcela(numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION reprocessar_pagamentos_parcela(vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  rg_pfc record;
  rg_prc record;
  vl_pago numeric;
  vl_restante numeric;
begin

   delete from sc_fcr.tbl_pfc_prc where cd_prc in (select prc.cd_prc 
                                                   from sc_fcr.tbl_prc prc
                                                      inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = prc.cd_fcr
                                                   where fcr.cd_crt=vp_cartao);
   update sc_fcr.tbl_prc set vl_pgt_prc =0 where cd_prc in (select prc.cd_prc 
                                                            from sc_fcr.tbl_prc prc
                                                               inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = prc.cd_fcr
                                                            where fcr.cd_crt=vp_cartao) ;  


   for rg in select fcr.cd_fcr,
                    fcr.cd_ant_fcr
             from sc_fcr.tbl_fcr fcr
             where fcr.cd_crt = vp_cartao
             order by fcr.cd_crt,fcr.cd_fcr loop

      raise notice 'fatura atual %, fatura ante %',rg.cd_fcr, rg.cd_ant_fcr;      


      update sc_fcr.tbl_prc set cd_fcr_atu_prc = rg.cd_fcr where cd_fcr = rg.cd_fcr;
      update sc_fcr.tbl_prc set cd_fcr_atu_prc = rg.cd_fcr where cd_fcr_atu_prc = rg.cd_ant_fcr and vl_prc - coalesce(vl_pgt_prc,0) > 0;

      for rg_pfc in select pfc.cd_pfc,
                           pfc.vl_pfc
                   from sc_fcr.tbl_pfc pfc
                   where pfc.cd_fcr = rg.cd_fcr
                     and pfc.st_pfc = 1 loop
                     
                vl_restante := rg_pfc.vl_pfc;       
                vl_pago := 0;
                raise notice 'pagamento %',rg_pfc.cd_pfc;
                
		for rg_prc in select prc.vl_prc - coalesce(vl_pgt_prc,0) valor_a_pagar,
		                     prc.cd_prc
			      from sc_fcr.tbl_prc prc
			        inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
			        inner join sc_opr.tbl_top top on top.cd_top = opr.cd_top
			      where prc.cd_fcr_atu_prc = rg.cd_fcr
				and vl_prc - vl_pgt_prc > 0
			      order by coalesce(top.ord_pri_rst_top,999),prc.cd_fcr, valor_a_pagar loop
			      
                raise notice 'parcela %',rg_prc.cd_prc;
				
			if vl_restante > rg_prc.valor_a_pagar then
			   vl_pago := rg_prc.valor_a_pagar;
			else
			   vl_pago := vl_restante;
			end if;	

			vl_restante := vl_restante - vl_pago;

			update sc_fcr.tbl_prc set vl_pgt_prc = vl_pgt_prc + vl_pago where cd_prc = rg_prc.cd_prc;
			
			insert into sc_fcr.tbl_pfc_prc values(rg_pfc.cd_pfc,rg_prc.cd_prc,vl_pago);

			if vl_restante = 0 then
			  exit;
			end if;
			
		end loop;                
                     
      end loop;
      
   end loop;          

end$$;


ALTER FUNCTION sc_fcr.reprocessar_pagamentos_parcela(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1551 (class 1255 OID 1632749)
-- Name: reprocessar_pagamentos_parcela(numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION reprocessar_pagamentos_parcela(vp_cartao numeric, vp_fatura numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  rg_pfc record;
  rg_prc record;
  vl_pago numeric;
  vl_restante numeric;
begin

   delete from sc_fcr.tbl_pfc_prc where cd_prc in (select prc.cd_prc 
                                                   from sc_fcr.tbl_prc prc
                                                      inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = prc.cd_fcr
                                                   where fcr.cd_crt=vp_cartao
                                                     and fcr.cd_fcr = coalesce(vp_fatura,fcr.cd_fcr));
   update sc_fcr.tbl_prc set vl_pgt_prc =0 where cd_prc in (select prc.cd_prc 
                                                            from sc_fcr.tbl_prc prc
                                                               inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = prc.cd_fcr
                                                            where fcr.cd_crt=vp_cartao
                                                              and fcr.cd_fcr = coalesce(vp_fatura,fcr.cd_fcr)) ;  


   for rg in select fcr.cd_fcr,
                    fcr.cd_ant_fcr
             from sc_fcr.tbl_fcr fcr
             where fcr.cd_crt = vp_cartao
               and fcr.cd_fcr = coalesce(vp_fatura,fcr.cd_fcr)
             order by fcr.cd_crt,fcr.cd_fcr loop

      raise notice 'fatura atual %, fatura ante %',rg.cd_fcr, rg.cd_ant_fcr;      


      update sc_fcr.tbl_prc set cd_fcr_atu_prc = rg.cd_fcr where cd_fcr = rg.cd_fcr;
      update sc_fcr.tbl_prc set cd_fcr_atu_prc = rg.cd_fcr where cd_fcr_atu_prc = rg.cd_ant_fcr and vl_prc - coalesce(vl_pgt_prc,0) > 0;

      for rg_pfc in select pfc.cd_pfc,
                           pfc.vl_pfc
                   from sc_fcr.tbl_pfc pfc
                   where pfc.cd_fcr = rg.cd_fcr
                     and pfc.st_pfc = 1 loop
                     
                vl_restante := rg_pfc.vl_pfc;       
                vl_pago := 0;
                raise notice 'pagamento %',rg_pfc.cd_pfc;
                
		for rg_prc in select prc.vl_prc - coalesce(vl_pgt_prc,0) valor_a_pagar,
		                     prc.cd_prc
			      from sc_fcr.tbl_prc prc
			        inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
			        inner join sc_opr.tbl_top top on top.cd_top = opr.cd_top
			      where prc.cd_fcr_atu_prc = rg.cd_fcr
				and vl_prc - vl_pgt_prc > 0
			      order by coalesce(top.ord_pri_rst_top,999),prc.cd_fcr, valor_a_pagar loop
			      
                raise notice 'parcela %',rg_prc.cd_prc;
				
			if vl_restante > rg_prc.valor_a_pagar then
			   vl_pago := rg_prc.valor_a_pagar;
			else
			   vl_pago := vl_restante;
			end if;	

			vl_restante := vl_restante - vl_pago;

			update sc_fcr.tbl_prc set vl_pgt_prc = vl_pgt_prc + vl_pago where cd_prc = rg_prc.cd_prc;
			
			insert into sc_fcr.tbl_pfc_prc values(rg_pfc.cd_pfc,rg_prc.cd_prc,vl_pago);

			if vl_restante = 0 then
			  exit;
			end if;
			
		end loop;                
                     
      end loop;
      
   end loop;          

end$$;


ALTER FUNCTION sc_fcr.reprocessar_pagamentos_parcela(vp_cartao numeric, vp_fatura numeric) OWNER TO scan;

--
-- TOC entry 1333 (class 1255 OID 564379)
-- Name: transferir_divida_cartao(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_fcr; Owner: scan
--

CREATE FUNCTION transferir_divida_cartao(vp_fatura numeric, vp_plastico numeric, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_st_fcr_transferencia_divida numeric(2,0) := 5;
  ct_top_transferencia_divida numeric(2,0) := 16;
  ct_tlt_saque_extra numeric(1,0) := 1;
  ct_st_prc_transferencia_divida numeric(2,0) := 4;
  ct_st_prc_a_faturar numeric(2,0) := 1;

  vl_cd_tfc numeric(10,0);
  vl_cd_crt_ant numeric(14,0);
  vl_cd_crt_atl numeric(14,0);
  vl_vl_fcr numeric(13,2);
  vl_cd_operacao numeric(10,0);
  vl_gerar_fatura boolean;

  rg_prc record;

begin
  
  select fcr.cd_crt, fcr.vl_sld_dvd_fcr
    into vl_cd_crt_ant, vl_vl_fcr
  from sc_fcr.tbl_fcr fcr
  where fcr.cd_fcr = vp_fatura;

  select pls.cd_crt
    into vl_cd_crt_atl
  from sc_opr.tbl_pls pls
  where pls.cd_pls = vp_plastico;
  
  -- alterar a situação para transferencia de divida
  update sc_fcr.tbl_fcr set st_fcr = ct_st_fcr_transferencia_divida where cd_fcr = vp_fatura;

  -- gravar uma auditoria de transferencia de divida
  select nextval('sc_fcr.sq_tfc') into vl_cd_tfc;

  insert into sc_fcr.tbl_tfc (cd_tfc, cd_ant_crt, cd_atl_crt, cd_fcr, cd_inc_usr, dt_inc_usr)
    values (vl_cd_tfc, vl_cd_crt_ant, vl_cd_crt_atl, vp_fatura, vp_usuario, now());

  -- gravar operacao de transferencia de divida no novo cartao
  select nextval('sc_opr.sq_opr') into vl_cd_operacao;
  insert into sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, dt_opr, vl_opr, vl_jrs_opr, vl_trf_opr,
                             nr_nsu_org_opr, nr_prc_opr, vl_prc_opr, vl_iof_opr, st_opr)
    values(vl_cd_operacao, ct_top_transferencia_divida, vp_plastico, now(), vl_vl_fcr, 0, 0,
           vl_cd_tfc, 1, vl_vl_fcr, 0, 2);
           
  -- atualizar o limite para ficar consumido
  update sc_opr.tbl_lmt set 
    vl_utl_lmt = coalesce(vl_utl_lmt, 0) + vl_vl_fcr 
  where cd_crt = vl_cd_crt_atl 
  and cd_tlt = ct_tlt_saque_extra;

  -- gerar parcelas do cartão anterior
  perform sc_fcr.gerar_parcelas(vl_cd_crt_ant, null);

  -- transferir parcelas que não foram faturadas
  for rg_prc in select *
                from sc_fcr.tbl_prc prc
                where prc.cd_fcr is null 
                  and prc.cd_crt = vl_cd_crt_ant 
                  and prc.st_prc = ct_st_prc_a_faturar loop

    -- inserindo a parcela no outro cartão
    insert into sc_fcr.tbl_prc (cd_prc, cd_crt, vl_prc, fg_dcr_prc, st_prc, cd_opr, 
                                dt_grc_prc, dt_vnc_prc, ds_prc, nr_prc)
      values (nextval('sc_fcr.sq_prc'), vl_cd_crt_atl, rg_prc.vl_prc, rg_prc.fg_dcr_prc, ct_st_prc_a_faturar, vl_cd_operacao, 
              rg_prc.dt_grc_prc, rg_prc.dt_vnc_prc, 'TRANS. DIVIDA: ' || rg_prc.ds_prc, rg_prc.nr_prc);

    -- marcando a parcela como transferencia de divida
    update sc_fcr.tbl_prc set st_prc = ct_st_prc_transferencia_divida where cd_prc = rg_prc.cd_prc;

  end loop;

  -- verificar se vai gerar fatura
  select count(*) > 0
    into vl_gerar_fatura
  from sc_opr.tbl_crt crt
  where crt.cd_crt = vl_cd_crt_atl
    and (current_date < crt.dt_prx_apr_crt - 10 or current_date > crt.dt_prx_apr_crt);

  if vl_gerar_fatura then
    -- gerar parcelas do cartão atual
    perform sc_fcr.gerar_parcelas(vl_cd_crt_atl, null);

    -- gerar fatura
    perform sc_fcr.gerar_fatura_cartao(vl_cd_crt_atl, current_date + 1, current_date + 1, false, true);
  end if;

  -- desmarcar cartao anterior da inadimplencia 
  update sc_opr.tbl_crt
    set fg_ind_crt = 'N',
        --dt_ini_atr_crt = null
	dt_fim_atr_crt = current_date
    where cd_crt = vl_cd_crt_ant; 
                    
end;$$;


ALTER FUNCTION sc_fcr.transferir_divida_cartao(vp_fatura numeric, vp_plastico numeric, vp_usuario numeric) OWNER TO scan;

SET search_path = sc_fep, pg_catalog;

--
-- TOC entry 1338 (class 1255 OID 564380)
-- Name: agrupa_fatura_empresa(numeric, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION agrupa_fatura_empresa(vp_fatura_atual numeric, vp_fatura_trocada numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_valor_nfs_fatura numeric;
  vl_valor_iss_fatura numeric;
  
  vl_codigo_boleto numeric;

  vl_data_vencimento_fatura date;
  vl_valor_fatura numeric;
begin

   -- trocando as faturas
   update sc_fep.tbl_fep_sfe set cd_fep = vp_fatura_atual where cd_fep = vp_fatura_trocada;

   -- retirando o complemento de faturamento minimo
   delete from sc_fep.tbl_fep_sfe where cd_fep = vp_fatura_atual and cd_sfe = 5;

   -- atualizando as cobrancas
   update sc_adp.tbl_hfe set cd_fep = vp_fatura_atual where cd_fep = vp_fatura_trocada;
   update sc_ssp.tbl_ssp set cd_fep = vp_fatura_atual where cd_fep = vp_fatura_trocada;
   update sc_fin.tbl_alr set cd_fep = vp_fatura_atual where cd_fep = vp_fatura_trocada;

   --deletando o boleto
   delete from sc_cbr.tbl_blt where nr_nsu_org_blt = vp_fatura_trocada and tp_org_blt = 1;

   --alterando valor da fatura atual

   select sum(vl_ttl_fep_sfe)
     into vl_valor_nfs_fatura
   from sc_fep.tbl_fep_sfe 
    where cd_fep = vp_fatura_atual
      and cd_sfe <> 6; 

   select coalesce(sum(vl_ttl_fep_sfe),0)
     into vl_valor_iss_fatura
   from sc_fep.tbl_fep_sfe
     where cd_sfe = 6
       and cd_fep = vp_fatura_atual; 
    
   update sc_fep.tbl_fep 
      set vl_fep = vl_valor_nfs_fatura - vl_valor_iss_fatura, 
          vl_nfs_fep = vl_valor_nfs_fatura 
    where cd_fep = vp_fatura_atual;

   -- alterando boleto fatura
   select cd_blt
     into vl_codigo_boleto
   from sc_cbr.tbl_blt 
   where nr_nsu_org_blt = vp_fatura_atual 
     and tp_org_blt = 1;
/*
   select dt_vnc_fep, vl_fep
     into vl_data_vencimento_fatura, vl_valor_fatura
   from sc_fep.tbl_fep  
   where cd_fep = vp_fatura_atual;   
*/
   if vl_codigo_boleto is not null then
     --perform sc_cbr.alterar_data_vencimento(vl_codigo_boleto, vl_data_vencimento_fatura + 1, vl_valor_fatura, 1);
     --perform sc_cbr.alterar_data_vencimento(vl_codigo_boleto, vl_data_vencimento_fatura, vl_valor_fatura, 1);
     delete from sc_cbr.tbl_blt where nr_nsu_org_blt = vp_fatura_atual and tp_org_blt = 1;
     
     perform sc_cbr.gerar_boleto_fatura_empresa(vp_fatura_atual);
   end if;

   -- deletando a fatura
   delete from sc_fep.tbl_fep where cd_fep = vp_fatura_trocada;

end;$$;


ALTER FUNCTION sc_fep.agrupa_fatura_empresa(vp_fatura_atual numeric, vp_fatura_trocada numeric) OWNER TO scan;

--
-- TOC entry 7814 (class 0 OID 0)
-- Dependencies: 1338
-- Name: FUNCTION agrupa_fatura_empresa(vp_fatura_atual numeric, vp_fatura_trocada numeric); Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON FUNCTION agrupa_fatura_empresa(vp_fatura_atual numeric, vp_fatura_trocada numeric) IS 'Rotina que agrupa faturas de empresas';


--
-- TOC entry 1871 (class 1255 OID 564381)
-- Name: alterar_vencimento_fatura_empresa(numeric, date, numeric, boolean); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION alterar_vencimento_fatura_empresa(vp_fatura numeric, vp_data_prorrogada date, vp_usuario numeric, vp_flag_cobra_juros_multa boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_dias_diferenca numeric;
  vl_data_vencimento_fatura date;
  vl_valor_fatura double precision;
  vl_valor_mora numeric := 0;
  vl_valor_multa numeric := 0;
  vl_valor_tarifa_prorrogacao numeric := 0;
  vl_cd_boleto numeric;
  vl_valor_fatura_prorrogado numeric := 0;
  
begin

  --Alteração realizada no dia 15/05/2019, Às 15:08, pelo Alexandre (Statix) - Inicio
  --if vp_usuario <> 2 then 
  --  raise 'Alteração de vencimento não necessária. Boleto já resgistrado. Pagamento pode ser efetuado com o boleto vencido.';
  --end if;
  --Alteração realizada no dia 15/05/2019, Às 15:08, pelo Alexandre (Statix) - Final

  -- dados da fatura
  begin
    select vl_fep, dt_vnc_fep, cd_blt
      into strict vl_valor_fatura, vl_data_vencimento_fatura, vl_cd_boleto
    from sc_fep.tbl_fep
    where cd_fep = vp_fatura;
  exception when others then
    raise 'Não existe fatura de empresa com esse código';
  end;

  -- dados do boleto
  /*begin
    select blt.cd_blt 
      into strict vl_cd_boleto
    from sc_cbr.tbl_blt blt
    where blt.nr_nsu_org_blt = vp_fatura
      and blt.tp_org_blt = 1; -- fatura de empresa
  exception when others then
    raise 'Não existe boleta para a fatura de empresa';
  end;*/
  
  -- calculando valor da fatura prorrogada
  select  * 
    into vl_valor_fatura_prorrogado, vl_valor_mora, vl_valor_multa, vl_valor_tarifa_prorrogacao
  from sc_fep.calcula_valor_alterar_vencimento_fatura_empresa_gravar(vl_cd_boleto, vl_valor_fatura::double precision, vl_data_vencimento_fatura, vp_data_prorrogada, vp_flag_cobra_juros_multa);  
    
  -- atualizar valor e vencimento da fatura
  update sc_fep.tbl_fep set vl_fep = vl_valor_fatura_prorrogado, dt_vnc_fep = vp_data_prorrogada where cd_fep = vp_fatura;

  -- gerando novo boleto
  perform sc_cbr.gerar_boleto(1, 1, vp_fatura);

  -- alterado em 20-01-2016
  -- atualizar valor e vencimento do boleto
  --perform sc_cbr.alterar_data_vencimento(vl_cd_boleto, vp_data_prorrogada,vl_valor_fatura_prorrogado::double precision, vp_usuario);

  
  -- guardar valores para auditoria
  insert into sc_fep.tbl_apf (cd_apf,cd_fep,dt_vnc_apf,vl_apf,cd_inc_usr,dt_inc_usr,vl_mlt_apf, vl_jrs_apf, vl_trf_apf)
           values (nextval('sc_fep.sq_apf'),vp_fatura,vl_data_vencimento_fatura,vl_valor_fatura,vp_usuario,current_timestamp,vl_valor_multa,vl_valor_mora,vl_valor_tarifa_prorrogacao); 

end;$$;


ALTER FUNCTION sc_fep.alterar_vencimento_fatura_empresa(vp_fatura numeric, vp_data_prorrogada date, vp_usuario numeric, vp_flag_cobra_juros_multa boolean) OWNER TO scan;

--
-- TOC entry 1591 (class 1255 OID 564382)
-- Name: baixar_fatura_empresa(numeric, double precision, numeric, timestamp without time zone, numeric, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION baixar_fatura_empresa(vp_cod_fatura numeric, vp_vlr_baixa double precision, vp_tp_baixa numeric, vp_data_baixa timestamp without time zone, vp_cod_usuario numeric, vp_conta_origem numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  CD_SISTEMA_BAIXA_FATURA_EMPRESA sc_cnt.tbl_sst.cd_sst%type := 9;
  SITUACAO_PAGAMENTO_CADASTRADA sc_fep.tbl_fep.st_fep%type := 1;
  SITUACAO_FATURA_PAGA sc_fep.tbl_fep.st_fep%type := 2;
  CD_CONTA_BAIXA_FATURA_EMPRESA sc_cnt.tbl_cnt.cd_cnt%type := 6339;
  
  TPE_SALDO_CONTA sc_fep.tbl_tpe.cd_tpe%type := 2;
  TPE_CONTA_BANCO sc_fep.tbl_tpe.cd_tpe%type := 3;
  TPE_BOLETO sc_fep.tbl_tpe.cd_tpe%type := 4;
  
  vl_saldo_conta_debito sc_cnt.tbl_cnt.vl_sld_cnt%type := 0;
  vl_cod_pagamento sc_fep.tbl_pfe.cd_pfe%type;
  vl_tipo_lancamento_baixa sc_cnt.tbl_tlc.cd_tlc%type;
  vl_conta_empresa sc_cnt.tbl_cnt.cd_cnt%type;
  vl_situacao_fatura sc_fep.tbl_fep.st_fep%type;
  vl_conta_credito_empresa sc_cad.tbl_ctr.cd_cnt_crd%type;
  vl_restante numeric(13,2);
  vl_pagamento numeric(13,2);

  ct_srv_tarifa_saque sc_fep.tbl_sfe.cd_sfe%type := 18;
  vl_situacao integer;
  
BEGIN
  
    select tpe.cd_tlc
    into vl_tipo_lancamento_baixa
    from sc_fep.tbl_tpe tpe
    where tpe.cd_tpe = vp_tp_baixa;
        
    select cd_cnt, st_fep, cd_cnt_crd, vl_fep - coalesce(vl_pgt_fep,0)
    into vl_conta_empresa, vl_situacao_fatura, vl_conta_credito_empresa, vl_restante
    from sc_cad.tbl_ctr ctr
       inner join sc_fep.tbl_fep fep on fep.cd_ctr = ctr.cd_ctr
    where fep.cd_fep = vp_cod_fatura;

    vp_vlr_baixa := vp_vlr_baixa::numeric(13,2);

    if vl_situacao_fatura <> SITUACAO_FATURA_PAGA then
    
        if vp_conta_origem is null then
         vp_conta_origem := vl_conta_empresa;
        end if;
    
        vl_saldo_conta_debito := sc_cnt.saldo_conta(vl_conta_empresa,'S','S');

        if vp_vlr_baixa > vl_restante then
          vl_pagamento := vl_restante;
        else
          vl_pagamento := vp_vlr_baixa;
        end if;
    
        if vl_saldo_conta_debito >= vl_pagamento then    
  
          select nextval('sc_fep.sq_pfe') into vl_cod_pagamento;
    
          insert into sc_fep.tbl_pfe(cd_pfe,cd_fep,dt_pgt_pfe,dt_rcb_pfe,st_pfe,cd_tpe,vl_pfe,cnt_cd,cd_inc_usr)
	          values(vl_cod_pagamento,vp_cod_fatura,vp_data_baixa,now(),SITUACAO_PAGAMENTO_CADASTRADA,vp_tp_baixa,vl_pagamento,vp_conta_origem,vp_cod_usuario);
    
          perform sc_cnt.lancar_debito_credito(vl_conta_empresa,vl_conta_credito_empresa,vl_tipo_lancamento_baixa,NULL,
					   'REF PAGAMENTO NR '|| vl_cod_pagamento,vl_pagamento,now()::timestamp,vp_cod_usuario,
					 CD_SISTEMA_BAIXA_FATURA_EMPRESA,vl_cod_pagamento);
    
          update sc_fep.tbl_fep
	    set st_fep = (case when vl_pagamento + coalesce(vl_pgt_fep,0) >= vl_fep then SITUACAO_FATURA_PAGA else st_fep end),
	        vl_pgt_fep = coalesce(vl_pgt_fep,0) + vl_pagamento
          where cd_fep = vp_cod_fatura;

          select st_fep 
            into vl_situacao
          from sc_fep.tbl_fep
          where cd_fep = vp_cod_fatura;

          if vl_situacao = SITUACAO_FATURA_PAGA then
            perform sc_fep.marcar_pagamento_tsm(vp_cod_fatura);
          end if;
	  
	else
	  RAISE EXCEPTION 'Não foi possível efetuar a baixa da fatura. Saldo da conta insuficiente. Fatura: %, Conta: %', vp_cod_fatura, vl_conta_empresa;
	end if;
    end if;
END;
$$;


ALTER FUNCTION sc_fep.baixar_fatura_empresa(vp_cod_fatura numeric, vp_vlr_baixa double precision, vp_tp_baixa numeric, vp_data_baixa timestamp without time zone, vp_cod_usuario numeric, vp_conta_origem numeric) OWNER TO scan;

--
-- TOC entry 1872 (class 1255 OID 1648324)
-- Name: calcula_valor_alterar_vencimento_fatura_empresa(numeric, double precision, date, date, boolean, boolean, boolean); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION calcula_valor_alterar_vencimento_fatura_empresa(vp_boleto numeric, vp_valor_fatura double precision, vp_data_vencimento date, vp_data_prorrogada date, vp_flag_cobra_juros_multa boolean, vp_cobra_tarifa_prorrogacao boolean DEFAULT true, vp_debito_em_conta boolean DEFAULT false, OUT vp_valor_prorrogado numeric, OUT vp_valor_mora numeric, OUT vp_valor_multa numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare

vl_taxa_mora double precision := 0;
vl_taxa_multa double precision := 0;
vl_dias_diferenca numeric;
vl_valor_mora_dia double precision := 0;
vl_existe_prorrogacao numeric := 0;
vl_codigo_fatura numeric;
vl_tarifa_prorrogacao numeric := 0;

begin
 
  if not vp_debito_em_conta and vp_flag_cobra_juros_multa and vp_data_vencimento >= current_date - 30 then 
    raise 'Alteração de vencimento não necessária. Boleto já resgistrado. Pagamento pode ser efetuado com o boleto vencido.';
  end if;

  vp_valor_mora := 0;
  vp_valor_multa := 0;
 
  if vp_flag_cobra_juros_multa then

  -- retornando o valor da tarifa de prorrogacao
  select replace(vl_prm,',','.')::numeric
    into vl_tarifa_prorrogacao
  from sc_cad.tbl_prm
  where nm_prm = 'VALOR_TARIFA_PRORROGACAO_FATURA_EMPRESA';  
  
  -- consultando taxas de mora e multa para prorrogacao
  begin
   select pc_jrs_tcb/100, pc_mlt_tcb/100, blt.nr_nsu_org_blt
     into vl_taxa_mora, vl_taxa_multa, vl_codigo_fatura
   from sc_cbr.tbl_blt blt
     inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
     inner join sc_cbr.tbl_tcb tcb on tcb.cd_tcb = ccb.cd_tcb
   where blt.cd_blt = vp_boleto;      

  exception when others then
    raise 'Percentual de Juros ou Multa não definidos no contrato de cobrança';
  end; 

  -- calculando diferenca de dias
  vl_dias_diferenca := vp_data_prorrogada - vp_data_vencimento;

  -- calculando a mora ao dia
  vl_valor_mora_dia := (vp_valor_fatura * vl_taxa_mora) / 30;

  -- calculando valor total mora 
  vp_valor_mora := round(vl_dias_diferenca::numeric * vl_valor_mora_dia::numeric,2);

  -- adicionando o valor da tarida a mora
  if vp_cobra_tarifa_prorrogacao then
    vp_valor_mora := vp_valor_mora + vl_tarifa_prorrogacao;
  end if;
    
  -- verificando se jah existe uma prorrogacao anterior se sim desconsiderar o calculo da multa novamente
  select count(*)
    into vl_existe_prorrogacao
  from sc_fep.tbl_apf
    where cd_fep = vl_codigo_fatura;

  if vl_existe_prorrogacao = 0 then
    -- calculando valor total multa 
    vp_valor_multa :=  round(vp_valor_fatura::numeric * vl_taxa_multa::numeric,2);
  end if;
    
  -- calculando valor da fatura prorrogada
  vp_valor_prorrogado := vp_valor_fatura + vp_valor_mora + vp_valor_multa;
    
  else
    vp_valor_prorrogado := vp_valor_fatura;
  end if;

end;$$;


ALTER FUNCTION sc_fep.calcula_valor_alterar_vencimento_fatura_empresa(vp_boleto numeric, vp_valor_fatura double precision, vp_data_vencimento date, vp_data_prorrogada date, vp_flag_cobra_juros_multa boolean, vp_cobra_tarifa_prorrogacao boolean, vp_debito_em_conta boolean, OUT vp_valor_prorrogado numeric, OUT vp_valor_mora numeric, OUT vp_valor_multa numeric) OWNER TO scan;

--
-- TOC entry 1342 (class 1255 OID 564384)
-- Name: calcula_valor_alterar_vencimento_fatura_empresa_OLD(numeric, double precision, date, date, boolean); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION "calcula_valor_alterar_vencimento_fatura_empresa_OLD"(vp_boleto numeric, vp_valor_fatura double precision, vp_data_vencimento date, vp_data_prorrogada date, vp_flag_cobra_juros_multa boolean, OUT vp_valor_prorrogado numeric, OUT vp_valor_mora numeric, OUT vp_valor_multa numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare

vl_taxa_mora double precision := 0;
vl_taxa_multa double precision := 0;
vl_dias_diferenca numeric;
vl_valor_mora_dia double precision := 0;
vl_existe_prorrogacao numeric := 0;
vl_codigo_fatura numeric;
vl_tarifa_prorrogacao numeric := 0;

begin

  vp_valor_mora := 0;
  vp_valor_multa := 0;
 
  if vp_flag_cobra_juros_multa then

  -- retornando o valor da tarifa de prorrogacao
  select replace(vl_prm,',','.')::numeric
    into vl_tarifa_prorrogacao
  from sc_cad.tbl_prm
  where nm_prm = 'VALOR_TARIFA_PRORROGACAO_FATURA_EMPRESA';  
  
  -- consultando taxas de mora e multa para prorrogacao
  begin
   select pc_jrs_tcb/100, pc_mlt_tcb/100, blt.nr_nsu_org_blt
     into vl_taxa_mora, vl_taxa_multa, vl_codigo_fatura
   from sc_cbr.tbl_blt blt
     inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
     inner join sc_cbr.tbl_tcb tcb on tcb.cd_tcb = ccb.cd_tcb
   where blt.cd_blt = vp_boleto;      

  exception when others then
    raise 'Percentual de Juros ou Multa não definidos no contrato de cobrança';
  end; 

  -- calculando diferenca de dias
  vl_dias_diferenca := vp_data_prorrogada - vp_data_vencimento;

  -- calculando a mora ao dia
  vl_valor_mora_dia := (vp_valor_fatura * vl_taxa_mora) / 30;

  -- calculando valor total mora 
  vp_valor_mora := round(vl_dias_diferenca::numeric * vl_valor_mora_dia::numeric,2);

  -- adicionando o valor da tarida a mora
  vp_valor_mora := vp_valor_mora + vl_tarifa_prorrogacao;

  -- verificando se jah existe uma prorrogacao anterior se sim desconsiderar o calculo da multa novamente
  select count(*)
    into vl_existe_prorrogacao
  from sc_fep.tbl_apf
    where cd_fep = vl_codigo_fatura;

  if vl_existe_prorrogacao = 0 then
    -- calculando valor total multa 
    vp_valor_multa :=  round(vp_valor_fatura::numeric * vl_taxa_multa::numeric,2);
  end if;
    
  -- calculando valor da fatura prorrogada
  vp_valor_prorrogado := vp_valor_fatura + vp_valor_mora + vp_valor_multa;
    
  else
    vp_valor_prorrogado := vp_valor_fatura;
  end if;

end;$$;


ALTER FUNCTION sc_fep."calcula_valor_alterar_vencimento_fatura_empresa_OLD"(vp_boleto numeric, vp_valor_fatura double precision, vp_data_vencimento date, vp_data_prorrogada date, vp_flag_cobra_juros_multa boolean, OUT vp_valor_prorrogado numeric, OUT vp_valor_mora numeric, OUT vp_valor_multa numeric) OWNER TO scan;

--
-- TOC entry 1634 (class 1255 OID 564383)
-- Name: calcula_valor_alterar_vencimento_fatura_empresa_OLD2(numeric, double precision, date, date, boolean, boolean); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION "calcula_valor_alterar_vencimento_fatura_empresa_OLD2"(vp_boleto numeric, vp_valor_fatura double precision, vp_data_vencimento date, vp_data_prorrogada date, vp_flag_cobra_juros_multa boolean, vp_cobra_tarifa_prorrogacao boolean DEFAULT true, OUT vp_valor_prorrogado numeric, OUT vp_valor_mora numeric, OUT vp_valor_multa numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare

vl_taxa_mora double precision := 0;
vl_taxa_multa double precision := 0;
vl_dias_diferenca numeric;
vl_valor_mora_dia double precision := 0;
vl_existe_prorrogacao numeric := 0;
vl_codigo_fatura numeric;
vl_tarifa_prorrogacao numeric := 0;

begin

  raise 'Alteração de vencimento não necessária. Boleto já resgistrado. Pagamento pode ser efetuado com o boleto vencido.';

  vp_valor_mora := 0;
  vp_valor_multa := 0;
 
  if vp_flag_cobra_juros_multa then

  -- retornando o valor da tarifa de prorrogacao
  select replace(vl_prm,',','.')::numeric
    into vl_tarifa_prorrogacao
  from sc_cad.tbl_prm
  where nm_prm = 'VALOR_TARIFA_PRORROGACAO_FATURA_EMPRESA';  
  
  -- consultando taxas de mora e multa para prorrogacao
  begin
   select pc_jrs_tcb/100, pc_mlt_tcb/100, blt.nr_nsu_org_blt
     into vl_taxa_mora, vl_taxa_multa, vl_codigo_fatura
   from sc_cbr.tbl_blt blt
     inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
     inner join sc_cbr.tbl_tcb tcb on tcb.cd_tcb = ccb.cd_tcb
   where blt.cd_blt = vp_boleto;      

  exception when others then
    raise 'Percentual de Juros ou Multa não definidos no contrato de cobrança';
  end; 

  -- calculando diferenca de dias
  vl_dias_diferenca := vp_data_prorrogada - vp_data_vencimento;

  -- calculando a mora ao dia
  vl_valor_mora_dia := (vp_valor_fatura * vl_taxa_mora) / 30;

  -- calculando valor total mora 
  vp_valor_mora := round(vl_dias_diferenca::numeric * vl_valor_mora_dia::numeric,2);

  -- adicionando o valor da tarida a mora
  if vp_cobra_tarifa_prorrogacao then
    vp_valor_mora := vp_valor_mora + vl_tarifa_prorrogacao;
  end if;
    
  -- verificando se jah existe uma prorrogacao anterior se sim desconsiderar o calculo da multa novamente
  select count(*)
    into vl_existe_prorrogacao
  from sc_fep.tbl_apf
    where cd_fep = vl_codigo_fatura;

  if vl_existe_prorrogacao = 0 then
    -- calculando valor total multa 
    vp_valor_multa :=  round(vp_valor_fatura::numeric * vl_taxa_multa::numeric,2);
  end if;
    
  -- calculando valor da fatura prorrogada
  vp_valor_prorrogado := vp_valor_fatura + vp_valor_mora + vp_valor_multa;
    
  else
    vp_valor_prorrogado := vp_valor_fatura;
  end if;

end;$$;


ALTER FUNCTION sc_fep."calcula_valor_alterar_vencimento_fatura_empresa_OLD2"(vp_boleto numeric, vp_valor_fatura double precision, vp_data_vencimento date, vp_data_prorrogada date, vp_flag_cobra_juros_multa boolean, vp_cobra_tarifa_prorrogacao boolean, OUT vp_valor_prorrogado numeric, OUT vp_valor_mora numeric, OUT vp_valor_multa numeric) OWNER TO scan;

--
-- TOC entry 1343 (class 1255 OID 564385)
-- Name: calcula_valor_alterar_vencimento_fatura_empresa_gravar(numeric, double precision, date, date, boolean); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION calcula_valor_alterar_vencimento_fatura_empresa_gravar(vp_boleto numeric, vp_valor_fatura double precision, vp_data_vencimento date, vp_data_prorrogada date, vp_flag_cobra_juros_multa boolean, OUT vp_valor_prorrogado numeric, OUT vp_valor_mora numeric, OUT vp_valor_multa numeric, OUT vp_tarifa_prorrogacao numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare

vl_taxa_mora double precision := 0;
vl_taxa_multa double precision := 0;
vl_dias_diferenca numeric;
vl_valor_mora_dia double precision := 0;
vl_existe_prorrogacao numeric := 0;
vl_codigo_fatura numeric;


begin

  vp_valor_mora := 0;
  vp_valor_multa := 0;
 
  if vp_flag_cobra_juros_multa then

  -- retornando o valor da tarifa de prorrogacao
  select replace(vl_prm,',','.')::numeric
    into vp_tarifa_prorrogacao
  from sc_cad.tbl_prm
  where nm_prm = 'VALOR_TARIFA_PRORROGACAO_FATURA_EMPRESA';  
  
  -- consultando taxas de mora e multa para prorrogacao
  begin
   select pc_jrs_tcb/100, pc_mlt_tcb/100, blt.nr_nsu_org_blt
     into vl_taxa_mora, vl_taxa_multa, vl_codigo_fatura
   from sc_cbr.tbl_blt blt
     inner join sc_cbr.tbl_ccb ccb on ccb.cd_ccb = blt.cd_ccb
     inner join sc_cbr.tbl_tcb tcb on tcb.cd_tcb = ccb.cd_tcb
   where blt.cd_blt = vp_boleto;      

  exception when others then
    raise 'Percentual de Juros ou Multa não definidos no contrato de cobrança';
  end; 

  -- calculando diferenca de dias
  vl_dias_diferenca := vp_data_prorrogada - vp_data_vencimento;

  -- calculando a mora ao dia
  vl_valor_mora_dia := (vp_valor_fatura * vl_taxa_mora) / 30;

  -- calculando valor total mora 
  vp_valor_mora := round(vl_dias_diferenca::numeric * vl_valor_mora_dia::numeric,2);

  -- verificando se jah existe uma prorrogacao anterior se sim desconsiderar o calculo da multa novamente
  select count(*)
    into vl_existe_prorrogacao
  from sc_fep.tbl_apf
    where cd_fep = vl_codigo_fatura;

  if vl_existe_prorrogacao = 0 then
    -- calculando valor total multa 
    vp_valor_multa :=  round(vp_valor_fatura::numeric * vl_taxa_multa::numeric,2);
  end if;
    
  -- calculando valor da fatura prorrogada
  vp_valor_prorrogado := vp_valor_fatura + vp_valor_mora + vp_valor_multa + vp_tarifa_prorrogacao;
    
  else
    vp_valor_prorrogado := vp_valor_fatura;
  end if;

end;$$;


ALTER FUNCTION sc_fep.calcula_valor_alterar_vencimento_fatura_empresa_gravar(vp_boleto numeric, vp_valor_fatura double precision, vp_data_vencimento date, vp_data_prorrogada date, vp_flag_cobra_juros_multa boolean, OUT vp_valor_prorrogado numeric, OUT vp_valor_mora numeric, OUT vp_valor_multa numeric, OUT vp_tarifa_prorrogacao numeric) OWNER TO scan;

--
-- TOC entry 1331 (class 1255 OID 564386)
-- Name: cancela_pagamento(numeric, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cancela_pagamento(vp_cd_pfe numeric, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_cd_sst_baixa_fatura_empresa numeric := 9;
  ct_st_pfe_cadastrado numeric := 1;
  ct_st_pfe_cancelado numeric := 2;
  
  vl_valor_pago numeric;
  vl_cd_fep numeric;

begin

  select pfe.vl_pfe, fep.cd_fep
    into vl_valor_pago, vl_cd_fep
  from sc_fep.tbl_pfe pfe
    inner join sc_fep.tbl_fep fep on fep.cd_fep = pfe.cd_fep
  where pfe.cd_pfe = vp_cd_pfe
    and pfe.st_pfe = ct_st_pfe_cadastrado;

  -- estorno dos lancamentos
  perform sc_cnt.cancelar_lancamento(ct_cd_sst_baixa_fatura_empresa, vp_cd_pfe, vp_usuario, 'ESTORNO DE PAGAMENTO DA FATURA DE EMPRESA ' || vl_cd_fep, null, null);

  -- atualizar  valor pago da fatura
  update sc_fep.tbl_fep set
    vl_pgt_fep = vl_pgt_fep - vl_valor_pago,
    st_fep = 1
  where cd_fep = vl_cd_fep;
  
  -- atualizar pagamento para estornado
  update sc_fep.tbl_pfe set st_pfe = 2 where cd_pfe = vp_cd_pfe;

end;$$;


ALTER FUNCTION sc_fep.cancela_pagamento(vp_cd_pfe numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 7815 (class 0 OID 0)
-- Dependencies: 1331
-- Name: FUNCTION cancela_pagamento(vp_cd_pfe numeric, vp_usuario numeric); Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON FUNCTION cancela_pagamento(vp_cd_pfe numeric, vp_usuario numeric) IS 'cancela de pagamento de fatura de empresa';


--
-- TOC entry 1332 (class 1255 OID 564387)
-- Name: cancelar_contabilizacao_fatura_empresa(numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cancelar_contabilizacao_fatura_empresa(vp_cod_fatura numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;

  VL_SITUACAO_FATURA_CANCELADA sc_fep.tbl_fep.st_fep%type := 3;
  VL_CODIGO_SERVICO_ISS sc_fep.tbl_sfe.cd_sfe%type := 6;
  VL_SISTEMA_FATURAMENTO_EMPRESA sc_cnt.tbl_sst.cd_sst%type := 19;

  vl_conta_debito sc_cnt.tbl_cnt.cd_cnt%type;
  vl_conta_credito sc_cnt.tbl_cnt.cd_cnt%type;

  vl_tipo_lancamento_estorno sc_cnt.tbl_tlc.cd_tlc%type;
  
begin

   for rg in select sfe.cd_cnt conta_receita,
                    sfe.cd_tlc,
                    sfe.cd_sfe,
                    sfe.fg_crd_dbt_sfe,
                    fep.cd_ctr,
                    ctr.cd_cnt_crd conta_empresa,
                    fep.cd_fep,
                    fep.dt_ctb_fep data_contabilizacao,
                    sum(sf.vl_ttl_fep_sfe) valor                    
             from sc_fep.tbl_fep fep
                inner join sc_fep.tbl_fep_sfe sf on fep.cd_fep= sf.cd_fep
                inner join sc_fep.tbl_sfe sfe on sfe.cd_sfe = sf.cd_sfe
                inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = fep.cd_ctr
             where fep.dt_ctb_fep is not null
               and fep.cd_fep = vp_cod_fatura  
             group by sfe.cd_cnt,
                    sfe.cd_tlc,
                    sfe.cd_sfe,
                    sfe.fg_crd_dbt_sfe,
                    fep.cd_ctr,
                    ctr.cd_cnt_crd,
                    fep.cd_fep,
                    fep.dt_ctb_fep  loop

	if rg.fg_crd_dbt_sfe = 'D' then 

           vl_conta_credito := rg.conta_receita;
           vl_conta_debito := rg.conta_empresa;
           
        else   

          vl_conta_credito := rg.conta_empresa;
          vl_conta_debito := rg.conta_receita;
          
	end if;

	select cd_est_tlc
	into vl_tipo_lancamento_estorno
	from sc_cnt.tbl_tlc
	where cd_tlc = rg.cd_tlc;

	if(vl_tipo_lancamento_estorno is null) then
	   raise exception 'NAO FOI POSSIVEL CANCELAR A FATURA. TIPO DE LANCAMENTO DE ESTORNO NAO CADASTRADO';
	end if;

	perform sc_cnt.lancar_debito_credito(vl_conta_debito,vl_conta_credito,vl_tipo_lancamento_estorno,null,'REF A ESTORNO DA FATURA NR '||rg.cd_fep,rg.valor, rg.data_contabilizacao,1, VL_SISTEMA_FATURAMENTO_EMPRESA, rg.cd_fep);

	update sc_fep.tbl_fep 
	   set dt_ctb_fep = NULL 
	where cd_fep = rg.cd_fep;

   end loop;
   
end$$;


ALTER FUNCTION sc_fep.cancelar_contabilizacao_fatura_empresa(vp_cod_fatura numeric) OWNER TO scan;

--
-- TOC entry 1665 (class 1255 OID 564388)
-- Name: cobrar_fatura_empresa(); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_fatura_empresa() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  rg record;
  TPE_SALDO_CONTA sc_fep.tbl_tpe.cd_tpe%type := 2;
  ct_parametro_debito_automatico numeric := 32;

  retorno record;
  vl_saldo_conta numeric(13,2);
  vl_valor_prorrogado numeric(13,2);
  vl_valor_mora numeric(13,2);
  vl_valor_multa numeric (13,2);
  vl_data_vencimento date;
  
BEGIN

  for rg in select fep.cd_fep,
		  (fep.vl_fep - coalesce(fep.vl_pgt_fep,0)) saldo_devedor,
		  fep.dt_vnc_fep,
		  fep.vl_fep,
		  fep.cd_blt,
		  ctr.cd_cnt
	    from sc_fep.tbl_fep fep
		inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = fep.cd_ctr
	    where fep.st_fep = 1 -- emitida
	      and fep.dt_vnc_org_fep::date <= current_date 
	      and exists (select 1 from sc_cad.tbl_pce_ctr where cd_ctr = ctr.cd_ctr and cd_pce = 32 and vl_pce_ctr = 'SIM')
   loop

      vl_saldo_conta := sc_cnt.saldo_conta(rg.cd_cnt,'S','S');

      if vl_saldo_conta >= rg.saldo_devedor then

      vl_data_vencimento := rg.dt_vnc_fep;

      while not sc_grl.eh_dia_util(vl_data_vencimento) loop
        vl_data_vencimento := vl_data_vencimento + interval '1 day';
      end loop;

        -- caso seja a data de vencimento baixar normalmente
        if vl_data_vencimento >= current_date then

          perform sc_fep.baixar_fatura_empresa(rg.cd_fep, rg.saldo_devedor, TPE_SALDO_CONTA, now()::timestamp, 1, null);

        else -- caso contrario verificar se tem saldo na conta apos prorrogacao

          select * from sc_fep.calcula_valor_alterar_vencimento_fatura_empresa(rg.cd_blt, rg.vl_fep, rg.dt_vnc_fep, current_date, true, false, true)
            into vl_valor_prorrogado, vl_valor_mora, vl_valor_multa;

          -- caso o valor de saldo na conta seja maior que o valor prorrogado
          -- prorrogar a fatura automaticamente
          -- efetuar a baixa com o valor prorrogado
          if vl_saldo_conta >= vl_valor_prorrogado then

              -- atualizar valor e vencimento da fatura
              update sc_fep.tbl_fep set vl_fep = vl_valor_prorrogado, dt_vnc_fep = current_date where cd_fep = rg.cd_fep;

              -- inserindo auditoria de prorrogacap
              insert into sc_fep.tbl_apf (cd_apf,cd_fep,dt_vnc_apf,vl_apf,cd_inc_usr,dt_inc_usr,vl_mlt_apf, vl_jrs_apf, vl_trf_apf)
              values (nextval('sc_fep.sq_apf'),rg.cd_fep,rg.dt_vnc_fep,rg.vl_fep,1,current_timestamp,vl_valor_multa,vl_valor_mora,0); 

              -- baixando a fatura
              perform sc_fep.baixar_fatura_empresa(rg.cd_fep, vl_valor_prorrogado, TPE_SALDO_CONTA, now()::timestamp, 1, null);
          
          end if;
        end if;
      end if;  
   end loop;

END;
$$;


ALTER FUNCTION sc_fep.cobrar_fatura_empresa() OWNER TO scan;

--
-- TOC entry 1615 (class 1255 OID 564389)
-- Name: cobrar_faturamento_minimo(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_faturamento_minimo(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_valor_fatura numeric, OUT vp_faturamento_minimo numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
  COD_PRM_CONTRATO_VL_COMPLEMENTO_FAT_MINIMO sc_cad.tbl_pce.cd_pce%type := 2;
    
  COD_SRV_COMPLEMENTO_FAT_MINIMO sc_fep.tbl_sfe.cd_sfe%type := 5;
  
  vl_valor_faturamento_minimo numeric;
  vl_codigo_empresa numeric;
  
begin

  vp_faturamento_minimo := 0;

  select cd_emp 
  into vl_codigo_empresa
  from sc_cad.tbl_ctr 
  where cd_ctr = vp_cod_contrato
  and fg_atv_ctr = 'S';
    
  select coalesce(replace(pce_ctr.vl_pce_ctr,',','.')::numeric,0)
  into vl_valor_faturamento_minimo
  from sc_cad.tbl_pce_ctr pce_ctr
  where cd_pce = COD_PRM_CONTRATO_VL_COMPLEMENTO_FAT_MINIMO
    and cd_ctr = vp_cod_contrato;

  if vp_valor_fatura > 0 and vp_valor_fatura < vl_valor_faturamento_minimo then
  
    vp_faturamento_minimo := vl_valor_faturamento_minimo - vp_valor_fatura;

    insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
      values(nextval('sc_fep.sq_fep_sfe'),vp_cod_fatura,COD_SRV_COMPLEMENTO_FAT_MINIMO,vp_faturamento_minimo,1,vp_faturamento_minimo,null,vl_codigo_empresa,'C');
  end if;

      
end;
$$;


ALTER FUNCTION sc_fep.cobrar_faturamento_minimo(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_valor_fatura numeric, OUT vp_faturamento_minimo numeric) OWNER TO scan;

--
-- TOC entry 1523 (class 1255 OID 1664113)
-- Name: cobrar_faturamento_minimo(numeric, numeric, numeric, character varying); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_faturamento_minimo(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_valor_fatura numeric, vp_mes_referencia character varying, OUT vp_faturamento_minimo numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  COD_PRM_CONTRATO_VL_COMPLEMENTO_FAT_MINIMO sc_cad.tbl_pce.cd_pce%type := 2;
    
  COD_SRV_COMPLEMENTO_FAT_MINIMO sc_fep.tbl_sfe.cd_sfe%type := 5;
  
  vl_valor_faturamento_minimo numeric;
  vl_codigo_empresa numeric;
  
  vl_valor_movimentacao numeric := 0;
  vl_codigo_conta numeric;
  vl_data_inicial date;
  vl_data_final date;
  
begin

  vp_faturamento_minimo := 0;

  select cd_emp, cd_cnt 
  into vl_codigo_empresa, vl_codigo_conta
  from sc_cad.tbl_ctr 
  where cd_ctr = vp_cod_contrato
  and fg_atv_ctr = 'S';
  
  vl_data_inicial := to_date('01/' || vp_mes_referencia, 'dd/mm/yyyy');
  
  vl_data_final := to_date('01/' || vp_mes_referencia, 'dd/mm/yyyy') + interval '1 month';
  
  /*
  --Retirando a cobrança de faturamento minimo de fatura baseado apenas no valor de lançamento, só será cobrado se o valor da fatura for maior do que zero
  select sum(vl_lcn)
  into vl_valor_movimentacao
  from sc_cnt.tbl_lcn
  where cd_cnt = vl_codigo_conta
  and dt_ref_lcn >= vl_data_inicial
  and dt_ref_lcn < vl_data_final;
  */
  
    
  select coalesce(replace(pce_ctr.vl_pce_ctr,',','.')::numeric,0)
  into vl_valor_faturamento_minimo
  from sc_cad.tbl_pce_ctr pce_ctr
  where cd_pce = COD_PRM_CONTRATO_VL_COMPLEMENTO_FAT_MINIMO
    and cd_ctr = vp_cod_contrato;

  if (vp_valor_fatura > 0 or vl_valor_movimentacao > 0) and vp_valor_fatura < vl_valor_faturamento_minimo then
  
    vp_faturamento_minimo := vl_valor_faturamento_minimo - vp_valor_fatura;

    insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
      values(nextval('sc_fep.sq_fep_sfe'),vp_cod_fatura,COD_SRV_COMPLEMENTO_FAT_MINIMO,vp_faturamento_minimo,1,vp_faturamento_minimo,null,vl_codigo_empresa,'C');
  end if;

      
end;
$$;


ALTER FUNCTION sc_fep.cobrar_faturamento_minimo(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_valor_fatura numeric, vp_mes_referencia character varying, OUT vp_faturamento_minimo numeric) OWNER TO scan;

--
-- TOC entry 1526 (class 1255 OID 859084)
-- Name: cobrar_iss_retido_fonte(numeric, numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_iss_retido_fonte(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_valor_comp_fat_minimo numeric, vp_valor_lib_imediata numeric, vp_filial numeric DEFAULT NULL::numeric, OUT vp_iss_retido numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
  COD_PRM_VL_ISS_RETIDO sc_cad.tbl_prm.nm_prm%type := 'VALOR_ISS_RETER_EMPRESA';
    
  COD_SRV_ISS_RETIDO_FONTE sc_fep.tbl_sfe.cd_sfe%type := 6;
  
  vl_empresa_recolhedora sc_cad.tbl_fem.fg_etd_rec_fem%type;
  
  vl_porcentagem_iss_retido numeric;
  vl_valor_iss_retido numeric(13,3);
  vl_valor_fatura_filial numeric;
  vl_codigo_empresa numeric;
  vl_valor_total_fatura_filial numeric;
  vl_cod_empresa numeric;
  
  rg record;
  
begin

  vp_iss_retido := 0;
  vl_valor_total_fatura_filial := 0;

  select replace(vl_prm,',','.')::numeric
  into vl_porcentagem_iss_retido
  from sc_cad.tbl_prm
  where nm_prm = COD_PRM_VL_ISS_RETIDO;

  for rg in 
    select distinct fc.cd_fem as codigo_filial,
       fc.cd_emp as codigo_empresa,
       fem.fg_etd_rec_fem as entidade_recolhedora	
    from sc_cad.tbl_fem_ctr fc
      inner join sc_cad.tbl_fem fem 
            on fem.cd_emp = fc.cd_emp 
            and fem.cd_fem = fc.cd_fem
    where fc.cd_ctr = vp_cod_contrato
      and (vp_filial is null or fem.cd_fem = vp_filial) loop

     vl_valor_iss_retido := 0;
      
     if rg.entidade_recolhedora = 'S' then

         vl_empresa_recolhedora := rg.entidade_recolhedora;
          
         select coalesce(sum(vl_ttl_fep_sfe),0)
          into vl_valor_fatura_filial
         from sc_fep.tbl_fep_sfe
         where cd_fep = vp_cod_fatura
           and cd_emp = rg.codigo_empresa
           and cd_fem = rg.codigo_filial
           and cd_sfe not in (COD_SRV_ISS_RETIDO_FONTE);

         if vl_valor_fatura_filial > 0 then
           vl_valor_iss_retido := vl_valor_fatura_filial * (vl_porcentagem_iss_retido / 100);
         end if;

         vl_valor_total_fatura_filial := vl_valor_total_fatura_filial + vl_valor_fatura_filial;
         vl_cod_empresa := rg.codigo_empresa;
           
	 if vl_valor_iss_retido > 0 then
           vp_iss_retido := vp_iss_retido + vl_valor_iss_retido;
           
           insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
           values(nextval('sc_fep.sq_fep_sfe'),vp_cod_fatura,COD_SRV_ISS_RETIDO_FONTE,vl_valor_iss_retido,1,vl_valor_iss_retido,rg.codigo_filial,rg.codigo_empresa,'D');
         end if;

     end if;
    
   end loop;

   if vl_empresa_recolhedora = 'S' and vp_filial is null then

     -- se houve liberacao imediata ou complemento de faturamento minimo cobrar iss
     if vp_valor_lib_imediata > 0 or vp_valor_comp_fat_minimo > 0 then

       vl_valor_iss_retido := (vp_valor_lib_imediata + vp_valor_comp_fat_minimo) * (vl_porcentagem_iss_retido / 100);

       insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
         values(nextval('sc_fep.sq_fep_sfe'),vp_cod_fatura,COD_SRV_ISS_RETIDO_FONTE,vl_valor_iss_retido,1,vl_valor_iss_retido,null,vl_cod_empresa,'D');
 
     end if;
        
     select coalesce(sum(vl_ttl_fep_sfe),0)
       into vp_iss_retido
     from sc_fep.tbl_fep_sfe
     where cd_fep = vp_cod_fatura
     and cd_sfe = COD_SRV_ISS_RETIDO_FONTE;

   end if;
         
end;
$$;


ALTER FUNCTION sc_fep.cobrar_iss_retido_fonte(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_valor_comp_fat_minimo numeric, vp_valor_lib_imediata numeric, vp_filial numeric, OUT vp_iss_retido numeric) OWNER TO scan;

--
-- TOC entry 1345 (class 1255 OID 564391)
-- Name: cobrar_liberacao_imediata(numeric, numeric, date); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_liberacao_imediata(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, OUT vp_liberacao_imediata numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
      
  COD_SRV_TARIFA_LIB_IMEDIATA sc_fep.tbl_sfe.cd_sfe%type := 4;

  COD_FORMA_COBRANCA_FATURAMENTO sc_fin.tbl_alr.frm_cbr_alr%type := 2;
  COD_SITUACAO_LIB_IMEDIATA_CADASTRADA sc_fin.tbl_alr.st_alr%type := 1;
  COD_SITUACAO_LIB_IMEDIATA_COBRADO sc_fin.tbl_alr.st_alr%type := 3;
  
  vl_codigo_empresa numeric;
  
begin

  vp_liberacao_imediata := 0;

  select cd_emp
  into vl_codigo_empresa
  from sc_cad.tbl_ctr 
  where cd_ctr = vp_cod_contrato
  and fg_atv_ctr = 'S';

  select coalesce(sum(vl_cbr_alr),0)
  into vp_liberacao_imediata
  from sc_fin.tbl_alr alr
    inner join sc_fin.tbl_drr drr on alr.cd_drr = drr.cd_drr
   where alr.cd_fep is null
    and drr.cd_ctr = vp_cod_contrato
    and alr.frm_cbr_alr = COD_FORMA_COBRANCA_FATURAMENTO
    and alr.st_alr = COD_SITUACAO_LIB_IMEDIATA_CADASTRADA
    and alr.dt_inc_usr < (vp_data_referencia + interval '1 day');
  
  if vp_liberacao_imediata > 0 then
    
    insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
      values(nextval('sc_fep.sq_fep_sfe'),vp_cod_fatura,COD_SRV_TARIFA_LIB_IMEDIATA,vp_liberacao_imediata,1,vp_liberacao_imediata,null,vl_codigo_empresa,'C');

    update sc_fin.tbl_alr
       set st_alr = COD_SITUACAO_LIB_IMEDIATA_COBRADO,
           cd_fep = vp_cod_fatura
    where cd_alr in (select alr.cd_alr
			from sc_fin.tbl_alr alr
			  inner join sc_fin.tbl_drr drr on alr.cd_drr = drr.cd_drr
			where alr.cd_fep is null
                          and drr.cd_ctr = vp_cod_contrato
			  and alr.frm_cbr_alr = COD_FORMA_COBRANCA_FATURAMENTO
			  and alr.st_alr = COD_SITUACAO_LIB_IMEDIATA_CADASTRADA
			  and alr.dt_inc_usr < (vp_data_referencia + interval '1 day'));   
			      
  end if;

      
end;
$$;


ALTER FUNCTION sc_fep.cobrar_liberacao_imediata(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, OUT vp_liberacao_imediata numeric) OWNER TO scan;

--
-- TOC entry 1654 (class 1255 OID 859085)
-- Name: cobrar_primeira_via_crt(numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_primeira_via_crt(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare
  COD_PRM_CONTRATO_VL_TRF_PRIMEIRA_VIA_CRT sc_cad.tbl_pce.cd_pce%type := 8;
  
  COD_SRV_PRIMEIRA_VIA_CRT sc_fep.tbl_sfe.cd_sfe%type := 1;
  
  vl_tipo_cobranca_primeira_via_crt numeric;

  rg record;

  vl_qtd_filial numeric;
  
begin

  vp_vlr_unitario := 0;
  vp_quantidade := 0;


  vl_tipo_cobranca_primeira_via_crt := sc_cad.get_parametro_contrato(COD_PRM_CONTRATO_VL_TRF_PRIMEIRA_VIA_CRT, vp_cod_contrato, vp_filial, 3)::numeric; 
      
  if vl_tipo_cobranca_primeira_via_crt = 1 then -- Se a primeira via é cobrada da empresa

   for rg in 
	select distinct fc.cd_fem as codigo_filial,
	       fc.cd_emp as codigo_empresa	
        from sc_cad.tbl_fem_ctr fc
        where fc.cd_ctr = vp_cod_contrato
          and (vp_filial is null or fc.cd_fem = vp_filial)
   loop


     vl_qtd_filial := 0;
     
     begin
     
       vp_vlr_unitario := replace(sc_cad.get_parametro_contrato(COD_PRM_CONTRATO_VL_TRF_PRIMEIRA_VIA_CRT, vp_cod_contrato, rg.codigo_filial),',','.')::numeric; 

       select count(*)
       into vl_qtd_filial
       from sc_ssp.tbl_ssp ssp
         inner join sc_opr.tbl_pls pls on pls.cd_pls = ssp.cd_pls
         inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
         inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
         inner join sc_ssp.tbl_daep daep on daep.cd_ssp = ssp.cd_ssp
         inner join sc_ssp.tbl_haep haep on haep.cd_haep = daep.cd_haep
       where ssp.st_ssp = 2 -- Gerada
         and crt.cd_ctr = vp_cod_contrato
         and ssp.cd_fep is null
         and pls.fg_prm_via = 'S'
         and ssp.fg_cbr_emi_ssp = 'S'
         and fnc.cd_emp = rg.codigo_empresa
         and fnc.cd_fem = rg.codigo_filial
         and ssp.dt_grc_ssp < (vp_data_referencia + interval '1 day')
         and haep.st_haep <> 3 -- Cancelado
         and ssp.tp_ssp = 1; -- plastico
         
     exception
       when others then
         vp_vlr_unitario := 0;
	 vl_qtd_filial := 0;
     end;      

    if coalesce(vl_qtd_filial,0) > 0 and coalesce(vp_vlr_unitario,0) > 0 then
    
      insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
      values(nextval('sc_fep.sq_fep_sfe'),vp_cod_fatura,COD_SRV_PRIMEIRA_VIA_CRT,vp_vlr_unitario,vl_qtd_filial,vl_qtd_filial*vp_vlr_unitario,rg.codigo_filial,rg.codigo_empresa,'C');
    
      update sc_ssp.tbl_ssp 
      set cd_fep = vp_cod_fatura 
      where cd_ssp in (select ssp.cd_ssp
                     from sc_ssp.tbl_ssp ssp
                        inner join sc_opr.tbl_pls pls on pls.cd_pls = ssp.cd_pls
                        inner join sc_opr.tbl_crt crt on pls.cd_crt = crt.cd_crt
                        inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                        inner join sc_ssp.tbl_daep daep on daep.cd_ssp = ssp.cd_ssp
                        inner join sc_ssp.tbl_haep haep on haep.cd_haep = daep.cd_haep
                     where ssp.st_ssp = 2 -- Gerada
                       and crt.cd_ctr = vp_cod_contrato
                       and ssp.cd_fep is null
                       and pls.fg_prm_via = 'S'
                       and ssp.fg_cbr_emi_ssp = 'S'
		       		   and fnc.cd_emp = rg.codigo_empresa
                       and fnc.cd_fem = rg.codigo_filial
                       and ssp.dt_grc_ssp < (vp_data_referencia + interval '1 day')
                       and haep.st_haep <> 3 -- Cancelado
                       and ssp.tp_ssp = 1); -- plastico

        vp_quantidade := vp_quantidade + vl_qtd_filial;                
    
    end if;

    end loop;
    
  end if;
  
  
  
end;
$$;


ALTER FUNCTION sc_fep.cobrar_primeira_via_crt(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) OWNER TO scan;

--
-- TOC entry 1528 (class 1255 OID 859086)
-- Name: cobrar_segunda_via_crt(numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_segunda_via_crt(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare
  COD_PRM_CONTRATO_VL_TRF_SEGUNDA_VIA_CRT sc_cad.tbl_pce.cd_pce%type := 9;
  
  COD_SRV_SEGUNDA_VIA_CRT sc_fep.tbl_sfe.cd_sfe%type := 2;
  
  vl_tipo_cobranca_segunda_via_crt numeric;

  rg record;

  vl_qtd_filial numeric;
  
begin

  vp_vlr_unitario := 0;
  vp_quantidade := 0;
  
  vl_tipo_cobranca_segunda_via_crt := sc_cad.get_parametro_contrato(COD_PRM_CONTRATO_VL_TRF_SEGUNDA_VIA_CRT, vp_cod_contrato, vp_filial, 3)::numeric; 
    
  if vl_tipo_cobranca_segunda_via_crt = 1 then -- Se a segunda via é cobrada da empresa

   for rg in 
	select distinct fc.cd_fem as codigo_filial,
	       fc.cd_emp as codigo_empresa	
        from sc_cad.tbl_fem_ctr fc
        where fc.cd_ctr = vp_cod_contrato
          and (vp_filial is null or fc.cd_fem = vp_filial)
   loop


     vl_qtd_filial := 0;
     
     begin
     
       vp_vlr_unitario := replace(sc_cad.get_parametro_contrato(COD_PRM_CONTRATO_VL_TRF_SEGUNDA_VIA_CRT, vp_cod_contrato, rg.codigo_filial),',','.')::numeric; 
       
       select count(*)
       into vl_qtd_filial
       from sc_ssp.tbl_ssp ssp
         inner join sc_opr.tbl_pls pls on pls.cd_pls = ssp.cd_pls
         inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
         inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
         inner join sc_ssp.tbl_daep daep on daep.cd_ssp = ssp.cd_ssp
         inner join sc_ssp.tbl_haep haep on haep.cd_haep = daep.cd_haep
       where ssp.st_ssp = 2 -- Gerada
         and crt.cd_ctr = vp_cod_contrato
         and ssp.cd_fep is null
         and pls.fg_prm_via = 'N'
         and ssp.fg_cbr_emi_ssp = 'S'
         and fnc.cd_emp = rg.codigo_empresa
         and fnc.cd_fem = rg.codigo_filial
         and ssp.dt_grc_ssp < (vp_data_referencia + interval '1 day')
         and haep.st_haep <> 3  -- Cancelado
         and ssp.tp_ssp = 1; -- plastico
         
     exception
       when others then
         vp_vlr_unitario := 0;
	 vl_qtd_filial := 0;
     end;      

    if coalesce(vl_qtd_filial,0) > 0 and coalesce(vp_vlr_unitario,0) > 0 then
    
      insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
      values(nextval('sc_fep.sq_fep_sfe'),vp_cod_fatura,COD_SRV_SEGUNDA_VIA_CRT,vp_vlr_unitario,vl_qtd_filial,vl_qtd_filial*vp_vlr_unitario,rg.codigo_filial,rg.codigo_empresa,'C');
    
      update sc_ssp.tbl_ssp 
      set cd_fep = vp_cod_fatura 
      where cd_ssp in (select ssp.cd_ssp
                     from sc_ssp.tbl_ssp ssp
                        inner join sc_opr.tbl_pls pls on pls.cd_pls = ssp.cd_pls
                        inner join sc_opr.tbl_crt crt on pls.cd_crt = crt.cd_crt
                        inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                        inner join sc_ssp.tbl_daep daep on daep.cd_ssp = ssp.cd_ssp
                        inner join sc_ssp.tbl_haep haep on haep.cd_haep = daep.cd_haep
                     where ssp.st_ssp = 2 -- Gerada
                       and crt.cd_ctr = vp_cod_contrato
                       and ssp.cd_fep is null
                       and pls.fg_prm_via = 'N'
                       and ssp.fg_cbr_emi_ssp = 'S'
		       		   and fnc.cd_emp = rg.codigo_empresa
                       and fnc.cd_fem = rg.codigo_filial
                       and ssp.dt_grc_ssp < (vp_data_referencia + interval '1 day')
                       and haep.st_haep <> 3  -- Cancelado
                       and ssp.tp_ssp = 1); -- plastico

        vp_quantidade := vp_quantidade + vl_qtd_filial;                
    
    end if;

    end loop;
    
  end if;
  
  
  
end;
$$;


ALTER FUNCTION sc_fep.cobrar_segunda_via_crt(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) OWNER TO scan;

--
-- TOC entry 1346 (class 1255 OID 564394)
-- Name: cobrar_seguro_affinity(numeric, numeric, date); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_seguro_affinity(vp_ctr numeric, vp_fep numeric, vp_data_vencimento date, OUT vp_quantidade numeric, OUT vp_valor_unitario numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
  ct_tipo_pagamento_empresa numeric := 1;
  ct_servico_seguro_affinity numeric := 2;
  ct_st_tsc_cobrado numeric := 2;
  ct_parametro_seguro_affinity numeric := 23;
  ct_st_scr_ativo numeric := 1;
  ct_sfe_seguro_affinity numeric := 13;

  vl_valor_servico numeric;
  vl_quantidade_total_servico numeric := 0;

  rg record;
begin

  -- verificar se a empresa tem esse servicos pro funcionario
  begin
    select replace(replace(pct.vl_pce_ctr,'.',''), ',', '.')
      into vl_valor_servico
    from sc_cad.tbl_pce_ctr pct
    where pct.cd_ctr = vp_ctr
      and pct.cd_pce = ct_parametro_seguro_affinity;
  exception when others then
    vl_valor_servico := null;
  end;

  if vl_valor_servico is null then
    vl_valor_servico := 0;
  end if;

  if vl_valor_servico > 0 then

    for rg in select count(*) as qnt_fem,
                     fnc.cd_emp,
                     fnc.cd_fem
              from sc_srv.tbl_scr scr
                inner join sc_opr.tbl_crt crt on crt.cd_crt = scr.cd_crt
                inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                inner join sc_srv.tbl_sgr sgr on sgr.cd_scr = scr.cd_scr
              where scr.st_scr = ct_st_scr_ativo
                and crt.cd_ctr = vp_ctr
                and scr.cd_srv = ct_servico_seguro_affinity
                and sgr.dt_vnc_sgr + interval '1 month' * qt_prs_sgr >= vp_data_vencimento
                and not exists (select 1 from sc_srv.tbl_tsc tsc where to_char(tsc.dt_vnc_tsc,'mm/yyyy') = to_char(vp_data_vencimento,'mm/yyyy') and tsc.cd_srv = ct_servico_seguro_affinity)
              group by fnc.cd_fem, fnc.cd_emp loop
              
      insert into sc_fep.tbl_fep_sfe(cd_fep_sfe, cd_fep, cd_sfe, vl_und_fep_sfe, qtd_fep_sfe, vl_ttl_fep_sfe, cd_fem, cd_emp, fg_dcr_fep_sfe) 
        values(nextval('sc_fep.sq_fep_sfe'), vp_fep, ct_sfe_seguro_affinity, vl_valor_servico, rg.qnt_fem, rg.qnt_fem*vl_valor_servico, rg.cd_fem, rg.cd_emp, 'C');

      vl_quantidade_total_servico := vl_quantidade_total_servico + rg.qnt_fem;

    end loop;

    -- inserir tarifas
    insert into sc_srv.tbl_tsc (cd_tsc, cd_srv, cd_crt, vl_tsc, st_tsc, dt_vnc_tsc, cd_inc_usr, dt_inc_usr)
    select nextval('sc_srv.sq_tsc'), ct_servico_seguro_affinity, crt.cd_crt, vl_valor_servico, ct_st_tsc_cobrado, vp_data_vencimento, 1, now()
    from sc_srv.tbl_scr scr
      inner join sc_opr.tbl_crt crt on crt.cd_crt = scr.cd_crt
      inner join sc_srv.tbl_sgr sgr on sgr.cd_scr = scr.cd_scr
    where scr.st_scr = ct_st_scr_ativo
      and crt.cd_ctr = vp_ctr
      and scr.cd_srv = ct_servico_seguro_affinity
      and sgr.dt_vnc_sgr + interval '1 month' * qt_prs_sgr >= vp_data_vencimento
      and not exists (select 1 from sc_srv.tbl_tsc tsc2 where to_char(tsc2.dt_vnc_tsc,'mm/yyyy') = to_char(vp_data_vencimento,'mm/yyyy') and tsc2.cd_srv = ct_servico_seguro_affinity);

  end if;

  vp_quantidade := coalesce(vl_quantidade_total_servico, 0);
  vp_valor_unitario := coalesce(vl_valor_servico, 0);
  
end;$$;


ALTER FUNCTION sc_fep.cobrar_seguro_affinity(vp_ctr numeric, vp_fep numeric, vp_data_vencimento date, OUT vp_quantidade numeric, OUT vp_valor_unitario numeric) OWNER TO scan;

--
-- TOC entry 1347 (class 1255 OID 564395)
-- Name: cobrar_seguro_perda_roubo(numeric, numeric, date); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_seguro_perda_roubo(vp_ctr numeric, vp_fep numeric, vp_data_vencimento date, OUT vp_quantidade numeric, OUT vp_valor_unitario numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
  ct_tipo_pagamento_empresa numeric := 1;
  ct_servico_seguro_perda_roubo numeric := 1;
  ct_st_tsc_cobrado numeric := 2;
  ct_parametro_seguro_perda_roubo numeric := 21;
  ct_st_scr_ativo numeric := 1;
  ct_sfe_seguro_perda_roubo numeric := 10;

  vl_valor_servico numeric;
  vl_quantidade_total_servico numeric := 0;

  rg record;
begin

  -- verificar se a empresa tem esse servicos pro funcionario
  begin
    select replace(replace(pct.vl_pce_ctr,'.',''), ',', '.')
      into vl_valor_servico
    from sc_cad.tbl_pce_ctr pct
    where pct.cd_ctr = vp_ctr
      and pct.cd_pce = ct_parametro_seguro_perda_roubo;
  exception when others then
    vl_valor_servico := null;
  end;

  if vl_valor_servico is null then
    vl_valor_servico := 0;
  end if;

  if vl_valor_servico > 0 then

    for rg in select count(*) as qnt_fem,
                     fnc.cd_emp,
                     fnc.cd_fem
              from sc_srv.tbl_scr scr
                inner join sc_opr.tbl_crt crt on crt.cd_crt = scr.cd_crt
                inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                inner join sc_srv.tbl_sgr sgr on sgr.cd_scr = scr.cd_scr
              where scr.st_scr = ct_st_scr_ativo
                and crt.cd_ctr = vp_ctr
                and scr.cd_srv = ct_servico_seguro_perda_roubo
                and sgr.dt_vnc_sgr + interval '1 month' * qt_prs_sgr >= vp_data_vencimento
                and not exists (select 1 from sc_srv.tbl_tsc tsc where to_char(tsc.dt_vnc_tsc,'mm/yyyy') = to_char(vp_data_vencimento,'mm/yyyy') and tsc.cd_srv = ct_servico_seguro_perda_roubo)
              group by fnc.cd_fem, fnc.cd_emp loop
              
      insert into sc_fep.tbl_fep_sfe(cd_fep_sfe, cd_fep, cd_sfe, vl_und_fep_sfe, qtd_fep_sfe, vl_ttl_fep_sfe, cd_fem, cd_emp, fg_dcr_fep_sfe) 
        values(nextval('sc_fep.sq_fep_sfe'), vp_fep, ct_sfe_seguro_perda_roubo, vl_valor_servico, rg.qnt_fem, rg.qnt_fem*vl_valor_servico, rg.cd_fem, rg.cd_emp, 'C');

      vl_quantidade_total_servico := vl_quantidade_total_servico + rg.qnt_fem;

    end loop;

    -- inserir tarifas
    insert into sc_srv.tbl_tsc (cd_tsc, cd_srv, cd_crt, vl_tsc, st_tsc, dt_vnc_tsc, cd_inc_usr, dt_inc_usr)
    select nextval('sc_srv.sq_tsc'), ct_servico_seguro_perda_roubo, crt.cd_crt, vl_valor_servico, ct_st_tsc_cobrado, vp_data_vencimento, 1, now()
    from sc_srv.tbl_scr scr
      inner join sc_opr.tbl_crt crt on crt.cd_crt = scr.cd_crt
      inner join sc_srv.tbl_sgr sgr on sgr.cd_scr = scr.cd_scr
    where scr.st_scr = ct_st_scr_ativo
      and crt.cd_ctr = vp_ctr
      and scr.cd_srv = ct_servico_seguro_perda_roubo
      and sgr.dt_vnc_sgr + interval '1 month' * qt_prs_sgr >= vp_data_vencimento
      and not exists (select 1 from sc_srv.tbl_tsc tsc2 where to_char(tsc2.dt_vnc_tsc,'mm/yyyy') = to_char(vp_data_vencimento,'mm/yyyy') and tsc2.cd_srv = ct_servico_seguro_perda_roubo);

  end if;

  vp_quantidade := coalesce(vl_quantidade_total_servico, 0);
  vp_valor_unitario := coalesce(vl_valor_servico, 0);
  
end;$$;


ALTER FUNCTION sc_fep.cobrar_seguro_perda_roubo(vp_ctr numeric, vp_fep numeric, vp_data_vencimento date, OUT vp_quantidade numeric, OUT vp_valor_unitario numeric) OWNER TO scan;

--
-- TOC entry 7816 (class 0 OID 0)
-- Dependencies: 1347
-- Name: FUNCTION cobrar_seguro_perda_roubo(vp_ctr numeric, vp_fep numeric, vp_data_vencimento date, OUT vp_quantidade numeric, OUT vp_valor_unitario numeric); Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON FUNCTION cobrar_seguro_perda_roubo(vp_ctr numeric, vp_fep numeric, vp_data_vencimento date, OUT vp_quantidade numeric, OUT vp_valor_unitario numeric) IS 'cobrar seguro de vida';


--
-- TOC entry 1516 (class 1255 OID 859087)
-- Name: cobrar_servico_avulso(numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_servico_avulso(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  vl_valor_servico_avulso numeric;
  
BEGIN

  select sum(coalesce(case when fep_sfe.fg_dcr_fep_sfe = 'C' then fep_sfe.vl_ttl_fep_sfe else fep_sfe.vl_ttl_fep_sfe*-1 end,0))
  into vl_valor_servico_avulso
   from sc_fep.tbl_fep_sfe fep_sfe
  inner join sc_cad.tbl_ctr ctr on ctr.cd_emp = fep_sfe.cd_emp
  where fep_sfe.cd_fep is null
    and ctr.cd_ctr = vp_cod_contrato
    and (vp_filial is null or fep_sfe.cd_fem = vp_filial);
  
  update sc_fep.tbl_fep_sfe
  set cd_fep = vp_cod_fatura 
  where cd_fep_sfe in(select fep_sfe.cd_fep_sfe
                        from sc_fep.tbl_fep_sfe fep_sfe
                        inner join sc_cad.tbl_ctr ctr on ctr.cd_emp = fep_sfe.cd_emp
                      where fep_sfe.cd_fep is null
                        and ctr.cd_ctr = vp_cod_contrato
                        and (vp_filial is null or fep_sfe.cd_fem = vp_filial));
                          
   return vl_valor_servico_avulso;                       
  
END;
$$;


ALTER FUNCTION sc_fep.cobrar_servico_avulso(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric) OWNER TO scan;

--
-- TOC entry 1531 (class 1255 OID 859088)
-- Name: cobrar_solicitacao_senha(numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_solicitacao_senha(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
declare
  COD_PRM_CONTRATO_VL_TRF_SOLICITACAO_SENHA sc_cad.tbl_pce.cd_pce%type := 19;
  
  COD_SRV_SOLICITACAO_SENHA sc_fep.tbl_sfe.cd_sfe%type := 7;
  
  vl_tipo_cobranca_solicitacao_senha numeric;

  rg record;

  vl_qtd_filial numeric;
  
begin

  vp_vlr_unitario := 0;
  vp_quantidade := 0;
  
  vl_tipo_cobranca_solicitacao_senha := sc_cad.get_parametro_contrato(COD_PRM_CONTRATO_VL_TRF_SOLICITACAO_SENHA, vp_cod_contrato, vp_filial, 3)::numeric; 
    
  if vl_tipo_cobranca_solicitacao_senha = 1 then -- Se a primeira via é cobrada da empresa

   for rg in 
	select distinct fc.cd_fem as codigo_filial,
	       fc.cd_emp as codigo_empresa	
        from sc_cad.tbl_fem_ctr fc
        where fc.cd_ctr = vp_cod_contrato
          and (vp_filial is null or fc.cd_fem = vp_filial)
   loop


     vl_qtd_filial := 0;
     vp_vlr_unitario := replace(sc_cad.get_parametro_contrato(COD_PRM_CONTRATO_VL_TRF_SOLICITACAO_SENHA, vp_cod_contrato, rg.codigo_filial),',','.')::numeric; 
     
     begin
     
       select count(*)
       into vl_qtd_filial
       from sc_ssp.tbl_ssp ssp
         inner join sc_opr.tbl_pls pls on pls.cd_pls = ssp.cd_pls
         inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
         inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
         inner join sc_ssp.tbl_daep daep on daep.cd_ssp = ssp.cd_ssp
         inner join sc_ssp.tbl_haep haep on haep.cd_haep = daep.cd_haep
       where ssp.st_ssp = 2 -- Gerada
         and crt.cd_ctr = vp_cod_contrato
         and ssp.cd_fep is null
         and pls.fg_prm_via = 'S'
         and ssp.fg_cbr_emi_ssp = 'S'
         and fnc.cd_emp = rg.codigo_empresa
         and fnc.cd_fem = rg.codigo_filial
         and ssp.dt_grc_ssp < (vp_data_referencia + interval '1 day')
         and haep.st_haep <> 3  -- Cancelado
         and ssp.tp_ssp = 2; -- tipo senha
         
     exception
       when others then
         vp_vlr_unitario := 0;
	 vl_qtd_filial := 0;
     end;      

    if coalesce(vl_qtd_filial,0) > 0 and coalesce(vp_vlr_unitario,0) > 0 then
    
      insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
      values(nextval('sc_fep.sq_fep_sfe'),vp_cod_fatura,COD_SRV_SOLICITACAO_SENHA,vp_vlr_unitario,vl_qtd_filial,vl_qtd_filial*vp_vlr_unitario,rg.codigo_filial,rg.codigo_empresa,'C');
    
      update sc_ssp.tbl_ssp 
      set cd_fep = vp_cod_fatura 
      where cd_ssp in (select ssp.cd_ssp
                     from sc_ssp.tbl_ssp ssp
                        inner join sc_opr.tbl_pls pls on pls.cd_pls = ssp.cd_pls
                        inner join sc_opr.tbl_crt crt on pls.cd_crt = crt.cd_crt
                        inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                        inner join sc_ssp.tbl_daep daep on daep.cd_ssp = ssp.cd_ssp
                        inner join sc_ssp.tbl_haep haep on haep.cd_haep = daep.cd_haep
                     where ssp.st_ssp = 2 -- Gerada
                       and crt.cd_ctr = vp_cod_contrato
                       and ssp.cd_fep is null
                       and pls.fg_prm_via = 'S'
                       and ssp.fg_cbr_emi_ssp = 'S'
		       		   and fnc.cd_emp = rg.codigo_empresa
                       and fnc.cd_fem = rg.codigo_filial
                       and ssp.dt_grc_ssp < (vp_data_referencia + interval '1 day')
                       and haep.st_haep <> 3 -- Cancelado
                       and ssp.tp_ssp = 2); -- tipo senha

        vp_quantidade := vp_quantidade + vl_qtd_filial;                
    
    end if;

    end loop;
    
  end if;
  
  
  
end;
$$;


ALTER FUNCTION sc_fep.cobrar_solicitacao_senha(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) OWNER TO scan;

--
-- TOC entry 1532 (class 1255 OID 859089)
-- Name: cobrar_tarifa_deposito(numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_deposito(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
DECLARE
  COD_PRM_CONTRATO_VL_TRF_DEPOSITO sc_cad.tbl_pce.cd_pce%type := 6;
  COD_PRM_CONTRATO_COBRA_TRF_DEPOSITO_RESCISAO sc_cad.tbl_pce.cd_pce%type := 31;
  
  COD_SRV_TARIFA_DEPOSITO sc_fep.tbl_sfe.cd_sfe%type := 3;

  rg record;

  vl_qtd_filial numeric;
  vl_cobra_rescisao boolean;	
  
BEGIN

  vp_vlr_unitario := 0;
  vp_quantidade := 0;
  
   select case when pce_ctr.vl_pce_ctr = 'SIM' then true else false end
  into vl_cobra_rescisao
  from sc_cad.tbl_pce_ctr pce_ctr
  where cd_pce = COD_PRM_CONTRATO_COBRA_TRF_DEPOSITO_RESCISAO
  and cd_ctr = vp_cod_contrato;

  vl_cobra_rescisao := coalesce(vl_cobra_rescisao,false);

  for rg in 
	select distinct fc.cd_fem as codigo_filial,
	       fc.cd_emp as codigo_empresa
        from sc_cad.tbl_fem_ctr fc
        where fc.cd_ctr = vp_cod_contrato
          and (vp_filial is null or fc.cd_fem = vp_filial)
  loop

    vl_qtd_filial := 0;
    vp_vlr_unitario := replace(sc_cad.get_parametro_contrato(COD_PRM_CONTRATO_VL_TRF_DEPOSITO, vp_cod_contrato, rg.codigo_filial),',','.')::numeric; 
                                 
    begin

      select  count(rdp.cd_rdp)
         into vl_qtd_filial
      from sc_adp.tbl_rdp rdp
        inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
      where hfe.cd_fep is null
        and (hfe.fg_cbr_hfe <> 'S' or hfe.fg_cbr_hfe is null)
	and hfe.cd_emp = rg.codigo_empresa
        and hfe.cd_fem = rg.codigo_filial -- CODIGO DA FILIAL NO LOOP
        and hfe.st_hfe = 5 -- DEPOSITADO
        and rdp.st_rdp = 5 -- DEPOSITADO
        and (vl_cobra_rescisao or (rdp.cd_tdp <> 5 and not vl_cobra_rescisao))
        and hfe.cd_ctr = vp_cod_contrato
        and hfe.dt_dps_hfe < (vp_data_referencia + interval '1 day')
        and ( rdp.fg_dps_um_dia_rdp is null or rdp.fg_dps_um_dia_rdp = 'S');

    exception   
      when others then
	vl_qtd_filial := 0;
	vp_vlr_unitario := 0;
    end;

    if coalesce(vl_qtd_filial,0) > 0 and coalesce(vp_vlr_unitario,0) > 0 then

      insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
      values(nextval('sc_fep.sq_fep_sfe'),vp_cod_fatura,COD_SRV_TARIFA_DEPOSITO,vp_vlr_unitario,vl_qtd_filial,vl_qtd_filial*vp_vlr_unitario,rg.codigo_filial,rg.codigo_empresa,'C');
	
      update sc_adp.tbl_hfe
      set cd_fep = vp_cod_fatura,
          fg_cbr_hfe = 'S' 
      where cd_hfe in (select distinct hfe.cd_hfe
			from sc_adp.tbl_rdp rdp
			inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
		      where hfe.cd_fep is null
			and (hfe.fg_cbr_hfe <> 'S' or hfe.fg_cbr_hfe is null)
			and hfe.cd_emp = rg.codigo_empresa
			and hfe.cd_fem = rg.codigo_filial -- CODIGO DA FILIAL NO LOOP
			and hfe.st_hfe = 5 -- DEPOSITADO
			and rdp.st_rdp = 5 -- DEPOSITADO
		    and (vl_cobra_rescisao or (rdp.cd_tdp <> 5 and not vl_cobra_rescisao))
			and hfe.cd_ctr = vp_cod_contrato
			and hfe.dt_dps_hfe < (vp_data_referencia + interval '1 day')
			and ( rdp.fg_dps_um_dia_rdp is null or rdp.fg_dps_um_dia_rdp = 'S')
		    );


      vp_quantidade := vp_quantidade + vl_qtd_filial;
       
    end if;  
	     
  end loop;           

END;
$$;


ALTER FUNCTION sc_fep.cobrar_tarifa_deposito(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) OWNER TO scan;

--
-- TOC entry 1533 (class 1255 OID 859090)
-- Name: cobrar_tarifa_deposito_d_2(numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_deposito_d_2(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
DECLARE
  COD_PRM_CONTRATO_VL_TRF_DEPOSITO sc_cad.tbl_pce.cd_pce%type := 20;
  COD_PRM_CONTRATO_COBRA_TRF_DEPOSITO_RESCISAO sc_cad.tbl_pce.cd_pce%type := 31;
  
  COD_SRV_TARIFA_DEPOSITO sc_fep.tbl_sfe.cd_sfe%type := 9;

  rg record;

  vl_qtd_filial numeric;
  vl_cobra_rescisao boolean;	

  
BEGIN

  vp_vlr_unitario := 0;
  vp_quantidade := 0;
  
  select case when pce_ctr.vl_pce_ctr = 'SIM' then true else false end
  into vl_cobra_rescisao
  from sc_cad.tbl_pce_ctr pce_ctr
  where cd_pce = COD_PRM_CONTRATO_COBRA_TRF_DEPOSITO_RESCISAO
  and cd_ctr = vp_cod_contrato;

  vl_cobra_rescisao := coalesce(vl_cobra_rescisao,false);

  for rg in 
	select distinct fc.cd_fem as codigo_filial,
	       fc.cd_emp as codigo_empresa
        from sc_cad.tbl_fem_ctr fc
        where fc.cd_ctr = vp_cod_contrato
          and (vp_filial is null or fc.cd_fem = vp_filial)
  loop

    vl_qtd_filial := 0;
    vp_vlr_unitario := replace(sc_cad.get_parametro_contrato(COD_PRM_CONTRATO_VL_TRF_DEPOSITO, vp_cod_contrato, rg.codigo_filial),',','.')::numeric; 
                                 
    begin

      select  count(rdp.cd_rdp)
         into vl_qtd_filial
      from sc_adp.tbl_rdp rdp
        inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
      where (hfe.cd_fep is null or hfe.cd_fep = vp_cod_fatura)
        and ((hfe.fg_cbr_hfe <> 'S' or hfe.fg_cbr_hfe is null) or hfe.cd_fep = vp_cod_fatura)
	and hfe.cd_emp = rg.codigo_empresa
        and hfe.cd_fem = rg.codigo_filial -- CODIGO DA FILIAL NO LOOP
        and hfe.st_hfe = 5 -- DEPOSITADO
        and rdp.st_rdp = 5 -- DEPOSITADO
        and (vl_cobra_rescisao or (rdp.cd_tdp <> 5 and not vl_cobra_rescisao))
        and hfe.cd_ctr = vp_cod_contrato
        and hfe.dt_dps_hfe < (vp_data_referencia + interval '1 day')
        and rdp.fg_dps_um_dia_rdp = 'N';
        

    exception   
      when others then
	vl_qtd_filial := 0;
	vp_vlr_unitario := 0;
    end;

    if coalesce(vl_qtd_filial,0) > 0 and coalesce(vp_vlr_unitario,0) > 0 then

      insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
      values(nextval('sc_fep.sq_fep_sfe'),vp_cod_fatura,COD_SRV_TARIFA_DEPOSITO,vp_vlr_unitario,vl_qtd_filial,vl_qtd_filial*vp_vlr_unitario,rg.codigo_filial,rg.codigo_empresa,'C');
	
      update sc_adp.tbl_hfe
      set cd_fep = vp_cod_fatura,
          fg_cbr_hfe = 'S'
      where cd_hfe in (select distinct hfe.cd_hfe
			from sc_adp.tbl_rdp rdp
			  inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
			where hfe.cd_fep is null
			  and (hfe.fg_cbr_hfe <> 'S' or hfe.fg_cbr_hfe is null)
			  and hfe.cd_emp = rg.codigo_empresa
			  and hfe.cd_fem = rg.codigo_filial -- CODIGO DA FILIAL NO LOOP
			  and hfe.st_hfe = 5 -- DEPOSITADO
			  and rdp.st_rdp = 5 -- DEPOSITADO
			  and (vl_cobra_rescisao or (rdp.cd_tdp <> 5 and not vl_cobra_rescisao))
			  and hfe.cd_ctr = vp_cod_contrato
			  and hfe.dt_dps_hfe < (vp_data_referencia + interval '1 day')
			  and rdp.fg_dps_um_dia_rdp = 'N'
		      );


      vp_quantidade := vp_quantidade + vl_qtd_filial;
       
    end if;  
	     
  end loop;           

END;
$$;


ALTER FUNCTION sc_fep.cobrar_tarifa_deposito_d_2(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) OWNER TO scan;

--
-- TOC entry 1348 (class 1255 OID 564400)
-- Name: cobrar_tarifa_saque_OLD(numeric, numeric, date); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION "cobrar_tarifa_saque_OLD"(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;

  ct_srv_tarifa_saque sc_fep.tbl_sfe.cd_sfe%type := 18;
  ct_prm_tarifa_saque sc_cad.tbl_pce.cd_pce%type := 15;
  ct_toc_tarifa_saque sc_cad.tbl_pce.cd_pce%type := 13;
  
  ct_tp_pgt_empresa numeric := 1;

  vl_qtd_filial numeric := 0;
  vl_qnt_deposito numeric := 0;	
  vl_valor_tarifa numeric := 0;
  vl_empresa numeric := 0;
  vl_nm_pce varchar;
  
BEGIN

  vp_quantidade := 0;
  vp_vlr_unitario := 0;
  
  begin
      select replace(replace(pce_ctr.vl_pce_ctr, '.', ''), ',', '.'), pce.nm_pce
        into strict vl_valor_tarifa, vl_nm_pce
      from sc_opr.tbl_crt crt
        inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = crt.cd_ctr
        inner join sc_cad.tbl_pce pce on pce.cd_pce = pce_ctr.cd_pce
      where ctr.cd_ctr = vp_cod_contrato
        and pce.cd_pce = ct_prm_tarifa_saque
        and pce_ctr.tp_pgt_pce_ctr = ct_tp_pgt_empresa;
  exception when others then
      vl_valor_tarifa := 0;
  end;

  if vl_valor_tarifa > 0 then   
    select count(*)
      into vl_qnt_deposito
    from sc_adp.tbl_rdp rdp
      inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
      inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
    where rdp.st_rdp = 5
      and crt.cd_ctr = vp_cod_contrato
      and crt.fg_atv_crt = 'S'
      and hfe.dt_dps_hfe > vl_data_apuracao - interval '3 month'
      and not exists (select 1 
		    from sc_opr.tbl_opr opr
		      inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
		    where pls.cd_crt = crt.cd_crt
		      and opr.dt_opr >= vl_data_apuracao - interval '1 month'
		      and opr.dt_opr < vl_data_apuracao
		      and opr.cd_top = ct_toc_tarifa_saque);

    if vl_qnt_deposito > 0 then
    
       vp_quantidade := vl_qnt_deposito;
       vp_vlr_unitario := vl_valor_tarifa;

       select cd_emp into vl_empresa from sc_cad.tbl_ctr where cd_ctr = vp_cod_contrato;
        
       insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
         values(nextval('sc_fep.sq_fep_sfe'), vp_cod_fatura, ct_srv_tarifa_saque, vp_vlr_unitario, vp_quantidade, vp_quantidade*vp_vlr_unitario, null, vl_empresa, 'C');
	
    end if;
  end if;

END;
$$;


ALTER FUNCTION sc_fep."cobrar_tarifa_saque_OLD"(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) OWNER TO scan;

--
-- TOC entry 1753 (class 1255 OID 859091)
-- Name: cobrar_tarifa_saque_mensal(numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_saque_mensal(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;

  vl_rg_crt record;
  vl_existe numeric;

  CT_SITUACAO_CANCELADO constant integer := 3;
  CT_SITUACAO_COBRADO_EMPRESA constant integer := 4;

  CT_SRV_TARIFA_SAQUE_MENSAL constant integer := 12;
  
  CT_USUARIO_ADM constant integer := 1;
  
  ct_srv_tarifa_saque sc_fep.tbl_sfe.cd_sfe%type := 18;
  ct_prm_tarifa_saque sc_cad.tbl_pce.cd_pce%type := 15;
  ct_toc_tarifa_saque sc_cad.tbl_pce.cd_pce%type := 13;
  
  vl_tipo_pagamento_saque_mensal numeric;
  ct_tp_pgt_empresa numeric := 1;

  vl_qtd_filial numeric := 0;
  vl_valor_tarifa numeric := 0;

  vl_codigo numeric;
  
BEGIN

  vp_quantidade := 0;
  vp_vlr_unitario := 0;

  for rg in 
	select distinct fc.cd_fem as codigo_filial,
	       fc.cd_emp as codigo_empresa
        from sc_cad.tbl_fem_ctr fc
        where fc.cd_ctr = vp_cod_contrato
          and (vp_filial is null or fc.cd_fem = vp_filial)
    loop

  vl_valor_tarifa := replace(sc_cad.get_parametro_contrato(ct_prm_tarifa_saque, vp_cod_contrato, rg.codigo_filial),',','.')::numeric; 
  vl_tipo_pagamento_saque_mensal := replace(sc_cad.get_parametro_contrato(ct_prm_tarifa_saque, vp_cod_contrato, rg.codigo_filial, 3),',','.')::numeric; 
  
  if vl_tipo_pagamento_saque_mensal = ct_tp_pgt_empresa and vl_valor_tarifa > 0 then   

    select nextval('sc_fep.sq_fep_sfe') into vl_codigo;
    
    vl_qtd_filial := sc_fep.gerar_registro_servico_tsm(vp_cod_contrato, rg.codigo_empresa, rg.codigo_filial, vp_cod_fatura, vl_codigo, vl_valor_tarifa);

    if vl_qtd_filial > 0 then
    
       vp_quantidade := vl_qtd_filial;
       vp_vlr_unitario := vl_valor_tarifa;

       insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
         values(vl_codigo, vp_cod_fatura, ct_srv_tarifa_saque, vp_vlr_unitario, vp_quantidade, vp_quantidade*vp_vlr_unitario, rg.codigo_filial, rg.codigo_empresa, 'C');
	
    end if;

   
  end if;

 end loop;

END;
$$;


ALTER FUNCTION sc_fep.cobrar_tarifa_saque_mensal(vp_cod_contrato numeric, vp_cod_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_vlr_unitario numeric) OWNER TO scan;

--
-- TOC entry 1676 (class 1255 OID 859092)
-- Name: cobrar_tarifa_transferencia(numeric, numeric, date, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_transferencia(vp_contrato numeric, vp_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_valor_unidade numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare

ct_pce_ctr_transferencia numeric := 11;
ct_tp_pgt_pce_ctr_empresa numeric := 1;
ct_cd_sfe_transferencia numeric := 11;

vl_tipo_cobranca numeric;
rg record;

begin

   for rg in select distinct fct.cd_emp as empresa, fct.cd_fem as filialEmpresa, count(*) as quantidade
              from sc_atb.tbl_tba tba
                inner join sc_atb.tbl_etb etb on etb.cd_tba = tba.cd_tba
		inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = etb.cd_fnc
		inner join sc_cad.tbl_fem_ctr fct on fct.cd_emp = fnc.cd_emp and fct.cd_fem = fnc.cd_fem
              where etb.cd_fep is null
                  and etb.fg_cbr_etb = 'S'
                  and fct.cd_ctr = vp_contrato
                  and tba.dt_inc_usr < vp_data_referencia + 1
                  and (vp_filial is null or fct.cd_fem = vp_filial)
              group by fct.cd_emp, fct.cd_fem loop

      vl_tipo_cobranca := sc_cad.get_parametro_contrato(ct_pce_ctr_transferencia, vp_contrato, rg.filialEmpresa, 3)::numeric; 
      vp_valor_unidade := replace(replace(sc_cad.get_parametro_contrato(ct_pce_ctr_transferencia, vp_contrato, rg.filialEmpresa),'.',''),',','.')::numeric; 
  

      vp_quantidade := 0;
      if vl_tipo_cobranca = ct_tp_pgt_pce_ctr_empresa then

        if rg.quantidade > 0 then
          insert into sc_fep.tbl_fep_sfe(cd_fep_sfe, cd_fep, cd_sfe, vl_und_fep_sfe, qtd_fep_sfe, vl_ttl_fep_sfe,cd_fem, cd_emp, fg_dcr_fep_sfe) 
            values(nextval('sc_fep.sq_fep_sfe'), vp_fatura, ct_cd_sfe_transferencia, vp_valor_unidade, rg.quantidade, (rg.quantidade * vp_valor_unidade), rg.filialEmpresa, rg.empresa, 'C');

          update sc_atb.tbl_etb 
            set cd_fep = vp_fatura 
          where cd_ctr = vp_contrato 
            and fg_cbr_etb = 'S' 
            and cd_fep is null 
            and cd_fnc in (select fnc.cd_fnc 
                         from sc_atb.tbl_etb etb
                           inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = etb.cd_fnc
                         where fnc.cd_emp = rg.empresa
                         and (rg.filialEmpresa is null or fnc.cd_fem = rg.filialEmpresa));
      end if;

      vp_quantidade := vp_quantidade + rg.quantidade;
  
  end if;

 end loop; 
end;$$;


ALTER FUNCTION sc_fep.cobrar_tarifa_transferencia(vp_contrato numeric, vp_fatura numeric, vp_data_referencia date, vp_filial numeric, OUT vp_quantidade numeric, OUT vp_valor_unidade numeric) OWNER TO scan;

--
-- TOC entry 1352 (class 1255 OID 564403)
-- Name: contabilizar_baixa_por_tipo(numeric, double precision, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION contabilizar_baixa_por_tipo(vp_cod_fatura numeric, vp_vlr_baixa double precision, vp_tp_baixa numeric, vp_cod_usuario numeric, vp_conta_origem numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
-- FUNCAO RESPONSAVEL POR REALIZAR CREDITOS NA CONTA DA EMPRESA
-- E DEBITO NA CONTA "VINCULADA" AO TIPO DE PAGAMENTO. ESSA FUNCAO É
-- UTILIZADA DURANTE O PROCESSO DE BAIXA DE FATURA DE EMPRESA.
-- ESSA FUNCAO NAO DEVE SER CHAMADA ISOLADAMENTE. ELA DEVE SER CHAMADA
-- ANTES DA FUNCAO DE REALIZACAO DE BAIXA(SC_FEP.BAIXAR_FATURA_EMPRESA).
-- ALBREGADO.

DECLARE

  TPE_CD_DESCONTO sc_fep.tbl_tpe.cd_tpe%type := 1;	
  TPE_CD_SALDO_CONTA sc_fep.tbl_tpe.cd_tpe%type := 2;
  TPE_CD_CONTA_BANCO sc_fep.tbl_tpe.cd_tpe%type := 3;
  TPE_CD_BOLETO sc_fep.tbl_tpe.cd_tpe%type := 4;
  
  CD_SISTEMA_BAIXA_FATURA_EMPRESA sc_cnt.tbl_sst.cd_sst%type := 12;
  
  vl_tipo_lancamento_baixa sc_cnt.tbl_tlc.cd_tlc%type;
  vl_conta_origem_baixa sc_cnt.tbl_cnt.cd_cnt%type;
  vl_conta_empresa sc_cnt.tbl_cnt.cd_cnt%type;
  vl_saldo_conta_debito sc_cnt.tbl_cnt.vl_sld_cnt%type := 0;
  
  CD_TLC_TRANSFERENCIA_BAIXA_FATURA_EMPRESA sc_cnt.tbl_tlc.cd_tlc%type := 98;

BEGIN
  
    vl_tipo_lancamento_baixa := CD_TLC_TRANSFERENCIA_BAIXA_FATURA_EMPRESA;
    
    select tpe.cd_cnt
    into vl_conta_origem_baixa
    from sc_fep.tbl_tpe tpe
    where tpe.cd_tpe = vp_tp_baixa;
    
    if(vp_tp_baixa <> TPE_CD_SALDO_CONTA) then
    
    -- OBTENDO O CODIGO DA CONTA DA EMPRESA
    
       select cd_cnt
       into vl_conta_empresa
       from sc_cad.tbl_ctr ctr
         inner join sc_fep.tbl_fep fep on fep.cd_ctr = ctr.cd_ctr
       where fep.cd_fep = vp_cod_fatura;
    
      -- SE A CONTA DO PARAMETRO FOR PASSADA, SEMPRE SERÁ CONSIDERADA 
      if vp_conta_origem is not null then
         vl_conta_origem_baixa := vp_conta_origem;
      end if;
      
      if vl_conta_origem_baixa is null then
        raise exception 'Não foi possível efetuar a baixa da fatura. Conta de origem não informada.';
      end if;
      
      vl_saldo_conta_debito := sc_cnt.saldo_conta(vl_conta_origem_baixa,'S','S');
      
      if (vl_saldo_conta_debito >= vp_vlr_baixa OR vp_tp_baixa = TPE_CD_DESCONTO)then    
          
         perform sc_cnt.lancar_debito_credito(vl_conta_origem_baixa,
                                              vl_conta_empresa,
                                              vl_tipo_lancamento_baixa,
                                              NULL,
                                              'TRANSFERENCIA PARA BAIXA DE FATURA EMPRESA',
                                              vp_vlr_baixa,
                                              now()::timestamp,
                                              vp_cod_usuario,
                                              CD_SISTEMA_BAIXA_FATURA_EMPRESA,
                                              (to_char(now(),'yyyymmdd'))::numeric);
                  
      else
	RAISE EXCEPTION 'Não foi possível efetuar a baixa da fatura. Saldo da conta insuficiente.';
      end if;    
      
    end if;
    
END;
$$;


ALTER FUNCTION sc_fep.contabilizar_baixa_por_tipo(vp_cod_fatura numeric, vp_vlr_baixa double precision, vp_tp_baixa numeric, vp_cod_usuario numeric, vp_conta_origem numeric) OWNER TO scan;

--
-- TOC entry 1353 (class 1255 OID 564404)
-- Name: contabilizar_baixar_fatura_empresa(numeric, double precision, numeric, timestamp without time zone, numeric, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION contabilizar_baixar_fatura_empresa(vp_cod_fatura numeric, vp_vlr_baixa double precision, vp_tp_baixa numeric, vp_data_baixa timestamp without time zone, vp_cod_usuario numeric, vp_conta_origem numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

BEGIN

  perform sc_fep.contabilizar_baixa_por_tipo(vp_cod_fatura,vp_vlr_baixa,vp_tp_baixa,vp_cod_usuario,vp_conta_origem);
  
  perform sc_fep.baixar_fatura_empresa(vp_cod_fatura,vp_vlr_baixa,vp_tp_baixa,vp_data_baixa,vp_cod_usuario,vp_conta_origem);


END;
$$;


ALTER FUNCTION sc_fep.contabilizar_baixar_fatura_empresa(vp_cod_fatura numeric, vp_vlr_baixa double precision, vp_tp_baixa numeric, vp_data_baixa timestamp without time zone, vp_cod_usuario numeric, vp_conta_origem numeric) OWNER TO scan;

--
-- TOC entry 1862 (class 1255 OID 983413)
-- Name: contabilizar_fatura_empresa(numeric, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION contabilizar_fatura_empresa(vp_cod_fatura numeric DEFAULT NULL::numeric, vp_usuario numeric DEFAULT (1)::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;

  VL_SITUACAO_FATURA_CANCELADA sc_fep.tbl_fep.st_fep%type := 3;
  VL_CODIGO_SERVICO_ISS sc_fep.tbl_sfe.cd_sfe%type := 6;
  VL_SISTEMA_FATURAMENTO_EMPRESA sc_cnt.tbl_sst.cd_sst%type := 19;

  vl_conta_debito sc_cnt.tbl_cnt.cd_cnt%type;
  vl_conta_credito sc_cnt.tbl_cnt.cd_cnt%type;
  
begin


   for rg in select sfe.cd_cnt conta_receita,
                    sfe.cd_tlc,
                    sfe.cd_sfe,
                    sfe.fg_crd_dbt_sfe,
                    fep.cd_ctr,
                    ctr.cd_cnt_crd conta_empresa,
                    fep.cd_fep,
                    fep.dt_grc_fep,
                    sum(sf.vl_ttl_fep_sfe) valor
             from sc_fep.tbl_fep fep
                inner join sc_fep.tbl_fep_sfe sf on fep.cd_fep= sf.cd_fep
                inner join sc_fep.tbl_sfe sfe on sfe.cd_sfe = sf.cd_sfe
                inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = fep.cd_ctr
             where fep.dt_ctb_fep is null
               and fep.st_fep <> VL_SITUACAO_FATURA_CANCELADA 
               and (vp_cod_fatura is null or fep.cd_fep = vp_cod_fatura)
             group by sfe.cd_cnt,
                    sfe.cd_tlc,
                    sfe.cd_sfe,
                    sfe.fg_crd_dbt_sfe,
                    fep.cd_ctr,
                    ctr.cd_cnt_crd,
                    fep.dt_grc_fep,
                    fep.cd_fep  
            order by fep.dt_grc_fep loop

	if rg.fg_crd_dbt_sfe = 'D' then 

           vl_conta_debito := rg.conta_receita;
           vl_conta_credito := rg.conta_empresa;
           
        else   

          vl_conta_debito := rg.conta_empresa;
          vl_conta_credito := rg.conta_receita;
          
	end if;

	perform sc_cnt.lancar_debito_credito(vl_conta_debito,vl_conta_credito,rg.cd_tlc,null,'REF FATURA NR '||rg.cd_fep,rg.valor, rg.dt_grc_fep, vp_usuario, VL_SISTEMA_FATURAMENTO_EMPRESA, rg.cd_fep);

	update sc_fep.tbl_fep 
	   set dt_ctb_fep = now() 
	where cd_fep = rg.cd_fep;

   end loop;
   
end$$;


ALTER FUNCTION sc_fep.contabilizar_fatura_empresa(vp_cod_fatura numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1354 (class 1255 OID 564406)
-- Name: corrige_problema_iss(); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION corrige_problema_iss() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin

  for rg in

   select distinct fep.cd_fep, fep.cd_ctr, emp.nm_emp, blt.cd_blt
from sc_fep.tbl_fep fep
inner join sc_cbr.tbl_blt blt on blt.nr_nsu_org_blt = fep.cd_fep and tp_org_blt = 1
inner join sc_cad.tbl_fem_ctr fem_ctr on fem_ctr.cd_ctr = fep.cd_ctr
inner join sc_cad.tbl_fem fem on fem.cd_emp = fem_ctr.cd_emp and fem.cd_fem = fem_ctr.cd_fem
inner join sc_cad.tbl_emp emp on emp.cd_emp = fem.cd_emp
inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
where fep.st_fep = 1
and fem_ctr.fg_atv_fem_ctr = 'S'
and fep.dt_grc_fep >= to_date('01112012','ddmmyyyy')
and cun.nr_cpf_cnpj_cun in
(
09638858000150,
13644774000105,
01438859000140,
63401475000100,
11184353000105,
07169369000503,
10888929000152,
05782682000155,
05846161000114,
11803058000190,
13892588000187,
07362870000150,
11971650000109,
04076757000110,
02906043000166,
09282461000179,
08613221000147,
09059588000123,
12408348000100,
08306533000108,
06051202000149,
04947331000194,
05141617000140,
15312047000168,
02096057000161,
12353200000107,
10367082000160,
11014091000130,
11831617000175,
11448970000170,
10770080000118,
01654874000125
)
order by nm_emp

  loop


	perform sc_fep.corrigir_reter_iss(rg.cd_fep, rg.cd_blt, '14/11/2012');

  end loop;

end;$$;


ALTER FUNCTION sc_fep.corrige_problema_iss() OWNER TO scan;

--
-- TOC entry 1521 (class 1255 OID 853668)
-- Name: corrigir_reter_iss(numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION corrigir_reter_iss(vp_fep numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  ct_sst_emitida_fep numeric := 1;
  ct_sst_paga_fep numeric := 2;
  ct_cd_iss_sfe numeric := 6;

  vl_fg_etd_rec_iss varchar;
  vl_qnt_sfe_iss numeric;
  vl_cd_emp numeric;

  rg record;

  vl_valor_fatura numeric;
  vl_valor_iss numeric := 0.0;
  vl_qtde numeric;
  vl_nosso_numero numeric;

  vl_iss numeric;
  
begin

  -- desfazendo a contabilização
  --perform sc_fep.cancelar_contabilizacao_fatura_empresa(vp_fep); 
  perform sc_cnt.excluir_lancamento('CORRECAO ISS',19,vp_fep,2);
  
  -- flag reter iss
  select fem.fg_etd_rec_fem, emp.cd_emp
    into vl_fg_etd_rec_iss, vl_cd_emp
  from sc_fep.tbl_fep fep
    inner join sc_cad.tbl_fem_ctr fem_ctr on fem_ctr.cd_ctr = fep.cd_ctr
    inner join sc_cad.tbl_fem fem on fem.cd_emp = fem_ctr.cd_emp and fem.cd_fem = fem_ctr.cd_fem
    inner join sc_cad.tbl_emp emp on emp.cd_emp = fem.cd_emp
    inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
  where fep.st_fep in (ct_sst_emitida_fep,ct_sst_paga_fep)
    and fem_ctr.fg_atv_fem_ctr = 'S'
    and fep.cd_fep = vp_fep;

  -- servicos iss
  select count(*)
    into vl_qnt_sfe_iss
  from sc_fep.tbl_fep_sfe fep_sfe
  where fep_sfe.cd_fep = vp_fep
    and fep_sfe.cd_sfe = ct_cd_iss_sfe; -- reter iss;

  -- se não era pra cobrar e cobrou
  if vl_fg_etd_rec_iss = 'N' and vl_qnt_sfe_iss > 0 then

     -- excluindo a cobranca de iss	
     delete from sc_fep.tbl_fep_sfe where cd_sfe = ct_cd_iss_sfe and cd_fep = vp_fep;	

  end if;

  -- se era pra cobrar e não cobrou
  if vl_fg_etd_rec_iss = 'S' and vl_qnt_sfe_iss = 0 then

     vl_valor_iss := 0;
    
     for rg in select cd_fem, sum(vl_ttl_fep_sfe) as valor
               from sc_fep.tbl_fep_sfe 
              where cd_fep = vp_fep
                and fg_dcr_fep_sfe = 'C'
              group by cd_fem loop

        vl_iss := (rg.valor * (0.05))::numeric(6,3);
        vl_valor_iss := vl_valor_iss + vl_iss;

	insert into sc_fep.tbl_fep_sfe (cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_emp,cd_fem,fg_dcr_fep_sfe) values
	  (nextval('sc_fep.sq_fep_sfe'),vp_fep,ct_cd_iss_sfe,vl_iss,1,vl_iss,vl_cd_emp,rg.cd_fem,'D');
              
     end loop;         

  end if;

  vl_valor_iss := vl_valor_iss::numeric(6,2);

  -- pegando novo valor da fatura
     select coalesce(sum(vl_ttl_fep_sfe),0)
        into vl_valor_fatura
         from sc_fep.tbl_fep_sfe 
              where cd_fep = vp_fep
                and fg_dcr_fep_sfe = 'C';

  --atualizando fatura
  update sc_fep.tbl_fep set vl_fep = vl_valor_fatura - vl_valor_iss, vl_org_fep = vl_valor_fatura - vl_valor_iss, dt_ctb_fep = null where cd_fep = vp_fep;
  
  perform sc_cbr.gerar_boleto(1,1,vp_fep);  

  -- contabilizando a fatura novamente
  perform sc_fep.contabilizar_fatura_empresa(vp_fep,2);
  

end;$$;


ALTER FUNCTION sc_fep.corrigir_reter_iss(vp_fep numeric) OWNER TO scan;

--
-- TOC entry 7817 (class 0 OID 0)
-- Dependencies: 1521
-- Name: FUNCTION corrigir_reter_iss(vp_fep numeric); Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON FUNCTION corrigir_reter_iss(vp_fep numeric) IS 'corrigindo o iss caso esteja cadastrado';


--
-- TOC entry 1355 (class 1255 OID 564408)
-- Name: exclui_faturamento_minimo(numeric, date); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION exclui_faturamento_minimo(vp_fatura numeric, vp_vencimento date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

vl_cod_servico numeric;
vl_valor_fat_minimo numeric;
vl_valor_iss numeric;
vl_valor_sem_filial numeric;
vl_novo_valor_fatura numeric;
vl_cod_boleto numeric;


begin


  select cd_fep_sfe, coalesce(vl_ttl_fep_sfe,0)
    into vl_cod_servico, vl_valor_fat_minimo
  from sc_fep.tbl_fep_sfe
   where cd_sfe = 5
    and cd_fep = vp_fatura;


  if vl_valor_fat_minimo > 0 then
     -- deleta o servico de complemento de faturamento minimo
     delete from sc_fep.tbl_fep_sfe where cd_fep_sfe = vl_cod_servico;

     -- verifica se tem iss para filial null se maior que 1 possui liberacao imediada
     -- recalcula iss
     select coalesce(sum(vl_ttl_fep_sfe),0)
      into vl_valor_sem_filial 
     from sc_fep.tbl_fep_sfe
       where cd_fep = vp_fatura
         and cd_fem is null;

     if (vl_valor_sem_filial) > 0 then
        update sc_fep.tbl_fep_sfe 
           set vl_ttl_fep_sfe = round(vl_ttl_fep_sfe*.05,2) 
        where cd_fep = vp_fatura
          and cd_fem is null
          and cd_sfe = 6;
     end if;
 
     select coalesce(sum(vl_ttl_fep_sfe),0)
      from sc_fep.tbl_fep_sfe 
       into vl_novo_valor_fatura
     where cd_fep = vp_fatura
       and fg_dcr_fep_sfe = 'C';
     
    select coalesce(sum(vl_ttl_fep_sfe),0)
      from sc_fep.tbl_fep_sfe
       into vl_valor_iss
     where cd_fep = vp_fatura
       and fg_dcr_fep_sfe = 'D';
     

     -- altera o valor da fatura e nota fiscal
    update sc_fep.tbl_fep set vl_fep = vl_novo_valor_fatura - vl_valor_iss, vl_nfs_fep = vl_novo_valor_fatura where cd_fep = vp_fatura;

    -- altera o boleto
     select cd_blt
        into vl_cod_boleto
     from sc_cbr.tbl_blt
        where tp_org_blt = 1
         and nr_nsu_org_blt = vp_fatura;

    perform sc_cbr.alterar_data_vencimento(vl_cod_boleto,vp_vencimento + 1,vl_novo_valor_fatura - vl_valor_iss,1);
    perform sc_cbr.alterar_data_vencimento(vl_cod_boleto,vp_vencimento,vl_novo_valor_fatura - vl_valor_iss,1); 
   
   
  end if;

end;$$;


ALTER FUNCTION sc_fep.exclui_faturamento_minimo(vp_fatura numeric, vp_vencimento date) OWNER TO scan;

--
-- TOC entry 1845 (class 1255 OID 564409)
-- Name: fatura_campanha_eleicao(date); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION fatura_campanha_eleicao(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_cd_ctr numeric := 0;
  vl_cd_fatura numeric;
  vl_valor_fatura numeric;
  vl_saldo_conta_debito numeric;
  vl_dia_semana varchar;
  vl_conta_empresa numeric;
  
begin

  select to_char(vp_data_referencia, 'D') into vl_dia_semana;

  --if vl_dia_semana = '6' then -- dia de sexta
  if true then -- qquer dia
    -- faturando o contrato governador
    vl_cd_ctr := 837;
    vl_cd_fatura := 0;

    select sc_fep.fatura_contrato(vl_cd_ctr, vp_data_referencia) into vl_cd_fatura;
    
    begin
      select fep.vl_fep
        into strict vl_valor_fatura
      from sc_fep.tbl_fep fep
      where fep.cd_fep = vl_cd_fatura;
    exception when others then
       vl_cd_fatura := 0;      
    end;

    if vl_cd_fatura > 0 then

      update sc_fep.tbl_fep set dt_vnc_fep = current_date + 4, dt_vnc_org_fep = current_date + 4 where cd_fep = vl_cd_fatura;

      select cd_cnt
        into vl_conta_empresa
      from sc_cad.tbl_ctr ctr
        inner join sc_fep.tbl_fep fep on fep.cd_ctr = ctr.cd_ctr
      where fep.cd_fep = vl_cd_fatura;

      perform sc_cbr.gerar_boleto(1,1,vl_cd_fatura);
      --vl_saldo_conta_debito := sc_cnt.saldo_conta(vl_conta_empresa, 'S', 'S');  

      --if vl_saldo_conta_debito > vl_valor_fatura then
      --  perform sc_fep.contabilizar_baixar_fatura_empresa(vl_cd_fatura, vl_valor_fatura, 2, current_timestamp::timestamp without time zone, 1, null);
      --end if;

    end if;

    -- faturando o contrato senadora
    vl_cd_ctr := 839;
    vl_cd_fatura := 0;

    select sc_fep.fatura_contrato(vl_cd_ctr, vp_data_referencia) into vl_cd_fatura;
    
    begin
      select fep.vl_fep
        into strict vl_valor_fatura
      from sc_fep.tbl_fep fep
      where fep.cd_fep = vl_cd_fatura;
    exception when others then
      vl_cd_fatura := 0;
    end;

    if vl_cd_fatura > 0 then

      update sc_fep.tbl_fep set dt_vnc_fep = current_date + 4, dt_vnc_org_fep = current_date + 4 where cd_fep = vl_cd_fatura;

      select cd_cnt
        into vl_conta_empresa
      from sc_cad.tbl_ctr ctr
        inner join sc_fep.tbl_fep fep on fep.cd_ctr = ctr.cd_ctr
      where fep.cd_fep = vl_cd_fatura;

      perform sc_cbr.gerar_boleto(1,1,vl_cd_fatura);
    --vl_saldo_conta_debito := sc_cnt.saldo_conta(vl_conta_empresa, 'S', 'S');  

    --if vl_saldo_conta_debito > vl_valor_fatura then
    --  perform sc_fep.contabilizar_baixar_fatura_empresa(vl_cd_fatura, vl_valor_fatura, 2, current_timestamp::timestamp without time zone, 1, null);
    --end if;

    end if;
  end if;

end;$$;


ALTER FUNCTION sc_fep.fatura_campanha_eleicao(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1335 (class 1255 OID 859093)
-- Name: fatura_contrato(numeric, date, numeric); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION fatura_contrato(vp_cod_contrato numeric, vp_data_referencia date, vp_filial numeric DEFAULT NULL::numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

  ST_FEP_CADASTRADA sc_fep.tbl_fep.st_fep%type := 1;
  COD_PRM_CONTRATO_DIA_VNC_FATURA_EMPRESA sc_cad.tbl_pce.cd_pce%type := 5;

  rg_cun record;
  
  vl_data_vencimento sc_fep.tbl_fep.dt_vnc_fep%type := vp_data_referencia;
  vl_fatura_empresa sc_fep.tbl_fep.vl_fep%type := 0;
  vl_cod_fatura_empresa sc_fep.tbl_fep.cd_fep%type := 0;
  vl_cod_cun sc_fep.tbl_fep.cd_cun%type;
  
  vl_quantidade_servico sc_fep.tbl_fep_sfe.qtd_fep_sfe%type;
  vl_unid_servico sc_fep.tbl_fep_sfe.vl_und_fep_sfe%type;

  vl_valor_liberacao_imediata numeric;
  vl_valor_complemento_fat_minimo numeric;
  vl_valor_iss_retido numeric;
  vl_valor_nota_fiscal_fatura numeric;
  vl_valor_servico_avulso numeric;
  vl_mes_referencia varchar;

begin

  select nextval('sc_fep.sq_fep') into vl_cod_fatura_empresa;

  -- obtendo o cod do cadastro unico
  -- sempre retorna o cun da filial matriz
  -- senao matriz entao a filial de menor codigo
  for rg_cun in 
  select distinct cun.cd_cun, fc.cd_fem, coalesce(fem.fg_mtz_fem,'N') as flag_matriz
  from sc_cad.tbl_ctr ctr
	inner join sc_cad.tbl_fem_ctr fc on fc.cd_ctr = ctr.cd_ctr
	inner join sc_cad.tbl_fem fem on fem.cd_emp = fc.cd_emp and fem.cd_fem = fc.cd_fem
	inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
  where ctr.cd_ctr = vp_cod_contrato
    and (vp_filial is null or fc.cd_fem = vp_filial)
    and fem.fg_atv_fem = 'S'
    and ctr.cd_prd = 1 -- Adicionado por Vitor Vasconcelos em 18-11-2018
    order by flag_matriz DESC, fc.cd_fem ASC loop

       if vl_cod_cun is null or rg_cun.flag_matriz = 'S' then
         vl_cod_cun := rg_cun.cd_cun;
       end if;

  end loop;

  -- obtendo a data de vencimento da fatura de acordo com o contrato
  select to_date(pce_ctr.vl_pce_ctr || '/' || to_char(vp_data_referencia,'MM/YYYY'),'DD/MM/YYYY')
  into vl_data_vencimento
  from sc_cad.tbl_pce_ctr pce_ctr
  where cd_ctr = vp_cod_contrato
    and cd_pce = COD_PRM_CONTRATO_DIA_VNC_FATURA_EMPRESA;

  if vl_data_vencimento < vp_data_referencia then
    vl_mes_referencia := to_char(vp_data_referencia,'MM/YYYY');
    vl_data_vencimento := vl_data_vencimento + interval '1 MONTH';
  else 
    vl_mes_referencia := to_char(vp_data_referencia - interval '1 MONTH','MM/YYYY');	
  end if;

  -- cobrar 1 via de cartao
  select *
  into vl_quantidade_servico,vl_unid_servico
  from sc_fep.cobrar_primeira_via_crt(vp_cod_contrato,vl_cod_fatura_empresa,vp_data_referencia,vp_filial);
                                          
  vl_fatura_empresa := vl_fatura_empresa + (coalesce(vl_quantidade_servico,0) * coalesce(vl_unid_servico,0));

  -- cobrar 2 via de cartao
  select *
  into vl_quantidade_servico,vl_unid_servico
  from sc_fep.cobrar_segunda_via_crt(vp_cod_contrato,vl_cod_fatura_empresa,vp_data_referencia,vp_filial);
                                          
  vl_fatura_empresa := vl_fatura_empresa + (coalesce(vl_quantidade_servico,0) * coalesce(vl_unid_servico,0));

  -- cobrar solicitacao de senha
  select *
  into vl_quantidade_servico,vl_unid_servico
  from sc_fep.cobrar_solicitacao_senha(vp_cod_contrato,vl_cod_fatura_empresa,vp_data_referencia,vp_filial);
                                          
  vl_fatura_empresa := vl_fatura_empresa + (coalesce(vl_quantidade_servico,0) * coalesce(vl_unid_servico,0));

  -- cobrar tarifa de deposito D+1
  select *
  into vl_quantidade_servico,vl_unid_servico
  from sc_fep.cobrar_tarifa_deposito(vp_cod_contrato,vl_cod_fatura_empresa,vp_data_referencia,vp_filial);

  vl_fatura_empresa := vl_fatura_empresa + (coalesce(vl_quantidade_servico,0) * coalesce(vl_unid_servico,0));

  -- cobrar tarifa de deposito D+2
  select *
  into vl_quantidade_servico,vl_unid_servico
  from sc_fep.cobrar_tarifa_deposito_d_2(vp_cod_contrato,vl_cod_fatura_empresa,vp_data_referencia,vp_filial);

  vl_fatura_empresa := vl_fatura_empresa + (coalesce(vl_quantidade_servico,0) * coalesce(vl_unid_servico,0));

  -- cobrar tarifa de saque mensal
  select *
  into vl_quantidade_servico,vl_unid_servico
  from sc_fep.cobrar_tarifa_saque_mensal(vp_cod_contrato,vl_cod_fatura_empresa,vp_data_referencia,vp_filial);

  vl_fatura_empresa := vl_fatura_empresa + (coalesce(vl_quantidade_servico,0) * coalesce(vl_unid_servico,0));

  -- COMENTADO EM ABRIL DE 2016 POR NUNCA SER UTILIZADO
  /*
  select *
  into vl_quantidade_servico,vl_unid_servico
  from sc_fep.cobrar_seguro_perda_roubo(vp_cod_contrato,vl_cod_fatura_empresa, vl_data_vencimento);

  vl_fatura_empresa := vl_fatura_empresa + (coalesce(vl_quantidade_servico,0) * coalesce(vl_unid_servico,0));
  */
  
  -- cobrar tarifa de transferencia
  select *
  into vl_quantidade_servico,vl_unid_servico
  from sc_fep.cobrar_tarifa_transferencia(vp_cod_contrato,vl_cod_fatura_empresa,vp_data_referencia,vp_filial);

  vl_fatura_empresa := vl_fatura_empresa + (coalesce(vl_quantidade_servico,0) * coalesce(vl_unid_servico,0));

  -- cobrar servico avulso de fatura
  select * 
  into vl_valor_servico_avulso
  from sc_fep.cobrar_servico_avulso(vp_cod_contrato,vl_cod_fatura_empresa,vp_data_referencia, vp_filial);
  
  
  vl_fatura_empresa := vl_fatura_empresa + coalesce(vl_valor_servico_avulso,0);
  

  -- cobrar liberacao imediada
  
  select *
    into vl_valor_liberacao_imediata
  from sc_fep.cobrar_liberacao_imediata(vp_cod_contrato,vl_cod_fatura_empresa,vp_data_referencia);
  
  vl_fatura_empresa := vl_fatura_empresa + coalesce(vl_valor_liberacao_imediata,0);
  
  -- calculando o valor da fatura

  select coalesce(sum(case when fg_dcr_fep_sfe = 'C' then vl_ttl_fep_sfe else vl_ttl_fep_sfe * -1 end),0)
    into vl_fatura_empresa
  from sc_fep.tbl_fep_sfe
  where cd_fep = vl_cod_fatura_empresa
    and cd_sfe not in (6); -- 6-ISS retido na fonta; 
  
  -- a cobranca do faturamento minimo em caso de faturamento por filial
  -- eh verificado ao final do faturamento
  if vp_filial is null then
  
    -- cobrar faturamento minimo
	--alteração feita na função de cobrar_faturamento_minimo conforme solicitado no ticket #60
    select *
      into vl_valor_complemento_fat_minimo
    from sc_fep.cobrar_faturamento_minimo(vp_cod_contrato,vl_cod_fatura_empresa,vl_fatura_empresa, vl_mes_referencia);

    
    vl_fatura_empresa := vl_fatura_empresa + coalesce(vl_valor_complemento_fat_minimo,0);
    

  end if;
  
  -- cobrar iss retido
  select *
  into vl_valor_iss_retido
  from sc_fep.cobrar_iss_retido_fonte(vp_cod_contrato, vl_cod_fatura_empresa, vl_valor_complemento_fat_minimo, vl_valor_liberacao_imediata, vp_filial);

  -- calculando o valor da fatura
  select sum(case when fg_dcr_fep_sfe = 'C' then vl_ttl_fep_sfe else vl_ttl_fep_sfe * -1 end)
    into vl_fatura_empresa
  from sc_fep.tbl_fep_sfe
  where cd_fep = vl_cod_fatura_empresa
    and cd_sfe not in (6); -- 6-ISS retido na fonta; 

  vl_valor_nota_fiscal_fatura := vl_fatura_empresa;

  if vl_valor_iss_retido > 0 then
    vl_fatura_empresa := vl_fatura_empresa - vl_valor_iss_retido::numeric(13,2);
  end if;

  -- inserindo o registro da fatura
  if vl_fatura_empresa > 0 then null;
     insert into sc_fep.tbl_fep(cd_fep,cd_ctr,vl_fep,dt_vnc_fep,st_fep,mes_ref_fep,dt_grc_fep,vl_nfs_fep,fg_eml_env_fep,cd_cun, dt_vnc_org_fep, vl_org_fep, fg_vld_atr_fep)
        values(vl_cod_fatura_empresa,vp_cod_contrato, vl_fatura_empresa,vl_data_vencimento,ST_FEP_CADASTRADA,vl_mes_referencia,now(),vl_valor_nota_fiscal_fatura,'N',vl_cod_cun,vl_data_vencimento, vl_fatura_empresa, 'S');

     -- gerando o boleto da fatura
     perform sc_cbr.gerar_boleto_fatura_empresa(vl_cod_fatura_empresa);   
  end if;

  return vl_cod_fatura_empresa;
  
end
$$;


ALTER FUNCTION sc_fep.fatura_contrato(vp_cod_contrato numeric, vp_data_referencia date, vp_filial numeric) OWNER TO scan;

--
-- TOC entry 1715 (class 1255 OID 1007054)
-- Name: fatura_empresas(date, numeric); Type: FUNCTION; Schema: sc_fep; Owner: postgres
--

CREATE FUNCTION fatura_empresas(vp_data_ref date, vp_codigo_empresa numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  rg_fem record;

  COD_PRM_CONTRATO_VL_COMPLEMENTO_FAT_MINIMO sc_cad.tbl_pce.cd_pce%type := 2; 
  COD_SRV_ISS_RETIDO_FONTE sc_fep.tbl_sfe.cd_sfe%type := 6;

  vl_fatura_matriz numeric;
  vl_cod_fatura numeric;
  vl_valor_fatura numeric(13,2);
  vl_soma_fatura numeric(13,2);
  vl_valor_faturamento_minimo numeric(13,2);
  vl_servicos_empresa numeric;
  vl_iss_retido_empresa numeric(13,3);
  vl_porcentagem_iss_retido numeric;
  
BEGIN

  vp_data_ref := coalesce(vp_data_ref,current_date);
  
  for rg in select ctr.cd_ctr, ctr.fg_fat_fem_ctr, ctr.cd_emp
            from sc_cad.tbl_ctr ctr
              inner join sc_cad.tbl_pce_ctr pcc on pcc.cd_ctr = ctr.cd_ctr
            where ctr.fg_atv_ctr = 'S'
              and ctr.cd_prd = 1 -- FATURA SOMENTE PRODUTO SALARIO DEVIDO PROBLEMA COM PREMIUM JOAO VICTOR 03/12/2018
              and pcc.cd_pce = 17
              and (vp_codigo_empresa is null or ctr.cd_emp = vp_codigo_empresa)
              and pcc.vl_pce_ctr::numeric = to_char(vp_data_ref,'dd')::numeric  LOOP

     vl_fatura_matriz := null;
     vl_soma_fatura := 0;
                                 
     if rg.fg_fat_fem_ctr = 'S' then

       for rg_fem in select distinct fc.cd_fem, coalesce(fem.fg_mtz_fem,'N') as flag_matriz
                     from sc_cad.tbl_fem_ctr fc
                     inner join sc_cad.tbl_fem fem on fem.cd_emp = rg.cd_emp and fem.cd_fem = fc.cd_fem  
                     where fc.cd_ctr = rg.cd_ctr
                       and fem.fg_atv_fem = 'S'
                     order by flag_matriz DESC, fc.cd_fem ASC loop
                       
              vl_cod_fatura := sc_fep.fatura_contrato(rg.cd_ctr,vp_data_ref, rg_fem.cd_fem);

              select vl_nfs_fep
                into vl_valor_fatura
              from sc_fep.tbl_fep
              where cd_fep = vl_cod_fatura;

              vl_valor_fatura := coalesce(vl_valor_fatura,0);

              vl_soma_fatura := vl_soma_fatura + vl_valor_fatura;

              if vl_fatura_matriz is null and vl_valor_fatura > 0 then
                vl_fatura_matriz := vl_cod_fatura;
              end if;
  
       end loop;    

       --retornando valor do complemento de faturamento minimo
       select coalesce(replace(pce_ctr.vl_pce_ctr,',','.')::numeric,0)
         into vl_valor_faturamento_minimo
       from sc_cad.tbl_pce_ctr pce_ctr
       where cd_pce = COD_PRM_CONTRATO_VL_COMPLEMENTO_FAT_MINIMO
       and cd_ctr = rg.cd_ctr;
        
       -- se o somatorio dos valores das faturas forem menor o faturamento minimo
       -- deve ser cobrado na matriz, senao existe matriz sera na filial de menor codigo
       if vl_soma_fatura < vl_valor_faturamento_minimo then

         perform sc_fep.cobrar_faturamento_minimo(rg.cd_ctr, vl_fatura_matriz, vl_soma_fatura);

       end if;

       -- retornando o valor de servicos somente da empresa
       select sum(vl_ttl_fep_sfe)
        into vl_servicos_empresa
       from sc_fep.tbl_fep_sfe
        where cd_fep = vl_fatura_matriz
        and cd_fem is null;

       vl_servicos_empresa := coalesce(vl_servicos_empresa,0);
      
       -- cobrar iss servicos gerados somente na empresa, ou seja, sem referencia a filial
       if vl_servicos_empresa > 0 then

         select replace(vl_prm,',','.')::numeric
           into vl_porcentagem_iss_retido
         from sc_cad.tbl_prm
         where nm_prm = 'VALOR_ISS_RETER_EMPRESA';

         vl_iss_retido_empresa := vl_servicos_empresa * (vl_porcentagem_iss_retido / 100);

         insert into sc_fep.tbl_fep_sfe(cd_fep_sfe,cd_fep,cd_sfe,vl_und_fep_sfe,qtd_fep_sfe,vl_ttl_fep_sfe,cd_fem,cd_emp,fg_dcr_fep_sfe) 
           values(nextval('sc_fep.sq_fep_sfe'),vl_fatura_matriz,COD_SRV_ISS_RETIDO_FONTE,vl_iss_retido_empresa,1,vl_iss_retido_empresa,null,rg.cd_emp,'D');

       end if;

       select sum(vl_ttl_fep_sfe)
         into vl_valor_fatura
       from sc_fep.tbl_fep_sfe
         where cd_fep = vl_fatura_matriz
       and cd_sfe <> COD_SRV_ISS_RETIDO_FONTE;

       select sum(vl_ttl_fep_sfe)
         into vl_iss_retido_empresa
       from sc_fep.tbl_fep_sfe
         where cd_fep = vl_fatura_matriz
         and cd_sfe = COD_SRV_ISS_RETIDO_FONTE;

       vl_iss_retido_empresa := coalesce(vl_iss_retido_empresa,0);

       vl_iss_retido_empresa := vl_iss_retido_empresa::numeric(13,2); 

       -- ajustando o valor da fatura e gerando novo boleto
       update sc_fep.tbl_fep 
          set vl_nfs_fep = vl_valor_fatura, 
              vl_fep = vl_valor_fatura - vl_iss_retido_empresa,
              vl_org_fep = vl_valor_fatura - vl_iss_retido_empresa,
              cd_blt = null
       where cd_fep = vl_fatura_matriz;

       delete from sc_cbr.tbl_blt where nr_nsu_org_blt = vl_fatura_matriz and tp_org_blt = 1;

       perform sc_cbr.gerar_boleto_fatura_empresa(vl_fatura_matriz);

     else

       perform sc_fep.fatura_contrato(rg.cd_ctr,vp_data_ref);

     end if;


     -- marcando os arquivos do tipo rescisao para nao haver cobranca retroativa caso o
     -- parametro de cobranca seja alterado para SIM
     update sc_adp.tbl_hfe set fg_cbr_hfe = 'S' where cd_hfe in (
      select hfe.cd_hfe
      from sc_adp.tbl_hfe hfe
      where (hfe.fg_cbr_hfe = 'N' or hfe.fg_cbr_hfe is null)
        and hfe.cd_ctr = rg.cd_ctr
        and hfe.st_hfe = 5 -- DEPOSITADO
        and hfe.cd_tdp = 5 -- DEPOSITADO
        and hfe.dt_dps_hfe < vp_data_ref);
     
  end loop;

  -- retornando a validacao de atraso para o proximo dia util
  if sc_grl.eh_dia_util(vp_data_ref) then

      update sc_fep.tbl_fep
        set fg_vld_atr_fep = 'S'
      where fg_vld_atr_fep = 'N'
        and dt_fg_vld_atr_fep < vp_data_ref;
     
  end if;
             
END;
$$;


ALTER FUNCTION sc_fep.fatura_empresas(vp_data_ref date, vp_codigo_empresa numeric) OWNER TO postgres;

--
-- TOC entry 1805 (class 1255 OID 1668897)
-- Name: gerar_registro_servico_tsm(numeric, numeric, numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_fep; Owner: postgres
--

CREATE FUNCTION gerar_registro_servico_tsm(vp_contrato numeric, vp_empresa numeric, vp_filial numeric, vp_fatura numeric, vp_servico numeric, vp_valor_tarifa numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;
  
  vl_quantidade integer := 0;
  
  vl_existe integer := 0;
  
  CT_SITUACAO_DEPOSITADO constant integer := 5;
  CT_SERVICO_TSM constant integer := 12;
  
  CT_SITUACAO_CANCELADO constant integer := 3;
  CT_SITUACAO_COBRADO_EMPRESA constant integer := 4;
begin
  for vl_rg in select distinct rdp.cd_crt
               from sc_adp.tbl_rdp rdp
                    inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
                    inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
               where rdp.st_rdp = CT_SITUACAO_DEPOSITADO
                 and crt.cd_ctr = vp_contrato
                 and hfe.cd_emp = vp_empresa
                 and hfe.cd_fem = vp_filial 
                 and hfe.cd_fep = vp_fatura loop
    vl_quantidade := vl_quantidade + 1;

    select coalesce(count(*), 0)
      into vl_existe
    from sc_srv.tbl_tsc tsc
         inner join sc_fep.tbl_fep_sfe fep_sfe on tsc.cd_fep_sfe = fep_sfe.cd_fep_sfe
    where fep_sfe.cd_fep = vp_fatura
      and tsc.st_tsc <> CT_SITUACAO_CANCELADO
      and tsc.cd_srv = CT_SERVICO_TSM
      and tsc.cd_crt = vl_rg.cd_crt;

    if vl_existe = 0 then
      insert into sc_srv.tbl_tsc(cd_tsc, cd_srv, cd_crt, vl_tsc, st_tsc, dt_vnc_tsc, cd_inc_usr, dt_inc_usr, cd_fep_sfe)
      values(nextval('sc_srv.sq_tsc'), CT_SERVICO_TSM, vl_rg.cd_crt, vp_valor_tarifa, CT_SITUACAO_COBRADO_EMPRESA, current_date, 1, now(), vp_servico);
    end if;
  end loop;

  return vl_quantidade;
end;$$;


ALTER FUNCTION sc_fep.gerar_registro_servico_tsm(vp_contrato numeric, vp_empresa numeric, vp_filial numeric, vp_fatura numeric, vp_servico numeric, vp_valor_tarifa numeric) OWNER TO postgres;

--
-- TOC entry 1809 (class 1255 OID 1668895)
-- Name: marcar_pagamento_tsm(numeric); Type: FUNCTION; Schema: sc_fep; Owner: postgres
--

CREATE FUNCTION marcar_pagamento_tsm(vp_codigo_fatura numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;

  CT_SITUACAO_COBRADO_EMPRESA constant integer := 4;
  CT_SITUACAO_PAGO_EMPRESA constant integer := 5;
begin
  for vl_rg in select tsc.cd_tsc
               from sc_srv.tbl_tsc tsc
                    inner join sc_fep.tbl_fep_sfe fep_sfe on tsc.cd_fep_sfe = fep_sfe.cd_fep_sfe
               where fep_sfe.cd_fep = vp_codigo_fatura
                 and tsc.st_tsc = CT_SITUACAO_COBRADO_EMPRESA loop
    update sc_srv.tbl_tsc
       set st_tsc = CT_SITUACAO_PAGO_EMPRESA,
           dt_pgto_tsc = now()
    where cd_tsc = vl_rg.cd_tsc;
  end loop;    
end;$$;


ALTER FUNCTION sc_fep.marcar_pagamento_tsm(vp_codigo_fatura numeric) OWNER TO postgres;

--
-- TOC entry 1359 (class 1255 OID 564412)
-- Name: prorrogar_altera_valor_fatura_vencida(numeric, numeric, date, double precision, double precision); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION prorrogar_altera_valor_fatura_vencida(vp_fatura numeric, vp_usuario numeric, vp_data_prorrogada date DEFAULT ('now'::text)::date, vp_valor_multa double precision DEFAULT 2.99, vp_valor_mora_dia double precision DEFAULT 0.05) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_dias_diferenca numeric;
  vl_data_vencimento_fatura date;
  vl_valor_fatura double precision;
  vl_valor_mora double precision := 0;
  vl_cd_boleto numeric;
begin

  -- dados da fatura
  begin
    select vl_fep, dt_vnc_fep
      into strict vl_valor_fatura, vl_data_vencimento_fatura
    from sc_fep.tbl_fep
    where cd_fep = vp_fatura;
  exception when others then
    raise 'Não existe fatura de empresa com esse código';
  end;

  -- dados do boleto
  begin
    select blt.cd_blt 
      into strict vl_cd_boleto
    from sc_cbr.tbl_blt blt
    where blt.nr_nsu_org_blt = vp_fatura
      and blt.tp_org_blt = 1; -- fatura de empresa
  exception when others then
    raise 'Não existe boleta para a fatura de empresa';
  end;

  vl_dias_diferenca := vp_data_prorrogada - vl_data_vencimento_fatura;
  vl_valor_mora := vl_dias_diferenca * vp_valor_mora_dia;

  vl_valor_fatura := vl_valor_fatura + vl_valor_mora + vp_valor_multa;

  -- atualizar valor do boleto e da fatura
  update sc_fep.tbl_fep set vl_fep = vl_valor_fatura where cd_fep = vp_fatura;
  update sc_cbr.tbl_blt set vl_blt = vl_valor_fatura where cd_blt = vl_cd_boleto;

  -- prorrogar a data do vencimento
  perform sc_cbr.alterar_data_vencimento(vl_cd_boleto, vp_data_prorrogada, vp_usuario);

end;$$;


ALTER FUNCTION sc_fep.prorrogar_altera_valor_fatura_vencida(vp_fatura numeric, vp_usuario numeric, vp_data_prorrogada date, vp_valor_multa double precision, vp_valor_mora_dia double precision) OWNER TO scan;

--
-- TOC entry 1360 (class 1255 OID 564413)
-- Name: reprocessar_prorrogacao(); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION reprocessar_prorrogacao() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  vl_juros numeric;
  vl_multa numeric;
  tx_juros numeric := 0.01; -- 1% 
  qtd_dias numeric;
  
  data_prorrogacao date;
  
  verifica_cobrar_multa numeric;
  
BEGIN

    -- ROTINA QUE RECALCULA OS JUROS E MULTA COBRADOS EM UMA PRORROGACAO DE FATURA DE EMPRESA.
    
    for rg in select *
              from sc_fep.tbl_apf apf
                inner join sc_fep.tbl_fep fep on fep.cd_fep = apf.cd_fep
              where apf.vl_apf <> fep.vl_fep   loop
       
       vl_juros = null;
       vl_multa = null;
              
       select dt_vnc_apf
       into data_prorrogacao
       from sc_fep.tbl_apf apf
       where apf.cd_fep = rg.cd_fep
         and apf.cd_apf =(select min(a.cd_apf)
                          from sc_fep.tbl_apf a
                          where a.cd_fep = apf.cd_fep
                            and a.cd_apf > rg.cd_apf);
                            
       if(data_prorrogacao is null) then
       	  select dt_vnc_fep 
            into data_prorrogacao 
          from sc_fep.tbl_fep 
          where cd_fep = rg.cd_fep;	
       end if;              
              
       qtd_dias = date_trunc('day',data_prorrogacao)::date - date_trunc('day',rg.dt_vnc_apf)::date;  
       --qtd_dias = (date_data_prorrogacao -  rg.dt_vnc_apf;  
       
       vl_juros = ((tx_juros/30) * rg.vl_apf)*qtd_dias;
       
       select count(*)
       into verifica_cobrar_multa
       from sc_fep.tbl_apf apf
       where apf.cd_fep = rg.cd_fep
         and apf.cd_apf < rg.cd_apf;
         
       if(verifica_cobrar_multa is null or verifica_cobrar_multa = 0) then
         vl_multa := 0.02 * rg.vl_apf;
       end if;  
       
       update sc_fep.tbl_apf 
       set vl_mlt_apf = vl_multa, 
           vl_jrs_apf = vl_juros 
       where cd_apf = rg.cd_apf;
       
     end loop;          
  
       -- REPROCESSANDO AS PRORROGACOES QUE FORAM REALIZADAS DE MANEIRA INCORRETAS:SEMPRE COBRANDO MULTA
       update sc_fep.tbl_apf 
       set vl_mlt_apf = 0.02*vl_apf
       where cd_fep IN(select distinct a.cd_fep
         from  sc_fep.tbl_apf a
            inner join sc_fep.tbl_fep fep on fep.cd_fep = a.cd_fep
         where a.cd_apf =(select max(apf.cd_apf) from sc_fep.tbl_apf apf where apf.cd_fep=a.cd_fep) 
           and ((coalesce(a.vl_mlt_apf,0)+coalesce(vl_jrs_apf,0) + a.vl_apf)-fep.vl_fep) <0
         );


END;
$$;


ALTER FUNCTION sc_fep.reprocessar_prorrogacao() OWNER TO scan;

--
-- TOC entry 1478 (class 1255 OID 1671963)
-- Name: retira_cobranca_faturamento_minimo(numeric); Type: FUNCTION; Schema: sc_fep; Owner: postgres
--

CREATE FUNCTION retira_cobranca_faturamento_minimo(vp_codigo_fatura numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;
  vl_valor_desconto numeric := 0.0;
begin
  for vl_rg in select cd_fep_sfe as codigo, vl_ttl_fep_sfe as valor
               from sc_fep.tbl_fep_sfe
               where cd_sfe = 5
                 and fg_dcr_fep_sfe = 'C'
                 and cd_fep = vp_codigo_fatura loop

    delete from sc_fep.tbl_fep_sfe where cd_fep_sfe = vl_rg.codigo;
    vl_valor_desconto := vl_valor_desconto + vl_rg.valor;
  end loop;

  if vl_valor_desconto > 0 then
    update sc_fep.tbl_fep 
       set vl_fep = vl_fep - vl_valor_desconto, 
           vl_nfs_fep = vl_nfs_fep - vl_valor_desconto, 
           vl_org_fep = vl_org_fep - vl_valor_desconto 
    where cd_fep = vp_codigo_fatura;

    perform sc_cbr.gerar_boleto(1, 1, vp_codigo_fatura);
  end if;
end;$$;


ALTER FUNCTION sc_fep.retira_cobranca_faturamento_minimo(vp_codigo_fatura numeric) OWNER TO postgres;

--
-- TOC entry 7818 (class 0 OID 0)
-- Dependencies: 1478
-- Name: FUNCTION retira_cobranca_faturamento_minimo(vp_codigo_fatura numeric); Type: COMMENT; Schema: sc_fep; Owner: postgres
--

COMMENT ON FUNCTION retira_cobranca_faturamento_minimo(vp_codigo_fatura numeric) IS 'rotina que retira a cobrança de faturamento minimo de uma determinada fatura';


--
-- TOC entry 1492 (class 1255 OID 564414)
-- Name: separa_fatura_empresa(numeric, numeric, date); Type: FUNCTION; Schema: sc_fep; Owner: scan
--

CREATE FUNCTION separa_fatura_empresa(vp_fatura_atual numeric, vp_filial_out numeric, vp_dt_vencimento date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;

  vl_proxima_fatura numeric;

  vl_valor_nfs_fatura numeric;
  vl_valor_iss_fatura numeric;
  
  vl_codigo_boleto numeric;
  vl_nosso_numero_boleto numeric;

  vl_data_vencimento_fatura date;
  vl_valor_fatura numeric;
begin

  -- cancelando o faturamento visto que irá refazer
  perform sc_fep.cancelar_contabilizacao_fatura_empresa(vp_fatura_atual); -- codigo da fatura

  --iterando sobre as filiais de uma fatura
  
  for rg in 
      select distinct cd_fem, cd_emp
      from sc_fep.tbl_fep_sfe 
      where cd_fep = vp_fatura_atual
        and cd_fem <> vp_filial_out
      order by cd_fem  loop

      -- pegando codigo da nova fatura
      select nextval('sc_fep.sq_fep') into vl_proxima_fatura;

        -- inserindo a nova fatura
      insert into sc_fep.tbl_fep 
      select vl_proxima_fatura as cd_fep, cd_ctr, 0 as vl_fep, dt_vnc_fep, st_fep, null as vl_pgt_fep, dt_grc_fep, mes_ref_fep, 0 as vl_nfs_fep,fg_eml_env_fep, null as dt_eml_env_fep, cd_cun, null, dt_vnc_fep
      from sc_fep.tbl_fep where cd_fep = vp_fatura_atual;

      -- atualizando os servicos para nova fatura
      update sc_fep.tbl_fep_sfe set cd_fep = vl_proxima_fatura where cd_fep = vp_fatura_atual and cd_fem = rg.cd_fem;

      --atualizando o hfe e o ssp
      update sc_adp.tbl_hfe set cd_fep = vl_proxima_fatura where cd_fep = vp_fatura_atual and cd_fem = rg.cd_fem;
    
      update sc_ssp.tbl_ssp set cd_fep = vl_proxima_fatura 
      where cd_fep = vp_fatura_atual 
      and cd_pls in (select cd_pls from sc_opr.tbl_pls pls 
                     inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
                     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                     where fnc.cd_fem = rg.cd_fem and fnc.cd_emp = rg.cd_emp);

      --atualizando valor e vencimento da nova fatura
   select coalesce(sum(vl_ttl_fep_sfe),0)
   into vl_valor_nfs_fatura
  from sc_fep.tbl_fep_sfe
   where cd_fep = vl_proxima_fatura
     and fg_dcr_fep_sfe = 'C';

  select coalesce(sum(vl_ttl_fep_sfe),0)
   into vl_valor_iss_fatura
  from sc_fep.tbl_fep_sfe
   where cd_fep = vl_proxima_fatura
     and fg_dcr_fep_sfe = 'D'; 

     update sc_fep.tbl_fep 
        set vl_fep = vl_valor_nfs_fatura - vl_valor_iss_fatura, 
	    vl_nfs_fep = vl_valor_nfs_fatura, 
	    dt_vnc_fep = vp_dt_vencimento, 
	    vl_org_fep = vl_valor_nfs_fatura - vl_valor_iss_fatura
     where cd_fep = vl_proxima_fatura;

      --gerando boleto nova fatura
      perform sc_cbr.gerar_boleto_fatura_empresa(vl_proxima_fatura);               

  end loop;  

  -- calculando novo valor
  select coalesce(sum(vl_ttl_fep_sfe),0)
   into vl_valor_nfs_fatura
  from sc_fep.tbl_fep_sfe
   where cd_fep = vp_fatura_atual
     and fg_dcr_fep_sfe = 'C';

  select coalesce(sum(vl_ttl_fep_sfe),0)
   into vl_valor_iss_fatura
  from sc_fep.tbl_fep_sfe
   where cd_fep = vp_fatura_atual
     and fg_dcr_fep_sfe = 'D';   
  

  -- atualizando o valor da fatura atual
  update sc_fep.tbl_fep set vl_fep = vl_valor_nfs_fatura - vl_valor_iss_fatura, vl_org_fep = vl_valor_nfs_fatura - vl_valor_iss_fatura, vl_nfs_fep = vl_valor_nfs_fatura  where cd_fep = vp_fatura_atual;

  -- atualizando o boleto
  /*select cd_blt, cd_doc_blt 
    into vl_codigo_boleto, vl_nosso_numero_boleto
  from sc_cbr.tbl_blt
  where nr_nsu_org_blt = vp_fatura_atual
    and tp_org_blt = 1;  

  delete from sc_cbr.tbl_blt where cd_blt = vl_codigo_boleto; */

   -- refazendo o boleto da fatura separada
  perform sc_cbr.gerar_boleto(1,1,vp_fatura_atual);  

  -- refazendo a contabilidade das faturas de empresas geradas
  perform sc_fep.contabilizar_fatura_empresa();
 
end;$$;


ALTER FUNCTION sc_fep.separa_fatura_empresa(vp_fatura_atual numeric, vp_filial_out numeric, vp_dt_vencimento date) OWNER TO scan;

--
-- TOC entry 7819 (class 0 OID 0)
-- Dependencies: 1492
-- Name: FUNCTION separa_fatura_empresa(vp_fatura_atual numeric, vp_filial_out numeric, vp_dt_vencimento date); Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON FUNCTION separa_fatura_empresa(vp_fatura_atual numeric, vp_filial_out numeric, vp_dt_vencimento date) IS 'Rotina que separa fatura de empresas';


SET search_path = sc_fin, pg_catalog;

--
-- TOC entry 1361 (class 1255 OID 564415)
-- Name: cancelar_boleto_avulso(); Type: FUNCTION; Schema: sc_fin; Owner: scan
--

CREATE FUNCTION cancelar_boleto_avulso() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  
begin

  -- capturando os boletos gerados com mais de 15 dias para realizar o cancelamento
  update sc_fin.tbl_bla 
     set st_bla = 3, 
         cd_alt_usr = 1, 
         dt_alt_usr = now()
  where st_bla = 1
    and dt_inc_usr + interval '15 day' < current_date;
  
end;$$;


ALTER FUNCTION sc_fin.cancelar_boleto_avulso() OWNER TO scan;

--
-- TOC entry 1522 (class 1255 OID 857589)
-- Name: cancelar_contabilizacao_recebimento_recurso(numeric, numeric, character varying); Type: FUNCTION; Schema: sc_fin; Owner: scan
--

CREATE FUNCTION cancelar_contabilizacao_recebimento_recurso(vp_codigo numeric, vp_usuario numeric, vp_historico character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  vl_rg_lcn sc_cnt.tbl_lcn%rowtype;
  vl_tipo_lancamento_estorno numeric;
  vl_cd_lcn numeric;
  vl_ctp_cd numeric;
  vl_valor_estorno_lancamento numeric;
  vl_quantidade_lancamento numeric;
  vl_lancamento_contra_partida numeric;

begin

   for vl_rg_lcn in select *
                   from sc_cnt.tbl_lcn lcn
                   where lcn.cd_sst = 14
                     and lcn.nsu_lcn = vp_codigo
                     and lcn.cd_tlc = 1
                     and lcn.cd_est_lcn is null 
                     order by lcn.cd_ctp_lcn DESC loop

    select cd_est_tlc
      into vl_tipo_lancamento_estorno
    from sc_cnt.tbl_tlc tlc
    where tlc.cd_tlc = vl_rg_lcn.cd_tlc;

    select nextval('sc_cnt.sq_lcn') into vl_cd_lcn;
    
    update sc_cnt.tbl_lcn set
      cd_est_lcn = vl_cd_lcn
    where cd_lcn = vl_rg_lcn.cd_lcn;

    if vl_rg_lcn.cd_ctp_lcn is null then
      vl_lancamento_contra_partida := null;
    end if;

    if vl_rg_lcn.fg_dcr_lcn = 'C' then
      perform sc_cnt.lancar_movimento(vl_cd_lcn, vl_lancamento_contra_partida, vl_tipo_lancamento_estorno, vl_rg_lcn.cd_cnt, 'D', vl_rg_lcn.vl_lcn, vl_rg_lcn.dt_ref_lcn, vp_usuario, null, vp_historico, vl_rg_lcn.cd_sst, vp_codigo);
    else
      perform sc_cnt.lancar_movimento(vl_cd_lcn, vl_lancamento_contra_partida, vl_tipo_lancamento_estorno, vl_rg_lcn.cd_cnt, 'C', vl_rg_lcn.vl_lcn, vl_rg_lcn.dt_ref_lcn, vp_usuario, null, vp_historico, vl_rg_lcn.cd_sst, vp_codigo);
    end if;

    if vl_lancamento_contra_partida is null then
      vl_lancamento_contra_partida := vl_cd_lcn;
    end if;
    
  end loop;
end;$$;


ALTER FUNCTION sc_fin.cancelar_contabilizacao_recebimento_recurso(vp_codigo numeric, vp_usuario numeric, vp_historico character varying) OWNER TO scan;

--
-- TOC entry 1364 (class 1255 OID 564416)
-- Name: cargainicialdistribuicaorecebimento(); Type: FUNCTION; Schema: sc_fin; Owner: scan
--

CREATE FUNCTION cargainicialdistribuicaorecebimento() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg_rrc sc_fin.tbl_rrc%rowtype;
  vl_codigo_contrato numeric;
  vl_valor_antecipado numeric;
  vl_valor_prazo numeric;
begin
  for vl_rg_rrc in select *
                   from sc_fin.tbl_rrc rrc
                   where cd_emp_old is not null
                     and not exists (select 1
                                     from sc_fin.tbl_drr drr
                                     where rrc.cd_rrc = drr.cd_rrc)
                   order by cd_rrc loop
    select cd_ctr
    into vl_codigo_contrato
    from sc_cad.tbl_ctr
    where cd_emp = vl_rg_rrc.cd_emp_old
      and cd_cnt = vl_rg_rrc.cd_cnt_crd;

    if vl_rg_rrc.st_rrc = 3 then
      select COALESCE(sum(vl_alr+vl_cbr_alr),0)
      into vl_valor_antecipado
      from sc_fin.tbl_alr
      where cd_rrc = vl_rg_rrc.cd_rrc;

      vl_valor_prazo := vl_rg_rrc.vl_rrc - vl_valor_antecipado;
    else
      vl_valor_prazo := 0;
      vl_valor_antecipado := 0;
    end if;
    
    insert into sc_fin.tbl_drr(cd_drr, cd_rrc, cd_emp, cd_ctr, vl_drr, st_drr, dt_inc_usr, cd_inc_usr, vl_lbr_ant_drr, vl_lbr_prz_drr)
    values(nextval('sc_fin.sq_drr'), vl_rg_rrc.cd_rrc, vl_rg_rrc.cd_emp_old, vl_codigo_contrato, vl_rg_rrc.vl_rrc, 1, now(), 1, vl_valor_antecipado, vl_valor_prazo);

    select COALESCE(sum(vl_alr+vl_cbr_alr),0)
    into vl_valor_antecipado
    from sc_fin.tbl_alr
    where cd_rrc = vl_rg_rrc.cd_rrc;
      
    if vl_valor_antecipado > 0 then
      update sc_fin.tbl_alr
         set cd_drr = currval('sc_fin.sq_drr')
      where cd_rrc = vl_rg_rrc.cd_rrc;
    end if;
  end loop;
end;$$;


ALTER FUNCTION sc_fin.cargainicialdistribuicaorecebimento() OWNER TO scan;

--
-- TOC entry 7820 (class 0 OID 0)
-- Dependencies: 1364
-- Name: FUNCTION cargainicialdistribuicaorecebimento(); Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON FUNCTION cargainicialdistribuicaorecebimento() IS 'rotina criada apenas para dar carga na tabela de distribuicao de recebimento de recurso';


--
-- TOC entry 1115 (class 1255 OID 564417)
-- Name: enviar_email_informe_deposito(); Type: FUNCTION; Schema: sc_fin; Owner: scan
--

CREATE FUNCTION enviar_email_informe_deposito() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;

count numeric := 1;

ct_situacao_rejeitado constant numeric := 4;
ct_situacao_processado constant numeric := 3;

vl_cabecalho text;
vl_informacao text;
vl_identificados text := '';
vl_rejeitados text := '';
vl_mensagem text;
vl_separador varchar := '';

vl_soma_identificados numeric := 0;
vl_soma_rejeitados numeric := 0;

vl_email_anterior varchar;

vl_codigos numeric ARRAY;

begin

  vl_informacao := 'Prezado cliente,<br><br>' || chr(10);
  vl_informacao := vl_informacao || 'Abaixo segue um resumo da situação dos seus comprovantes de depósito enviados recentemente.<br><br>' || chr(10);
  vl_informacao := vl_informacao || 'Informamos que essa informação também pode ser consultada via site www.somacontadigital.com.br. Acesse a opção EMPRESA, 
                                     utilizando seu usuário e senha. Para consultar acesse: Financeiro - Comprovante de Depósito.<br><br>' || chr(10);


  vl_cabecalho := '<!DOCTYPE html>' || chr(10);
  vl_cabecalho := vl_cabecalho || '<html>' || chr(10);
  vl_cabecalho := vl_cabecalho || '<head>' || chr(10);
  --vl_cabecalho := vl_cabecalho || '<meta http-equiv="Content-Type" content="text/html; charset=utf-8">' || chr(10);
  vl_cabecalho := vl_cabecalho || '<style type="text/css">' || chr(10);
  vl_cabecalho := vl_cabecalho || '.tabela {' || chr(10);
  vl_cabecalho := vl_cabecalho || '	width: 100%;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	font-family: Arial;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	font-size: 10pt;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	border-collapse: collapse;' || chr(10);
  vl_cabecalho := vl_cabecalho || '}' || chr(10);
  vl_cabecalho := vl_cabecalho || '.tabela th {' || chr(10);
  vl_cabecalho := vl_cabecalho || '	padding: 2px;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	text-align: center;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	border: 1px solid #f2aa5c;' || chr(10);
  vl_cabecalho := vl_cabecalho || '}' || chr(10);
  vl_cabecalho := vl_cabecalho || '.tabela td {' || chr(10);
  vl_cabecalho := vl_cabecalho || '	padding: 2px;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	border: 1px solid #f2aa5c;' || chr(10);
  vl_cabecalho := vl_cabecalho || '}' || chr(10);
  vl_cabecalho := vl_cabecalho || '.tabela thead tr {' || chr(10);
  vl_cabecalho := vl_cabecalho || '	background: #f7be80;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	color: white;' || chr(10);
  vl_cabecalho := vl_cabecalho || '}' || chr(10);
  vl_cabecalho := vl_cabecalho || '.tabela tfoot tr {' || chr(10);
  vl_cabecalho := vl_cabecalho || '	background: #f69730;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	color: #FFF;' || chr(10);
  vl_cabecalho := vl_cabecalho || '}' || chr(10);
  vl_cabecalho := vl_cabecalho || '.impar {' || chr(10);
  vl_cabecalho := vl_cabecalho || '	background:#CCC;' || chr(10);
  vl_cabecalho := vl_cabecalho || '}' || chr(10);
  vl_cabecalho := vl_cabecalho || '</style>' || chr(10);
  vl_cabecalho := vl_cabecalho || '</head>' || chr(10);
  vl_cabecalho := vl_cabecalho || '<body>' || chr(10);

  
  for rg in select idp.cd_idp, lower(idp.eml_idp) as eml_idp, idp.st_idp, idp.dt_ref_idp, idp.vl_idp, 
                   idp.mtv_rej_idp, bnc.nm_rdz_bnc, rrc.dt_prv_lbr_rrc
       from sc_fin.tbl_idp idp
        inner join sc_fin.tbl_ccr ccr on ccr.cd_ccr = idp.cd_ccr
        inner join sc_fin.tbl_bnc bnc on bnc.cd_bnc = ccr.cd_bnc
        left join sc_fin.tbl_rrc rrc on rrc.cd_rrc = idp.cd_rrc
       where idp.fg_eml_env_idp = 'N'
         and idp.eml_idp is not null
         and idp.eml_idp <> ''
         and idp.st_idp in (ct_situacao_rejeitado, ct_situacao_processado)
         and strpos(eml_idp,'@') > 0
         and idp.dt_inc_usr >= '2019-10-19'
       order by idp.eml_idp, idp.st_idp  
  loop       

     if vl_email_anterior is null then
        vl_email_anterior := rg.eml_idp;
     end if;

     if vl_email_anterior <> rg.eml_idp then

        vl_mensagem = vl_cabecalho || vl_informacao;

        if vl_identificados <> '' then
          vl_mensagem := vl_mensagem || vl_identificados || '</tbody>' || chr(10);
          vl_mensagem := vl_mensagem || '<tfoot>'|| chr(10);
	  vl_mensagem := vl_mensagem || '<th colspan="2" />'|| chr(10);
          vl_mensagem := vl_mensagem || '<th style="text-align:right">'|| sc_pbl.valor_formato_ptbr(vl_soma_identificados) ||'</th>'|| chr(10);
          vl_mensagem := vl_mensagem || '<th colspan="2" />'|| chr(10);
          vl_mensagem := vl_mensagem || '</tfoot>'|| chr(10);
          vl_mensagem := vl_mensagem || '</table>'|| chr(10);
          vl_separador := '<br><br>'|| chr(10);
        end if;

        if vl_rejeitados <> '' then
          vl_mensagem := vl_mensagem || vl_separador || vl_rejeitados || '</tbody>'|| chr(10);
          vl_mensagem := vl_mensagem || '<tfoot>'|| chr(10);
	  vl_mensagem := vl_mensagem || '<th colspan="2" />'|| chr(10);
          vl_mensagem := vl_mensagem || '<th style="text-align:right">'|| sc_pbl.valor_formato_ptbr(vl_soma_rejeitados) ||'</th>'|| chr(10);
          vl_mensagem := vl_mensagem || '<th colspan="2" />'|| chr(10);
          vl_mensagem := vl_mensagem || '</tfoot>'|| chr(10);
          vl_mensagem := vl_mensagem || '</table>'|| chr(10);
        end if;

        vl_mensagem := vl_mensagem || '<br><br><b>Essa é uma mensagem automática. Por favor, não responda a esse e-mail.<br><br></b>' || chr(10);

        vl_mensagem := vl_mensagem || '<br><br><br><img src="cid:image">';
        vl_mensagem := vl_mensagem || '</body>'|| chr(10) ||'</html>';

        --vl_mensagem := convert_to(vl_mensagem,'UTF8');
        
        begin
 
          perform sc_pbl.enviar_email_saqpag(vl_email_anterior, 'Soma Conta Digital - Acompanhe seus Comprovantes de Depósito', vl_mensagem, E'C:\\arquivo_scan\\envio\\faturaEmpresa\\;logo_topo.png;<image>');  

          update sc_fin.tbl_idp set fg_eml_env_idp = 'S', dt_eml_env_idp = clock_timestamp() where cd_idp = ANY (vl_codigos); 

        exception when others then
           raise notice 'ERRO AO ENVIAR E-MAIL PARA ENDEREÇO: %. ERRO: %', vl_email_anterior, sqlerrm;
        end;

        vl_codigos := null;
        vl_identificados := '';
        vl_rejeitados := '';

        vl_soma_identificados := 0;
        vl_soma_rejeitados := 0;
        
        vl_email_anterior := rg.eml_idp;
     
     end if;
     
     if rg.st_idp = ct_situacao_processado then

       if vl_identificados = '' then
         
         count := 0;

         vl_identificados = '<table class="tabela">' || chr(10);
         vl_identificados := vl_identificados || '<thead>' || chr(10);
	 vl_identificados := vl_identificados || '<tr>' || chr(10);
	 vl_identificados := vl_identificados || '<th colspan="5" style="color:green;">Seus comprovantes IDENTIFICADOS</th>' || chr(10);
	 vl_identificados := vl_identificados || '</tr>' || chr(10);	
	 vl_identificados := vl_identificados || '<tr>' || chr(10);
	 vl_identificados := vl_identificados || '<th>Data do Depósito</th>' || chr(10);
	 vl_identificados := vl_identificados || '<th>Conta do Depósito</th>' || chr(10);
	 vl_identificados := vl_identificados || '<th>Valor</th>' || chr(10);
	 vl_identificados := vl_identificados || '<th>Situação</th>' || chr(10);
	 vl_identificados := vl_identificados || '<th>Observação</th>' || chr(10);
	 vl_identificados := vl_identificados || '</tr>' || chr(10);
	 vl_identificados := vl_identificados || '</thead>' || chr(10);
	 vl_identificados := vl_identificados || '<tbody>' || chr(10);
       
       end if;

        vl_identificados := vl_identificados || '<tr class="' || case when mod(count,2) = 0 then '' else 'impar' end || '">' || chr(10);
	vl_identificados := vl_identificados || '<td align="center">'|| to_char(rg.dt_ref_idp,'dd/MM/yyyy') ||'</td>' || chr(10);
	vl_identificados := vl_identificados || '<td>'|| rg.nm_rdz_bnc ||'</td>' || chr(10);
	vl_identificados := vl_identificados || '<td align="right">'|| sc_pbl.valor_formato_ptbr(rg.vl_idp) ||'</td>' || chr(10);
	vl_identificados := vl_identificados || '<td align="center">IDENTIFICADO</td>' || chr(10);
	vl_identificados := vl_identificados || '<td>Recurso disponível para utilização em ' || to_char(rg.dt_prv_lbr_rrc + interval '3 hour','dd/mm/yyyy HH24:mi:ss') || '</td>' || chr(10);
	vl_identificados := vl_identificados || '</tr>';

	vl_soma_identificados := vl_soma_identificados + rg.vl_idp;
       
     end if;

     if rg.st_idp = ct_situacao_rejeitado then
       
       if vl_rejeitados = '' then

         count := 0;
       
         vl_rejeitados = '<table class="tabela">' || chr(10);
         vl_rejeitados := vl_rejeitados || '<thead>' || chr(10);
	 vl_rejeitados := vl_rejeitados || '<tr>' || chr(10);
	 vl_rejeitados := vl_rejeitados || '<th colspan="5" style="color:red;">Seus comprovantes REJEITADOS</th>' || chr(10);
	 vl_rejeitados := vl_rejeitados || '</tr>' || chr(10);	
	 vl_rejeitados := vl_rejeitados || '<tr>' || chr(10);
	 vl_rejeitados := vl_rejeitados || '<th>Data do Depósito</th>' || chr(10);
	 vl_rejeitados := vl_rejeitados || '<th>Conta do Depósito</th>' || chr(10);
	 vl_rejeitados := vl_rejeitados || '<th>Valor</th>' || chr(10);
	 vl_rejeitados := vl_rejeitados || '<th>Situação</th>' || chr(10);
	 vl_rejeitados := vl_rejeitados || '<th>Observação</th>' || chr(10);
	 vl_rejeitados := vl_rejeitados || '</tr>' || chr(10);
	 vl_rejeitados := vl_rejeitados || '</thead>' || chr(10);
	 vl_rejeitados := vl_rejeitados || '<tbody>' || chr(10);
       
       end if;

        vl_rejeitados := vl_rejeitados || '<tr class="' || case when mod(count,2) = 0 then '' else 'impar' end || '">' || chr(10);
	vl_rejeitados := vl_rejeitados || '<td align="center">'|| to_char(rg.dt_ref_idp,'dd/MM/yyyy') ||'</td>' || chr(10);
	vl_rejeitados := vl_rejeitados || '<td>'|| rg.nm_rdz_bnc ||'</td>' || chr(10);
	vl_rejeitados := vl_rejeitados || '<td align="right">'|| sc_pbl.valor_formato_ptbr(rg.vl_idp) ||'</td>' || chr(10);
	vl_rejeitados := vl_rejeitados || '<td align="center">REJEITADO</td>' || chr(10);
	vl_rejeitados := vl_rejeitados || '<td>'|| sc_grl.get_descricao_dominio('MTV_REJ_IDP', rg.mtv_rej_idp) || '</td>' || chr(10);
	vl_rejeitados := vl_rejeitados || '</tr>';
	

        vl_soma_rejeitados := vl_soma_rejeitados + rg.vl_idp;
	
     end if;

     select array_append(vl_codigos,rg.cd_idp) into vl_codigos;

  end loop;


  if vl_rejeitados <> '' or vl_identificados <> '' then

        vl_mensagem = vl_cabecalho || vl_informacao;

        if vl_identificados <> '' then
          vl_mensagem := vl_mensagem || vl_identificados || '</tbody>' || chr(10);
          vl_mensagem := vl_mensagem || '<tfoot>'|| chr(10);
	  vl_mensagem := vl_mensagem || '<th colspan="2" />'|| chr(10);
          vl_mensagem := vl_mensagem || '<th style="text-align:right">'|| sc_pbl.valor_formato_ptbr(vl_soma_identificados) ||'</th>'|| chr(10);
          vl_mensagem := vl_mensagem || '<th colspan="2" />'|| chr(10);
          vl_mensagem := vl_mensagem || '</tfoot>'|| chr(10);
          vl_mensagem := vl_mensagem || '</table>'|| chr(10);
          vl_separador := '<br><br>'|| chr(10);
        end if;

        if vl_rejeitados <> '' then
          vl_mensagem := vl_mensagem || vl_separador || vl_rejeitados || '</tbody>'|| chr(10);
          vl_mensagem := vl_mensagem || '<tfoot>'|| chr(10);
	  vl_mensagem := vl_mensagem || '<th colspan="2" />'|| chr(10);
          vl_mensagem := vl_mensagem || '<th style="text-align:right">'|| sc_pbl.valor_formato_ptbr(vl_soma_rejeitados) ||'</th>'|| chr(10);
          vl_mensagem := vl_mensagem || '<th colspan="2" />'|| chr(10);
          vl_mensagem := vl_mensagem || '</tfoot>'|| chr(10);
          vl_mensagem := vl_mensagem || '</table>'|| chr(10);
        end if;

        vl_mensagem := vl_mensagem || '<br><br><b>Essa é uma mensagem automática. Por favor, não responda a esse e-mail.<br><br></b>' || chr(10);

        vl_mensagem := vl_mensagem || '<br><br><br><img src="cid:image">';
        vl_mensagem := vl_mensagem || '</body>'|| chr(10) ||'</html>';


        --vl_mensagem := convert_to(vl_mensagem,'UTF8');
        
        begin
 
          perform sc_pbl.enviar_email_saqpag(vl_email_anterior, 'SOMA CONTA DIGITAL - Acompanhe seus Comprovantes de Depósito', vl_mensagem, 'C:\\arquivo_scan\\envio\\faturaEmpresa\\logo_topo.png');  

          update sc_fin.tbl_idp set fg_eml_env_idp = 'S', dt_eml_env_idp = clock_timestamp() where cd_idp = ANY (vl_codigos); 

        exception when others then
           raise notice 'ERRO AO ENVIAR E-MAIL PARA ENDEREÇO: %. ERRO: %', vl_email_anterior, sqlerrm;
        end;
         
   end if;
     
  exception when others then
    raise 'ERRO NO ENVIO DE EMAIL DE COMPROVANTE DE DEPOSITO %', sqlerrm;
end;$$;


ALTER FUNCTION sc_fin.enviar_email_informe_deposito() OWNER TO scan;

--
-- TOC entry 7821 (class 0 OID 0)
-- Dependencies: 1115
-- Name: FUNCTION enviar_email_informe_deposito(); Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON FUNCTION enviar_email_informe_deposito() IS 'funcao que envia email com a situacao dos comprovantes de deposito';


--
-- TOC entry 1366 (class 1255 OID 564420)
-- Name: finaliza_recebimento(numeric); Type: FUNCTION; Schema: sc_fin; Owner: scan
--

CREATE FUNCTION finaliza_recebimento(vp_codigo numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
----------------------
vl_existe_bloqueio numeric;
vl_valor_liberado double precision;

rg_rrc record;
rg_drr record;
----------------------
begin
  --iterando sobre os recebimentos de recursos cadastrados que expirou o prazo de liberacao
  for rg_rrc in select rrc.cd_rrc as codigo,
                       rrc.vl_rrc as valor
                from sc_fin.tbl_rrc rrc
		where rrc.st_rrc = 1 -- cadastrado
                  --and (rrc.cd_rrc = vp_codigo or vp_codigo is null)
                  and rrc.cd_rrc = COALESCE(vp_codigo, rrc.cd_rrc) 
		  and rrc.dt_prv_lbr_rrc <= now() loop

    --iterando sobre as distribuicoes de recebimento de recursos
    for rg_drr in select drr.cd_drr as codigo,
                         drr.vl_drr - (drr.vl_lbr_ant_drr + drr.vl_lbr_prz_drr) as valor_a_liberar,
                         ctr.cd_cnt as conta
                  from sc_fin.tbl_drr drr
                       inner join sc_cad.tbl_ctr ctr on drr.cd_ctr = ctr.cd_ctr
                  where drr.cd_rrc = rg_rrc.codigo
                    and drr.st_drr = 1 --cadastrado
                    and drr.vl_drr > (drr.vl_lbr_ant_drr + drr.vl_lbr_prz_drr) loop
      --verificando se existe registro de bloqueio por recebimento de recurso
      select count(*)
      into vl_existe_bloqueio
      from sc_cnt.tbl_tbc_cnt
      where cd_cnt = rg_drr.conta
        and cd_tbc = 1 -- recebimento de recurso
        and vl_blq_tbc_cnt >= rg_drr.valor_a_liberar;
    
      if vl_existe_bloqueio = 1 then
        -- atualizar o valor de bloqueio
        update sc_cnt.tbl_tbc_cnt 
           set vl_blq_tbc_cnt = vl_blq_tbc_cnt - rg_drr.valor_a_liberar
        where cd_cnt = rg_drr.conta
          and cd_tbc = 1; -- recebimento de recurso

        --atualizando o valor liberado da distribuicao de recurso
        update sc_fin.tbl_drr
           set vl_lbr_prz_drr = vl_lbr_prz_drr + rg_drr.valor_a_liberar
        where cd_drr = rg_drr.codigo;
      else
        update sc_fin.tbl_drr
           set st_drr = 3 --problema no desbloqueio do saldo
        where cd_drr = rg_drr.codigo;
      end if;
    end loop;

    --calculando o valor liberado total do recebimento de recurso
    select sum(drr.vl_lbr_ant_drr + drr.vl_lbr_prz_drr)
      into vl_valor_liberado
    from sc_fin.tbl_drr drr
    where drr.cd_rrc = rg_rrc.codigo
      and drr.st_drr = 1; --cadastrado

    --verificando se pode ser realizado a finalizacao do recebimento de recurso
    if rg_rrc.valor <= vl_valor_liberado then
      --atualizar recebimento
      update sc_fin.tbl_rrc 
         set st_rrc = 3,  -- finalizada
             dt_fnz_rrc = current_timestamp
      where cd_rrc = rg_rrc.codigo;
    end if;
  end loop;
end;$$;


ALTER FUNCTION sc_fin.finaliza_recebimento(vp_codigo numeric) OWNER TO scan;

SET search_path = sc_fsc, pg_catalog;

--
-- TOC entry 1337 (class 1255 OID 1622673)
-- Name: atualizar_nfse_contrato_prepago(); Type: FUNCTION; Schema: sc_fsc; Owner: scan
--

CREATE FUNCTION atualizar_nfse_contrato_prepago() RETURNS void
    LANGUAGE plpgsql
    AS $$ 

declare
  vl_parametros varchar;
begin
  perform sc_job.executar_java_job('atualizarNotasPrePago', vl_parametros);
end;

$$;


ALTER FUNCTION sc_fsc.atualizar_nfse_contrato_prepago() OWNER TO scan;

--
-- TOC entry 1116 (class 1255 OID 1622672)
-- Name: gerar_nfse_contrato_prepago(); Type: FUNCTION; Schema: sc_fsc; Owner: scan
--

CREATE FUNCTION gerar_nfse_contrato_prepago() RETURNS void
    LANGUAGE plpgsql
    AS $$ 

declare
  vl_parametros varchar;
begin
  perform sc_job.executar_java_job('gerarNotasPrePago', vl_parametros);
end;

$$;


ALTER FUNCTION sc_fsc.gerar_nfse_contrato_prepago() OWNER TO scan;

SET search_path = sc_grl, pg_catalog;

--
-- TOC entry 1367 (class 1255 OID 564421)
-- Name: adicionar_mes(date, numeric); Type: FUNCTION; Schema: sc_grl; Owner: scan
--

CREATE FUNCTION adicionar_mes(vp_data date, qt_meses numeric) RETURNS date
    LANGUAGE plpgsql
    AS $$Declare
 
retorno date;
cont numeric := 1;
 
Begin
 
     retorno := vp_data;
 
     while cont < qt_meses loop
 
        retorno := retorno + interval '1 month';
        cont := cont + 1;
    
     end loop;
 
     return retorno;
End;
$$;


ALTER FUNCTION sc_grl.adicionar_mes(vp_data date, qt_meses numeric) OWNER TO scan;

--
-- TOC entry 1368 (class 1255 OID 564422)
-- Name: eh_dia_util(timestamp with time zone); Type: FUNCTION; Schema: sc_grl; Owner: scan
--

CREATE FUNCTION eh_dia_util(vp_data timestamp with time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $$Declare

retorno boolean;
existe numeric;

Begin

     retorno := (date_part('dow', vp_data) <> 0 And date_part('dow', vp_data) <> 6);

     if retorno then

        -- testa se nao eh feriado

        select coalesce(count(*),0)
          into existe
        from sc_pbl.tbl_frd
        where dt_frd = vp_data;

        if existe > 0 then
          retorno := false;
        end if;

     end if;

     return retorno;
End;
$$;


ALTER FUNCTION sc_grl.eh_dia_util(vp_data timestamp with time zone) OWNER TO scan;

--
-- TOC entry 1729 (class 1255 OID 1012835)
-- Name: gera_numero_aleatorio(numeric); Type: FUNCTION; Schema: sc_grl; Owner: scan
--

CREATE FUNCTION gera_numero_aleatorio(vp_numero_digitos numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_retorno numeric;
begin
  loop
    select round(cast (random()*power(10, vp_numero_digitos) as numeric),0)
    into vl_retorno;
  
    exit when (vl_retorno = 0 and vp_numero_digitos = 1) or (vl_retorno >= power(10, vp_numero_digitos - 1) and vl_retorno < power(10, vp_numero_digitos));
  end loop;
  
  return vl_retorno;
end;$$;


ALTER FUNCTION sc_grl.gera_numero_aleatorio(vp_numero_digitos numeric) OWNER TO scan;

--
-- TOC entry 7822 (class 0 OID 0)
-- Dependencies: 1729
-- Name: FUNCTION gera_numero_aleatorio(vp_numero_digitos numeric); Type: COMMENT; Schema: sc_grl; Owner: scan
--

COMMENT ON FUNCTION gera_numero_aleatorio(vp_numero_digitos numeric) IS 'funcao que gera um numero de aleatorio com a quantidade de digitos passados como parametro';


--
-- TOC entry 1369 (class 1255 OID 564423)
-- Name: get_anterior_dia_util(timestamp with time zone); Type: FUNCTION; Schema: sc_grl; Owner: scan
--

CREATE FUNCTION get_anterior_dia_util(vp_data timestamp with time zone) RETURNS date
    LANGUAGE plpgsql
    AS $$

declare

vl_data date;

Begin

     vl_data := vp_data - interval '1 day';

     while not sc_grl.eh_dia_util(vl_data) loop
       vl_data := vl_data - interval '1 day';
     end loop;

     return vl_data;
End;
$$;


ALTER FUNCTION sc_grl.get_anterior_dia_util(vp_data timestamp with time zone) OWNER TO scan;

--
-- TOC entry 1370 (class 1255 OID 564424)
-- Name: get_descricao_dominio(character varying, numeric); Type: FUNCTION; Schema: sc_grl; Owner: scan
--

CREATE FUNCTION get_descricao_dominio(vp_nome_campo character varying, vp_valor_campo numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$Declare
 
retorno varchar;
 
Begin
 
    begin

     select nm_vlr_dmn
       into retorno
     from sc_cad.tbl_dmn
     where nm_cmp_dmn = vp_nome_campo
       and vl_cmp_dmn = vp_valor_campo;  

    exception when others then

      raise exception 'Campo ou Valor do domínio não encontrado';
     
    end;
  
    return retorno;
End;
$$;


ALTER FUNCTION sc_grl.get_descricao_dominio(vp_nome_campo character varying, vp_valor_campo numeric) OWNER TO scan;

--
-- TOC entry 1371 (class 1255 OID 564425)
-- Name: get_proximo_dia_util(timestamp with time zone); Type: FUNCTION; Schema: sc_grl; Owner: scan
--

CREATE FUNCTION get_proximo_dia_util(vp_data timestamp with time zone) RETURNS date
    LANGUAGE plpgsql
    AS $$

declare

vl_data date;

Begin

     vl_data := vp_data + interval '1 day';

     while not sc_grl.eh_dia_util(vl_data) loop
       vl_data := vl_data + interval '1 day';
     end loop;

     return vl_data;
End;
$$;


ALTER FUNCTION sc_grl.get_proximo_dia_util(vp_data timestamp with time zone) OWNER TO scan;

SET search_path = sc_hlt, pg_catalog;

--
-- TOC entry 1682 (class 1255 OID 873243)
-- Name: processar_arquivo_holerite(numeric); Type: FUNCTION; Schema: sc_hlt; Owner: scan
--

CREATE FUNCTION processar_arquivo_holerite(vp_codigo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_nr_cpf numeric;
  vl_dt_pgt date;
  rg record;
  rg_hlt record;
  rg_dhl record;

  vl_i numeric;
  vl_flag character;
  vl_nome_func varchar;

begin

    for rg in select *
              from sc_hlt.tbl_ahl
              where st_ahl = 1 
                and (cd_ahl = vp_codigo or vp_codigo is null) loop

      -- POPULANDO CAMPOS DA TABELA DE HOLERITE
      for rg_hlt in select *
                    from sc_hlt.tbl_hlt
                    where cd_ahl = rg.cd_ahl loop

          select ha.nr_cpf_hlt_arq,dt_pgt_hlt_arq,nm_fnc_hlt_arq
          into vl_nr_cpf, vl_dt_pgt, vl_nome_func
          from sc_hlt.tbl_hlt_arq ha
          where ha.cd_hlt = rg_hlt.cd_hlt;

          update sc_hlt.tbl_hlt
          set cnpj_emp_hlt = rg.cnpj_ahl,
              nm_emp_hlt = rg.nm_emp_ahl,
              nr_cpf_hlt = vl_nr_cpf,
              dt_pgt_hlt = vl_dt_pgt,
              nm_fnc_hlt = vl_nome_func
          where cd_hlt = rg_hlt.cd_hlt;    

          update sc_hlt.tbl_hlt
          set st_hlt = 2
          where cd_hlt = rg_hlt.cd_hlt;

          vl_i := 0;
          for rg_dhl in select *
                        from sc_hlt.tbl_dhl_arq da
                        where da.cd_hlt = rg_hlt.cd_hlt
                        order by da.cd_dhl_arq loop

             if vl_i = 0 then
                vl_flag := 'C';
             else
                vl_flag := 'D';
             end if;
             
             if rg_dhl.ds1_dhl_arq is not null and rg_dhl.ds1_dhl_arq <> '' then
                 insert into sc_hlt.tbl_dhl(cd_dhl,cd_hlt,ds_dhl,vl_dhl,fg_dcr_dhl) values(nextval('sc_hlt.sq_dhl'),rg_hlt.cd_hlt,rg_dhl.ds1_dhl_arq,rg_dhl.vl1_dhl_arq,vl_flag);
             end if; 
             if rg_dhl.ds2_dhl_arq is not null and rg_dhl.ds2_dhl_arq <> '' then
                 insert into sc_hlt.tbl_dhl(cd_dhl,cd_hlt,ds_dhl,vl_dhl,fg_dcr_dhl) values(nextval('sc_hlt.sq_dhl'),rg_hlt.cd_hlt,rg_dhl.ds2_dhl_arq,rg_dhl.vl2_dhl_arq,vl_flag);
             end if; 
             if rg_dhl.ds3_dhl_arq is not null and rg_dhl.ds3_dhl_arq <> '' then
                 insert into sc_hlt.tbl_dhl(cd_dhl,cd_hlt,ds_dhl,vl_dhl,fg_dcr_dhl) values(nextval('sc_hlt.sq_dhl'),rg_hlt.cd_hlt,rg_dhl.ds3_dhl_arq,rg_dhl.vl3_dhl_arq,vl_flag);
             end if; 
             if rg_dhl.ds4_dhl_arq is not null and rg_dhl.ds4_dhl_arq <> '' then
                 insert into sc_hlt.tbl_dhl(cd_dhl,cd_hlt,ds_dhl,vl_dhl,fg_dcr_dhl) values(nextval('sc_hlt.sq_dhl'),rg_hlt.cd_hlt,rg_dhl.ds4_dhl_arq,rg_dhl.vl4_dhl_arq,vl_flag);
             end if; 
             
             vl_i := vl_i+1;             
 
                        
          end loop;              
          
      end loop;  

      


      update sc_hlt.tbl_ahl 
      set st_ahl = 2,
          cd_cun = (select cd_cun from sc_cad.tbl_cun where nr_cpf_cnpj_cun = rg.cnpj_ahl) 
      where cd_ahl = rg.cd_ahl;            

    end loop;          

end$$;


ALTER FUNCTION sc_hlt.processar_arquivo_holerite(vp_codigo numeric) OWNER TO scan;

SET search_path = sc_ind, pg_catalog;

--
-- TOC entry 1349 (class 1255 OID 564426)
-- Name: atualiza_inadimplencia(); Type: FUNCTION; Schema: sc_ind; Owner: scan
--

CREATE FUNCTION atualiza_inadimplencia() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin
  

    delete from sc_ind.tbl_ind where cd_fcr in(select crt.cd_fcr 
                                               from sc_opr.tbl_crt crt 
                                                  inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr );
 
    insert into sc_ind.tbl_ind (SELECT fcr.cd_fcr,
                                       grt.cd_grt,
                                       grt.nm_grt,
                                       ast.cd_ast,
                                       ast.nm_ast,
                                       emp.cd_emp,
                                       emp.nm_emp,
                                       fem.cd_fem,
                                       fem.nm_fem,
                                       gem.cd_gem,
                                       gem.nm_gem,
                                       se.vl_total, 
                                       se.vl_se, 
				       CASE
					    WHEN fcr.vl_sld_dvd_fcr > se.vl_total THEN se.vl_total
					    ELSE fcr.vl_sld_dvd_fcr
				       END, 
				       CASE
					    WHEN se.vl_se > 0::numeric THEN 
					    CASE
						WHEN tlt.principal_ind > se.vl_se THEN se.vl_se
						ELSE tlt.principal_ind
					    END
					    ELSE 0::numeric
				       END, 
                                       fcr.dt_vnc_fcr, 
                                       to_char(fcr.dt_vnc_fcr::timestamp with time zone, 'mm/yyyy'::text),
                                       cun.nm_cun,
                                       crt.cd_crt
			     FROM sc_fcr.tbl_fcr fcr
			        JOIN sc_opr.tbl_crt crt ON fcr.cd_crt = crt.cd_crt
				LEFT JOIN ( SELECT fcr_tlt.cd_fcr, 
				                   sum(fcr_tlt.vl_rst_fcr_tlt) AS principal_ind, 
				                   sum(fcr_tlt.vl_ttl_fcr_tlt) AS principal_total
		                            FROM sc_fcr.tbl_fcr_tlt fcr_tlt
				            WHERE fcr_tlt.cd_tlt = 1::numeric
				            GROUP BY fcr_tlt.cd_fcr ) tlt ON tlt.cd_fcr = fcr.cd_fcr
			       JOIN sc_cad.tbl_ctr ctr ON ctr.cd_ctr = crt.cd_ctr
			       JOIN sc_cad.tbl_grt grt ON grt.cd_grt = ctr.cd_grt
                               LEFT JOIN sc_cad.tbl_ast ast ON ast.cd_ast = ctr.cd_ast
                               JOIN sc_cad.tbl_fnc fnc ON fnc.cd_fnc = crt.cd_fnc
                               JOIN sc_cad.tbl_cun cun ON cun.cd_cun = fnc.cd_cun 
                               JOIN sc_cad.tbl_emp emp ON emp.cd_emp = fnc.cd_emp
                               JOIN sc_cad.tbl_fem fem ON fem.cd_emp = fnc.cd_emp AND fem.cd_fem = fnc.cd_fem
                               JOIN sc_cad.tbl_gem gem ON gem.cd_gem = emp.cd_gem
			       LEFT JOIN ( SELECT sum(
						  CASE
						    WHEN opr.cd_top = 5::numeric THEN opr.vl_opr
						    ELSE 0::numeric
						  END) AS vl_se, 
						  sum(opr.vl_opr) AS vl_total, 
						  prc.cd_fcr
				           FROM sc_opr.tbl_opr opr
				              JOIN sc_fcr.tbl_prc prc ON prc.cd_opr = opr.cd_opr
				           GROUP BY prc.cd_fcr) se ON se.cd_fcr = fcr.cd_fcr
		             WHERE fcr.cd_fcr in(select crt.cd_fcr 
                                               from sc_opr.tbl_crt crt 
                                                  inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr ));
       for rg in select ind.cd_crt,ind.mes_ref,min(ind.cd_fcr) cd_fcr
                 from sc_ind.tbl_ind ind
                 group by ind.cd_crt,ind.mes_ref
                 having count(*) > 1 loop

             delete from sc_ind.tbl_ind where cd_fcr = rg.cd_fcr;    
       end loop;              
end$$;


ALTER FUNCTION sc_ind.atualiza_inadimplencia() OWNER TO scan;

--
-- TOC entry 1350 (class 1255 OID 564427)
-- Name: get_inadimplencia_empresa(numeric, numeric, character varying); Type: FUNCTION; Schema: sc_ind; Owner: scan
--

CREATE FUNCTION get_inadimplencia_empresa(vp_empresa numeric, vp_filial numeric, vp_mes_vencimento character varying) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

   vl_inadimplencia numeric(13,5);

begin

   select sum(vl_pcp_ind)/sum(vl_pcp_ttl_opr)
   into vl_inadimplencia
   from sc_ind.tbl_ind ind
   where ind.cd_emp = vp_empresa
     and (vp_filial is null or ind.cd_fem = vp_filial)
     and mes_ref = vp_mes_vencimento
   having sum(vl_pcp_ttl_opr) > 0 ;   

   return coalesce(vl_inadimplencia,0);
    
end$$;


ALTER FUNCTION sc_ind.get_inadimplencia_empresa(vp_empresa numeric, vp_filial numeric, vp_mes_vencimento character varying) OWNER TO scan;

--
-- TOC entry 1351 (class 1255 OID 564428)
-- Name: get_saldo_devedor(numeric); Type: FUNCTION; Schema: sc_ind; Owner: scan
--

CREATE FUNCTION get_saldo_devedor(vp_cartao numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_retorno numeric;
begin

  select fcr.vl_sld_dvd_fcr
  into vl_retorno
  from sc_fcr.tbl_fcr fcr
   inner join sc_opr.tbl_crt crt on crt.cd_fcr = fcr.cd_fcr;

  return vl_retorno;
end$$;


ALTER FUNCTION sc_ind.get_saldo_devedor(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1491 (class 1255 OID 564429)
-- Name: informa_inadimplencia(); Type: FUNCTION; Schema: sc_ind; Owner: scan
--

CREATE FUNCTION informa_inadimplencia() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   vl_mes_anterior_1 varchar;
   vl_mes_anterior_2 varchar;
   
   vl_ind_mes_1 numeric;
   vl_ind_mes_2 numeric;

   vl_prc_aceitavel numeric;
   
   vl_html varchar;
   vl_assunto varchar;

   rg record;

   count numeric;

begin	
        select vl_prm::numeric
        into vl_prc_aceitavel
        from sc_cad.tbl_prm
        where nm_prm = 'PRC_IND_EMP';

        select to_char(current_date - interval '1 month','mm/yyyy'),
               to_char(current_date - interval '2 month','mm/yyyy')
        into vl_mes_anterior_1,vl_mes_anterior_2;

	vl_html := '<html xmlns="http://www.w3.org/1999/xhtml">
		<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>EMPRESAS INADIMPLENTES</title>

		<style>

		.tabela{
			width: 100%;
			font-family:Arial;
			border:1px solid #999;
			border-collapse: collapse;
		}

		.tabela th{
			background:#03F;
		    color:#FFF;
			text-align:center;
			border:1px solid #999;
		}

		.tabela tr td{
			border:1px solid #999;
		}

		.impar{
			background:#CCC;
		}

		</style>

		</head>

		<body>
		<table class="tabela">
			<tr>
				<th>Empresa</th>
				<th>'||vl_mes_anterior_1||'</th>
				<th>'||vl_mes_anterior_2||'</th>
		       </tr>';
  


   count := 1;
   for rg in select emp.cd_emp,
                    emp.nm_emp,
                    sc_ind.get_inadimplencia_empresa(cd_emp,null,vl_mes_anterior_1) ind_mes_1,
                    sc_ind.get_inadimplencia_empresa(cd_emp,null,vl_mes_anterior_2) ind_mes_2
             from sc_cad.tbl_emp emp
             where exists(select 1 
                          from sc_cad.tbl_ctr ctr
                             inner join sc_cad.tbl_tlt_ctr tlt on ctr.cd_ctr = tlt.cd_ctr
                          where ctr.cd_emp = emp.cd_emp
                            and tlt.cd_tlt = 1
                            and tlt.pr_lmt > 0
                            and ctr.fg_atv_ctr = 'S')
                            
             order by emp.nm_emp loop
             

       if(rg.ind_mes_1 > vl_prc_aceitavel and rg.ind_mes_2 > vl_prc_aceitavel) then

           vl_html := vl_html || '<tr class="' || case when mod(count,2) = 0 then '' else 'impar' end || '">';
           vl_html := vl_html || '<td>'||rg.cd_emp||'-'||rg.nm_emp||'</td>';
           vl_html := vl_html || '<td align=''right''>'||rg.ind_mes_1*100||'</td>';
           vl_html := vl_html || '<td align=''right''>'||rg.ind_mes_2*100||'</td>';
           vl_html := vl_html || '</tr>';

           perform sc_ind.zera_limite_novos_cartoes(rg.cd_emp); 

           
           count := count + 1;
       end if;                    
       
   end loop;             

          vl_html := vl_html || '</table></body></html>';

       vl_assunto := 'ATENCAO: ALERTA DE EMPRESAS INADIMPLENTES';      



   perform sc_pbl.enviar_email_saqpag('vitor@saqcard.com.br',vl_assunto,vl_html,null);
   

end$$;


ALTER FUNCTION sc_ind.informa_inadimplencia() OWNER TO scan;

--
-- TOC entry 1372 (class 1255 OID 564430)
-- Name: zera_limite_novos_cartoes(numeric); Type: FUNCTION; Schema: sc_ind; Owner: scan
--

CREATE FUNCTION zera_limite_novos_cartoes(vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin

   for rg in select ctr.cd_ctr,tlt.cd_tlt,tlt.pr_lmt
             from sc_cad.tbl_ctr ctr
               inner join sc_cad.tbl_tlt_ctr tlt on tlt.cd_ctr = ctr.cd_ctr
             where cd_emp = vp_empresa loop

      update sc_opr.tbl_lmt
      set vl_prc_lmt = rg.pr_lmt
      where cd_crt in (select cd_crt from sc_opr.tbl_crt where cd_ctr = rg.cd_ctr)
        and cd_tlt = rg.cd_tlt
        and vl_prc_lmt is null;

      update sc_cad.tbl_tlt_ctr 
      set pr_lmt = 0,
          cd_alt_usr = 1,
          dt_alt_usr = now() 
      where cd_ctr = rg.cd_ctr 
        and cd_tlt = rg.cd_tlt;   
        
   end loop;          

end$$;


ALTER FUNCTION sc_ind.zera_limite_novos_cartoes(vp_empresa numeric) OWNER TO scan;

SET search_path = sc_iso8583, pg_catalog;

--
-- TOC entry 920 (class 1259 OID 1010967)
-- Name: tbl_msg8583; Type: TABLE; Schema: sc_iso8583; Owner: scan
--

CREATE TABLE tbl_msg8583 (
    cd_msg bigint NOT NULL,
    bit001 character varying(60),
    bit002 character varying(60),
    bit003 character varying(60),
    bit004 character varying(60),
    bit005 character varying(60),
    bit006 character varying(60),
    bit007 character varying(60),
    bit008 character varying(60),
    bit009 character varying(60),
    bit010 character varying(60),
    bit011 character varying(60),
    bit012 character varying(60),
    bit013 character varying(60),
    bit014 character varying(60),
    bit015 character varying(60),
    bit016 character varying(60),
    bit017 character varying(60),
    bit018 character varying(60),
    bit019 character varying(60),
    bit020 character varying(60),
    bit021 character varying(60),
    bit022 character varying(60),
    bit023 character varying(60),
    bit024 character varying(60),
    bit025 character varying(60),
    bit026 character varying(60),
    bit027 character varying(60),
    bit028 character varying(60),
    bit029 character varying(60),
    bit030 character varying(60),
    bit031 character varying(60),
    bit032 character varying(60),
    bit033 character varying(60),
    bit034 character varying(60),
    bit035 character varying(60),
    bit036 character varying(60),
    bit037 character varying(60),
    bit038 character varying(60),
    bit039 character varying(60),
    bit040 character varying(60),
    bit041 character varying(60),
    bit042 character varying(60),
    bit043 character varying(60),
    bit044 character varying(60),
    bit045 character varying(60),
    bit046 character varying(60),
    bit047 character varying(60),
    bit048 character varying(60),
    bit049 character varying(60),
    bit050 character varying(60),
    bit051 character varying(60),
    bit052 character varying(60),
    bit053 character varying(60),
    bit054 character varying(60),
    bit055 character varying(60),
    bit056 character varying(60),
    bit057 character varying(60),
    bit058 character varying(60),
    bit059 character varying(60),
    bit060 character varying(60),
    bit061 character varying(60),
    bit062 character varying(1000),
    bit063 character varying(1000),
    bit064 character varying(60),
    bit065 character varying(60),
    bit066 character varying(60),
    bit067 character varying(60),
    bit068 character varying(60),
    bit069 character varying(60),
    bit070 character varying(60),
    bit071 character varying(60),
    bit072 character varying(60),
    bit073 character varying(60),
    bit074 character varying(60),
    bit075 character varying(60),
    bit076 character varying(60),
    bit077 character varying(60),
    bit078 character varying(60),
    bit079 character varying(60),
    bit080 character varying(60),
    bit081 character varying(60),
    bit082 character varying(60),
    bit083 character varying(60),
    bit084 character varying(60),
    bit085 character varying(60),
    bit086 character varying(60),
    bit087 character varying(60),
    bit088 character varying(60),
    bit089 character varying(60),
    bit090 character varying(60),
    bit091 character varying(60),
    bit092 character varying(60),
    bit093 character varying(60),
    bit094 character varying(60),
    bit095 character varying(60),
    bit096 character varying(60),
    bit097 character varying(60),
    bit098 character varying(60),
    bit099 character varying(60),
    bit100 character varying(60),
    bit101 character varying(60),
    bit102 character varying(60),
    bit103 character varying(60),
    bit104 character varying(60),
    bit105 character varying(60),
    bit106 character varying(60),
    bit107 character varying(60),
    bit108 character varying(60),
    bit109 character varying(60),
    bit110 character varying(60),
    bit111 character varying(60),
    bit112 character varying(60),
    bit113 character varying(60),
    bit114 character varying(60),
    bit115 character varying(60),
    bit116 character varying(60),
    bit117 character varying(60),
    bit118 character varying(60),
    bit119 character varying(60),
    bit120 character varying(60),
    bit121 character varying(60),
    bit122 character varying(60),
    bit123 character varying(60),
    bit124 character varying(60),
    bit125 character varying(60),
    bit126 character varying(60),
    bit127 character varying(60),
    bit128 character varying(60),
    cd_pai_msg numeric(10,0),
    dt_msg timestamp without time zone DEFAULT clock_timestamp() NOT NULL
);


ALTER TABLE tbl_msg8583 OWNER TO scan;

--
-- TOC entry 1597 (class 1255 OID 1010986)
-- Name: abrir_sessao(tbl_msg8583); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION abrir_sessao(mensagem tbl_msg8583) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

   
   vl_cod_mensagem_retorno bigint;
   vl_vrs_processo_cripto varchar;
   vl_vrs_tabela_wk numeric;	
   vl_qtd_indice_wk numeric;

   vl_bit0048 varchar;
   vl_indice_baixo_wk numeric;
   vl_indice_alto_wk numeric;

   bit007 varchar;

begin

   select nextval('sc_iso8583.sq_msg8583') into vl_cod_mensagem_retorno; 

   -- tratamento de versao do processo de criptografia
   vl_vrs_processo_cripto := sc_iso8583.return_tlv_value(4, mensagem.bit048);
   vl_vrs_tabela_wk := sc_iso8583.return_tlv_value(5, mensagem.bit048);

   if vl_vrs_processo_cripto is not null then

     -- ativa tratamento de criptografia invertendo a versao do processo de croptografia
     vl_bit0048 := '004011';
     vl_bit0048 := vl_bit0048 || substr(vl_vrs_processo_cripto,strpos(vl_vrs_processo_cripto,'v'),length(vl_vrs_processo_cripto));
     vl_bit0048 := vl_bit0048 || substr(vl_vrs_processo_cripto,1,strpos(vl_vrs_processo_cripto,'v')-1);
   
     -- versao da tabela de working key
     vl_bit0048 := vl_bit0048 || '005002' || trim(to_char(vl_vrs_tabela_wk,'00'));  

     -- retornando indices da tabela de working key

     select count(*)
        into vl_qtd_indice_wk
     from sc_iso8583.tbl_wkey
     where vrs_wkey = vl_vrs_tabela_wk; 
   
     -- indice baixo da tabela de working key
     while vl_indice_baixo_wk is null or vl_indice_baixo_wk > (vl_qtd_indice_wk / 2) - 1 loop

       vl_indice_baixo_wk := sc_grl.gera_numero_aleatorio(1);

     end loop;

     vl_bit0048 := vl_bit0048 || '006002' || trim(to_char(vl_indice_baixo_wk,'00'));   

     -- indice alto da tabela de working key
     while vl_indice_alto_wk is null or vl_indice_alto_wk < (vl_qtd_indice_wk / 2) loop

       vl_indice_alto_wk := sc_grl.gera_numero_aleatorio(1);

     end loop;

     vl_bit0048 := vl_bit0048 || '007002' || trim(to_char(vl_indice_alto_wk,'00')); 

   end if;

   if mensagem.bit032::numeric = 6142 then --Se CIELO
     bit007 := mensagem.bit007;
   else
     bit007 := to_char(now(),'mmddhh24miss');
   end if;


   insert into sc_iso8583.tbl_msg8583(cd_msg,bit001,bit003,bit007,bit011,bit012,bit013,bit032,bit039,bit041,bit042,bit048,bit070,bit127)
   values(vl_cod_mensagem_retorno,
          '0x810', 
          mensagem.bit003,
          bit007,
          mensagem.bit011,
          mensagem.bit012,
          mensagem.bit013,
          mensagem.bit032,
          '00',
          mensagem.bit041,
          mensagem.bit042,
          vl_bit0048,
          mensagem.bit070,
          vl_cod_mensagem_retorno::varchar);

    return vl_cod_mensagem_retorno;       

end$$;


ALTER FUNCTION sc_iso8583.abrir_sessao(mensagem tbl_msg8583) OWNER TO scan;

--
-- TOC entry 1112 (class 1255 OID 1010987)
-- Name: confirma_cancelamento_transacao(tbl_msg8583); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION confirma_cancelamento_transacao(mensagem tbl_msg8583) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

 vl_cod_mensagem_retorno bigint;
 vl_cod_retorno numeric;
 vl_cod_requisicao numeric;


 TIPO_REQUISICAO_AUT_COMPRA_DEBITO numeric   := 1;
 TIPO_REQUISICAO_CONFIRMA_COMPRA  numeric    := 2;
 TIPO_REQUISICAO_DESFAZ_COMPRA  numeric      := 3;
 TIPO_REQUISICAO_AUT_COMPRA_CREDITO  numeric := 4;
 TIPO_REQUISICAO_CANCELAMENTO_COMPRA numeric := 5;
 TIPO_REQUISICAO_CONFIRMA_CANCELAMENTO_COMPRA  numeric    := 14;  

 vl_nsu_trans_original varchar;
 vl_tipo_requisicao numeric;  

begin

   vl_nsu_trans_original := substring(mensagem.bit090,21,9);

   vl_tipo_requisicao := TIPO_REQUISICAO_CONFIRMA_CANCELAMENTO_COMPRA;

   select nextval('sc_iso8583.sq_msg8583') into vl_cod_mensagem_retorno; 

   select * 
   into vl_cod_requisicao,vl_cod_retorno 
   from sc_rdc.processar_requisicao_rdc(mensagem.bit042, --codigo estabelecimento
				   mensagem.bit011::numeric, -- NSU DO TEF
				   mensagem.bit041, -- IDENTIFICACAO DO TERMINAL
				   null,-- PLASTICO 
				   vl_tipo_requisicao,
				   null, -- validade 
				   null,--codigo seguranca 
				   null,--valor
				   null, --qtd parcelas 
				   vl_nsu_trans_original::numeric);

   insert into sc_iso8583.tbl_msg8583(cd_msg,bit001,bit003,bit007,bit011,bit012,bit013,bit039,bit041,bit042,bit090,bit127,cd_pai_msg)
   values(vl_cod_mensagem_retorno,
          '0x412',
          mensagem.bit003,
          to_char(now(),'mmddhh24miss'),--bit007
          mensagem.bit011,
          mensagem.bit012,
          mensagem.bit013,
          trim(to_char(vl_cod_retorno,'00')),--bit039
          mensagem.bit041,
          mensagem.bit042,
          mensagem.bit090,
          --vl_cod_requisicao::varchar,
          vl_nsu_trans_original,
          --sc_arq.preencher(9,vl_cod_requisicao::varchar,'0',2),
          mensagem.cd_msg);

    return vl_cod_mensagem_retorno;    
end$$;


ALTER FUNCTION sc_iso8583.confirma_cancelamento_transacao(mensagem tbl_msg8583) OWNER TO scan;

--
-- TOC entry 1732 (class 1255 OID 1010988)
-- Name: confirma_transacao(tbl_msg8583); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION confirma_transacao(mensagem tbl_msg8583) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

 vl_cod_mensagem_retorno bigint;
 vl_cod_retorno numeric;
 vl_cod_requisicao numeric;


 TIPO_REQUISICAO_AUT_COMPRA_DEBITO numeric   := 1;
 TIPO_REQUISICAO_CONFIRMA_COMPRA  numeric    := 2;
 TIPO_REQUISICAO_DESFAZ_COMPRA  numeric      := 3;
 TIPO_REQUISICAO_AUT_COMPRA_CREDITO  numeric := 4;
 TIPO_REQUISICAO_CANCELAMENTO_COMPRA numeric := 5;  

 vl_nsu_trans_original varchar;
 vl_tipo_requisicao numeric;  

begin

   vl_nsu_trans_original := substring(mensagem.bit090,21,9);

   vl_tipo_requisicao := TIPO_REQUISICAO_CONFIRMA_COMPRA;

   select nextval('sc_iso8583.sq_msg8583') into vl_cod_mensagem_retorno; 

   select * 
   into vl_cod_requisicao,vl_cod_retorno 
   from sc_rdc.processar_requisicao_rdc(mensagem.bit042, --codigo estabelecimento
				   mensagem.bit011::numeric, -- NSU DO TEF
				   mensagem.bit041, -- IDENTIFICACAO DO TERMINAL
				   null,-- PLASTICO 
				   vl_tipo_requisicao,
				   null, -- validade 
				   null,--codigo seguranca 
				   null,--valor
				   null, --qtd parcelas 
				   vl_nsu_trans_original::numeric);


  insert into sc_iso8583.tbl_msg8583(cd_msg,bit001,bit003,bit007,bit011,bit012,bit013,bit039,bit041,bit042,bit090,bit127,cd_pai_msg)
   values(vl_cod_mensagem_retorno,
          '0x212',
          mensagem.bit003,
          to_char(now(),'mmddhh24miss'),--bit007
          mensagem.bit011,
          mensagem.bit012,
          mensagem.bit013,
          trim(to_char(vl_cod_retorno,'00')),--bit039
          mensagem.bit041,
          mensagem.bit042,
          mensagem.bit090,
          --vl_cod_requisicao::varchar,
          vl_nsu_trans_original,
          --sc_arq.preencher(9,vl_cod_requisicao::varchar,'0',2),
          mensagem.cd_msg);

    return vl_cod_mensagem_retorno;    
end$$;


ALTER FUNCTION sc_iso8583.confirma_transacao(mensagem tbl_msg8583) OWNER TO scan;

--
-- TOC entry 1718 (class 1255 OID 1010989)
-- Name: consulta_saldo_parcela(tbl_msg8583); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION consulta_saldo_parcela(mensagem tbl_msg8583) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

 vl_cod_mensagem_retorno bigint;
 
  vl_cod_cartao numeric;
   vl_valor double precision;
   vl_filial_estabelecimento varchar;
   vl_qtd_parcela numeric;
   vl_validade character(7);
   vl_tipo_requisicao numeric;
   vl_cod_requisicao numeric;
   vl_cod_retorno numeric;
   vl_cod_seguranca numeric;


 TIPO_REQUISICAO_CONSULTA_SALDO numeric   := 6;
 TIPO_REQUISICAO_CONSULTA_PARCELAS numeric   := 7;
 TIPO_REQUISICAO_CONSULTA_SALDO_CREDITO numeric   := 13;
 TIPO_REQUISICAO_CONSULTA_PARCELAS_DEBITO numeric := 17;
 

 bit004 varchar;
 bit062 varchar; 
 bit038 varchar;
 bit039 varchar;
 vl_plastico numeric;
 vl_data_operacao timestamp;
 vl_cod_operacao numeric;
 vl_nr_parcela numeric;
 vl_nome_cartao varchar;

 vl_senha_valida varchar := 'N';

 vl_versao_tabela varchar;
 vl_indice_tabela varchar;

 vl_cartao_original numeric;

begin

   select nextval('sc_iso8583.sq_msg8583') into vl_cod_mensagem_retorno; 

   -- verificando se a entrada foi digitada ou magnetica
   if mensagem.bit022::numeric = 11 then
     vl_cod_cartao := mensagem.bit002::numeric;
     vl_senha_valida := 'S';
   elsif mensagem.bit022::numeric = 21 then
     vl_cod_cartao := substr(mensagem.bit035,1,16)::numeric;
   end if;

   vl_valor := mensagem.bit004::double precision / 100;
   vl_filial_estabelecimento := mensagem.bit042;
   vl_qtd_parcela := mensagem.bit067::numeric;
   vl_validade := mensagem.bit014::character(7);

   -- verificando o tipo de requisicao
   if mensagem.bit003 = '102000' then  

       vl_tipo_requisicao := TIPO_REQUISICAO_CONSULTA_SALDO;

       if mensagem.bit022::numeric = 11 then
         vl_cod_retorno := 99;
       end if;
     
   elsif mensagem.bit003 = '103800' then 

       vl_tipo_requisicao := TIPO_REQUISICAO_CONSULTA_PARCELAS;

   elsif mensagem.bit003 = '102810' then 

       vl_tipo_requisicao := TIPO_REQUISICAO_CONSULTA_PARCELAS_DEBITO;

   elsif mensagem.bit003 = '103000' then 

       vl_tipo_requisicao := TIPO_REQUISICAO_CONSULTA_SALDO_CREDITO;    
   
   end if;

 /*  vl_cartao_original :=  vl_cod_cartao;
   if vl_cod_cartao = 6201554727828916 then
     vl_cod_cartao := 6028993990617624;
   end if;*/

   if vl_senha_valida = 'N' then

     vl_versao_tabela := sc_iso8583.return_tlv_value(5, mensagem.bit048);
     vl_indice_tabela := sc_iso8583.return_tlv_value(8, mensagem.bit048);

     -- validando a senha
     select sc_iso8583.valida_senha(vl_cartao_original::varchar, mensagem.bit052, vl_versao_tabela, vl_indice_tabela)
     into vl_senha_valida;

   end if;

   if mensagem.bit022 = '011' and length(sc_iso8583.return_tlv_value(2, mensagem.bit048)) = 6 then
       vl_cod_seguranca := substr(mensagem.bit048,strpos(mensagem.bit048,' ')+1,length(mensagem.bit048))::numeric;
   end if;

   if vl_senha_valida = 'S' and vl_cod_retorno is null then 

     select * 
     into vl_cod_requisicao,vl_cod_retorno 
     from sc_rdc.processar_requisicao(vl_filial_estabelecimento, 
				   mensagem.bit011::numeric, -- NSU DO TEF
				   mensagem.bit041, -- IDENTIFICACAO DO TERMINAL
				   vl_cod_cartao,-- PLASTICO 
				   vl_tipo_requisicao,
				   vl_validade::varchar, 
				   vl_cod_seguranca::varchar,--codigo seguranca 
				   vl_valor, 
				   vl_qtd_parcela);

     if vl_cod_retorno <> 0 then
       bit038 := null;
     else


       select opr.cd_pls,to_char(pls.dt_vld_pls,'mm/yyyy'),opr.dt_opr,opr.cd_opr,opr.vl_opr,pls.nm_pls,opr.nr_prc_opr
       into vl_plastico,vl_validade,vl_data_operacao,vl_cod_operacao,vl_valor,vl_nome_cartao,vl_nr_parcela
       from sc_rdc.tbl_rqs rqs
         inner join sc_opr.tbl_opr opr on opr.cd_opr = rqs.cd_opr
         inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
       where cd_rqs = vl_cod_requisicao;
       
       bit038 := vl_cod_operacao::varchar;
       bit004 := sc_arq.preencher(12,replace(vl_valor::varchar,'.',''),'0',2);

     
     end if;       

   end if;

   --MONTANDO O CUPOM OU A MENSAGEM DE RETORNO
   if vl_cod_retorno = 0 then
      bit062 := sc_iso8583.gerar_cupom_consulta(vl_cartao_original,vl_validade,mensagem.bit042::numeric,mensagem.bit011::numeric,bit038::numeric,vl_data_operacao,vl_cod_operacao, mensagem.bit041,mensagem.bit003,vl_nr_parcela,vl_valor::numeric,vl_nome_cartao);
   ELSE
      bit062 := 'DTRANSACAO NAO AUTORIZADA#NAO AUTORIZADA';
   end if; 

  insert into sc_iso8583.tbl_msg8583(cd_msg,bit001,bit003,bit004,bit007,bit011,bit012,bit013,bit038,bit039,bit041,bit042,bit062,bit127,cd_pai_msg)
   values(vl_cod_mensagem_retorno,
          '0x110',
          mensagem.bit003,
          bit004,
          to_char(now(),'mmddhh24miss'),--bit007
          mensagem.bit011,
          mensagem.bit012,
          mensagem.bit013,
          bit038,
          trim(to_char(vl_cod_retorno,'00')),--bit039
          mensagem.bit041,
          mensagem.bit042,
          bit062,
          --vl_cod_mensagem_retorno::varchar,
          vl_cod_requisicao::varchar,
          --sc_arq.preencher(9,vl_cod_requisicao::varchar,'0',2),
          mensagem.cd_msg);

    return vl_cod_mensagem_retorno;    
end$$;


ALTER FUNCTION sc_iso8583.consulta_saldo_parcela(mensagem tbl_msg8583) OWNER TO scan;

--
-- TOC entry 1674 (class 1255 OID 1010992)
-- Name: desfaz_transacao(tbl_msg8583); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION desfaz_transacao(mensagem tbl_msg8583) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

 vl_cod_mensagem_retorno bigint;
 vl_cod_retorno numeric;
 vl_cod_requisicao numeric;


 TIPO_REQUISICAO_AUT_COMPRA_DEBITO numeric   := 1;
 TIPO_REQUISICAO_CONFIRMA_COMPRA  numeric    := 2;
 TIPO_REQUISICAO_DESFAZ_COMPRA  numeric      := 3;
 TIPO_REQUISICAO_AUT_COMPRA_CREDITO  numeric := 4;
 TIPO_REQUISICAO_CANCELAMENTO_COMPRA numeric := 5;  

 vl_nsu_tef varchar; 
 vl_nsu_trans_original varchar;
 vl_tipo_requisicao numeric;
 vl_data_gmt varchar;

 vl_eh_cielo varchar := 'N';

 vl_bit038 varchar;

begin

      -- Verifica se é CIELO
   if mensagem.bit032 is not null then
     if mensagem.bit032::numeric = 6142 then
        vl_eh_cielo := 'S';
     end if;
   end if;
   
   vl_nsu_tef := substring(mensagem.bit090,5,6);
   vl_data_gmt := substring(mensagem.bit090,11,10);

   if vl_eh_cielo = 'S' then
      select max(bit127)
      into vl_nsu_trans_original
      from sc_iso8583.tbl_msg8583
      where bit011 = trim(substring(mensagem.bit090,21,6))
        and bit001 = '0x210';
   else 
	   select f.bit127
	     into vl_nsu_trans_original
	   from sc_iso8583.tbl_msg8583 f
	     inner join sc_iso8583.tbl_msg8583 p on p.cd_msg = f.cd_pai_msg
	   where p.bit011 = vl_nsu_tef
	     and p.bit007 = vl_data_gmt;
   end if;	     

   --vl_nsu_trans_original := substring(mensagem.bit090,21,9);
   
   vl_tipo_requisicao := TIPO_REQUISICAO_DESFAZ_COMPRA;

   select nextval('sc_iso8583.sq_msg8583') into vl_cod_mensagem_retorno; 

   select * 
   into vl_cod_requisicao,vl_cod_retorno 
   from sc_rdc.processar_requisicao_rdc(mensagem.bit042, --codigo estabelecimento
				   mensagem.bit011::numeric, -- NSU DO TEF
				   mensagem.bit041, -- IDENTIFICACAO DO TERMINAL
				   null,-- PLASTICO 
				   vl_tipo_requisicao,
				   null, 
				   null,--codigo seguranca 
				   null, 
				   null,
				   vl_nsu_trans_original::numeric);

  if vl_eh_cielo = 'S' then
    if vl_cod_retorno = 0 then
      vl_bit038 := trim(to_char(vl_cod_requisicao,'000000'));
    end if;
  end if;				   


  insert into sc_iso8583.tbl_msg8583(cd_msg,bit001,bit003,bit004,bit007,bit011,bit012,bit013,bit032,bit038,bit039,bit041,bit042,bit049,bit090,bit127,cd_pai_msg)
   values(vl_cod_mensagem_retorno,
          '0x430',
          mensagem.bit003,
          mensagem.bit004,
          to_char(now(),'mmddhh24miss'),--bit007
          mensagem.bit011,
          mensagem.bit012,
          mensagem.bit013,
          mensagem.bit032,
          vl_bit038,
          trim(to_char(vl_cod_retorno,'00')),--bit039
          mensagem.bit041,
          mensagem.bit042,
          mensagem.bit049,
          mensagem.bit090,
          vl_cod_requisicao::varchar,
          --sc_arq.preencher(9,vl_cod_requisicao::varchar,'0',2),
          mensagem.cd_msg);

    return vl_cod_mensagem_retorno;    
end$$;


ALTER FUNCTION sc_iso8583.desfaz_transacao(mensagem tbl_msg8583) OWNER TO scan;

--
-- TOC entry 1791 (class 1255 OID 1010994)
-- Name: estorno_transacao(tbl_msg8583); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION estorno_transacao(mensagem tbl_msg8583) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

 vl_cod_mensagem_retorno bigint;
 
 vl_cod_cartao numeric;
 vl_valor double precision;
 vl_filial_estabelecimento varchar;
 vl_qtd_parcela numeric;
 vl_validade character(7);
 vl_tipo_requisicao numeric;
 vl_cod_requisicao numeric;
 vl_cod_retorno numeric;
 vl_cod_seguranca numeric; 


 TIPO_REQUISICAO_AUT_COMPRA_DEBITO numeric   := 1;
 TIPO_REQUISICAO_CONFIRMA_COMPRA  numeric    := 2;
 TIPO_REQUISICAO_DESFAZ_COMPRA  numeric      := 3;
 TIPO_REQUISICAO_AUT_COMPRA_CREDITO  numeric := 4;
 TIPO_REQUISICAO_CANCELAMENTO_COMPRA numeric := 5;  

 vl_nsu_trans_original varchar;
 bit038 varchar;
 bit062 varchar;
 bit063 varchar;
 vl_plastico numeric;
 vl_data_operacao timestamp;
 vl_cod_operacao numeric;
 vl_nr_parcela numeric;
 vl_nome_cartao varchar;

 vl_eh_cielo varchar := 'N';

begin

      -- Verifica se é CIELO
   if mensagem.bit032 is not null then
     if mensagem.bit032::numeric = 6142 then
        vl_eh_cielo := 'S';
     end if;
   end if;


   -- verificando se a entrada foi digitada ou magnetica
   if mensagem.bit022::numeric = 11 then
     vl_cod_cartao := mensagem.bit002::numeric;
   elsif mensagem.bit022::numeric = 21 then
     vl_cod_cartao := substr(mensagem.bit035,1,16)::numeric;
   end if;

   if vl_eh_cielo = 'S' then
      select max(m.bit127)
      into vl_nsu_trans_original
      from sc_iso8583.tbl_msg8583 m
      where m.bit038 = trim(substring(mensagem.bit090,5,6))
        and m.bit001 = '0x210';     
   else
     vl_nsu_trans_original := substring(mensagem.bit090,21,9);
   end if;  
   
   vl_valor := mensagem.bit004::double precision / 100;
   vl_filial_estabelecimento := mensagem.bit042;
   vl_qtd_parcela := mensagem.bit067::numeric;
   vl_validade := mensagem.bit014::character(7);

   vl_tipo_requisicao := TIPO_REQUISICAO_CANCELAMENTO_COMPRA;

   select nextval('sc_iso8583.sq_msg8583') into vl_cod_mensagem_retorno; 

   select * 
   into vl_cod_requisicao,vl_cod_retorno 
   from sc_rdc.processar_requisicao_rdc(vl_filial_estabelecimento, 
				   mensagem.bit011::numeric, -- NSU DO TEF
				   mensagem.bit041, -- IDENTIFICACAO DO TERMINAL
				   vl_cod_cartao,-- PLASTICO 
				   vl_tipo_requisicao,
				   vl_validade::varchar, 
				   vl_cod_seguranca::varchar,--codigo seguranca 
				   vl_valor, 
				   vl_qtd_parcela,
				   vl_nsu_trans_original::numeric);				   


  if vl_cod_retorno <> 0 then
    bit038 := null;
  else

    select opr.cd_pls,to_char(pls.dt_vld_pls,'mm/yyyy'),opr.dt_opr,opr.cd_opr,opr.vl_opr,pls.nm_pls,opr.nr_prc_opr
       into vl_plastico,vl_validade,vl_data_operacao,vl_cod_operacao,vl_valor,vl_nome_cartao,vl_nr_parcela
       from sc_rdc.tbl_rqs rqs
         inner join sc_opr.tbl_opr opr on opr.cd_opr = rqs.cd_opr
         inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
       where cd_rqs = vl_cod_requisicao;

    -- Sei que ninguem vai entender essa peripécia. 
    -- Mas isso foi necessário pq o bit038 possui somente 6 caracteres. Essa foi a forma mais bacana no momento.
    -- Se for o Gregorio, pode pular que nao vai conseguir entender. Nao mexa!
    bit038 := ABS(trunc(vl_cod_operacao::numeric/1000000)*1000000 - vl_cod_operacao)::varchar; 
       
 end if;       

   --MONTANDO O CUPOM OU A MENSAGEM DE RETORNO
   if vl_cod_retorno = 0 then
      bit062 := sc_iso8583.gerar_cupom(vl_plastico,vl_validade,mensagem.bit042::numeric,mensagem.bit011::numeric,bit038::numeric,vl_data_operacao,vl_cod_operacao, mensagem.bit041,mensagem.bit003,vl_nr_parcela,vl_valor::numeric,vl_nome_cartao);
   ELSE
      bit062 := 'DTRANSACAO NAO AUTORIZADA#NAO AUTORIZADA';
   end if; 

  insert into sc_iso8583.tbl_msg8583(cd_msg,bit001,bit003,bit004,bit007,bit011,bit012,bit013,bit032,bit037,bit038,bit039,bit041,bit042,bit048,bit049,bit062,bit063,bit090,bit127,cd_pai_msg)
   values(vl_cod_mensagem_retorno,
          '0x410',
          mensagem.bit003,
          mensagem.bit004,
          to_char(now(),'mmddhh24miss'),--bit007
          mensagem.bit011,
          mensagem.bit012,
          mensagem.bit013,
          mensagem.bit032,
          mensagem.bit037,
          bit038,
          trim(to_char(vl_cod_retorno,'00')),--bit039
          mensagem.bit041,
          mensagem.bit042,
          mensagem.bit048,
          mensagem.bit049,
          bit062,
          bit063,
          mensagem.bit090,
          --vl_cod_mensagem_retorno::varchar,
          vl_cod_requisicao::varchar,
          --sc_arq.preencher(9,vl_cod_requisicao::varchar,'0',2),
          mensagem.cd_msg);

    return vl_cod_mensagem_retorno;    
end$$;


ALTER FUNCTION sc_iso8583.estorno_transacao(mensagem tbl_msg8583) OWNER TO scan;

--
-- TOC entry 1719 (class 1255 OID 1010995)
-- Name: executar(bigint); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION executar(vp_cod_msg bigint) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

 rg_mensagem sc_iso8583.tbl_msg8583;
 
begin

   select *
   into rg_mensagem
   from sc_iso8583.tbl_msg8583
   where cd_msg = vp_cod_msg;

   if rg_mensagem.bit001 = '0x800' then
      return sc_iso8583.abrir_sessao(rg_mensagem);
   elsif rg_mensagem.bit001 = '0x200' then   
      return sc_iso8583.solicita_compra(rg_mensagem);
   elsif rg_mensagem.bit001 = '0x202' then   
      return sc_iso8583.confirma_transacao(rg_mensagem);
   elsif rg_mensagem.bit001 = '0x402' then   
      return sc_iso8583.confirma_cancelamento_transacao(rg_mensagem);   
   elsif rg_mensagem.bit001 = '0x420' then   
      return sc_iso8583.desfaz_transacao(rg_mensagem);
   elsif rg_mensagem.bit001 = '0x400' then   
      return sc_iso8583.estorno_transacao(rg_mensagem);
   elsif rg_mensagem.bit001 = '0x100' then   
      return sc_iso8583.consulta_saldo_parcela(rg_mensagem);
   end if;

end$$;


ALTER FUNCTION sc_iso8583.executar(vp_cod_msg bigint) OWNER TO scan;

--
-- TOC entry 1772 (class 1255 OID 1010996)
-- Name: gerar_cupom(numeric, character varying, numeric, numeric, numeric, timestamp without time zone, numeric, character varying, character varying, numeric, numeric, character varying); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION gerar_cupom(vp_plastico numeric, vp_validade character varying, vp_filial numeric, vp_nsu_org numeric, vp_nsu_autorizacao numeric, vp_data_operacao timestamp without time zone, vp_cod_operacao numeric, vp_id_terminal character varying, vp_tipo_operacao character varying, vp_nr_parcela numeric, vp_valor numeric, vp_nome_cartao character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare	

  vl_cupom varchar;
  vl_tamanho_linha integer := 38;

begin

  vl_cupom := 'F' || sc_arq.preencher(vl_tamanho_linha,'REDE SOMA CONTA DIGITAL',' ',3) || '@';
  vl_cupom := vl_cupom || '@';
  vl_cupom := vl_cupom || 'CARTAO: ' || substring(vp_plastico::varchar,1,4) || '**** ****'||substring(vp_plastico::varchar,13,4);

  vl_cupom := vl_cupom || sc_arq.repetir(' ', 6) || vp_validade || '@';

    -- ESTABELECIMENTO
  vl_cupom := vl_cupom || 'ESTAB.: ' || TRIM(TO_CHAR(vp_filial, '000000000000000'));

    -- NSU DE ORIGEM
  vl_cupom := vl_cupom || sc_arq.repetir(' ', 3) ||  'SEQ: ' || TRIM(TO_CHAR(vp_nsu_org, '000000')) || '@';

    -- IDENTIFICADOR DE TERMINAL
  vl_cupom := vl_cupom || 'TERM. : ' ||  sc_arq.preencher(8, vp_id_terminal, '0',2);

    -- NSU DE AUTORIZAC?O
    vl_cupom :=vl_cupom || sc_arq.repetir(' ', 8) || 'DOC: ' || TRIM(TO_CHAR(vp_nsu_autorizacao, '000000000')) || '@';

    -- DATA DA OPERAC?O
    vl_cupom := vl_cupom || 'DATA  : ' || TO_CHAR(vp_data_operacao, 'DD/MM/YYYY HH24:MI:SS');

    -- NUMERO DA OPERAC?O
    vl_cupom := vl_cupom || '@' ||
             'AUTO. : ' || TRIM(TO_CHAR(vp_cod_operacao,'00000000')) || '@';

    if vp_tipo_operacao = '003000' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'VENDA CREDITO A VISTA',' ',3) || '@';
    elsif vp_tipo_operacao = '002000' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'VENDA DEBITO A VISTA',' ',3) || '@';
    elsif vp_tipo_operacao = '003800' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'VENDA PARCELADA ESTABELECIMENTO',' ',3) || '@';
    elsif vp_tipo_operacao = '003810' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'VENDA PARCELADA EMISSOR',' ',3) || '@';
    elsif vp_tipo_operacao = '200020' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'ESTORNO DE COMPRA DEBITO',' ',3) || '@';
    elsif vp_tipo_operacao = '200030' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'ESTORNO DE COMPRA CREDITO',' ',3) || '@';
    elsif vp_tipo_operacao = '200040' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'ESTORNO DE PGTO FATURA',' ',3) || '@';
    end if;

    if vp_nr_parcela is not null and vp_nr_parcela > 1 then

       vl_cupom := vl_cupom || 'EM ' || trim(to_char(vp_nr_parcela,'00'))|| '@';
    
    end if;   

    vl_cupom := vl_cupom || 'VALOR : ' || sc_arq.preencher(vl_tamanho_linha - 8,to_char(vp_valor,'9G999G990D00'), ' ',2) || '@';
    
    vl_cupom := vl_cupom || '@';

    vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha, 'RECONHECO E PAGAREI A IMPORTANCIA', ' ',3) || '@';

    vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha, 'ACIMA INDICADA', ' ',3) || '@';

    vl_cupom := vl_cupom || '@';

    vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha, '_', '_',1) || '@';

    vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha, vp_nome_cartao, ' ',3) || '@';

    vl_cupom := vl_cupom || '@';

    vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha, 'CONFIRA A ASSINATURA', ' ',3) || '@';

    vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha, 'PROCESSADO POR APTARE.COM.BR', ' ',3) || '@';
    
    return vl_cupom;
end$$;


ALTER FUNCTION sc_iso8583.gerar_cupom(vp_plastico numeric, vp_validade character varying, vp_filial numeric, vp_nsu_org numeric, vp_nsu_autorizacao numeric, vp_data_operacao timestamp without time zone, vp_cod_operacao numeric, vp_id_terminal character varying, vp_tipo_operacao character varying, vp_nr_parcela numeric, vp_valor numeric, vp_nome_cartao character varying) OWNER TO scan;

--
-- TOC entry 1726 (class 1255 OID 1010997)
-- Name: gerar_cupom(numeric, character varying, numeric, numeric, numeric, timestamp without time zone, numeric, character varying, character varying, numeric, numeric, character varying, numeric); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION gerar_cupom(vp_plastico numeric, vp_validade character varying, vp_filial numeric, vp_nsu_org numeric, vp_nsu_autorizacao numeric, vp_data_operacao timestamp without time zone, vp_cod_operacao numeric, vp_id_terminal character varying, vp_tipo_operacao character varying, vp_nr_parcela numeric, vp_valor numeric, vp_nome_cartao character varying, vp_modo_entrada numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare	

  ct_modo_entrada_digitado numeric := 11;
  ct_modo_entrada_magnetico numeric := 21;

  vl_cupom varchar;
  vl_tamanho_linha integer := 38;

  

begin

  vl_cupom := 'F' || sc_arq.preencher(vl_tamanho_linha,'REDE SOMA CONTA DIGITAL',' ',3) || '@';
  vl_cupom := vl_cupom || '@';
  vl_cupom := vl_cupom || 'CARTAO: ' || substring(vp_plastico::varchar,1,4) || '**** ****'||substring(vp_plastico::varchar,13,4);

  vl_cupom := vl_cupom || sc_arq.repetir(' ', 6) || vp_validade || '@';

    -- ESTABELECIMENTO
  vl_cupom := vl_cupom || 'ESTAB.: ' || TRIM(TO_CHAR(vp_filial, '000000000000000'));

    -- NSU DE ORIGEM
  vl_cupom := vl_cupom || sc_arq.repetir(' ', 3) ||  'SEQ: ' || TRIM(TO_CHAR(vp_nsu_org, '000000')) || '@';

    -- IDENTIFICADOR DE TERMINAL
  vl_cupom := vl_cupom || 'TERM. : ' ||  sc_arq.preencher(8, vp_id_terminal, '0',2);

    -- NSU DE AUTORIZAC?O
    vl_cupom :=vl_cupom || sc_arq.repetir(' ', 8) || 'DOC: ' || TRIM(TO_CHAR(vp_nsu_autorizacao, '000000000')) || '@';

    -- DATA DA OPERAC?O
    vl_cupom := vl_cupom || 'DATA  : ' || TO_CHAR(vp_data_operacao, 'DD/MM/YYYY HH24:MI:SS');

    -- NUMERO DA OPERAC?O
    vl_cupom := vl_cupom || '@' ||
             'AUTO. : ' || TRIM(TO_CHAR(vp_cod_operacao,'00000000')) || '@';

    if vp_tipo_operacao = '003000' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'VENDA CREDITO A VISTA',' ',3) || '@';
    elsif vp_tipo_operacao = '002000' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'VENDA DEBITO A VISTA',' ',3) || '@';
    elsif vp_tipo_operacao = '003800' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'VENDA PARCELADA ESTABELECIMENTO',' ',3) || '@';
    elsif vp_tipo_operacao = '003810' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'VENDA PARCELADA EMISSOR',' ',3) || '@';
    elsif vp_tipo_operacao = '200020' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'ESTORNO DE COMPRA DEBITO',' ',3) || '@';
    elsif vp_tipo_operacao = '200030' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'ESTORNO DE COMPRA CREDITO',' ',3) || '@';
    elsif vp_tipo_operacao = '200040' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'ESTORNO DE PGTO FATURA',' ',3) || '@';
    end if;

    if vp_nr_parcela is not null and vp_nr_parcela > 1 then

       vl_cupom := vl_cupom || 'EM ' || trim(to_char(vp_nr_parcela,'00'))|| '@';
    
    end if;   

    vl_cupom := vl_cupom || 'VALOR : ' || sc_arq.preencher(vl_tamanho_linha - 8,to_char(vp_valor,'9G999G990D00'), ' ',2) || '@';
    
    vl_cupom := vl_cupom || '@';

    if vp_modo_entrada = ct_modo_entrada_digitado then

      vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha, 'RECONHECO E PAGAREI A IMPORTANCIA', ' ',3) || '@';

      vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha, 'ACIMA INDICADA', ' ',3) || '@';

      vl_cupom := vl_cupom || '@';

      vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha, '_', '_',1) || '@';

      vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha, vp_nome_cartao, ' ',3) || '@';

      vl_cupom := vl_cupom || '@';

      vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha, 'CONFIRA A ASSINATURA', ' ',3) || '@';

      vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha, 'PROCESSADO POR APTARE.COM.BR', ' ',3) || '@';
      

    end if;  
    
    return vl_cupom;
end$$;


ALTER FUNCTION sc_iso8583.gerar_cupom(vp_plastico numeric, vp_validade character varying, vp_filial numeric, vp_nsu_org numeric, vp_nsu_autorizacao numeric, vp_data_operacao timestamp without time zone, vp_cod_operacao numeric, vp_id_terminal character varying, vp_tipo_operacao character varying, vp_nr_parcela numeric, vp_valor numeric, vp_nome_cartao character varying, vp_modo_entrada numeric) OWNER TO scan;

--
-- TOC entry 1720 (class 1255 OID 1010998)
-- Name: gerar_cupom_consulta(numeric, character varying, numeric, numeric, numeric, timestamp without time zone, numeric, character varying, character varying, numeric, numeric, character varying); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION gerar_cupom_consulta(vp_plastico numeric, vp_validade character varying, vp_filial numeric, vp_nsu_org numeric, vp_nsu_autorizacao numeric, vp_data_operacao timestamp without time zone, vp_cod_operacao numeric, vp_id_terminal character varying, vp_tipo_operacao character varying, vp_nr_parcela numeric, vp_valor numeric, vp_nome_cartao character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare	

  vl_cupom varchar;
  vl_tamanho_linha integer := 38;

begin

  vl_cupom := 'F' || sc_arq.preencher(vl_tamanho_linha,'REDE SOMA CONTA DIGITAL',' ',3) || '@';
  vl_cupom := vl_cupom || '@';
  vl_cupom := vl_cupom || 'CARTAO: ' || substring(vp_plastico::varchar,1,4) || '**** ****'||substring(vp_plastico::varchar,13,4);

  vl_cupom := vl_cupom || sc_arq.repetir(' ', 6) || vp_validade || '@';

    -- ESTABELECIMENTO
  vl_cupom := vl_cupom || 'ESTAB.: ' || TRIM(TO_CHAR(vp_filial, '000000000000000'));

    -- NSU DE ORIGEM
  vl_cupom := vl_cupom || sc_arq.repetir(' ', 3) ||  'SEQ: ' || TRIM(TO_CHAR(vp_nsu_org, '000000')) || '@';

    -- IDENTIFICADOR DE TERMINAL
  vl_cupom := vl_cupom || 'TERM. : ' ||  sc_arq.preencher(8, vp_id_terminal, '0',2);

    -- NSU DE AUTORIZAC?O
    vl_cupom :=vl_cupom || sc_arq.repetir(' ', 8) || 'DOC: ' || TRIM(TO_CHAR(vp_nsu_autorizacao, '000000000')) || '@';

    -- DATA DA OPERAC?O
    vl_cupom := vl_cupom || 'DATA  : ' || TO_CHAR(vp_data_operacao, 'DD/MM/YYYY HH24:MI:SS');

    -- NUMERO DA OPERAC?O
    vl_cupom := vl_cupom || '@' ||
             'AUTO. : ' || TRIM(TO_CHAR(vp_cod_operacao,'000000')) || '@';

    if vp_tipo_operacao = '102000' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'CONSULTA SALDO',' ',3) || '@';
    elsif vp_tipo_operacao = '103000' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'CONSULTA SALDO DE LIMITE',' ',3) || '@';
    elsif vp_tipo_operacao = '103800' then
       vl_cupom := vl_cupom || sc_arq.preencher(vl_tamanho_linha,'CONSULTA DE PARCELA',' ',3) || '@';
    end if;

    if vp_nr_parcela is not null and vp_nr_parcela > 1 then

       vl_cupom := vl_cupom || 'EM ' || trim(to_char(vp_nr_parcela,'00'))|| '@';
    
    end if;   

    vl_cupom := vl_cupom || 'VALOR : ' || sc_arq.preencher(vl_tamanho_linha - 8,to_char(vp_valor,'9G999G990D00'), ' ',2) || '@';
    
    
    return vl_cupom;
end$$;


ALTER FUNCTION sc_iso8583.gerar_cupom_consulta(vp_plastico numeric, vp_validade character varying, vp_filial numeric, vp_nsu_org numeric, vp_nsu_autorizacao numeric, vp_data_operacao timestamp without time zone, vp_cod_operacao numeric, vp_id_terminal character varying, vp_tipo_operacao character varying, vp_nr_parcela numeric, vp_valor numeric, vp_nome_cartao character varying) OWNER TO scan;

--
-- TOC entry 1721 (class 1255 OID 1010999)
-- Name: return_tlv_value(numeric, character varying); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION return_tlv_value(tag numeric, entrada character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

   vl_tag numeric;
   vl_tamanho int;
   vl_pos numeric;

begin

    while coalesce(length(entrada),0) > 0 loop

      vl_tag := substr(entrada,1,3);
      vl_tamanho := substr(entrada,4,3);

      if vl_tag = tag then
	 return substr(entrada,7,vl_tamanho);
      end if;

      entrada := substr(entrada,7 + vl_tamanho,length(entrada));

      if vl_tag = tag then
	 return vl_retorno;
      end if;
    end loop;

    return null;       

end$$;


ALTER FUNCTION sc_iso8583.return_tlv_value(tag numeric, entrada character varying) OWNER TO scan;

--
-- TOC entry 1741 (class 1255 OID 1011000)
-- Name: solicita_compra(tbl_msg8583); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION solicita_compra(mensagem tbl_msg8583) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

   vl_cod_mensagem_retorno bigint;

   vl_cod_cartao numeric;
   vl_valor double precision;
   vl_filial_estabelecimento varchar;
   vl_qtd_parcela numeric;
   vl_validade character(7);
   vl_tipo_requisicao numeric;
   vl_cod_requisicao numeric;
   vl_cod_retorno numeric;
   vl_cod_seguranca numeric;

 TIPO_REQUISICAO_AUT_COMPRA_DEBITO numeric   := 1;
 TIPO_REQUISICAO_CONFIRMA_COMPRA  numeric    := 2;
 TIPO_REQUISICAO_DESFAZ_COMPRA  numeric      := 3;
 TIPO_REQUISICAO_AUT_COMPRA_CREDITO  numeric := 4;
 TIPO_REQUISICAO_CANCELAMENTO_COMPRA numeric := 5;  
 TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_SEM_JUROS numeric := 8;
 TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_COM_JUROS numeric := 9;
 TIPO_REQUISICAO_AUT_SAQUE_DEBITO numeric   := 10;
 TIPO_REQUISICAO_AUT_SAQUE_CREDITO numeric   := 11;
 TIPO_REQUISICAO_PGTO_FATURA numeric   := 12;
 TIPO_REQUISICAO_AUT_COMPRA_DEB_PARC_SEM_JUROS numeric := 15;
 TIPO_REQUISICAO_AUT_COMPRA_DEB_PARC_COM_JUROS numeric := 16;
 COD_RETORNO_TRANSACAO_NAO_PERMITIDA numeric := 53;


 bit062 varchar; 
 bit038 varchar;
 bit039 varchar;
 vl_plastico numeric;
 vl_data_operacao timestamp;
 vl_cod_operacao numeric;
 vl_nr_parcela numeric;
 vl_nome_cartao varchar;

 vl_senha_valida varchar := 'N';

 vl_versao_tabela varchar;
 vl_indice_tabela varchar;

 vl_cartao_original numeric;

 vl_eh_cielo varchar := 'N';

 vl_msg_erro varchar;

begin

  select nextval('sc_iso8583.sq_msg8583') into vl_cod_mensagem_retorno; 

  /*if mensagem.bit035 is null then
    vl_senha_valida = 'INSCONISTENCIA NA ISO OU AUSENCIA DE CAMPO';
  else
  */

   -- Verifica se é CIELO
   if mensagem.bit032 is not null then
     if mensagem.bit032::numeric = 6142 then
        vl_eh_cielo := 'S';
     end if;
   end if;
   
     
   -- verificando se a entrada foi digitada ou magnetica
   if mensagem.bit022::numeric = 11 then
     vl_cod_cartao := mensagem.bit002::numeric;
     vl_senha_valida := 'S';
   elsif mensagem.bit022::numeric = 21 then
     vl_cod_cartao := substr(mensagem.bit035,1,16)::numeric;

     if mensagem.bit003 = '004000' then
       vl_senha_valida := 'S';
     end if;
   
   end if;

   vl_cartao_original :=  vl_cod_cartao;
  /* if vl_cod_cartao = 6058683546051594 then
     vl_cod_cartao := 6028993990617624;
   end if;*/

   vl_valor := mensagem.bit004::double precision / 100;
   vl_filial_estabelecimento := mensagem.bit042;
   vl_qtd_parcela := mensagem.bit067::numeric;
   vl_validade := mensagem.bit014::character(7);

   if vl_senha_valida = 'N' then

     if vl_eh_cielo = 'N' then
       vl_versao_tabela := sc_iso8583.return_tlv_value(5, mensagem.bit048);
       vl_indice_tabela := sc_iso8583.return_tlv_value(8, mensagem.bit048);
     else
       vl_versao_tabela := 99;
       vl_indice_tabela := 99;
     end if;  

     -- validando a senha
     select sc_iso8583.valida_senha(vl_cartao_original::varchar, mensagem.bit052, vl_versao_tabela, vl_indice_tabela)
     into vl_senha_valida;

   end if;

   --end if;

   if vl_senha_valida = 'S' then

     if mensagem.bit003 = '003000' or mensagem.bit003 = '001000' then -- COMPRA A CREDITO


       vl_tipo_requisicao := TIPO_REQUISICAO_AUT_COMPRA_CREDITO;
       --vl_tipo_requisicao := TIPO_REQUISICAO_AUT_COMPRA_DEBITO;

         if vl_eh_cielo = 'S' then
		 if mensagem.bit048 like '%VPS%' then
		    vl_tipo_requisicao := TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_SEM_JUROS;
		 end if;
         end if; 

     elsif mensagem.bit003 = '003800' then -- COMPRA A CREDITO SEM JUROS

       vl_tipo_requisicao := TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_SEM_JUROS;  

     elsif mensagem.bit003 = '003810' then -- COMPRA A CREDITO COM JUROS

       vl_tipo_requisicao := TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_COM_JUROS;  
      
     elsif mensagem.bit003 = '002000' then -- COMPRA A DEBITO

       vl_tipo_requisicao := TIPO_REQUISICAO_AUT_COMPRA_DEBITO;

     elsif mensagem.bit003 = '002400' then -- SAQUE A DEBITO

       vl_tipo_requisicao := TIPO_REQUISICAO_AUT_SAQUE_DEBITO; 

     elsif mensagem.bit003 = '003400' then -- SAQUE A CREDITO

       --vl_tipo_requisicao := TIPO_REQUISICAO_AUT_SAQUE_CREDITO;   
       vl_tipo_requisicao := TIPO_REQUISICAO_AUT_SAQUE_DEBITO; 

     elsif mensagem.bit003 = '004000' then -- SAQUE A CREDITO

       vl_tipo_requisicao := TIPO_REQUISICAO_PGTO_FATURA;   

     elsif mensagem.bit003 = '002800' then -- COMPRA A CREDITO SEM JUROS

       vl_tipo_requisicao := TIPO_REQUISICAO_AUT_COMPRA_DEB_PARC_SEM_JUROS;  

     elsif mensagem.bit003 = '002810' then -- COMPRA A CREDITO COM JUROS

       vl_tipo_requisicao := TIPO_REQUISICAO_AUT_COMPRA_DEB_PARC_COM_JUROS; 
   
     end if;


     if mensagem.bit022 = '011' then
       vl_cod_seguranca := substr(mensagem.bit048,strpos(mensagem.bit048,' ')+1,length(mensagem.bit048))::numeric;
     end if;
   

     select * 
     into vl_cod_requisicao,vl_cod_retorno 
     from sc_rdc.processar_requisicao_rdc(vl_filial_estabelecimento, 
				   mensagem.bit011::numeric, -- NSU DO TEF
				   mensagem.bit041, -- IDENTIFICACAO DO TERMINAL
				   vl_cod_cartao,-- PLASTICO 
				   vl_tipo_requisicao,
				   vl_validade::varchar, 
				   vl_cod_seguranca::varchar,--codigo seguranca 
				   vl_valor, 
				   vl_qtd_parcela,
				   null,
				   mensagem.bit032::numeric);


     if vl_cod_retorno <> 0 then
       bit038 := null;
     else

       select opr.cd_pls,to_char(pls.dt_vld_pls,'mm/yyyy'),opr.dt_opr,opr.cd_opr,opr.vl_opr,pls.nm_pls,opr.nr_prc_opr
       into vl_plastico,vl_validade,vl_data_operacao,vl_cod_operacao,vl_valor,vl_nome_cartao,vl_nr_parcela
       from sc_rdc.tbl_rqs rqs
         inner join sc_opr.tbl_opr opr on opr.cd_opr = rqs.cd_opr
         inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
       where cd_rqs = vl_cod_requisicao;

       -- Sei que ninguem vai entender essa peripécia. 
       -- Mas isso foi necessário pq o bit038 possui somente 6 caracteres. Essa foi a forma mais bacana no momento.
       -- Se for o Gregorio, pode pular que nao vai conseguir entender. Nao mexa!
       bit038 := ABS(trunc(vl_cod_operacao::numeric/1000000)*1000000 - vl_cod_operacao)::varchar; 
      
     end if;

     --MONTANDO O CUPOM OU A MENSAGEM DE RETORNO
     if vl_cod_retorno = 0 then
       bit062 := sc_iso8583.gerar_cupom(vl_cartao_original,vl_validade,mensagem.bit042::numeric,mensagem.bit011::numeric,vl_cod_requisicao,vl_data_operacao,vl_cod_operacao, mensagem.bit041,mensagem.bit003,vl_nr_parcela,vl_valor::numeric,vl_nome_cartao,mensagem.bit022::numeric);
     else
       if vl_cod_retorno = 14 then
          vl_msg_erro = 'CARTAO BLOQUEADO-INVALIDO';
       elsif vl_cod_retorno = 51 then    
          vl_msg_erro = 'SALDO-LIMITE INSUFICIENTE';
       elsif vl_cod_retorno = 61 then      
          vl_msg_erro = 'SALDO-LIMITE INSUFICIENTE';
       elsif vl_cod_retorno = 53 then      
          vl_msg_erro = 'TRANSACAO NAO PERMITIDA';
       elsif vl_cod_retorno = 69 then      
          vl_msg_erro = 'ESTABELECIMENTO INVALIDO';
       end if;
       bit062 := 'DTRANSACAO NAO AUTORIZADA.#NAO AUTORIZADA-' || coalesce(vl_msg_erro,' ') || vl_cod_retorno;
       
       if vl_eh_cielo = 'S' then
         bit039 := '51';
       end if;
     end if;

     bit039 := trim(to_char(vl_cod_retorno,'00'));


   else

    if vl_senha_valida = 'N0' then
      bit039 := 'N0';
    else
      bit039 := '99';  
    end if;
    
    bit062 := 'DSENHA INVALIDA.#SENHA INVALIDA';

    if length(vl_senha_valida) > 2 then 
      bit062 := 'D' || vl_senha_valida;
    end if;

    if vl_eh_cielo = 'S' then
      bit039 := '55';
    end if;
    
   end if;

   insert into sc_iso8583.tbl_msg8583(cd_msg,bit001,bit003,bit004,bit007,bit011,bit012,bit013,bit032,bit037,bit038,bit039,bit041,bit042,bit049,bit062,bit063,bit127,cd_pai_msg)
   values(vl_cod_mensagem_retorno,
          '0x210',
          mensagem.bit003,
          mensagem.bit004,
          to_char(now(),'mmddhh24miss'),--bit007
          mensagem.bit011,
          mensagem.bit012,
          mensagem.bit013,
          mensagem.bit032,
          mensagem.bit037,
          bit038,
          bit039,--bit039
          mensagem.bit041,
          mensagem.bit042,
          mensagem.bit049,
          bit062,
          null,
          vl_cod_requisicao::varchar,
          --sc_arq.preencher(9,vl_cod_requisicao::varchar,'0',2),
          mensagem.cd_msg);

    return vl_cod_mensagem_retorno;    
end$$;


ALTER FUNCTION sc_iso8583.solicita_compra(mensagem tbl_msg8583) OWNER TO scan;

--
-- TOC entry 1724 (class 1255 OID 1011003)
-- Name: valida_senha(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: sc_iso8583; Owner: scan
--

CREATE FUNCTION valida_senha(vp_pan character varying, vp_lock_pin_block character varying, vp_versao_wk character varying, vp_indice_wk character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

   vl_senha varchar;
   vl_ctrl varchar := '0000';
   vl_partial_pan varchar;
   vl_existe numeric;

   vl_versao_wk numeric; 
   vl_indice_wk numeric;

   rg_wk sc_iso8583.tbl_wkey%rowtype;

begin

    --if vp_pan = '6028994660896009' then
    --  return 'S';
    --end if;

    vl_partial_pan := substr(vp_pan,4,12);
    vl_versao_wk := vp_versao_wk::numeric;
    vl_indice_wk := vp_indice_wk::numeric;


    if vl_versao_wk is null or vl_indice_wk is null then
      return 'N0';
    end if;

    select *
      into rg_wk
    from sc_iso8583.tbl_wkey
    where vrs_wkey = vl_versao_wk
      and idc_wkey = vl_indice_wk;    

    -- caso o indice da tabela de working key informado nao seja encontrado
    if rg_wk is null then
      return 'N0';
    end if;

    select sc_rdc.decripta3des(vl_ctrl || vl_partial_pan, vp_lock_pin_block, rg_wk.open_wkey)
      into vl_senha;

    if vl_senha is null then
      return 'N0';
    end if;
 
  /* if vp_pan::numeric = 6058683546051594 then
     vp_pan := '6028993990617624';
   end if;*/

    select  count(*)
     into vl_existe
    from sc_opr.tbl_pls
    where cd_pls = vp_pan::numeric
      and nm_snh_pls = md5(vl_senha);

    if vl_existe > 0 then
      return 'S';
    else
      return 'N';
    end if;

end$$;


ALTER FUNCTION sc_iso8583.valida_senha(vp_pan character varying, vp_lock_pin_block character varying, vp_versao_wk character varying, vp_indice_wk character varying) OWNER TO scan;

SET search_path = sc_job, pg_catalog;

--
-- TOC entry 1842 (class 1255 OID 564431)
-- Name: enviar_email(numeric); Type: FUNCTION; Schema: sc_job; Owner: scan
--

CREATE FUNCTION enviar_email(vp_tipo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

ct_st_erro numeric := 3;
rg record;
existe numeric := 1;
texto text;
count numeric := 1;
assunto varchar(100);


begin

  if vp_tipo <> 1 then
    select count(*)
      into existe
    from sc_job.tbl_ljb ljb
      inner join sc_job.tbl_job job on job.cd_job = ljb.cd_job
          where job.tp_job = vp_tipo
      and ljb.st_ljb = ct_st_erro 
      and ljb.dt_ini_ljb >= to_timestamp(to_char(clock_timestamp(), 'dd/MM/yyyy HH24') || ':00:00', 'dd/MM/yyyy HH24:mi:ss');
    
  end if; 

  if existe = 0 then
    return;
  end if;


  texto := '<html xmlns="http://www.w3.org/1999/xhtml">
		<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Jobs SAQPAG</title>

		<style>

		.tabela{
			width: 100%;
			font-family:Arial;
			border:1px solid #999;
			border-collapse: collapse;
		}

		.tabela th{
			background:#03F;
		    color:#FFF;
			text-align:center;
			border:1px solid #999;
		}

		.tabela tr td{
			border:1px solid #999;
		}

		.impar{
			background:#CCC;
		}

		</style>

		</head>

		<body>
		<table class="tabela">
			<tr>
			<th>Ordem</th>
			<th>Código</th>
			<th>Comando</th>
			<th>Descrição</th>
			<th>Data Inicial</th>
			<th>Data Final</th>
			<th>Estado</th>
			<th>Erro</th>
		    </tr>';
  
  for rg in select ljb.*, job.nm_job, job.nr_ord_job, job.cd_job,job.cmd_job
              from sc_job.tbl_ljb ljb
                inner join sc_job.tbl_job job on job.cd_job = ljb.cd_job
                where job.tp_job = vp_tipo
                and (case when vp_tipo = 1 then true else ljb.st_ljb = ct_st_erro end)
                and ljb.dt_ini_ljb >= (case when vp_tipo = 1 then current_date else to_timestamp(to_char(clock_timestamp(), 'dd/MM/yyyy HH24') || ':00:00', 'dd/MM/yyyy HH24:mi:ss') end)
             order by job.nr_ord_job loop


 	texto := texto || '<tr class="' || case when mod(count,2) = 0 then '' else 'impar' end || '">';
	texto := texto || '<td>'|| rg.nr_ord_job ||'</td>';
        texto := texto || '<td>'|| rg.cd_job ||'</td>';
        texto := texto || '<td>'|| rg.cmd_job ||'</td>';
	texto := texto || '<td>'|| rg.nm_job ||'</td>';
	texto := texto || '<td align="center">'|| to_char(rg.dt_ini_ljb,'dd/MM/yyyy HH24:mi:ss') ||'</td>';
	texto := texto || '<td align="center">'|| to_char(rg.dt_fim_ljb,'dd/MM/yyyy HH24:mi:ss') ||'</td>';
	texto := texto || '<td>'|| case when rg.st_ljb = 2 then 'SUCESSO' else 'ERRO' end ||'</td>';
	texto := texto || '<td>'|| coalesce(rg.ds_err_ljb,'') ||'</td>';
	texto := texto || '</tr>';

	count := count + 1;
   end loop;


   texto := texto || '</table>
		     </body></html>';


   assunto := 'JOB SAQPAG - INDEFINIDO';

   if vp_tipo = 1 then
     assunto := 'JOB SAQPAG - UMA HORA DA MANHÃ';
   elsif vp_tipo = 2 then
     assunto := 'JOB SAQPAG - HORA EM HORA';
   end if;

  -- enviando o email
   perform sc_pbl.enviar_email_saqpag('tecnologia@somacontadigital.com.br',assunto,texto,null);
     
  exception when others then
    raise 'ERRO NO ENVIO DE EMAIL DE JOBS %', sqlerrm;
end;$$;


ALTER FUNCTION sc_job.enviar_email(vp_tipo numeric) OWNER TO scan;

--
-- TOC entry 7823 (class 0 OID 0)
-- Dependencies: 1842
-- Name: FUNCTION enviar_email(vp_tipo numeric); Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON FUNCTION enviar_email(vp_tipo numeric) IS 'funcao que envia email com os estados dos jobs';


--
-- TOC entry 1610 (class 1255 OID 975800)
-- Name: executar_java_job(character varying, character varying); Type: FUNCTION; Schema: sc_job; Owner: scan
--

CREATE FUNCTION executar_java_job(vp_nome character varying, vp_parametros character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_retorno text;
begin
   select sc_job.executar_job_java_novo(vp_nome, vp_parametros)
     into vl_retorno;

  raise notice 'retorno da execução do job: %', vl_retorno;
end;$$;


ALTER FUNCTION sc_job.executar_java_job(vp_nome character varying, vp_parametros character varying) OWNER TO scan;

--
-- TOC entry 1326 (class 1255 OID 1622959)
-- Name: executar_java_job_empresa(character varying, character varying); Type: FUNCTION; Schema: sc_job; Owner: postgres
--

CREATE FUNCTION executar_java_job_empresa(vp_nome character varying, vp_parametros character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  protocolo varchar := 'http';
  url varchar := '172.20.3.218';
  porta varchar := '8080';
  aplicacao varchar := 'empresa';

begin

   perform sc_job.executar_job_java(protocolo, url, porta, aplicacao, vp_nome, vp_parametros);
  

end;$$;


ALTER FUNCTION sc_job.executar_java_job_empresa(vp_nome character varying, vp_parametros character varying) OWNER TO postgres;

--
-- TOC entry 1735 (class 1255 OID 1015552)
-- Name: executar_java_job_teste(character varying, character varying); Type: FUNCTION; Schema: sc_job; Owner: scan
--

CREATE FUNCTION executar_java_job_teste(vp_nome character varying, vp_parametros character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  protocolo varchar := 'http';
  url varchar := '192.168.1.6';
  porta varchar := '8080';
  aplicacao varchar := 'scan2';

begin

   perform sc_job.executar_job_java(protocolo, url, porta, aplicacao, vp_nome, vp_parametros);
  

end;$$;


ALTER FUNCTION sc_job.executar_java_job_teste(vp_nome character varying, vp_parametros character varying) OWNER TO scan;

--
-- TOC entry 1643 (class 1255 OID 975786)
-- Name: executar_job_java(character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: sc_job; Owner: scan
--

CREATE FUNCTION executar_job_java(character varying, character varying, character varying, character varying, character varying, character varying) RETURNS void
    LANGUAGE javau
    AS $$br.com.aptare.a2pg.PlJavaJobExecute.executar$$;


ALTER FUNCTION sc_job.executar_job_java(character varying, character varying, character varying, character varying, character varying, character varying) OWNER TO scan;

--
-- TOC entry 1601 (class 1255 OID 1665882)
-- Name: executar_job_java_novo(character varying, character varying); Type: FUNCTION; Schema: sc_job; Owner: scan
--

CREATE FUNCTION executar_job_java_novo(character varying, character varying) RETURNS character varying
    LANGUAGE javau
    AS $$br.com.soma.pljava.ws.ApiJob.executar(java.lang.String, java.lang.String)$$;


ALTER FUNCTION sc_job.executar_job_java_novo(character varying, character varying) OWNER TO scan;

--
-- TOC entry 1785 (class 1255 OID 564432)
-- Name: executar_por_tipo(numeric); Type: FUNCTION; Schema: sc_job; Owner: scan
--

CREATE FUNCTION executar_por_tipo(vp_tipo_job numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  vl_qtd_job_em_execucao numeric;
  rg_job record;
  
  ST_LOG_JOB_EM_ANDAMENTO sc_job.tbl_ljb.st_ljb%type := 1;
  ST_LOG_JOB_CONCLUIDO sc_job.tbl_ljb.st_ljb%type := 2;
  ST_LOG_JOB_ERRO sc_job.tbl_ljb.st_ljb%type := 3;

  CT_TIPO_JOB_HORA_EM_HORA numeric := 2;
  CT_TIPO_JOB_DEZ_EM_DEZ_MINUTROS numeric := 6;
 
  codigo_log numeric;

  _conn text;
  
BEGIN


  -- NAO EXECUTAR OS JOBS DE HORA EM HORA NO PERIODO NOTURNO
  if vp_tipo_job in (CT_TIPO_JOB_HORA_EM_HORA,CT_TIPO_JOB_DEZ_EM_DEZ_MINUTROS) and date_part('hour', clock_timestamp()) >= 1 and date_part('hour', clock_timestamp()) <= 5 then
     return;
  end if; 
  
  _conn:='hostaddr=127.0.0.1 port=5432 dbname=scan user=scan password=scan';

  for rg_job in select *
                from sc_job.tbl_job job
                where job.tp_job = vp_tipo_job 
                  and job.fg_atv_job = 'S'
                  and job.dt_vig_ini_job < now()
                  and (job.dt_vig_fim_job > now() OR job.dt_vig_fim_job is null)
                order by job.nr_ord_job loop
                            
      select count(*)
      into vl_qtd_job_em_execucao
      from sc_job.tbl_ljb ljb
      where ljb.cd_job = rg_job.cd_job
        and ljb.st_ljb = ST_LOG_JOB_EM_ANDAMENTO;
        
      if( vl_qtd_job_em_execucao = 0 ) then

        codigo_log := nextval('sc_job.sq_ljb');
 
        PERFORM dblink_exec(_conn,'
                insert into sc_job.tbl_ljb(cd_ljb,cd_job,st_ljb,dt_ini_ljb) 
           values(' || codigo_log || ',' || rg_job.cd_job || ',' || ST_LOG_JOB_EM_ANDAMENTO || ',clock_timestamp());');
      
        BEGIN
 
          PERFORM * FROM dblink(_conn, 'select ' || rg_job.cmd_job) as x (x text);
          PERFORM dblink_exec(_conn,'
                 update sc_job.tbl_ljb
             set st_ljb = ' || ST_LOG_JOB_CONCLUIDO || ',
                 dt_fim_ljb = clock_timestamp()
             where cd_ljb = ' || codigo_log  || ';');
             
        EXCEPTION 
           WHEN OTHERS THEN
 
            PERFORM dblink_exec(_conn,'             
               update sc_job.tbl_ljb
                 set st_ljb = ' || ST_LOG_JOB_ERRO || ',
                   ds_err_ljb = ''' || sqlerrm || ''',
                   dt_fim_ljb = clock_timestamp()
               where cd_ljb = ' || codigo_log || ';');
        END;   
        
      end if;  
                  
  end loop;

  -- envia email com estado de execucao dos jobs
  perform sc_job.enviar_email(vp_tipo_job);                
                
END
$$;


ALTER FUNCTION sc_job.executar_por_tipo(vp_tipo_job numeric) OWNER TO scan;

--
-- TOC entry 7824 (class 0 OID 0)
-- Dependencies: 1785
-- Name: FUNCTION executar_por_tipo(vp_tipo_job numeric); Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON FUNCTION executar_por_tipo(vp_tipo_job numeric) IS 'ROTINA RESPONSAVEL POR EXECUTAR OS COMANDOS DOS JOBS';


--
-- TOC entry 1381 (class 1255 OID 564433)
-- Name: funcoes_thread_java(); Type: FUNCTION; Schema: sc_job; Owner: scan
--

CREATE FUNCTION funcoes_thread_java() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin

  -- gerador de alerta atm
  perform sc_rds.alerta_sem_comunicacao();

  -- sonda da operacoes de recarga
  perform sc_rcg.sonda();

end;$$;


ALTER FUNCTION sc_job.funcoes_thread_java() OWNER TO scan;

SET search_path = sc_meta, pg_catalog;

--
-- TOC entry 1378 (class 1255 OID 564434)
-- Name: preencher_valores(character varying); Type: FUNCTION; Schema: sc_meta; Owner: scan
--

CREATE FUNCTION preencher_valores(vp_mes_referencia character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

  vl_valor numeric := 0;
  vl_data_inicial date := to_date('01/' || vp_mes_referencia, 'dd/mm/yyyy'); -- formato do mes de referencia (MM/YYYY)
  vl_data_final date := vl_data_inicial + INTERVAL'1 month';
begin
  -- 1. SAQUE EXTRA - INICIO
  select sum(opr.vl_opr) into vl_valor
  from sc_fcr.tbl_fcr fcr
	inner join sc_fcr.tbl_prc prc on prc.cd_fcr = fcr.cd_fcr
	inner join sc_opr.tbl_opr opr on prc.cd_opr = opr.cd_opr
  where opr.cd_top = 5 -- saque extra
    and opr.st_opr = 2 -- confirmada
    and fcr.st_fcr in (1,2) -- aberta e fechada
    and fcr.dt_vnc_fcr >= vl_data_inicial
    and fcr.dt_vnc_fcr < vl_data_final;
    
  INSERT INTO sc_meta.tbl_2015(codigo, mes_referencia, tipo, valor, ativo)
    VALUES (nextval('sc_meta.sq_2015'), vl_data_final, 1, vl_valor, 'S');
  -- 1. SAQUE EXTRA - FIM
  
  -- 2. CARTÕES ATIVOS - INICIO
  select count(*) 
    INTO vl_valor
  from sc_opr.tbl_crt crt 
  where crt.fg_atv_crt = 'S';
  
  INSERT INTO sc_meta.tbl_2015(codigo, mes_referencia, tipo, valor, ativo)
    VALUES (nextval('sc_meta.sq_2015'), vl_data_final, 2, vl_valor, 'S');
  -- 2. CARTÕES ATIVOS - FIM

  -- 3. INADIMPLENCIA - INICIO
  select (sum(vl_pcp_ind)/sum(vl_pcp_ttl_opr))*100 
    INTO vl_valor
  from sc_ind.tbl_ind ind
  where ind.mes_ref = vp_mes_referencia;

  INSERT INTO sc_meta.tbl_2015(codigo, mes_referencia, tipo, valor, ativo)
    VALUES (nextval('sc_meta.sq_2015'), vl_data_final, 3, vl_valor, 'S');
  -- 3. INADIMPLENCIA - FIM
end;$$;


ALTER FUNCTION sc_meta.preencher_valores(vp_mes_referencia character varying) OWNER TO scan;

--
-- TOC entry 7825 (class 0 OID 0)
-- Dependencies: 1378
-- Name: FUNCTION preencher_valores(vp_mes_referencia character varying); Type: COMMENT; Schema: sc_meta; Owner: scan
--

COMMENT ON FUNCTION preencher_valores(vp_mes_referencia character varying) IS 'rotina que preenche os valores na tabela de referencia';


SET search_path = sc_mgr, pg_catalog;

--
-- TOC entry 1379 (class 1255 OID 564435)
-- Name: ativar_cartoes_sem_deposito(); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION ativar_cartoes_sem_deposito() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin



  for rg in select crt.cd_crt
            from sc_opr.tbl_crt crt
              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
              inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
            where not exists(select 1 
                             from sc_adp.tbl_hfe hfe
                             where hfe.cd_ctr = crt.cd_ctr
                               and hfe.st_hfe = 5
                               and hfe.cd_tdp = 1
                            )
              and crt.fg_atv_crt = 'N'
              and ctr.fg_atv_ctr = 'S'
              and fnc.st_fnc = 1 loop


        perform sc_opr.ativar_cartao(rg.cd_crt,1,'CARTOES DE EMPRESAS QUE AINDA NAO FORAM MIGRADAS DA SAQCARD E QUE OS CARTOES FORAM INATIVADOS POR FALTA DE DEPOSITO');      

      
              
   end loop;                               
                               
   
end$$;


ALTER FUNCTION sc_mgr.ativar_cartoes_sem_deposito() OWNER TO scan;

--
-- TOC entry 1380 (class 1255 OID 564436)
-- Name: atualizar_divida(); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION atualizar_divida() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin

    perform sc_mgr.atualizar_divida_fatura();
    perform sc_mgr.atualizar_divida_tarifas();


end$$;


ALTER FUNCTION sc_mgr.atualizar_divida() OWNER TO scan;

--
-- TOC entry 1506 (class 1255 OID 564437)
-- Name: atualizar_divida_fatura(numeric); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION atualizar_divida_fatura(vp_fatura numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  CT_SITUACAO_PAGA numeric := 2;
  CT_SITUACAO_FINALIZADA numeric := 4;
  
  VL_TIPO_DIVIDA_FATURA numeric := 1; 
  rg record;

  vl_sql varchar;
  vl_where varchar := '';
begin

     -- ADICIONANDO NOVAS DIVIDAS  

     vl_sql := 'select fcr.cd_fcr,
		  fcr.dt_vnc_fcr,
		  fcr.vl_sld_dvd_fcr,
		  cun.nr_cpf_cnpj_cun,
		  fcr.cd_crt,
		  fcr.nr_dia_atr_fcr nr_dia_atraso
	   from   sc_opr.tbl_crt crt
	     inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
	     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	     inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun';

     if vp_fatura is not null then

       vl_where := ' where fcr.cd_fcr = ' || vp_fatura;

     end if;

     vl_sql := vl_sql || vl_where;
     
     insert into sc_mgr.tbl_dvd(cd_dvd,tp_dvd,nr_nsu_dvd,dt_dvd,crt_sc_dvd,nr_cpf_dvd,dt_atu_dvd,vl_dvd,st_dvd,nr_dia_atr_crt_dvd,vl_org_dvd)
		      (select nextval('sc_mgr.sq_dvd'),
			       1,
			       fcr.cd_fcr,
			       fcr.dt_vnc_fcr,
			       fcr.cd_crt,
			       fcr.nr_cpf_cnpj_cun,
			       now(),
			       fcr.vl_sld_dvd_fcr,
			       1,
			       nr_dia_atr_crt,
			       fcr.vl_sld_dvd_fcr
			from (select *
			      from  dblink('dbname=sca host=192.168.1.6 user=sca password=sca',vl_sql) as fcr(cd_fcr numeric, dt_vnc_fcr timestamp, vl_sld_dvd_fcr numeric,nr_cpf_cnpj_cun numeric, cd_crt numeric,nr_dia_atr_crt numeric)
			     ) as fcr
			 where not exists(select 1 
					  from sc_mgr.tbl_dvd dvd 
					  where dvd.nr_nsu_dvd = fcr.cd_fcr
					    and dvd.tp_dvd = VL_TIPO_DIVIDA_FATURA));
    -- FIM - ADICIONAR NOVAS DIVIDAS

    --ATUALIZANDO DIVIDAS
	vl_sql := 'select fcr.cd_fcr,
			  fcr.dt_vnc_fcr,
			  case when fcr.st_fcr = 4 then 0 else fcr.vl_sld_dvd_fcr end vl_sld_dvd_fcr,
			  cun.nr_cpf_cnpj_cun,
			  fcr.cd_crt
		   from sc_opr.tbl_crt crt
		     inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
		     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
		     inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun';

    vl_sql := vl_sql || vl_where;
     
    for rg in select dvd.cd_dvd,
                     fcr.cd_fcr,
                     fcr.dt_vnc_fcr,
                     fcr.cd_crt,
                     fcr.nr_cpf_cnpj_cun,
                     fcr.vl_sld_dvd_fcr
              from (select *
		    from  dblink('dbname=sca host=192.168.1.6 user=sca password=sca', vl_sql) as 
		                     fcr(cd_fcr numeric, dt_vnc_fcr timestamp, vl_sld_dvd_fcr numeric,nr_cpf_cnpj_cun numeric, cd_crt numeric)
	          ) as fcr
	         inner join sc_mgr.tbl_dvd dvd on dvd.nr_nsu_dvd = fcr.cd_fcr
	       where (dvd.vl_dvd - coalesce(dvd.vl_pg_dvd,0)) > fcr.vl_sld_dvd_fcr
	          and dvd.tp_dvd = VL_TIPO_DIVIDA_FATURA 
	          and dvd.st_dvd <> CT_SITUACAO_PAGA loop
	          
	 update sc_mgr.tbl_dvd
          set vl_dvd = rg.vl_sld_dvd_fcr + coalesce(vl_pg_dvd,0),
              dt_atu_dvd = now()
          where cd_dvd = rg.cd_dvd;
	          
   end loop;	   

   -- FINALIZANDO DIVIDAS
   for rg in select max(nr_nsu_dvd) nr_nsu_dvd,
                    crt_sc_dvd,
                    count(*)
             from sc_mgr.tbl_dvd
             where tp_dvd = VL_TIPO_DIVIDA_FATURA
               and st_dvd not in(CT_SITUACAO_PAGA,CT_SITUACAO_FINALIZADA)
             group by crt_sc_dvd 
             having count(*) > 1 loop

           update sc_mgr.tbl_dvd 
             set st_dvd = CT_SITUACAO_FINALIZADA 
           where tp_dvd = VL_TIPO_DIVIDA_FATURA 
             and st_dvd <> CT_SITUACAO_PAGA
             and crt_sc_dvd = rg.crt_sc_dvd
             and nr_nsu_dvd < rg.nr_nsu_dvd;
             
   end loop;          
end$$;


ALTER FUNCTION sc_mgr.atualizar_divida_fatura(vp_fatura numeric) OWNER TO scan;

--
-- TOC entry 1382 (class 1255 OID 564438)
-- Name: atualizar_divida_fatura_OLD(); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION "atualizar_divida_fatura_OLD"() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  CT_SITUACAO_PAGA numeric := 2;
  CT_SITUACAO_FINALIZADA numeric := 4;
  
  VL_TIPO_DIVIDA_FATURA numeric := 1; 
  rg record;
begin

    -- ADICIONANDO NOVAS DIVIDAS  
     insert into sc_mgr.tbl_dvd(cd_dvd,tp_dvd,nr_nsu_dvd,dt_dvd,crt_sc_dvd,nr_cpf_dvd,dt_atu_dvd,vl_dvd,st_dvd,nr_dia_atr_crt_dvd,vl_org_dvd)
		      (select nextval('sc_mgr.sq_dvd'),
			       1,
			       fcr.cd_fcr,
			       fcr.dt_vnc_fcr,
			       fcr.cd_crt,
			       fcr.nr_cpf_cnpj_cun,
			       now(),
			       fcr.vl_sld_dvd_fcr,
			       1,
			       nr_dia_atr_crt,
			       fcr.vl_sld_dvd_fcr
			from (select *
			      from  dblink('dbname=sca host=10.255.100.5 user=sca password=sca',
					  'select fcr.cd_fcr,
						  fcr.dt_vnc_fcr,
						  fcr.vl_sld_dvd_fcr,
						  cun.nr_cpf_cnpj_cun,
						  fcr.cd_crt,
				                  fcr.nr_dia_atr_fcr nr_dia_atraso
					   from sc_opr.tbl_crt crt
					     inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
					     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
					     inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun') as fcr(cd_fcr numeric, dt_vnc_fcr timestamp, vl_sld_dvd_fcr numeric,nr_cpf_cnpj_cun numeric, cd_crt numeric,nr_dia_atr_crt numeric)
			     ) as fcr
			 where not exists(select 1 
					  from sc_mgr.tbl_dvd dvd 
					  where dvd.nr_nsu_dvd = fcr.cd_fcr
					    and dvd.tp_dvd = VL_TIPO_DIVIDA_FATURA));
    -- FIM - ADICIONAR NOVAS DIVIDAS

    --ATUALIZANDO DIVIDAS
    for rg in select dvd.cd_dvd,
                     fcr.cd_fcr,
                     fcr.dt_vnc_fcr,
                     fcr.cd_crt,
                     fcr.nr_cpf_cnpj_cun,
                     fcr.vl_sld_dvd_fcr
              from (select *
		    from  dblink('dbname=sca host=10.255.100.5 user=sca password=sca',
				  'select fcr.cd_fcr,
				          fcr.dt_vnc_fcr,
				          case when fcr.st_fcr = 4 then 0 else fcr.vl_sld_dvd_fcr end vl_sld_dvd_fcr,
				          cun.nr_cpf_cnpj_cun,
				          fcr.cd_crt
				   from sc_opr.tbl_crt crt
				     inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
				     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
				     inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun') as 
		                     fcr(cd_fcr numeric, dt_vnc_fcr timestamp, vl_sld_dvd_fcr numeric,nr_cpf_cnpj_cun numeric, cd_crt numeric)
	          ) as fcr
	         inner join sc_mgr.tbl_dvd dvd on dvd.nr_nsu_dvd = fcr.cd_fcr
	       where (dvd.vl_dvd - coalesce(dvd.vl_pg_dvd,0)) > fcr.vl_sld_dvd_fcr
	          and dvd.tp_dvd = VL_TIPO_DIVIDA_FATURA 
	          and dvd.st_dvd <> CT_SITUACAO_PAGA loop
	          
	 update sc_mgr.tbl_dvd
          set vl_dvd = rg.vl_sld_dvd_fcr + coalesce(vl_pg_dvd,0),
              dt_atu_dvd = now()
          where cd_dvd = rg.cd_dvd;
	          
   end loop;	   

   -- FINALIZANDO DIVIDAS
   for rg in select max(nr_nsu_dvd) nr_nsu_dvd,
                    crt_sc_dvd,
                    count(*)
             from sc_mgr.tbl_dvd
             where tp_dvd = VL_TIPO_DIVIDA_FATURA
               and st_dvd not in(CT_SITUACAO_PAGA,CT_SITUACAO_FINALIZADA)
             group by crt_sc_dvd 
             having count(*) > 1 loop

           update sc_mgr.tbl_dvd 
             set st_dvd = CT_SITUACAO_FINALIZADA 
           where tp_dvd = VL_TIPO_DIVIDA_FATURA 
             and st_dvd <> CT_SITUACAO_PAGA
             and crt_sc_dvd = rg.crt_sc_dvd
             and nr_nsu_dvd < rg.nr_nsu_dvd;
             
   end loop;          
end$$;


ALTER FUNCTION sc_mgr."atualizar_divida_fatura_OLD"() OWNER TO scan;

--
-- TOC entry 1358 (class 1255 OID 564439)
-- Name: atualizar_divida_tarifas(); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION atualizar_divida_tarifas() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  VL_TIPO_DIVIDA_TARIFA numeric := 2; 
  VL_SITUACAO_CADASTRADA numeric := 1;
  VL_SITUACAO_PAGA numeric := 2;
  

begin

	--ADICIONANDO NOVAS DIVIDAS
	insert into sc_mgr.tbl_dvd(cd_dvd,tp_dvd,nr_nsu_dvd,dt_dvd,crt_sc_dvd,nr_cpf_dvd,dt_atu_dvd,vl_dvd)
		      (select nextval('sc_mgr.sq_dvd'),
			       2,
			       tsc.cd_tsc,
			       tsc.dt_vnc_tsc,
			       tsc.cd_crt,
			       tsc.nr_cpf_cnpj_cun,
			       now(),
			       tsc.vl_tsc
			from (select *
			      from  dblink('dbname=sca host=192.168.1.6 user=sca password=sca',
					  'select tsc.cd_tsc,
					          tsc.dt_vnc_tsc,
					          tsc.cd_crt,
					          tsc.vl_tsc,
					          cun.nr_cpf_cnpj_cun
					   from sc_srv.tbl_tsc tsc
					     inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
					     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
					     inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
					   where cd_srv=6
					     and st_tsc = 1
					  ') as tsc(cd_tsc numeric, dt_vnc_tsc timestamp, cd_crt numeric, vl_tsc numeric, nr_cpf_cnpj_cun numeric)
			     ) as tsc
			 where not exists(select 1 
					  from sc_mgr.tbl_dvd dvd 
					  where dvd.tp_dvd = 2
					    and dvd.nr_nsu_dvd = tsc.cd_tsc));
	-- FIM ADICIONANDO DIVIDAS


	for rg in   select *
		    from  dblink('dbname=sca host=192.168.1.6 user=sca password=sca',
				  'select tsc.cd_tsc,
					  tsc.dt_vnc_tsc,
					  tsc.cd_crt,
					  tsc.vl_tsc,
					  cun.nr_cpf_cnpj_cun
				   from sc_srv.tbl_tsc tsc
				     inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
				     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
				     inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
				   where cd_srv = 6
				     and tsc.st_tsc <> 1 --cadastrada
				  ') as tsc(cd_tsc numeric, dt_vnc_tsc timestamp, cd_crt numeric, vl_tsc numeric, nr_cpf_cnpj_cun numeric)
			   inner join sc_mgr.tbl_dvd dvd on dvd.nr_nsu_dvd = tsc.cd_tsc
		    where dvd.tp_dvd = VL_TIPO_DIVIDA_TARIFA
		      and dvd.st_dvd = VL_SITUACAO_CADASTRADA loop
				
		update sc_mgr.tbl_dvd set st_dvd = VL_SITUACAO_PAGA where cd_dvd = rg.cd_dvd;
				
	end loop;
			


					    
end$$;


ALTER FUNCTION sc_mgr.atualizar_divida_tarifas() OWNER TO scan;

--
-- TOC entry 1602 (class 1255 OID 564440)
-- Name: cancelar_pagamento_divida(numeric, character varying); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION cancelar_pagamento_divida(vp_codigo_pagamento numeric, vp_estorna_pgt_saqcard character varying DEFAULT 'S'::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  VL_TIPO_LANCAMENTO sc_cnt.tbl_tlc.cd_tlc%type := 1155;
  VL_CONTA_A_REPASSAR_SAQCARD numeric := 36;
  vl_conta_credito numeric;
  vl_pagamento numeric;
  vl_codigo_divida numeric;

begin

    select cd_cnt,
           vl_pdv,
           cd_dvd
    into vl_conta_credito,
         vl_pagamento,
         vl_codigo_divida
    from sc_mgr.tbl_pdv
    where cd_pdv = vp_codigo_pagamento;


    perform sc_cnt.lancar_debito_credito(VL_CONTA_A_REPASSAR_SAQCARD,vl_conta_credito,VL_TIPO_LANCAMENTO,null,('REF ESTORNO DE CAPTURA DE DIVIDA NA SAQCARD.')::varchar,vl_pagamento,now()::timestamp,1,5,vp_codigo_pagamento);

    update sc_mgr.tbl_pdv set st_pdv = 3, dt_cnc_pdv = now() where cd_pdv = vp_codigo_pagamento;

    update sc_mgr.tbl_dvd set vl_pg_dvd = coalesce(vl_pg_dvd,0) - vl_pagamento,st_dvd=3 where cd_dvd = vl_codigo_divida; 


    perform sc_mgr.processar_cancelamentos_saqcard(vp_estorna_pgt_saqcard);

   
end$$;


ALTER FUNCTION sc_mgr.cancelar_pagamento_divida(vp_codigo_pagamento numeric, vp_estorna_pgt_saqcard character varying) OWNER TO scan;

--
-- TOC entry 1362 (class 1255 OID 564441)
-- Name: efetuar_baixa_saqcard(); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION efetuar_baixa_saqcard() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
rg record;
begin

   for rg in select crt.cd_crt
             from sc_opr.tbl_crt crt 
                inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
                inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
                inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
             where cnt.vl_sld_cnt > 0   
               and exists(select 1
                          from sc_mgr.tbl_dvd d
                          where d.nr_cpf_dvd = cun.nr_cpf_cnpj_cun
                            and d.st_dvd <> 2) loop

         perform sc_mgr.efetuar_baixa_saqcard(rg.cd_crt);                   
   end loop;                         
             
             

end$$;


ALTER FUNCTION sc_mgr.efetuar_baixa_saqcard() OWNER TO scan;

--
-- TOC entry 1383 (class 1255 OID 564442)
-- Name: efetuar_baixa_saqcard(numeric); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION efetuar_baixa_saqcard(vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   VL_CONTA_A_REPASSAR_SAQCARD numeric := 36;
   VL_TIPO_LANCAMENTO numeric := 1022;

   VL_SITUACAO_DIVIDA_CADASTRADA numeric := 1;
   VL_SITUACAO_DIVIDA_PAGA numeric := 2;
   VL_SITUACAO_DIVIDA_PAGA_PARCIAL numeric := 3;

   VL_SITUACAO_PAGAMENTO_CADASTRADA numeric := 1;

   VL_QUANTIDADE_DIAS numeric := 60;
   VL_PERCENTUAL_DESCONTO numeric := 30;

   vl_eh_pagamento_total varchar;
   vl_saldo_restante numeric := 0;
   vl_desconto numeric := 0;
   vl_conta_debito numeric;


   rg record;
   
begin

   vl_saldo_restante := sc_cnt.get_saldo_cartao(vp_cartao,'S','S');

   vl_desconto := 0;

   -- CAPTURANDO DIVIDA MENOR QUE 60 DIAS
   if vl_saldo_restante > 0 then

       	 select cnt_crt.cd_cnt
	 into vl_conta_debito
	 from sc_opr.tbl_cnt_crt cnt_crt
	 where cnt_crt.cd_crt = vp_cartao
	   and cnt_crt.fg_pdr_cnt_crt = 'S';


       for rg in select (dvd.vl_dvd - coalesce(dvd.vl_pg_dvd,0)) valor_a_pagar,
                        dvd.cd_dvd,
                        dvd.crt_sc_dvd
                 from sc_mgr.tbl_dvd dvd
                    inner join sc_cad.tbl_cun cun on cun.nr_cpf_cnpj_cun = dvd.nr_cpf_dvd
                    inner join sc_cad.tbl_fnc fnc on fnc.cd_cun = cun.cd_cun
                    inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
                 where crt.cd_crt = vp_cartao
                   and dvd.st_dvd in( VL_SITUACAO_DIVIDA_CADASTRADA, VL_SITUACAO_DIVIDA_PAGA_PARCIAL)
                   and coalesce(dvd.nr_dia_atr_crt_dvd,0) < VL_QUANTIDADE_DIAS
                 order by dvd.dt_dvd loop

           if RG.valor_a_pagar > 0 then 

		   vl_desconto := rg.valor_a_pagar;

		   if(vl_saldo_restante >= rg.valor_a_pagar) then
		     vl_desconto := rg.valor_a_pagar;
		     vl_eh_pagamento_total := 'S';
		   else
		     vl_desconto := vl_saldo_restante;
		     vl_eh_pagamento_total := 'N';
		   end if;

		   insert into sc_mgr.tbl_pdv(cd_pdv,cd_dvd,vl_pdv,dt_pdv,st_pdv,cd_cnt) values(nextval('sc_mgr.sq_pdv'),rg.cd_dvd,vl_desconto,now(),VL_SITUACAO_PAGAMENTO_CADASTRADA,vl_conta_debito);

		   if(vl_eh_pagamento_total = 'S') then
		   
		      update sc_mgr.tbl_dvd
		      set st_dvd = VL_SITUACAO_DIVIDA_PAGA,
			  vl_pg_dvd = coalesce(vl_pg_dvd,0) + vl_desconto              
		      where cd_dvd = rg.cd_dvd;
		      
		   else
		   
		      update sc_mgr.tbl_dvd
		      set st_dvd = VL_SITUACAO_DIVIDA_PAGA_PARCIAL,
			  vl_pg_dvd = coalesce(vl_pg_dvd,0) + vl_desconto 
		      where cd_dvd = rg.cd_dvd;
		   
		   end if;   
		   
		   vl_saldo_restante := vl_saldo_restante - vl_desconto;

		   perform sc_cnt.lancar_debito_credito(vl_conta_debito,VL_CONTA_A_REPASSAR_SAQCARD,VL_TIPO_LANCAMENTO,null,('REF A DIVIDA ATIVA NA SAQCARD CARTAO '||rg.crt_sc_dvd)::varchar,vl_desconto,now()::timestamp,1,5,rg.cd_dvd);
		   
		   if(vl_saldo_restante = 0) then
		      return;
		   end if;

		   perform sc_mgr.restitui_limite_saqcard(currval('sc_mgr.sq_pdv'));

           end if;      


       end loop;     
   
   end if;
end$$;


ALTER FUNCTION sc_mgr.efetuar_baixa_saqcard(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1589 (class 1255 OID 564443)
-- Name: efetuar_baixa_saqcard_divida_antiga(numeric); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION efetuar_baixa_saqcard_divida_antiga(vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   VL_CONTA_A_REPASSAR_SAQCARD numeric := 36;
   VL_TIPO_LANCAMENTO numeric := 1022;

   VL_SITUACAO_DIVIDA_CADASTRADA numeric := 1;
   VL_SITUACAO_DIVIDA_PAGA numeric := 2;
   VL_SITUACAO_DIVIDA_PAGA_PARCIAL numeric := 3;

   VL_SITUACAO_PAGAMENTO_CADASTRADA numeric := 1;

   VL_QUANTIDADE_DIAS numeric := 60;
   VL_PERCENTUAL_DESCONTO numeric := 30;

   vl_eh_pagamento_total varchar;
   vl_saldo_restante numeric := 0;
   vl_desconto numeric := 0;
   vl_conta_debito numeric;


   rg record;
   
begin

   vl_saldo_restante := sc_cnt.get_saldo_cartao(vp_cartao,'S','S');

   vl_desconto := 0;

   -- INSERIDO CODIGO CHAMADO 2657 
   if vp_cartao = 62015554674542 then
      VL_PERCENTUAL_DESCONTO := 50;
   end if;
   -- FIM CHAMADO 2657 

   -- INSERIDO CODIGO CHAMADO 4895 
   if vp_cartao = 60586814085395 then
      VL_PERCENTUAL_DESCONTO := 60;
   end if;
   -- FIM CHAMADO 4895

       -- CAPTURANDO DIVIDA MAIOR QUE 60 DIAS
       if(vl_saldo_restante > 0) then
       
                select cnt_crt.cd_cnt
		 into vl_conta_debito
		 from sc_opr.tbl_cnt_crt cnt_crt
		 where cnt_crt.cd_crt = vp_cartao
		   and cnt_crt.fg_pdr_cnt_crt = 'S';

               vl_saldo_restante := coalesce(vl_saldo_restante,0) * (VL_PERCENTUAL_DESCONTO/100);
       
	       for rg in select (dvd.vl_dvd - coalesce(dvd.vl_pg_dvd,0)) valor_a_pagar,
				dvd.cd_dvd,
				dvd.crt_sc_dvd
			 from sc_mgr.tbl_dvd dvd
			    inner join sc_cad.tbl_cun cun on cun.nr_cpf_cnpj_cun = dvd.nr_cpf_dvd
			    inner join sc_cad.tbl_fnc fnc on fnc.cd_cun = cun.cd_cun
			    inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
			 where crt.cd_crt = vp_cartao
			   and dvd.st_dvd in( VL_SITUACAO_DIVIDA_CADASTRADA, VL_SITUACAO_DIVIDA_PAGA_PARCIAL)
			   and coalesce(dvd.nr_dia_atr_crt_dvd,0) >= VL_QUANTIDADE_DIAS
			 order by dvd.dt_dvd loop

		   vl_desconto := rg.valor_a_pagar;

		   if(vl_saldo_restante >= rg.valor_a_pagar) then
		     vl_desconto := rg.valor_a_pagar;
		     vl_eh_pagamento_total := 'S';
		   else
		     vl_desconto := vl_saldo_restante;
		     vl_eh_pagamento_total := 'N';
		   end if;

		   insert into sc_mgr.tbl_pdv(cd_pdv,cd_dvd,vl_pdv,dt_pdv,st_pdv,cd_cnt) values(nextval('sc_mgr.sq_pdv'),rg.cd_dvd,vl_desconto,now(),VL_SITUACAO_PAGAMENTO_CADASTRADA,vl_conta_debito);

		   if(vl_eh_pagamento_total = 'S') then
		   
		      update sc_mgr.tbl_dvd
		      set st_dvd = VL_SITUACAO_DIVIDA_PAGA,
			  vl_pg_dvd = coalesce(vl_pg_dvd,0) + vl_desconto              
		      where cd_dvd = rg.cd_dvd;
		      
		   else
		   
		      update sc_mgr.tbl_dvd
		      set st_dvd = VL_SITUACAO_DIVIDA_PAGA_PARCIAL,
			  vl_pg_dvd = coalesce(vl_pg_dvd,0) + vl_desconto 
		      where cd_dvd = rg.cd_dvd;
		   
		   end if;   
		   
		   vl_saldo_restante := vl_saldo_restante - vl_desconto;

		   perform sc_cnt.lancar_debito_credito(vl_conta_debito,VL_CONTA_A_REPASSAR_SAQCARD,VL_TIPO_LANCAMENTO,null,('REF A DIVIDA ATIVA NA SAQCARD CARTAO '||rg.crt_sc_dvd)::varchar,vl_desconto,now()::timestamp,1,5,rg.cd_dvd);
		   
		   if(vl_saldo_restante = 0) then
		      return;
		   end if;

		   perform sc_mgr.restitui_limite_saqcard(currval('sc_mgr.sq_pdv'));

	       end loop;     
       end if;
   
end$$;


ALTER FUNCTION sc_mgr.efetuar_baixa_saqcard_divida_antiga(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1384 (class 1255 OID 564444)
-- Name: insere_novos_cartoes(); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION insere_novos_cartoes() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin
end$$;


ALTER FUNCTION sc_mgr.insere_novos_cartoes() OWNER TO scan;

--
-- TOC entry 1504 (class 1255 OID 564445)
-- Name: processar_cancelamentos_saqcard(character varying); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION processar_cancelamentos_saqcard(vp_estorna_pgt_saqcard character varying DEFAULT 'S'::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   SITUACAO_PAGAMENTO_CANCELADO sc_mgr.tbl_pdv.st_pdv%type := 3;
   vl_codigo_pagamento_saqcard numeric;
   vl_codigo_conta numeric;
   rg record;

begin



   for rg in select pdv.vl_pdv,
                    dvd.crt_sc_dvd cd_crt,
                    pdv.cd_pdv
	     from sc_mgr.tbl_pdv pdv
	        inner join sc_mgr.tbl_dvd dvd on dvd.cd_dvd = pdv.cd_dvd
	     where pdv.st_pdv = SITUACAO_PAGAMENTO_CANCELADO
	       and pdv.dt_prc_cnc_pdv is null loop


            if(vp_estorna_pgt_saqcard = 'S') then
              		
	      select pfc.cd_pfc,pfc.cd_cnt
	      into vl_codigo_pagamento_saqcard, vl_codigo_conta
	      from  dblink('dbname=sca host=192.168.1.6 user=sca password=sca',
			   'select pfc.cd_pfc, cnt.cd_cnt
		            from sc_fcr.tbl_pfc pfc
			      inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = pfc.cd_fcr
			      inner join sc_opr.tbl_crt crt on crt.cd_fcr = fcr.cd_fcr
			      inner join sc_opr.tbl_cnt_crt cnt on cnt.cd_crt = crt.cd_crt
		            where crt.cd_crt ='||rg.cd_crt||'
		              and pfc.vl_pfc ='||rg.vl_pdv||'
		              and pfc.st_pfc = 1') as pfc(cd_pfc numeric, cd_cnt numeric);

	      
	      
		      if(vl_codigo_pagamento_saqcard is null) then
			 raise exception 'Não encontrado pagamento com o mesmo valor a ser cancelado na Saqcard';
		      end if;
		      
	      else
	      
		  select cnt.cd_cnt
		  into  vl_codigo_conta
		  from  dblink('dbname=sca host=192.168.1.6 user=sca password=sca',
			   'select cnt.cd_cnt
		            from sc_opr.tbl_cnt_crt cnt
		            where cnt.cd_crt ='||rg.cd_crt) as cnt(cd_cnt numeric);
	          	      
	      end if;	


              update sc_mgr.tbl_pdv set dt_prc_cnc_pdv = now() where cd_pdv = rg.cd_pdv;

              if(vp_estorna_pgt_saqcard = 'S') then 
              
		      perform * from dblink('dbname=sca host=192.168.1.6 user=sca password=sca',
						   'select sc_fcr.estorno_pagamento('||vl_codigo_pagamento_saqcard||',1)') as x (x text);              
						   
              end if;						   

              perform * from dblink('dbname=sca host=192.168.1.6 user=sca password=sca',
                                    'select sc_cnt.lancar_debito_credito('||vl_codigo_conta||',129563,1111,null,''REF A ESTORNO DE BAIXA DE DIVIDA CAPTURADA NA SOMA''::varchar,'||rg.vl_pdv||',now()::timestamp,1,5,'||rg.cd_pdv||')') as x (x text);
              			   
	      

	       
   end loop;	       

end$$;


ALTER FUNCTION sc_mgr.processar_cancelamentos_saqcard(vp_estorna_pgt_saqcard character varying) OWNER TO scan;

--
-- TOC entry 1385 (class 1255 OID 564446)
-- Name: restitui_limite_saqcard(numeric); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION restitui_limite_saqcard(vp_cod_pagamento numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
    vl_pagamento numeric;
    vl_limite_utilizado numeric;
    vl_a_restituir numeric;
    vl_codigo_cartao numeric;
begin

   select pdv.vl_pdv,
          lmt.vl_utl_lmt,
          lmt.cd_crt
   into vl_pagamento,
        vl_limite_utilizado,
        vl_codigo_cartao       
   from sc_mgr.tbl_pdv pdv
      inner join sc_mgr.tbl_dvd dvd on dvd.cd_dvd = pdv.cd_dvd
      inner join sc_mgr.tbl_lmt lmt on lmt.cd_crt_sc_lmt = dvd.crt_sc_dvd
   where pdv.cd_pdv = vp_cod_pagamento
     and dvd.tp_dvd = 1;


   if coalesce(vl_limite_utilizado,0) > 0 then

      if vl_limite_utilizado >= vl_pagamento then
         vl_a_restituir := vl_pagamento;
      else
         vl_a_restituir := vl_limite_utilizado;
      end if;

      update sc_mgr.tbl_lmt set vl_utl_lmt = coalesce(vl_utl_lmt,0) - vl_a_restituir where cd_crt = vl_codigo_cartao; -- Restituindo limite Saqcard
      
      update sc_opr.tbl_lmt set vl_utl_lmt = coalesce(vl_utl_lmt,0) - vl_a_restituir where cd_crt = vl_codigo_cartao; -- Restituindo limite Saqpag

      update sc_mgr.tbl_pdv set vl_rst_lmt_pdv = coalesce(vl_rst_lmt_pdv,0) + vl_a_restituir where cd_pdv = vp_cod_pagamento;
   
   end if;
   
end$$;


ALTER FUNCTION sc_mgr.restitui_limite_saqcard(vp_cod_pagamento numeric) OWNER TO scan;

--
-- TOC entry 1503 (class 1255 OID 564447)
-- Name: sincroniza_limite_saqcard(numeric, numeric, character); Type: FUNCTION; Schema: sc_mgr; Owner: scan
--

CREATE FUNCTION sincroniza_limite_saqcard(vp_empresa numeric DEFAULT NULL::numeric, vp_cartao numeric DEFAULT NULL::numeric, vp_atualiza_concedido character DEFAULT 'N'::bpchar) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  rg record;
  rg_saqcard record;
  
  vl_cartao_saqcard numeric;
  vl_limite_conc_saqcard numeric;
  vl_limite_util_saqcard numeric;

  vl_cartao_saqcard_old numeric;
  vl_limite_conc_saqcard_old numeric;
  vl_limite_util_saqcard_old numeric;

  vl_limite_util_atual numeric;

  vl_qtd_cartao_limite numeric;
  
begin

	for rg in select *
		  from sc_opr.tbl_crt crt
		     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
		     inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
		     inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
		     inner join sc_cad.tbl_fem_ctr fctr on fctr.cd_ctr = ctr.cd_ctr and fctr.cd_emp = fnc.cd_emp and fctr.cd_fem = fnc.cd_fem
		     inner join sc_cad.tbl_tlt_ctr tlt on tlt.cd_fem_ctr = fctr.cd_fem_ctr
		     inner join sc_opr.tbl_lmt lmt on lmt.cd_crt = crt.cd_crt
		  where tlt.pr_lmt > 0
		    and (coalesce(crt.dt_pri_dps_crt::date,now()::date) - coalesce(crt.dt_ult_dps_crt::date,now()::date)) < 90 
		    and lmt.cd_tlt = 1
		    and tlt.cd_tlt = 1
		    and (crt.cd_crt = vp_cartao or vp_cartao is null)
		    and (fnc.cd_emp = vp_empresa or vp_empresa is null)
		    and fctr.fg_atv_fem_ctr = 'S'
		  order by crt.dt_inc_usr loop

		    vl_cartao_saqcard := null;


		   for rg_saqcard in select *
				     from  dblink('dbname=sca host=192.168.1.6 user=sca password=sca',
						 'select crt.cd_crt,
						         dt_ult_dps_crt,
						         lmt.vl_cnc_lmt,
						         lmt.vl_utl_lmt,
						         sc_opr.autoriza_tipo_operacao_cartao(crt.cd_crt,5)
						  from sc_opr.tbl_crt crt
						    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
						    inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
						    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
						    inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
						    inner join sc_cad.tbl_tlt_ctr tlt on tlt.cd_ctr = ctr.cd_ctr
						    inner join sc_opr.tbl_lmt lmt on lmt.cd_crt = crt.cd_crt
						  where cun.nr_cpf_cnpj_cun =' || rg.nr_cpf_cnpj_cun || '
						    and emp.cd_emp_new = ' || rg.cd_emp || '
						    and ctr.fg_atv_ctr = ''N''
						    and tlt.cd_tlt = 1
						    and lmt.cd_tlt = 1
						  order by crt.dt_ult_dps_crt desc  
						  ') as crt(cd_crt numeric, dt_ult_dps_crt date,vl_cnc_lmt numeric,vl_utl_lmt numeric,autorizado boolean) loop

	             vl_cartao_saqcard := rg_saqcard.cd_crt;
	             
	             if rg_saqcard.autorizado then
			vl_limite_conc_saqcard := rg_saqcard.vl_cnc_lmt;
		     else
		     	vl_limite_conc_saqcard := 0;
		     end if;
		     
	             vl_limite_util_saqcard := rg_saqcard.vl_utl_lmt;
	             exit;
	             
                  end loop;

                  if vl_cartao_saqcard is not null then

                        --
                  
			select vl_cnc_lmt,vl_utl_lmt,cd_crt_sc_lmt
			into vl_limite_conc_saqcard_old, vl_limite_util_saqcard_old, vl_cartao_saqcard_old
			from sc_mgr.tbl_lmt
			where cd_crt = rg.cd_crt;

			if vl_cartao_saqcard_old is not null then -- SE É UMA ATUALIZACAO (NAO EXISTE AINDA REGISTRO)

			    if vl_cartao_saqcard_old = vl_cartao_saqcard then

			       if vl_limite_util_saqcard < vl_limite_util_saqcard_old then -- se o valor utilizado na saqcard diminuiu

			          select vl_utl_lmt
			          into vl_limite_util_atual
			          from sc_opr.tbl_lmt
			          where cd_crt = rg.cd_crt
			            and cd_tlt = 1;

			          vl_limite_util_atual := vl_limite_util_atual - (vl_limite_util_saqcard_old - vl_limite_util_saqcard);

			          if vl_limite_util_atual >= 0 then
			             update sc_opr.tbl_lmt 
			             set vl_utl_lmt = vl_limite_util_atual 
			             where cd_crt = rg.cd_crt 
			               and cd_tlt = 1;

			             update sc_mgr.tbl_lmt set vl_utl_lmt = vl_limite_util_saqcard where cd_crt = rg.cd_crt;
			               
			          end if;


                               elsif vl_limite_util_saqcard > vl_limite_util_saqcard_old then

                                  select vl_utl_lmt
			          into vl_limite_util_atual
			          from sc_opr.tbl_lmt
			          where cd_crt = rg.cd_crt
			            and cd_tlt = 1;

			          vl_limite_util_atual := vl_limite_util_atual + (vl_limite_util_saqcard - vl_limite_util_saqcard_old);  

			          if vl_limite_util_atual >= 0 then
			             update sc_opr.tbl_lmt 
			             set vl_utl_lmt = vl_limite_util_atual 
			             where cd_crt = rg.cd_crt 
			               and cd_tlt = 1;
			               
			             update sc_mgr.tbl_lmt set vl_utl_lmt = vl_limite_util_saqcard where cd_crt = rg.cd_crt;
			               
			          end if;

			          
			       end if;

			       if vp_atualiza_concedido = 'S' then

			          if coalesce(vl_limite_conc_saqcard,0) > 0 then 
			       
			             perform sc_opr.altera_limite_cartao(rg.cd_crt,1,coalesce(vl_limite_conc_saqcard,0),'ATUALIZACAO UTILIZANDO BASE DA SAQCARD');
			             
			          end if; 
			         
			       end if;
			       
			    else 
			      raise exception 'O CARTAO SAQCARD VINCULADO AO CARTAO SOMA % FOI ALTERADO',rg.cd_crt;
			    end if;

			else -- SE É UMA INSERCAO

	                   if rg.vl_cnc_lmt = 0 then -- SO INSERE SE NAO TIVER LIMITE

	                      if vl_limite_conc_saqcard > 0 then -- SÓ INSERE SE O LIMITE CONCEDIDO NA SAQCARD FOR MAIOR QUE ZERO

	                        -- Verifica se existe outro limite já cadastrado para esse cartao saqcard
	                        select count(*)
	                        into vl_qtd_cartao_limite
	                        from sc_mgr.tbl_lmt
	                        where cd_crt_sc_lmt = vl_cartao_saqcard;

	                        if vl_qtd_cartao_limite = 0 then -- Só insere se não existir limite vinculado a este cartao saqcard

				       insert into sc_mgr.tbl_lmt(cd_crt,cd_crt_sc_lmt,fg_ind_lmt,vl_cnc_lmt,vl_utl_lmt,nr_cpf_lmt,dt_inc_usr,dt_alt_usr)
				       values(rg.cd_crt,vl_cartao_saqcard,'N',vl_limite_conc_saqcard,vl_limite_util_saqcard,rg.nr_cpf_cnpj_cun,now(),null);
				   
				       perform sc_opr.altera_limite_cartao(rg.cd_crt,1,vl_limite_conc_saqcard,'CONCESSAO UTILIZANDO BASE DA SAQCARD');
				       
				       update sc_opr.tbl_lmt 
					  set vl_utl_lmt = vl_limite_util_saqcard 
					where cd_crt = rg.cd_crt 
					  and cd_tlt = 1;
				end if;	  
			          
			     end if;     
			          
			   end if;
			
			end if; 
                  
                  end if;
                  
	end loop;	  
end;
$$;


ALTER FUNCTION sc_mgr.sincroniza_limite_saqcard(vp_empresa numeric, vp_cartao numeric, vp_atualiza_concedido character) OWNER TO scan;

SET search_path = sc_mnt, pg_catalog;

--
-- TOC entry 1664 (class 1255 OID 976433)
-- Name: enviar_arquivo_minutrade(); Type: FUNCTION; Schema: sc_mnt; Owner: scan
--

CREATE FUNCTION enviar_arquivo_minutrade() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  rg record;

  ct_situacao_arquivo_gerado numeric := 1;
  ct_situacao_arquivo_enviado numeric := 2;

  ct_codigo_sftp_minutrade numeric := 3;
  
  ct_prm_diretorio_minutrade varchar := 'DIRETORIO_ARQUIVO_MINUTRADE';

  vl_diretorio_arquivo varchar;

begin

   select vl_prm
   into vl_diretorio_arquivo
   from sc_cad.tbl_prm
   where nm_prm = ct_prm_diretorio_minutrade;
   
   for rg in select *
             from sc_mnt.tbl_arm
             where st_arm = ct_situacao_arquivo_gerado loop
     begin
     
      perform sc_pbl.enviar_arquivo_sftp(ct_codigo_sftp_minutrade, vl_diretorio_arquivo, rg.nm_arm);

      update sc_mnt.tbl_arm set st_arm = ct_situacao_arquivo_enviado, dt_env_arm = now() where cd_arm = rg.cd_arm;
       
     exception 
     
       when others then
       
       raise exception 'problema %,%', SQLSTATE, SQLERRM;
       
     end; 
     
   end loop;         

end
$$;


ALTER FUNCTION sc_mnt.enviar_arquivo_minutrade() OWNER TO scan;

--
-- TOC entry 7826 (class 0 OID 0)
-- Dependencies: 1664
-- Name: FUNCTION enviar_arquivo_minutrade(); Type: COMMENT; Schema: sc_mnt; Owner: scan
--

COMMENT ON FUNCTION enviar_arquivo_minutrade() IS 'Rotina que envia via SFTP os arquivos da minutrade';


--
-- TOC entry 1656 (class 1255 OID 878880)
-- Name: gerar_arquivo_minutrade(); Type: FUNCTION; Schema: sc_mnt; Owner: scan
--

CREATE FUNCTION gerar_arquivo_minutrade() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;

  ct_situacao_mnt_atualizada numeric := 2;
  ct_situacao_mnt_gerada numeric := 3;

  ct_prm_diretorio_minutrade varchar := 'DIRETORIO_ARQUIVO_MINUTRADE';

  vl_nome_arquivo varchar;
  vl_diretorio_arquivo varchar;

  vl_qtd_reg numeric := 0;
  vl_total_arquivo numeric := 0;

  vl_codigo_arquivo numeric;

  ct_nome_evento varchar := 'fee-paid';
  ct_nome_experiencia varchar := 'saqpag-experiencia';
  vl_linha varchar;
  
begin

   select count(*)
   into vl_qtd_reg
   from sc_mnt.tbl_mnt
   where st_mnt = ct_situacao_mnt_atualizada;

   select vl_prm
   into vl_diretorio_arquivo
   from sc_cad.tbl_prm
   where nm_prm = ct_prm_diretorio_minutrade;

   -- INSERINDO O HEADER
   if vl_qtd_reg > 0 then

     select nextval('sc_mnt.sq_arm') into vl_codigo_arquivo;

     vl_nome_arquivo := to_char(now(),'yyyymmdd') ||'_triggers_'||ct_nome_evento||'_'||ct_nome_experiencia||'.csv';

     insert into sc_mnt.tbl_arm(cd_arm,nm_arm,dt_grc_arm,dt_pgto_arm,st_arm,qtd_reg_arm,vl_ttl_arm) 
     values(vl_codigo_arquivo,vl_nome_arquivo,now(),current_date,1,vl_qtd_reg,0); 

     vl_nome_arquivo := vl_diretorio_arquivo || '/' || vl_nome_arquivo;

     vl_linha := 'consumerName;identifier;email;mobile;idEvent;dateMaturityl;datePay;amount';
     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
   
   end if;
   

   for rg in select mnt.*, cun.nr_cpf_cnpj_cun as cpf, cun.nm_cun as nome, cun.eml_cun as email
             from sc_mnt.tbl_mnt mnt
             inner join sc_opr.tbl_crt crt on crt.cd_crt = mnt.cd_crt
	     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	     inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
             where st_mnt = ct_situacao_mnt_atualizada 
              and  nr_ddd_tlf_mnt is not null
              and  nr_tlf_mnt is not null loop

     vl_linha := rg.nome; -- consumerName
     vl_linha := vl_linha || ';' || rg.cpf; -- identifier
     vl_linha := vl_linha || ';' || coalesce(rg.email,''); -- email
     vl_linha := vl_linha || ';' || rg.nr_ddd_tlf_mnt || rg.nr_tlf_mnt; -- mobile
     vl_linha := vl_linha || ';' || rg.cd_mnt; -- idEvent
     vl_linha := vl_linha || ';' || to_char(rg.dt_inc_usr,'dd-mm-yyyy'); -- dateMaturityl
     vl_linha := vl_linha || ';' || to_char(now(),'dd-mm-yyyy'); -- datePay
     vl_linha := vl_linha || ';' || rg.vl_mnt::INTEGER; -- amount
     
     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

     insert into sc_mnt.tbl_dar(cd_dar,cd_arm,tp_org_dar,nsu_org_dar,id_evt_dar,nr_ddd_tlf_dar,nr_tlf_dar,id_dar,nm_dar,eml_dar,st_dar,vl_dar) 
     values(nextval('sc_mnt.sq_dar'),vl_codigo_arquivo,1,rg.cd_crt,rg.cd_mnt,rg.nr_ddd_tlf_mnt,rg.nr_tlf_mnt,rg.cpf,rg.nome,rg.email,1,rg.vl_mnt);
     
     vl_total_arquivo := vl_total_arquivo + rg.vl_mnt;
     
     update sc_mnt.tbl_mnt 
        set st_mnt = ct_situacao_mnt_gerada,
            cd_arm = vl_codigo_arquivo 
     where cd_mnt = rg.cd_mnt; 

   end loop;

   update sc_mnt.tbl_arm set vl_ttl_arm = vl_total_arquivo where cd_arm = vl_codigo_arquivo;

exception
when others then
  perform sc_arq.excluirArquivo(vl_nome_arquivo); 
  RAISE EXCEPTION 'Problema na geração do arquivo de carga da minutrade. ERRO:%, DETALHE:%,', SQLSTATE, SQLERRM;         


END$$;


ALTER FUNCTION sc_mnt.gerar_arquivo_minutrade() OWNER TO scan;

--
-- TOC entry 1668 (class 1255 OID 969386)
-- Name: gerar_minutrade_job(); Type: FUNCTION; Schema: sc_mnt; Owner: scan
--

CREATE FUNCTION gerar_minutrade_job() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin

    perform sc_mnt.popular_minutrade();
    perform sc_mnt.popular_telefones();
    perform sc_mnt.gerar_arquivo_minutrade();
   
end$$;


ALTER FUNCTION sc_mnt.gerar_minutrade_job() OWNER TO scan;

--
-- TOC entry 1556 (class 1255 OID 877682)
-- Name: get_valor_tmc_minutrade(numeric); Type: FUNCTION; Schema: sc_mnt; Owner: scan
--

CREATE FUNCTION get_valor_tmc_minutrade(vp_cartao numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_tmc numeric;
begin

   select coalesce(pct.vl_pgt_pct,0)
   into vl_tmc
   from sc_mnt.tbl_ads ads
     inner join sc_mnt.tbl_pct pct on pct.cd_pct = ads.cd_pct
   where ads.cd_crt = vp_cartao
     and ads.st_ads = 1;

     return vl_tmc;


end$$;


ALTER FUNCTION sc_mnt.get_valor_tmc_minutrade(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1558 (class 1255 OID 877706)
-- Name: inserir_bonus(numeric); Type: FUNCTION; Schema: sc_mnt; Owner: scan
--

CREATE FUNCTION inserir_bonus(vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_cod_pacote numeric;
  vl_bonus numeric;
begin

  select ads.cd_pct,
         pct.vl_bns_pct
  into vl_cod_pacote,
       vl_bonus
  from sc_mnt.tbl_ads ads
    inner join sc_mnt.tbl_pct pct on pct.cd_pct = ads.cd_pct
  where st_ads = 1
    and ads.cd_crt = vp_cartao
    AND NOT EXISTS (select 1 from sc_mnt.tbl_mnt where cd_crt = ads.cd_crt AND to_char(dt_inc_usr,'mm/yyyy') = to_char(current_date,'mm/yyyy'));

    insert into sc_mnt.tbl_mnt(cd_mnt,cd_crt,vl_mnt,dt_inc_usr,cd_inc_usr,st_mnt,cd_pct) values(nextval('sc_mnt.sq_mnt'),vp_cartao,vl_bonus,now(),1,1,vl_cod_pacote);
    
end$$;


ALTER FUNCTION sc_mnt.inserir_bonus(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1672 (class 1255 OID 954054)
-- Name: popular_minutrade(); Type: FUNCTION; Schema: sc_mnt; Owner: scan
--

CREATE FUNCTION popular_minutrade() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;

  CT_SITUACAO_COBRADO_PAGO_CARTAO constant integer := 2;
  CT_SITUACAO_COBRADO_EMPRESA constant integer := 4;
begin

   --listando as tarifas de serviços cobradas diretamente do usuário de cartão
   for rg in select *
		from sc_srv.tbl_tsc tsc
		  inner join sc_cad.tbl_pcs pcs on pcs.cd_pcs = sc_cad.get_pacote_servico_cartao(tsc.cd_crt)
		  inner join sc_cad.tbl_dps dps on dps.cd_pcs = pcs.cd_pcs and dps.cd_pce = 36
		  inner join sc_mnt.tbl_pct pct on pct.cd_pct = coalesce(dps.vl_pce_dps,'-1')::numeric
		where tsc.st_tsc IN (CT_SITUACAO_COBRADO_PAGO_CARTAO, CT_SITUACAO_COBRADO_EMPRESA)
		  and not exists(select 1 from sc_mnt.tbl_mnt m where m.cd_tsc = tsc.cd_tsc)
		  --and tsc.dt_pgto_tsc < ('01-'||to_char(current_date,'mm-yyyy'))::date 
		  and tsc.cd_srv = 12
		  and tsc.dt_inc_usr::date>'01-04-2017'
		  and pct.vl_bns_pct > 0
		  and vl_tsc-pct.vl_bns_pct=-.10
		  ORDER BY TSC.DT_INC_USR
		 loop
        insert into sc_mnt.tbl_mnt values(nextval('sc_mnt.sq_mnt'),rg.cd_crt,rg.vl_bns_pct,now(),1,null,null,1,null,null,rg.cd_pct,null,rg.cd_tsc);	  
    end loop;

end;$$;


ALTER FUNCTION sc_mnt.popular_minutrade() OWNER TO scan;

--
-- TOC entry 1621 (class 1255 OID 879754)
-- Name: popular_telefones(); Type: FUNCTION; Schema: sc_mnt; Owner: scan
--

CREATE FUNCTION popular_telefones() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_situacao_mnt_cadastrada numeric := 1;
  ct_situacao_mnt_atualizada numeric := 2;
  ct_situacao_mnt_bonus_nao_efetivado numeric := 5;
  

  vl_ddd_telefone numeric;
  vl_nr_telefone numeric;

  rg record;
begin

   for rg in select *
             from sc_mnt.tbl_mnt mnt
                inner join sc_opr.tbl_crt crt on crt.cd_crt = mnt.cd_crt
               inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
             where st_mnt = ct_situacao_mnt_bonus_nao_efetivado 
               and (current_date - mnt.dt_inc_usr::date) <= 30 loop

      select nr_ddd_tlf,nr_tlf
      into vl_ddd_telefone,vl_nr_telefone
      from sc_cad.tbl_tlf
      where tp_tlf = 2
        and tp_org_tlf = 1
        and nsu_org_tlf = rg.cd_cun
        and fg_atv_tlf = 'S'
      order by coalesce(fg_prn_tlf,'N') desc,dt_inc_usr desc limit 1;

      if vl_nr_telefone is not null then

         if vl_nr_telefone <> rg.nr_tlf_mnt or 
            vl_ddd_telefone <> rg.nr_ddd_tlf_mnt  then

            update sc_mnt.tbl_mnt 
               set nr_tlf_mnt = vl_nr_telefone,
                   nr_ddd_tlf_mnt = vl_ddd_telefone,
                   st_mnt = ct_situacao_mnt_atualizada 
            where cd_mnt = rg.cd_mnt;
         
         end if;
     end if;    
       
             
   end loop;          


   for rg in select *
             from sc_mnt.tbl_mnt mnt
               inner join sc_opr.tbl_crt crt on crt.cd_crt = mnt.cd_crt
               inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
             where st_mnt = ct_situacao_mnt_cadastrada loop

      select nr_ddd_tlf,nr_tlf
      into vl_ddd_telefone,vl_nr_telefone
      from sc_cad.tbl_tlf
      where tp_tlf = 2
        and tp_org_tlf = 1
        and nsu_org_tlf = rg.cd_cun
        and fg_atv_tlf = 'S'
      order by coalesce(fg_prn_tlf,'N') desc,dt_inc_usr desc limit 1;

      if vl_nr_telefone is not null then

         update sc_mnt.tbl_mnt 
            set nr_ddd_tlf_mnt = vl_ddd_telefone,
                nr_tlf_mnt = vl_nr_telefone,
                st_mnt = ct_situacao_mnt_atualizada 
         where cd_mnt = rg.cd_mnt;
      
      end if;

             
   end loop;             

end$$;


ALTER FUNCTION sc_mnt.popular_telefones() OWNER TO scan;

--
-- TOC entry 1248 (class 1255 OID 955727)
-- Name: processar_arquivo_retorno(); Type: FUNCTION; Schema: sc_mnt; Owner: scan
--

CREATE FUNCTION processar_arquivo_retorno() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  st_mnt_bonus_efetivado numeric     := 4;
  st_mnt_bonus_nao_efetivado numeric := 5;

  vl_descricao varchar;
  vl_data_pagamento date;
begin

    for rg in select *
             from sc_mnt.tbl_rmt rmt
                inner join sc_mnt.tbl_mnt mnt on mnt.cd_mnt = rmt.id_evt_rmt
             where st_rmt = 1 
               and trg_rmt is not null
               and exists(select 1 
                          from sc_mnt.tbl_rmt 
                          where trg_rmt=rmt.trg_rmt 
                            and cd_rmt <> rmt.cd_rmt)  loop

          update sc_mnt.tbl_rmt set st_rmt = 3 where cd_rmt = rg.cd_rmt;                  
    end loop;         

   for rg in select *
             from sc_mnt.tbl_rmt rmt
                inner join sc_mnt.tbl_mnt mnt on mnt.cd_mnt = rmt.id_evt_rmt
                inner join sc_srv.tbl_tsc tsc on tsc.cd_tsc = mnt.cd_tsc
             where st_rmt = 1 loop

       vl_data_pagamento := coalesce(rg.dt_pgt_rmt, rg.dt_vnc_tsc);
       if rg.dlv_rmt > 0 then
          vl_descricao := 'BONUS EFETUADO NO TELEFONE '||rg.tlf_rmt||'. DATA DA EFETIVACAO:'||vl_data_pagamento||'. REF A TMC COBRADA DIA '||RG.dt_vnc_tsc|| ' E PAGA DIA '||vl_data_pagamento;

	  if vl_descricao is not null then
            insert into sc_opr.tbl_ocr(cd_ocr,cd_toc,cd_crt,cd_pls,nm_his_ocr,fg_atm_ocr,cd_inc_usr,dt_inc_usr)
            values(nextval('sc_opr.sq_ocr'),28,rg.cd_crt,null,vl_descricao,'N',1,now());
            update sc_mnt.tbl_mnt set st_mnt = st_mnt_bonus_efetivado,dt_pgt_mnt = rg.dt_pgt_rmt where cd_mnt = rg.cd_mnt;  
          else
            raise notice 'telefone: %, data efetivaçãp: %, data vencimento: %, data pagamento: %', rg.tlf_rmt, vl_data_pagamento, rg.dt_vnc_tsc, vl_data_pagamento;
          end if;
       else
          vl_descricao := 'BONUS NAO EFETUADO NO TELEFONE '||rg.tlf_rmt||'. DATA:'||vl_data_pagamento;

          if vl_descricao is not null then
            insert into sc_opr.tbl_ocr(cd_ocr,cd_toc,cd_crt,cd_pls,nm_his_ocr,fg_atm_ocr,cd_inc_usr,dt_inc_usr)
            values(nextval('sc_opr.sq_ocr'),29,rg.cd_crt,null, vl_descricao,'N',1,now());
            update sc_mnt.tbl_mnt set st_mnt = st_mnt_bonus_nao_efetivado where cd_mnt = rg.cd_mnt;  
          else
            raise notice 'telefone: %, data pagamento: %', rg.tlf_rmt, vl_data_pagamento;
          end if;
       end if;      

       if vl_descricao is not null then
         update sc_mnt.tbl_rmt set st_rmt = 2 where cd_rmt = rg.cd_rmt;
       end if;
    end loop;         

end$$;


ALTER FUNCTION sc_mnt.processar_arquivo_retorno() OWNER TO scan;

--
-- TOC entry 1681 (class 1255 OID 992810)
-- Name: receber_arquivo_retorno(); Type: FUNCTION; Schema: sc_mnt; Owner: scan
--

CREATE FUNCTION receber_arquivo_retorno() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
 
begin

  perform sc_job.executar_java_job('recebeRetornoMinutrade', 'codigo==3');
  
   
end$$;


ALTER FUNCTION sc_mnt.receber_arquivo_retorno() OWNER TO scan;

--
-- TOC entry 7827 (class 0 OID 0)
-- Dependencies: 1681
-- Name: FUNCTION receber_arquivo_retorno(); Type: COMMENT; Schema: sc_mnt; Owner: scan
--

COMMENT ON FUNCTION receber_arquivo_retorno() IS 'Rotina que recebe o arquivo de retorno';


SET search_path = sc_msg, pg_catalog;

--
-- TOC entry 1797 (class 1255 OID 1633493)
-- Name: cadastrar_push_funcionarios_ativos(character varying); Type: FUNCTION; Schema: sc_msg; Owner: scan
--

CREATE FUNCTION cadastrar_push_funcionarios_ativos(vp_msg character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  ct_situacao_funcionario_demitido constant numeric := 2;
  rg record;
BEGIN
	for rg in select distinct(fnc.cd_fnc), tlf.nr_ddd_tlf, tlf.nr_tlf, crt.cd_crt, ucr.id_push_msg
	  from sc_sgr.tbl_ucr ucr
	    inner join sc_opr.tbl_crt crt on crt.cd_crt = ucr.cd_crt
	    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	    inner join sc_cad.tbl_tlf tlf on tlf.nsu_org_tlf = cun.cd_cun
	  where ucr.id_push_msg is not null
	    and fnc.st_fnc <> 2
            and crt.fg_atv_crt = 'S'
	    and tlf.fg_prn_tlf = 'S'
	    and tlf.fg_atv_tlf = 'S'
	    and cun.nr_cpf_cnpj_cun = 94487294304
    LOOP
      insert into sc_msg.tbl_msg values(nextval('sc_msg.sq_msg'), 1, rg.nr_ddd_tlf, rg.nr_tlf, vp_msg, 'S', 'N', null, 1, now(), null, null, null, rg.cd_crt, rg.id_push_msg, 2);
    END LOOP;
END$$;


ALTER FUNCTION sc_msg.cadastrar_push_funcionarios_ativos(vp_msg character varying) OWNER TO scan;

--
-- TOC entry 1182 (class 1255 OID 862131)
-- Name: enviar_mensagem(numeric, numeric); Type: FUNCTION; Schema: sc_msg; Owner: postgres
--

CREATE FUNCTION enviar_mensagem(vp_tms numeric, vp_codigo numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  vl_parametros text[];
  vl_mensagem varchar(500);
  vl_posicao numeric := 1;
  vl_qnt_mensagem numeric := 0;

  -- variaveis pra mandar a mensagem
  vl_tipoEnvio integer[];	
  vl_nsu bigint[];
  vl_ddd integer[];
  vl_numero integer[];
  vl_idEnvio varchar[];
  vl_texto varchar[];
  vl_retorno integer;

  vl_assunto_email varchar;
  vl_texto_email varchar;

  _conn text;
  vl_email_erro varchar;  

  vl_auth_firebase_soma varchar := 'AAAAdYHcV7U:APA91bEwHpQcSqbmHXq_JuxFmvUOjybg6pu1Ch4WNr7jSr2orBF6yzvXiAeg4dGk-23BSh4ey7lOpQ9YiM18PysOyvYuakfaZAZCXnO3SsmJbLtNUq1mE92WbVKZk7Doxji0gZ1_xtNm';

begin

  _conn:='hostaddr=127.0.0.1 port=5432 dbname=scan user=scan password=scan';

  select count(*)
    into vl_qnt_mensagem
  from sc_msg.tbl_msg msg
    inner join sc_msg.tbl_tms tms on tms.cd_tms = msg.cd_tms
  where msg.fg_env_msg = 'N'
    and msg.fg_atv_msg = 'S' 
    and (vp_tms is null or tms.cd_tms = vp_tms)
    and (vp_codigo is null or msg.cd_msg = vp_codigo)
    and msg.ddd_msg > 0
    and msg.nr_msg > 0;
  
  if vl_qnt_mensagem > 0 then  

    while vl_qnt_mensagem > 0 loop

      vl_posicao := 1;
       
      vl_nsu := null;
      vl_ddd := null;
      vl_numero := null;
      vl_texto := null;  
  
    for rg in select *
              from sc_msg.tbl_msg msg
                inner join sc_msg.tbl_tms tms on tms.cd_tms = msg.cd_tms
              where msg.fg_env_msg = 'N'
                and msg.fg_atv_msg = 'S' 
                and (vp_tms is null or tms.cd_tms = vp_tms)
                and (vp_codigo is null or msg.cd_msg = vp_codigo) 
                and msg.ddd_msg > 0 -- verificar depois pois nao pode ter ddd zerado
                and msg.nr_msg > 0 -- verificar depois pois nao pode ter celular zerado
                limit 300 
    loop

      -- montando as mensagens
      vl_mensagem := rg.msg_tms;
      if rg.prm_msg is not null then
        vl_parametros := string_to_array(rg.prm_msg, '@');
        for i in 1..array_length(vl_parametros,1) loop
          vl_mensagem := replace(vl_mensagem, '{'||i||'}', vl_parametros[i]);
        end loop;
      end if;

      if length(vl_mensagem) <= 140 then

        -- adicionando as mensagens
        vl_nsu[vl_posicao] := rg.cd_msg;
        vl_ddd[vl_posicao] := rg.ddd_msg;
        vl_numero[vl_posicao] := rg.nr_msg;
        vl_texto[vl_posicao] := sc_pbl.sem_acento(vl_mensagem);
        vl_tipoEnvio[vl_posicao] := rg.tp_env_msg;
  	vl_idEnvio[vl_posicao] := rg.id_push_msg;

        vl_posicao := vl_posicao + 1;

      end if;

    end loop;

    -- enviando mensagem servidor da aptare
    -- ENVIO ANTIGO
    -- vl_retorno := sc_msg.mandarmensagens(vl_nsu, vl_ddd, vl_numero, vl_texto, 13, 'SOMA', '321SaqPag');

    -- NOVO ENVIO
    vl_retorno := sc_msg.mandarmensagens(vl_tipoEnvio, vl_nsu, vl_ddd, vl_numero, vl_idEnvio, vl_texto, 13, vl_auth_firebase_soma, 'SOMA', '321SaqPag');

    if(vl_retorno <> 0) then
      vl_assunto_email := 'PROBLEMA ENVIO SMS';

      vl_texto_email := '<html xmlns="http://www.w3.org/1999/xhtml">
		<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		</head>
		<body>';

      vl_texto_email := vl_texto_email || 'OCORREU PROBLEMA NO ENVIO DE MENSAGENS PARA O SERVIDOR DA APTARE. ROTINA sc_msg.enviar_mensagem RETORNO ' || vl_retorno::varchar;

      vl_texto_email := vl_texto_email || '</body></html>';
      
      vl_email_erro := 'select sc_pbl.enviar_email_saqpag(''tecnologia@somacontadigital.com.br'',''' || vl_assunto_email || ''',''' || vl_texto_email || ''',null)';

      PERFORM * FROM dblink(_conn, vl_email_erro) as x (x text);

      return; 
    end if;

      -- atualizando as mensagens pra enviada
      update sc_msg.tbl_msg msg set
        fg_env_msg = 'S',
        dt_env_msg = now(),
        cd_rtn_msg = vl_retorno
      where cd_msg = ANY (vl_nsu);

      vl_qnt_mensagem := vl_qnt_mensagem - 300;
    
    end loop;

  end if;

end;$$;


ALTER FUNCTION sc_msg.enviar_mensagem(vp_tms numeric, vp_codigo numeric) OWNER TO postgres;

--
-- TOC entry 1529 (class 1255 OID 564450)
-- Name: enviar_mensagem_OLD(numeric); Type: FUNCTION; Schema: sc_msg; Owner: scan
--

CREATE FUNCTION "enviar_mensagem_OLD"(vp_tms numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  vl_parametros text[];
  vl_mensagem varchar(500);
  vl_posicao numeric := 1;
  vl_qnt_mensagem numeric := 0;

  -- variaveis pra mandar a mensagem
  vl_nsu bigint[];
  vl_ddd integer[];
  vl_numero integer[];
  vl_texto varchar[];
  vl_retorno integer;

begin

  select count(*)
    into vl_qnt_mensagem
  from sc_msg.tbl_msg msg
    inner join sc_msg.tbl_tms tms on tms.cd_tms = msg.cd_tms
  where msg.fg_env_msg = 'N'
    and msg.fg_atv_msg = 'S' 
    and case when vp_tms is null then true else tms.cd_tms = vp_tms end;
  
  if vl_qnt_mensagem > 0 then  

    while vl_qnt_mensagem > 0 loop

      vl_posicao := 1;
       
      vl_nsu := null;
      vl_ddd := null;
      vl_numero := null;
      vl_texto := null;  
  
    for rg in select *
              from sc_msg.tbl_msg msg
                inner join sc_msg.tbl_tms tms on tms.cd_tms = msg.cd_tms
              where msg.fg_env_msg = 'N'
                and msg.fg_atv_msg = 'S' 
                and case when vp_tms is null then true else tms.cd_tms = vp_tms end limit 300 loop

      -- montando as mensagens
      vl_mensagem := rg.msg_tms;
      if rg.prm_msg is not null then
        vl_parametros := string_to_array(rg.prm_msg, '@');
        for i in 1..array_length(vl_parametros,1) loop
          vl_mensagem := replace(vl_mensagem, '{'||i||'}', vl_parametros[i]);
        end loop;
      end if;

      -- adicionando as mensagens
      vl_nsu[vl_posicao] := rg.cd_msg;
      vl_ddd[vl_posicao] := rg.ddd_msg;
      vl_numero[vl_posicao] := rg.nr_msg;
      vl_texto[vl_posicao] := vl_mensagem;


      vl_posicao := vl_posicao + 1;

    end loop;

    -- enviando mensagem servidor da aptare
    vl_retorno := sc_msg.mandarmensagens(vl_nsu, vl_ddd, vl_numero, vl_texto, 13, 'SAQPAG', '321SaqPag');

    if(vl_retorno <> 0) then
      perform sc_pbl.enviar_email_saqpag('tecnologia@saqpag.com.br', 'PROBLEMA ENVIO SMS', 'OCORREU PROBLEMA NO ENVIO DE MENSAGENS PARA O SERVIDOR DA APTARE. ROTINA sc_msg.enviar_mensagem.',null);
    end if;
    

    -- atualizando as mensagens pra enviada
    update sc_msg.tbl_msg msg set
      fg_env_msg = 'S',
      dt_env_msg = now(),
      cd_rtn_msg = vl_retorno
    where cd_msg = ANY (vl_nsu);

    vl_qnt_mensagem := vl_qnt_mensagem - 300;

    end loop;

  end if;

end;$$;


ALTER FUNCTION sc_msg."enviar_mensagem_OLD"(vp_tms numeric) OWNER TO scan;

--
-- TOC entry 1796 (class 1255 OID 1624599)
-- Name: enviar_mensagem_old2(numeric, numeric); Type: FUNCTION; Schema: sc_msg; Owner: scan
--

CREATE FUNCTION enviar_mensagem_old2(vp_tms numeric, vp_codigo numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  vl_parametros text[];
  vl_mensagem varchar(500);
  vl_posicao numeric := 1;
  vl_qnt_mensagem numeric := 0;

  -- variaveis pra mandar a mensagem
  vl_nsu bigint[];
  vl_ddd integer[];
  vl_numero integer[];
  vl_texto varchar[];
  vl_retorno integer;

  vl_assunto_email varchar;
  vl_texto_email varchar;

  _conn text;
  vl_email_erro varchar;  

begin

  _conn:='hostaddr=127.0.0.1 port=5432 dbname=scan user=scan password=scan';

  select count(*)
    into vl_qnt_mensagem
  from sc_msg.tbl_msg msg
    inner join sc_msg.tbl_tms tms on tms.cd_tms = msg.cd_tms
  where msg.fg_env_msg = 'N'
    and msg.fg_atv_msg = 'S' 
    and (vp_tms is null or tms.cd_tms = vp_tms)
    and (vp_codigo is null or msg.cd_msg = vp_codigo)
    and msg.ddd_msg > 0;
  
  if vl_qnt_mensagem > 0 then  

    while vl_qnt_mensagem > 0 loop

      vl_posicao := 1;
       
      vl_nsu := null;
      vl_ddd := null;
      vl_numero := null;
      vl_texto := null;  
  
    for rg in select *
              from sc_msg.tbl_msg msg
                inner join sc_msg.tbl_tms tms on tms.cd_tms = msg.cd_tms
              where msg.fg_env_msg = 'N'
                and msg.fg_atv_msg = 'S' 
                and (vp_tms is null or tms.cd_tms = vp_tms)
                and (vp_codigo is null or msg.cd_msg = vp_codigo) 
                and msg.ddd_msg > 0 -- verificar depois pois nao pode ter ddd zerado
                and msg.nr_msg > 0 -- verificar depois pois nao pode ter celular zerado
                limit 300 
    loop

      -- montando as mensagens
      vl_mensagem := rg.msg_tms;
      if rg.prm_msg is not null then
        vl_parametros := string_to_array(rg.prm_msg, '@');
        for i in 1..array_length(vl_parametros,1) loop
          vl_mensagem := replace(vl_mensagem, '{'||i||'}', vl_parametros[i]);
        end loop;
      end if;

      if length(vl_mensagem) <= 140 then

        -- adicionando as mensagens
        vl_nsu[vl_posicao] := rg.cd_msg;
        vl_ddd[vl_posicao] := rg.ddd_msg;
        vl_numero[vl_posicao] := rg.nr_msg;
        vl_texto[vl_posicao] := sc_pbl.sem_acento(vl_mensagem);

        vl_posicao := vl_posicao + 1;

      end if;

    end loop;

    -- enviando mensagem servidor da aptare
    vl_retorno := sc_msg.mandarmensagens(vl_nsu, vl_ddd, vl_numero, vl_texto, 13, 'SOMA', '321SaqPag');


    if(vl_retorno <> 0) then
      vl_assunto_email := 'PROBLEMA ENVIO SMS';

      vl_texto_email := '<html xmlns="http://www.w3.org/1999/xhtml">
		<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		</head>
		<body>';

      vl_texto_email := vl_texto_email || 'OCORREU PROBLEMA NO ENVIO DE MENSAGENS PARA O SERVIDOR DA APTARE. ROTINA sc_msg.enviar_mensagem RETORNO ' || vl_retorno::varchar;

      vl_texto_email := vl_texto_email || '</body></html>';
      
      vl_email_erro := 'select sc_pbl.enviar_email_saqpag(''tecnologia@somacontadigital.com.br'',''' || vl_assunto_email || ''',''' || vl_texto_email || ''',null)';

      PERFORM * FROM dblink(_conn, vl_email_erro) as x (x text);

      return; 
    end if;

      -- atualizando as mensagens pra enviada
      update sc_msg.tbl_msg msg set
        fg_env_msg = 'S',
        dt_env_msg = now(),
        cd_rtn_msg = vl_retorno
      where cd_msg = ANY (vl_nsu);

      vl_qnt_mensagem := vl_qnt_mensagem - 300;
    
    end loop;

  end if;

end;$$;


ALTER FUNCTION sc_msg.enviar_mensagem_old2(vp_tms numeric, vp_codigo numeric) OWNER TO scan;

--
-- TOC entry 1736 (class 1255 OID 1019706)
-- Name: enviar_mensagem_operacao_compra(numeric); Type: FUNCTION; Schema: sc_msg; Owner: scan
--

CREATE FUNCTION enviar_mensagem_operacao_compra(vp_cod_operacao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $_$declare
  ct_cd_tms_compra numeric := 8;
  
  vl_operacao varchar;
  vl_telefone varchar; 
  vl_retorno numeric;
  vl_nome_estab varchar;
  vl_prm varchar;
  vl_cd_msg numeric;
  
begin

   select 'R$ ' || replace(to_char(opr.vl_opr,'999G999G990D99'),' ',''), (tlf.nr_ddd_tlf::varchar||tlf.nr_tlf::varchar), fet.nm_fet
     into vl_operacao, vl_telefone,vl_nome_estab
   from sc_opr.tbl_opr opr
     inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
     inner join sc_rdc.tbl_etb etb on etb.cd_etb = fet.cd_etb
     inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
     inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
     inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
     inner join sc_cad.tbl_tlf tlf on tlf.tp_org_tlf = 1 and tlf.nsu_org_tlf = cun.cd_cun
   where opr.cd_opr = vp_cod_operacao
     and tlf.fg_prn_tlf = 'S'
     and tlf.fg_atv_tlf = 'S';

   if vl_telefone is not null then
       
       vl_prm := vl_operacao || '@' || vl_nome_estab;

       select nextval('sc_msg.sq_msg') into vl_cd_msg;

       insert into sc_msg.tbl_msg (cd_msg, cd_tms, ddd_msg, nr_msg, 
                                 prm_msg, fg_atv_msg, fg_env_msg, cd_inc_usr, dt_inc_usr)
         values (vl_cd_msg, ct_cd_tms_compra, substr(vl_telefone, 0, 3)::numeric, substr(vl_telefone,3,length(vl_telefone))::numeric, 
                 vl_prm, 'S', 'N', 1, now());

       perform sc_msg.enviar_mensagem(ct_cd_tms_compra, vl_cd_msg);

   
   end if;
   
end;$_$;


ALTER FUNCTION sc_msg.enviar_mensagem_operacao_compra(vp_cod_operacao numeric) OWNER TO scan;

--
-- TOC entry 1539 (class 1255 OID 862126)
-- Name: gerar_codigo_validacao(numeric, numeric, numeric, numeric, numeric, numeric, character varying, character varying); Type: FUNCTION; Schema: sc_msg; Owner: scan
--

CREATE FUNCTION gerar_codigo_validacao(vp_tipo numeric, vp_nsu numeric, vp_tamanho numeric, vp_timeout numeric, vp_ddd numeric, vp_telefone numeric, vp_tipo_validacao character varying, vp_valida_reenvio character varying, OUT vr_codigo numeric, OUT vr_mensagem character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

DECLARE
   -- constantes
   situacao_cadastrado         CONSTANT numeric := 1;
   situacao_invalidado         CONSTANT numeric := 3;

   tipo_sms_codigo_validacao   CONSTANT numeric := 7;

   -- variaveis pra mandar a mensagem
   vl_codigo                            numeric;
   vl_codigo_validacao                  numeric;
   vl_intervalo                         varchar;
   vl_data_exp                          timestamp;
   vl_existe                            numeric;
   vl_codigo_sms                        numeric;
   vl_qtd_sms                           numeric;
   vl_maximo_reenvio                    numeric;
   vl_parametro                         varchar;
BEGIN
   vr_mensagem := 'Sucesso';

   -- retornando o paramentro de qtd maxima de reenvio de sms
   SELECT (vl_prm)::numeric
     INTO vl_maximo_reenvio
     FROM sc_cad.tbl_prm
    WHERE nm_prm = 'NUMERO_MAXIMO_REENVIO_SMS_COD_VALIDACAO_SAQFACIL';

   vl_qtd_sms := 0;

   -- verificando se ja ultrapassou o numero maximo de reenvio
   IF vp_valida_reenvio = 'S'
   THEN
      SELECT sum (nr_env_cvm)
        INTO vl_qtd_sms
        FROM sc_msg.tbl_cvm
       WHERE tp_org_cvm = vp_tipo AND nsu_org_cvm = vp_nsu;

      vl_qtd_sms := coalesce (vl_qtd_sms, 0);
   END IF;

   IF vl_qtd_sms >= vl_maximo_reenvio or vp_telefone = 0 or vp_ddd = 0
   THEN
      vr_codigo := 0;
      vr_mensagem :=
         'Não foi possível enviar o código de validação, seus dados podem estar desatualizados. Favor verfique o número de telefone cadastrado.';
      RETURN;
   END IF;

   -- verificando se existe codigo de validacao ainda nao expirado
   SELECT cd_cvm, dt_exp_vld_cvm
     INTO vl_codigo, vl_data_exp
     FROM sc_msg.tbl_cvm
    WHERE     tp_org_cvm = vp_tipo
          AND nsu_org_cvm = vp_nsu
          AND st_cvm = situacao_cadastrado;

   vl_codigo := coalesce (vl_codigo, 0);

   IF (vl_codigo = 0 OR vl_data_exp <= clock_timestamp ())
   THEN                        -- gerar novo codigo e invalida codigo anterior
      vl_qtd_sms := 0;
      vl_codigo := nextval ('sc_msg.sq_cvm');
      vl_codigo_validacao := sc_acc.gera_numero_aleatorio (vp_tamanho);
      vl_data_exp := clock_timestamp () + INTERVAL '1 minute' * vp_timeout;

      -- invalidando os codigos anteriores
      UPDATE sc_msg.tbl_cvm
         SET st_cvm = situacao_invalidado, dt_st_cvm = clock_timestamp ()
       WHERE     tp_org_cvm = vp_tipo
             AND nsu_org_cvm = vp_nsu
             AND st_cvm = situacao_cadastrado;

      -- gerando o novo codigo de validacao
      INSERT INTO sc_msg.tbl_cvm
           VALUES (vl_codigo,
                   vp_tipo,
                   vp_nsu,
                   vl_codigo_validacao::text,
                   vl_data_exp,
                   situacao_cadastrado,
                   clock_timestamp ());
   ELSE                                           -- retorna codigo cadastrado
      SELECT cd_cvm, cd_vld_cvm
        INTO vl_codigo, vl_codigo_validacao
        FROM sc_msg.tbl_cvm
       WHERE     tp_org_cvm = vp_tipo
             AND nsu_org_cvm = vp_nsu
             AND st_cvm = situacao_cadastrado;
   END IF;

   -- inserindo a mensagem SMS
   vl_codigo_sms := nextval ('sc_msg.sq_msg');

   -- criando parametro da mensagem
   vl_parametro := vl_codigo_validacao || '@' || vp_tipo_validacao;

   INSERT INTO sc_msg.tbl_msg (cd_msg,
                               cd_tms,
                               ddd_msg,
                               nr_msg,
                               prm_msg,
                               fg_atv_msg,
                               fg_env_msg,
                               cd_inc_usr,
                               dt_inc_usr,
                               cd_crt)
        VALUES (vl_codigo_sms,
                tipo_sms_codigo_validacao,
                vp_ddd,
                vp_telefone,
                vl_parametro,
                'S',
                'N',
                1,
                now (),
                NULL);

   -- enviando a mensagem SMS
   PERFORM sc_msg.enviar_mensagem(NULL, vl_codigo_sms);

   -- atualizando o numero de mensagens enviadas
   SELECT count (*)
     INTO vl_existe
     FROM sc_msg.tbl_msg
    WHERE cd_msg = vl_codigo_sms AND fg_env_msg = 'S';

   IF vl_existe > 0
   THEN
      vl_qtd_sms := vl_qtd_sms + 1;

      UPDATE sc_msg.tbl_cvm
         SET nr_env_cvm = vl_qtd_sms
       WHERE cd_cvm = vl_codigo;
   END IF;

   vr_codigo := vl_codigo;
END;
$$;


ALTER FUNCTION sc_msg.gerar_codigo_validacao(vp_tipo numeric, vp_nsu numeric, vp_tamanho numeric, vp_timeout numeric, vp_ddd numeric, vp_telefone numeric, vp_tipo_validacao character varying, vp_valida_reenvio character varying, OUT vr_codigo numeric, OUT vr_mensagem character varying) OWNER TO scan;

--
-- TOC entry 1197 (class 1255 OID 1624602)
-- Name: mandarmensagens(integer[], bigint[], integer[], integer[], character varying[], character varying[], integer, character varying, character varying, character varying); Type: FUNCTION; Schema: sc_msg; Owner: scan
--

CREATE FUNCTION mandarmensagens(integer[], bigint[], integer[], integer[], character varying[], character varying[], integer, character varying, character varying, character varying) RETURNS integer
    LANGUAGE javau
    AS $$
br.com.aptare.a2pg.MensagemSms.mandarMensagens
$$;


ALTER FUNCTION sc_msg.mandarmensagens(integer[], bigint[], integer[], integer[], character varying[], character varying[], integer, character varying, character varying, character varying) OWNER TO scan;

--
-- TOC entry 1239 (class 1255 OID 564451)
-- Name: mandarmensagens_OLD(bigint[], integer[], integer[], character varying[], integer, character varying, character varying); Type: FUNCTION; Schema: sc_msg; Owner: scan
--

CREATE FUNCTION "mandarmensagens_OLD"(bigint[], integer[], integer[], character varying[], integer, character varying, character varying) RETURNS integer
    LANGUAGE javau
    AS $$br.com.aptare.a2pg.MensagemSms.mandarMensagens$$;


ALTER FUNCTION sc_msg."mandarmensagens_OLD"(bigint[], integer[], integer[], character varying[], integer, character varying, character varying) OWNER TO scan;

--
-- TOC entry 1245 (class 1255 OID 1624601)
-- Name: mandarmensagens_OLD2(integer[], bigint[], integer[], integer[], character varying[], character varying[], integer, character varying, character varying); Type: FUNCTION; Schema: sc_msg; Owner: scan
--

CREATE FUNCTION "mandarmensagens_OLD2"(integer[], bigint[], integer[], integer[], character varying[], character varying[], integer, character varying, character varying) RETURNS integer
    LANGUAGE javau
    AS $$
br.com.aptare.a2pg.MensagemSms.mandarMensagens
$$;


ALTER FUNCTION sc_msg."mandarmensagens_OLD2"(integer[], bigint[], integer[], integer[], character varying[], character varying[], integer, character varying, character varying) OWNER TO scan;

--
-- TOC entry 1480 (class 1255 OID 1041571)
-- Name: sonda(); Type: FUNCTION; Schema: sc_msg; Owner: scan
--

CREATE FUNCTION sonda() RETURNS void
    LANGUAGE plpgsql
    AS $$declare


rg record;
vl_sql varchar;
vl_separador varchar := '';
_conn varchar;
vl_existe numeric;
vl_entrou boolean := false;

begin

  -- enquanto nao libera para aptare direto
  _conn := 'host=b4b.aptare.com.br port=5432 dbname=sms user=sms password=sms';
  vl_sql := 'select nsu_org_msn, dt_inc_msn from tbl_msn where cd_cli = 13 and nsu_org_msn in (';
 
  for rg in select cd_msg
             from sc_msg.tbl_msg
             where fg_atv_msg = 'S'
               and fg_env_msg = 'N'
               and dt_inc_usr >= dt_inc_usr - interval '2 hour'
             order by cd_msg loop

        -- enquanto nao libera para aptare direto 
        vl_sql := vl_sql || vl_separador || rg.cd_msg;
        vl_separador := ',';     

        vl_entrou := true;

  end loop;

  if vl_entrou then
    vl_sql := vl_sql || ')';

    raise notice '%', vl_sql;

    for rg in select * from dblink( _conn, vl_sql) as r(nsu_org_msn numeric, dt_inc_msn timestamp) loop

       --raise notice 'existe %,%', rg.nsu_org_msn, rg.dt_inc_msn;
       update sc_msg.tbl_msg set fg_env_msg = 'S', dt_env_msg = rg.dt_inc_msn where cd_msg = rg.nsu_org_msn;

    end loop;
    
  end if;

end$$;


ALTER FUNCTION sc_msg.sonda() OWNER TO scan;

--
-- TOC entry 1536 (class 1255 OID 862129)
-- Name: validar_codigo_validacao(numeric, numeric, character varying); Type: FUNCTION; Schema: sc_msg; Owner: scan
--

CREATE FUNCTION validar_codigo_validacao(vp_tipo numeric, vp_nsu numeric, vp_codigo_validacao character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

  -- constantes
  situacao_cadastrado constant numeric := 1;
  situacao_validado constant numeric := 2;
  situacao_invalidado constant numeric := 3;

  tipo_sms_saque_facil constant numeric := 7;

  -- variaveis pra mandar a mensagem
  vl_codigo numeric;
  vl_codigo_validacao varchar;
  vl_intervalo varchar;
  vl_data_exp timestamp;
  vl_existe numeric;

  vl_codigo_sms numeric;
  
begin

  -- validando o codigo informado
  select cd_cvm, cd_vld_cvm, dt_exp_vld_cvm
  into vl_codigo, vl_codigo_validacao, vl_data_exp
    from sc_msg.tbl_cvm 
  where tp_org_cvm = vp_tipo
    and nsu_org_cvm = vp_nsu
    and st_cvm = situacao_cadastrado;

  if vl_data_exp >= clock_timestamp() then

    if vl_codigo_validacao = vp_codigo_validacao then

      update sc_msg.tbl_cvm
        set st_cvm = situacao_validado,
            dt_st_cvm = clock_timestamp()
      where cd_cvm = vl_codigo;      
    
      return 'S';
    else
      return 'N';  
    end if;
    
  else

    update sc_msg.tbl_cvm
        set st_cvm = situacao_invalidado,
            dt_st_cvm = clock_timestamp()
      where cd_cvm = vl_codigo;
  
    return 'O código informado expirou. Favor solicite um novo código de validação.';
  end if; 

  return 'N';
  
end;$$;


ALTER FUNCTION sc_msg.validar_codigo_validacao(vp_tipo numeric, vp_nsu numeric, vp_codigo_validacao character varying) OWNER TO scan;

SET search_path = sc_opr, pg_catalog;

--
-- TOC entry 1853 (class 1255 OID 564452)
-- Name: altera_limite_cartao(numeric, numeric, numeric, character varying); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION altera_limite_cartao(vp_crt numeric, vp_tlt numeric, vp_valor numeric, vp_historico character varying) RETURNS void
    LANGUAGE plpgsql
    AS $_$declare
  vl_existe_limite numeric;
  vl_existe_limite_saque_extra numeric;
  vl_valor_antigo numeric := 0;
  vl_valor_maximo numeric := 0;
  vl_valor_minimo numeric := 0;
  vl_tipo_limite varchar(40);

  vl_empresa numeric := 0;

  ct_tp_ocr_alteracao_limite constant numeric := 4;
  ct_tp_limite_saque_extra constant numeric := 1;
  ct_tp_limite_compra constant numeric := 2;
  ct_empresa_soma constant numeric := 29;

  ct_msg_erro_limite_compra varchar := 'O limite de COMPRA não pode ser maior que 30% do valor do limite de SAQUE EXTRA';

begin

  -- verificando se a alteracao é no limite de SAQUE EXTRA
  ----- se for, deverá verificar no contrato vinculado ao cartao, se tem valor maximo e valor minimo do saque extra
  ----- se tiver, validar se o valor informado esta dentro do maximo e minimo definido no contrato
  --Comentando a validacao de tipo de limite para o sistema considerar o mesmo valor máximo de limite para todos os tipos de limite
  if /*vp_tlt = ct_tp_limite_saque_extra and*/ vp_valor > 0 then

    select fnc.cd_emp
      into vl_empresa
    from sc_opr.tbl_crt crt
         inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
    where crt.cd_crt = vp_crt;

    if vl_empresa = ct_empresa_soma or vp_tlt = ct_tp_limite_saque_extra then
      vl_valor_maximo := replace(replace(sc_cad.get_parametro_contrato_cartao(25, vp_crt),'.',''), ',', '.')::numeric;
      vl_valor_minimo := replace(replace(sc_cad.get_parametro_contrato_cartao(26, vp_crt),'.',''), ',', '.')::numeric;
    
      /*
      select replace(replace(pc.vl_pce_ctr,'.',''), ',', '.')::numeric
        into vl_valor_maximo
      from sc_opr.tbl_crt crt
	   inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
	   inner join sc_cad.tbl_pce_ctr pc on pc.cd_ctr = ctr.cd_ctr
      where crt.cd_crt = vp_crt
        and pc.cd_pce = 25;

      select replace(replace(pc.vl_pce_ctr,'.',''), ',', '.')::numeric
        into vl_valor_minimo
      from sc_opr.tbl_crt crt
	   inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
	   inner join sc_cad.tbl_pce_ctr pc on pc.cd_ctr = ctr.cd_ctr
      where crt.cd_crt = vp_crt
        and pc.cd_pce = 26;
      */  

      if vl_valor_maximo is not null and vl_valor_maximo > 0 and vp_valor > vl_valor_maximo then  
        vp_valor := vl_valor_maximo;
      end if;

      if vl_valor_minimo is not null and vp_valor < vl_valor_minimo then  
        vp_valor := vl_valor_minimo;
      end if; 
    end if;
  end if;

  /*if vp_tlt = ct_tp_limite_compra and vp_valor > 0 then

    -- caso o cartao possua limite de saque extra
    -- verifica se o valor é maior que 30% do limite do saque extra
    select count(*)
      into vl_existe_limite_saque_extra
    from sc_opr.tbl_lmt
    where cd_crt = vp_crt
      and cd_tlt = ct_tp_limite_saque_extra
      and vl_cnc_lmt * .3 < vp_valor;

    if vl_existe_limite_saque_extra > 0 then
    
       raise exception '%', ct_msg_erro_limite_compra;
   
    end if;

  end if;*/

  -- verificar se o cartao tem o tipo de limite que deve ser alterado
  select count(*)
    into vl_existe_limite
  from sc_opr.tbl_lmt
  where cd_crt = vp_crt
    and cd_tlt = vp_tlt;
    
  --se existir, proceder com a atualizacao
  if vl_existe_limite > 0 then
    --obtendo o valor antigo para poder gravar o historico de alteracao
    select vl_cnc_lmt
      into vl_valor_antigo
    from sc_opr.tbl_lmt
    where cd_crt = vp_crt
      and cd_tlt = vp_tlt;

    --realizando a alteracao de limite
    update sc_opr.tbl_lmt 
       set vl_cnc_lmt = coalesce(vp_valor,0)
    where cd_crt = vp_crt
      and cd_tlt = vp_tlt;
  else
    --senÃ£o existir incluir o limite para o cartao
    insert into sc_opr.tbl_lmt (cd_crt, cd_tlt, vl_cnc_lmt, vl_utl_lmt)
    values (vp_crt, vp_tlt, coalesce(vp_valor,0), 0);
  end if;

  if vl_valor_antigo is not null and vl_valor_antigo <> coalesce(vp_valor,0) then

          --retornando o tipo de limite
          select nm_tlt
           into vl_tipo_limite
          from sc_opr.tbl_tlt
           where cd_tlt = vp_tlt; 

	  --gravando o historico de alteracao de limite
	  insert into sc_opr.tbl_hlm (cd_hlm, cd_crt, cd_tlt, vl_cnc_lmt_ant, vl_cnc_lmt_atl, cd_inc_usr, dt_inc_usr)
	  values (nextval('sc_opr.sq_hlm'), vp_crt, vp_tlt, vl_valor_antigo, coalesce(vp_valor,0), 1, now());

	  --gravando ocorrencia de cartao de alteracao de limite
	  vp_historico := vp_historico || '.\n' || vl_tipo_limite || ' - VALOR ANTERIOR: R$ ' || TRUNC(vl_valor_antigo, 2) || ' / VALOR ATUAL: R$ ' || TRUNC(coalesce(vp_valor,0), 2);
	  
	  insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr)
		values (nextval('sc_opr.sq_ocr'), ct_tp_ocr_alteracao_limite, vp_crt, vp_historico, 'S', 1, now());
  end if;		
end;$_$;


ALTER FUNCTION sc_opr.altera_limite_cartao(vp_crt numeric, vp_tlt numeric, vp_valor numeric, vp_historico character varying) OWNER TO scan;

--
-- TOC entry 7828 (class 0 OID 0)
-- Dependencies: 1853
-- Name: FUNCTION altera_limite_cartao(vp_crt numeric, vp_tlt numeric, vp_valor numeric, vp_historico character varying); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION altera_limite_cartao(vp_crt numeric, vp_tlt numeric, vp_valor numeric, vp_historico character varying) IS 'rotina que altera o limite de um determinado cartao, de um determinado tipo de limite, gravando historico de alteracao e ocorrencia de cartao';


--
-- TOC entry 1783 (class 1255 OID 1649228)
-- Name: altera_limite_cartao_manual(numeric, numeric, numeric, character varying, character varying); Type: FUNCTION; Schema: sc_opr; Owner: postgres
--

CREATE FUNCTION altera_limite_cartao_manual(vp_crt numeric, vp_tlt numeric, vp_valor numeric, vp_historico character varying, vp_alt_lmt character varying) RETURNS void
    LANGUAGE plpgsql
    AS $_$declare
  
  vl_existe_limite numeric;
  vl_existe_limite_saque_extra numeric;
  vl_valor_antigo numeric := 0;
  vl_valor_maximo numeric := 0;
  vl_valor_minimo numeric := 0;
  vl_tipo_limite varchar(40);

  ct_tp_ocr_alteracao_limite constant numeric := 4;
  ct_tp_limite_saque_extra constant numeric := 1;
  ct_tp_limite_compra constant numeric := 2;

  ct_msg_erro_limite_compra varchar := 'O limite de COMPRA não pode ser maior que 30% do valor do limite de SAQUE EXTRA';

begin

  -- verificando se a alteracao é no limite de SAQUE EXTRA
  ----- se for, deverá verificar no contrato vinculado ao cartao, se tem valor maximo e valor minimo do saque extra
  ----- se tiver, validar se o valor informado esta dentro do maximo e minimo definido no contrato
  if vp_tlt = ct_tp_limite_saque_extra and vp_valor > 0 then

    vl_valor_maximo := replace(replace(sc_cad.get_parametro_contrato_cartao(25, vp_crt),'.',''), ',', '.')::numeric;
    vl_valor_minimo := replace(replace(sc_cad.get_parametro_contrato_cartao(26, vp_crt),'.',''), ',', '.')::numeric;
    
    /*
    select replace(replace(pc.vl_pce_ctr,'.',''), ',', '.')::numeric
      into vl_valor_maximo
    from sc_opr.tbl_crt crt
	inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
	inner join sc_cad.tbl_pce_ctr pc on pc.cd_ctr = ctr.cd_ctr
    where crt.cd_crt = vp_crt
      and pc.cd_pce = 25;

    select replace(replace(pc.vl_pce_ctr,'.',''), ',', '.')::numeric
      into vl_valor_minimo
    from sc_opr.tbl_crt crt
	inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
	inner join sc_cad.tbl_pce_ctr pc on pc.cd_ctr = ctr.cd_ctr
    where crt.cd_crt = vp_crt
      and pc.cd_pce = 26;
    */  

    if vl_valor_maximo is not null and vl_valor_maximo > 0 and vp_valor > vl_valor_maximo and vp_alt_lmt = 'S' then  
      vp_valor := vl_valor_maximo;
    end if;

    if vl_valor_minimo is not null and vp_valor < vl_valor_minimo then  
      vp_valor := vl_valor_minimo;
    end if; 
  end if;

  if vp_tlt = ct_tp_limite_compra and vp_valor > 0 then

    -- caso o cartao possua limite de saque extra
    -- verifica se o valor é maior que 30% do limite do saque extra
    select count(*)
      into vl_existe_limite_saque_extra
    from sc_opr.tbl_lmt
    where cd_crt = vp_crt
      and cd_tlt = ct_tp_limite_saque_extra
      and vl_cnc_lmt * .3 < vp_valor;

    if vl_existe_limite_saque_extra > 0 then
    
       raise exception '%', ct_msg_erro_limite_compra;
   
    end if;

  end if;

  -- verificar se o cartao tem o tipo de limite que deve ser alterado
  select count(*)
    into vl_existe_limite
  from sc_opr.tbl_lmt
  where cd_crt = vp_crt
    and cd_tlt = vp_tlt;
    
  --se existir, proceder com a atualizacao
  if vl_existe_limite > 0 then
    --obtendo o valor antigo para poder gravar o historico de alteracao
    select vl_cnc_lmt
      into vl_valor_antigo
    from sc_opr.tbl_lmt
    where cd_crt = vp_crt
      and cd_tlt = vp_tlt;

    --realizando a alteracao de limite
    update sc_opr.tbl_lmt 
       set vl_cnc_lmt = coalesce(vp_valor,0), fg_alt_lmt = vp_alt_lmt
    where cd_crt = vp_crt
      and cd_tlt = vp_tlt;
  else
    --senão existir incluir o limite para o cartao
    insert into sc_opr.tbl_lmt (cd_crt, cd_tlt, vl_cnc_lmt, vl_utl_lmt, fg_alt_lmt)
    values (vp_crt, vp_tlt, coalesce(vp_valor,0), 0, vp_alt_lmt);
  end if;

  if vl_valor_antigo is not null and vl_valor_antigo <> coalesce(vp_valor,0) then

          --retornando o tipo de limite
          select nm_tlt
           into vl_tipo_limite
          from sc_opr.tbl_tlt
           where cd_tlt = vp_tlt; 

	  --gravando o historico de alteracao de limite
	  insert into sc_opr.tbl_hlm (cd_hlm, cd_crt, cd_tlt, vl_cnc_lmt_ant, vl_cnc_lmt_atl, cd_inc_usr, dt_inc_usr)
	  values (nextval('sc_opr.sq_hlm'), vp_crt, vp_tlt, vl_valor_antigo, coalesce(vp_valor,0), 1, now());

	  --gravando ocorrencia de cartao de alteracao de limite
	  vp_historico := vp_historico || '.\n' || vl_tipo_limite || ' - VALOR ANTERIOR: R$ ' || TRUNC(vl_valor_antigo, 2) || ' / VALOR ATUAL: R$ ' || TRUNC(coalesce(vp_valor,0), 2);
	  
	  insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr)
		values (nextval('sc_opr.sq_ocr'), ct_tp_ocr_alteracao_limite, vp_crt, vp_historico, 'S', 1, now());
  end if;		
end;$_$;


ALTER FUNCTION sc_opr.altera_limite_cartao_manual(vp_crt numeric, vp_tlt numeric, vp_valor numeric, vp_historico character varying, vp_alt_lmt character varying) OWNER TO postgres;

--
-- TOC entry 1387 (class 1255 OID 564453)
-- Name: ativar_cartao(numeric, numeric, character varying); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION ativar_cartao(vp_codigo_cartao numeric, vp_usuario numeric, vp_historico character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  CT_TIPO_OCORRENCIA_ATIVACAO_CARTAO  numeric := 11;
  CT_SIT_FUNCIONARIO_DEMITIDO  	      numeric := 2;

  vl_cartao	numeric := 0;
  vl_situacao_funcionario numeric := 1;
  vl_historico  varchar;
begin

  -- verificando se existe o cartao informado e se o mesmo esta realmente inativo
  select cd_crt 
    into vl_cartao
  from sc_opr.tbl_crt 
  where cd_crt = vp_codigo_cartao
    and fg_atv_crt = 'N';

  if vl_cartao is null then
     raise 'Não foi possível encontrar o cartão ou o cartão informado não está INATIVO';
  end if; 

  -- verificando se o funcionario do cartao a ser ativado esta como DEMITIDO
  select fnc.st_fnc 
    into vl_situacao_funcionario
  from sc_opr.tbl_crt crt
	inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
  where crt.cd_crt = vp_codigo_cartao;
       
  if vl_situacao_funcionario in (CT_SIT_FUNCIONARIO_DEMITIDO) then
     raise 'Não é possível ativar o cartão pois o funcionário está DEMITIDO.';
  end if;

  if vp_historico is null or vp_historico = '' then
    vl_historico := 'CARTAO FOI ATIVADO POIS VOLTOU A RECEBER DEPOSITO';
  else
    vl_historico := vp_historico;
  end if;

  -- atualizando o cartao
  update sc_opr.tbl_crt set fg_atv_crt = 'S' where cd_crt = vp_codigo_cartao;

  -- gravando a ocorrencia
  insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		     values (nextval('sc_opr.sq_ocr'), CT_TIPO_OCORRENCIA_ATIVACAO_CARTAO, vp_codigo_cartao, null, 
				 vl_historico, 'N', vp_usuario, now());

  
end;$$;


ALTER FUNCTION sc_opr.ativar_cartao(vp_codigo_cartao numeric, vp_usuario numeric, vp_historico character varying) OWNER TO scan;

--
-- TOC entry 7829 (class 0 OID 0)
-- Dependencies: 1387
-- Name: FUNCTION ativar_cartao(vp_codigo_cartao numeric, vp_usuario numeric, vp_historico character varying); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION ativar_cartao(vp_codigo_cartao numeric, vp_usuario numeric, vp_historico character varying) IS 'rotina que ativa e grava ocorrencia de um determinado cartao inativo';


--
-- TOC entry 1391 (class 1255 OID 564454)
-- Name: atualiza_campanha_promocional(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION atualiza_campanha_promocional() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;
begin

   -- retirando os cartoes pertencentes a tabela de tarifa da campanha por terem efetuado o primeiro saque extra
   -- desconsidera os funcionarios da administracao da SCOPA
   update sc_opr.tbl_crt set cd_tvt = 1
     where cd_crt in (
         select distinct pls.cd_crt from sc_opr.tbl_pls pls
            inner join sc_opr.tbl_opr opr on opr.cd_pls = pls.cd_pls
            inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
            inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
          where crt.cd_tvt = 3
            and opr.cd_top = 5
            and opr.st_opr = 2
            and (fnc.cd_emp <> 1142 or fnc.cd_fem <> 1)
         );

   -- inserindo cartoes na tabela de campanha para incentivar o uso do saque extra
   update sc_opr.tbl_crt set cd_tvt = 3 where cd_crt in (
     select distinct lmt.cd_crt as cartao
       from sc_opr.tbl_lmt lmt
       inner join sc_opr.tbl_pls pls on pls.cd_crt = lmt.cd_crt
       inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
     where lmt.vl_cnc_lmt - lmt.vl_utl_lmt > 0
       and lmt.cd_tlt = 1
       and crt.cd_tvt = 1
       and crt.fg_atv_crt = 'S'
       and crt.fg_ind_crt = 'N'
       and exists (select 1 from sc_opr.tbl_hlm hlm where hlm.cd_crt = pls.cd_crt and hlm.dt_inc_usr <= current_date - 60)
       and not exists (select 1 from sc_opr.tbl_opr opr inner join sc_opr.tbl_pls pls on opr.cd_pls = pls.cd_pls where pls.cd_crt = lmt.cd_crt and opr.cd_top = 5 and opr.st_opr = 2)
       and sc_opr.autoriza_tipo_operacao_cartao(pls.cd_crt,5) = true
   );    
  
end;$$;


ALTER FUNCTION sc_opr.atualiza_campanha_promocional() OWNER TO scan;

--
-- TOC entry 1393 (class 1255 OID 564455)
-- Name: atualiza_cartao_padrao(numeric, numeric); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION atualiza_cartao_padrao(vp_plastico numeric, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_cartao 		numeric;
  vl_cad_unico		numeric;
  vl_cartao_padrao 	numeric;
  vl_historico		text;
  

  TP_OCR_INCLUSAO_CARTAO_PADRAO sc_opr.tbl_top.cd_top%type := 9;
  TP_OCR_EXCLUSAO_CARTAO_PADRAO sc_opr.tbl_top.cd_top%type := 10; 
begin

   -- verificando o numero do cartao do plastico que foi passado
   begin
     select crt.cd_crt, cun.cd_cun, cun.cd_crt
	  into vl_cartao, vl_cad_unico, vl_cartao_padrao
     from sc_opr.tbl_pls pls
	inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
	inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
     where pls.cd_pls = vp_plastico;  
         
   exception when others THEN
        raise notice 'Não foi possível obter o número do cartão';
   end;

   if vl_cartao = vl_cartao_padrao then
     -- no caso, irá retirar o cartao enviado como cartao padrao
	  -- 1. gravando ocorrencia de exclusao de cartao padrao
	 insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, 
				nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
	      values (nextval('sc_opr.sq_ocr'), TP_OCR_EXCLUSAO_CARTAO_PADRAO, vl_cartao, null,
			 'O CLIENTE NÃO POSSUI MAIS CARTÃO PADRÃO.', 'N', vp_usuario, now());
	  
	  -- 2. desmarcando o cartao padrao 
	  update sc_cad.tbl_cun  set cd_crt = null where cd_cun = vl_cad_unico;
   else
     -- no caso, o cartão enviado irá ser o cartão padrão
     /*
	 if vl_cartao_padrao is not null then
		insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, 
				nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
	              values (nextval('sc_opr.sq_ocr'), TP_OCR_EXCLUSAO_CARTAO_PADRAO, vl_cartao_padrao, null,
			        'EXCLUSAO DO CARTAO PADRAO. ATUAL: ' || vl_cartao, 'N', vp_usuario, now());

		vl_historico := 'INCLUSAO DO CARTAO PADRAO. ANTERIOR: ' || vl_cartao_padrao;
	 else
		vl_historico := 'INCLUSAO DO CARTAO PADRAO. ';
	 end if;
	 insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, 
				nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
	      values (nextval('sc_opr.sq_ocr'), TP_OCR_INCLUSAO_CARTAO_PADRAO, vl_cartao, null,
			 vl_historico, 'N', vp_usuario, now());
	
         --NAO SERA FEITO MAIS NENHUM CARTAO PADRAO
	 --update sc_cad.tbl_cun  set cd_crt = vl_cartao where cd_cun = vl_cad_unico;
     */
     raise 'Não é mais permitido cadastrar cartão padrão.';
   end if;
  
end;$$;


ALTER FUNCTION sc_opr.atualiza_cartao_padrao(vp_plastico numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 7830 (class 0 OID 0)
-- Dependencies: 1393
-- Name: FUNCTION atualiza_cartao_padrao(vp_plastico numeric, vp_usuario numeric); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION atualiza_cartao_padrao(vp_plastico numeric, vp_usuario numeric) IS 'rotina que atualiza o cartão padrão e grava ocorrência';


--
-- TOC entry 1394 (class 1255 OID 564456)
-- Name: atualiza_contrato_cartao(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION atualiza_contrato_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;
begin
  for vl_rg in select crt.cd_crt as cartao, crt.cd_ctr as cartao_contrato, ctr.cd_ctr as contrato
               from sc_cad.tbl_fnc fnc
                 inner join sc_cad.tbl_fem_ctr ctr on ctr.cd_emp = fnc.cd_emp and fnc.cd_fem = ctr.cd_fem
                 inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
               where crt.cd_ctr <> ctr.cd_ctr
                 and fg_atv_fem_ctr = 'S' loop
               
    update sc_opr.tbl_crt set
      cd_ctr = vl_rg.contrato
    where cd_crt = vl_rg.cartao;

  end loop;
end;$$;


ALTER FUNCTION sc_opr.atualiza_contrato_cartao() OWNER TO scan;

--
-- TOC entry 1811 (class 1255 OID 1652443)
-- Name: atualiza_limite_cartao(numeric, numeric, double precision, character varying); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION atualiza_limite_cartao(vp_crt numeric, vp_tlt numeric, vp_prc double precision, vp_historico character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_valor_atualizar numeric;
  
  vl_valor_antigo numeric;
  vl_valor_variacao numeric;

  ct_tp_ocr_alteracao_limite constant numeric := 4;

  vl_valor_maximo numeric := 0;
  vl_valor_minimo numeric := 0;
  vl_tem_idade_suficiente numeric := 0;

begin

    if vp_historico is not null then
      vp_historico := '. ' || vp_historico; 
    end if;

    if vp_prc > 0 then
       -- calculando o valor da media de deposito dos ultimos tres meses
       vl_valor_atualizar := coalesce(sc_adp.valor_media_abastecimento_cartao(vp_crt), 0);

       -- calculando o valor do novo limite
       vl_valor_atualizar := round((vl_valor_atualizar * (vp_prc / 100))::numeric, -1);

       -- VERIFICANDO IDADE
       -- SOMENTE LIBERAR PARA IDADES ENTRE 18 E 99
       select count(*)
       into vl_tem_idade_suficiente
       from sc_opr.tbl_crt crt
          inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
          inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
          left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
       where (cpf.cd_cun is null or
              (EXTRACT( YEAR FROM AGE(cpf.dt_nsc_cpf)) between 18 and 99 ))
         and crt.cd_crt = vp_crt;

       if vl_tem_idade_suficiente = 0 then
          vl_valor_atualizar := 0;
       end if;  
          
          

       -- validando variacao de limite via parametro
       -- caso o limite venha a variar a menor no valor do parametro definido mesmo nao sofrera alteracao
       begin
         select coalesce(lmt.vl_cnc_lmt,0), coalesce(tlt.vl_var_tlt,0)
	   into vl_valor_antigo, vl_valor_variacao
         from sc_opr.tbl_lmt lmt
	   inner join sc_opr.tbl_tlt tlt on tlt.cd_tlt = lmt.cd_tlt
         where lmt.cd_crt = vp_crt
	   and lmt.cd_tlt = vp_tlt;
    
       exception
          when others then
       
	vl_valor_antigo := 0;  
	vl_valor_variacao := 0;       

       end;

       if vl_valor_atualizar > 0 then

         vl_valor_maximo := replace(replace(sc_cad.get_parametro_contrato_cartao(25, vp_crt),'.',''), ',', '.')::numeric;
         --vl_valor_minimo := replace(replace(sc_cad.get_parametro_contrato_cartao(26, vp_crt),'.',''), ',', '.')::numeric;

         vl_valor_maximo := coalesce(vl_valor_maximo,0);
       
         if (abs(vl_valor_atualizar - vl_valor_antigo) > vl_valor_variacao) 
            or vl_valor_atualizar > vl_valor_antigo
            or vl_valor_atualizar >= vl_valor_maximo then
            
	    --realizando a alteracao de limite no banco
	    perform sc_opr.altera_limite_cartao(vp_crt, vp_tlt, vl_valor_atualizar, 'ATUALIZACAO AUTOMATICA DE LIMITE' || coalesce(vp_historico,''));
         end if;

       end if;   

       if vl_valor_atualizar = 0 and vl_valor_antigo > 0 then
           perform sc_opr.altera_limite_cartao(vp_crt, vp_tlt, vl_valor_atualizar, 'ATUALIZACAO AUTOMATICA DE LIMITE - MEDIA ZERADA SOBRE VALOR CONCEDIDO' || coalesce(vp_historico,''));
       end if;
   else
     -- no caso de ZERAR o limite do cartão
     vl_valor_atualizar := 0;
     perform sc_opr.altera_limite_cartao(vp_crt, vp_tlt, vl_valor_atualizar, 'ATUALIZACAO AUTOMATICA DE LIMITE - ZERANDO O LIMITE' || coalesce(vp_historico,''));
   end if;

end;$$;


ALTER FUNCTION sc_opr.atualiza_limite_cartao(vp_crt numeric, vp_tlt numeric, vp_prc double precision, vp_historico character varying) OWNER TO scan;

--
-- TOC entry 7831 (class 0 OID 0)
-- Dependencies: 1811
-- Name: FUNCTION atualiza_limite_cartao(vp_crt numeric, vp_tlt numeric, vp_prc double precision, vp_historico character varying); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION atualiza_limite_cartao(vp_crt numeric, vp_tlt numeric, vp_prc double precision, vp_historico character varying) IS 'rotina que atualiza o limite de um determinado cartao, de um determinado tipo de limite, aplicando um percentual informado sobre a media de depositos dos ultimos três meses';


--
-- TOC entry 1749 (class 1255 OID 564457)
-- Name: atualiza_limite_cartao_OLD(numeric, numeric, double precision); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION "atualiza_limite_cartao_OLD"(vp_crt numeric, vp_tlt numeric, vp_prc double precision) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_valor_atualizar numeric;
  
  vl_valor_antigo numeric;
  vl_valor_variacao numeric;

  ct_tp_ocr_alteracao_limite constant numeric := 4;

  vl_valor_maximo numeric := 0;
  vl_valor_minimo numeric := 0;
  vl_tem_idade_suficiente numeric := 0;
begin

    if vp_prc > 0 then
       -- calculando o valor da media de deposito dos ultimos tres meses
       vl_valor_atualizar := coalesce(sc_adp.valor_media_abastecimento_cartao(vp_crt), 0);

       -- calculando o valor do novo limite
       vl_valor_atualizar := round((vl_valor_atualizar * (vp_prc / 100))::numeric, -1);

       -- VERIFICANDO IDADE
       -- SOMENTE LIBERAR PARA IDADES ENTRE 18 E 99
       select count(*)
       into vl_tem_idade_suficiente
       from sc_opr.tbl_crt crt
          inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
          inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
          left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
       where (cpf.cd_cun is null or
              (EXTRACT( YEAR FROM AGE(cpf.dt_nsc_cpf)) between 18 and 99 ))
         and crt.cd_crt = vp_crt;

       if vl_tem_idade_suficiente = 0 then
          vl_valor_atualizar := 0;
       end if;  
          
          

       -- validando variacao de limite via parametro
       -- caso o limite venha a variar a menor no valor do parametro definido mesmo nao sofrera alteracao
       begin
         select coalesce(lmt.vl_cnc_lmt,0), coalesce(tlt.vl_var_tlt,0)
	   into vl_valor_antigo, vl_valor_variacao
         from sc_opr.tbl_lmt lmt
	   inner join sc_opr.tbl_tlt tlt on tlt.cd_tlt = lmt.cd_tlt
         where lmt.cd_crt = vp_crt
	   and lmt.cd_tlt = vp_tlt;
    
       exception
          when others then
       
	vl_valor_antigo := 0;  
	vl_valor_variacao := 0;       

       end;

       if vl_valor_atualizar > 0 then

         vl_valor_maximo := replace(replace(sc_cad.get_parametro_contrato_cartao(25, vp_crt),'.',''), ',', '.')::numeric;
         --vl_valor_minimo := replace(replace(sc_cad.get_parametro_contrato_cartao(26, vp_crt),'.',''), ',', '.')::numeric;

         vl_valor_maximo := coalesce(vl_valor_maximo,0);
       
         if (abs(vl_valor_atualizar - vl_valor_antigo) > vl_valor_variacao) 
            or vl_valor_atualizar > vl_valor_antigo
            or vl_valor_atualizar >= vl_valor_maximo then
            
	    --realizando a alteracao de limite no banco
	    perform sc_opr.altera_limite_cartao(vp_crt, vp_tlt, vl_valor_atualizar, 'ATUALIZACAO AUTOMATICA DE LIMITE');
         end if;

       end if;   

       if vl_valor_atualizar = 0 and vl_valor_antigo > 0 then
           perform sc_opr.altera_limite_cartao(vp_crt, vp_tlt, vl_valor_atualizar, 'ATUALIZACAO AUTOMATICA DE LIMITE - MEDIA ZERADA SOBRE VALOR CONCEDIDO');
       end if;
   else
     -- no caso de ZERAR o limite do cartão
     vl_valor_atualizar := 0;
     perform sc_opr.altera_limite_cartao(vp_crt, vp_tlt, vl_valor_atualizar, 'ATUALIZACAO AUTOMATICA DE LIMITE - ZERANDO O LIMITE');
   end if;

end;$$;


ALTER FUNCTION sc_opr."atualiza_limite_cartao_OLD"(vp_crt numeric, vp_tlt numeric, vp_prc double precision) OWNER TO scan;

--
-- TOC entry 7832 (class 0 OID 0)
-- Dependencies: 1749
-- Name: FUNCTION "atualiza_limite_cartao_OLD"(vp_crt numeric, vp_tlt numeric, vp_prc double precision); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION "atualiza_limite_cartao_OLD"(vp_crt numeric, vp_tlt numeric, vp_prc double precision) IS 'rotina que atualiza o limite de um determinado cartao, de um determinado tipo de limite, aplicando um percentual informado sobre a media de depositos dos ultimos três meses';


--
-- TOC entry 1396 (class 1255 OID 564458)
-- Name: atualiza_limite_cartao_padrao2(date); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION atualiza_limite_cartao_padrao2(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;

  ct_tp_ocr_alteracao_limite constant numeric := 4;

  vl_valor_antigo numeric;
  vl_valor_novo numeric;
  vl_percentual numeric;
begin
  for vl_rg in select cun.cd_crt, fnc.cd_emp, fnc.cd_fem, lmt.cd_tlt, sum(case when crt.cd_crt <> cun.cd_crt then lmt.vl_cnc_lmt else 0 end) as vl_outros_cartoes
               from sc_opr.tbl_lmt lmt
                    inner join sc_opr.tbl_crt crt on lmt.cd_crt = crt.cd_crt
                    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc 
                    inner join sc_cad.tbl_cun cun on fnc.cd_cun = cun.cd_cun
               where cun.cd_crt is not null
                 and crt.dt_pri_dps_crt < current_date - interval '90 day'
                 and exists (select 1
                             from sc_opr.tbl_hlm hlm
                                  inner join sc_opr.tbl_crt crt2 on hlm.cd_crt = crt2.cd_crt
                                  inner join sc_cad.tbl_fnc fnc2 on fnc2.cd_fnc = crt2.cd_fnc 
                             where fnc2.cd_cun = cun.cd_cun
                               and hlm.dt_inc_usr >= vp_data_referencia
                               and hlm.dt_inc_usr < vp_data_referencia + interval '1 day')
               group by cun.cd_crt, fnc.cd_emp, fnc.cd_fem, lmt.cd_tlt
               having round(sum(lmt.vl_cnc_lmt), -1) > 0  loop
    --obtendo o percentual a ser aplicado sobre a media de deposito
    select pr_lmt
    into vl_percentual
    from sc_cad.tbl_tlt_ctr ctr
         inner join sc_opr.tbl_fem_crt f on f.cd_fem_ctr = ctr.cd_fem_ctr
    where crt.cd_crt = vl_rg.cd_crt
      and f.cd_emp = vl_rg.cd_emp
      and f.cd_fem = vl_rg.cd_fem
      and ctr.cd_tlt = vl_rg.cd_tlt;
      
    --calculando a media de deposito de salario do cartao padrao atual
    vl_valor_novo := (vl_percentual/100) * coalesce(sc_adp.valor_media_abastecimento_cartao(vl_rg.cd_crt), 0);

    vl_valor_novo := round(vl_valor_novo + vl_rg.vl_outros_cartoes, -1);

    --alterando limite de cartao no banco de dados
    perform sc_opr.altera_limite_cartao(vl_rg.cd_crt, vl_rg.cd_tlt, vl_valor_novo, 'ATUALIZACAO DE LIMITE DE CARTAO PADRAO');
  end loop;
end;$$;


ALTER FUNCTION sc_opr.atualiza_limite_cartao_padrao2(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7833 (class 0 OID 0)
-- Dependencies: 1396
-- Name: FUNCTION atualiza_limite_cartao_padrao2(vp_data_referencia date); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION atualiza_limite_cartao_padrao2(vp_data_referencia date) IS 'rotina que obtem os clientes com cartao padrao que sofreram alteracao na data passada como parametro e efetua uma atualizacao do limite';


--
-- TOC entry 1850 (class 1255 OID 564459)
-- Name: atualiza_limite_contrato(numeric, date); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION atualiza_limite_contrato(vp_codigo_contrato numeric, vp_data_deposito date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg_ctr record;
  vl_rg_crt record;

  ct_st_depositado constant numeric = 5;
  
  ct_tdp_salario constant numeric = 1;
  ct_tdp_outros constant numeric = 8;

  vl_existe_limite_compra numeric;
begin
  --iterando sobre os tipos de limites das filiais ativas do contrato
  for vl_rg_ctr in --select cd_tlt, pr_lmt, fg_car_lmt_ctr, f.cd_fem, f.cd_emp
                   --from sc_cad.tbl_tlt_ctr tc
                   --inner join sc_cad.tbl_fem_ctr f on f.cd_fem_ctr = tc.cd_fem_ctr
                   --inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = f.cd_ctr
                   --where f.cd_ctr = vp_codigo_contrato
                    -- and f.fg_atv_fem_ctr = 'S' 

               select cd_tlt, pr_lmt, fg_car_lmt_ctr, f.cd_fem, f.cd_emp
                   from sc_cad.tbl_fem_ctr f 
                   inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = f.cd_ctr
                   left join sc_cad.tbl_tlt_ctr tc on tc.cd_fem_ctr = f.cd_fem_ctr
                   where f.cd_ctr = vp_codigo_contrato
                     and f.fg_atv_fem_ctr = 'S'

                     
  loop  
      if vp_data_deposito is not null then
        --iterando sobre os depositos realizados para os cartoes do contrato e dia passados como parametro
        for vl_rg_crt in select distinct rdp.cd_crt, lmt.cd_tlt, lmt.vl_prc_lmt
                         from sc_adp.tbl_hfe hfe
                              inner join sc_adp.tbl_rdp rdp on hfe.cd_hfe = rdp.cd_hfe
                              inner join sc_opr.tbl_crt crt on rdp.cd_crt = crt.cd_crt
                              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                              left join sc_opr.tbl_lmt lmt on lmt.cd_crt = crt.cd_crt and lmt.cd_tlt = coalesce(vl_rg_ctr.cd_tlt, lmt.cd_tlt)
                         where lmt.fg_alt_lmt = 'S'
                           and hfe.cd_ctr = vp_codigo_contrato
                           and hfe.cd_emp = vl_rg_ctr.cd_emp
                           and hfe.cd_fem = vl_rg_ctr.cd_fem
                           and hfe.st_hfe = ct_st_depositado
                           and rdp.st_rdp = ct_st_depositado
                           and rdp.cd_tdp in (ct_tdp_salario, ct_tdp_outros)
                           and hfe.dt_dps_hfe >= vp_data_deposito
                           and hfe.dt_dps_hfe < vp_data_deposito + interval '1 day'
                           and (COALESCE(fnc.dt_adm_fnc, crt.dt_pri_dps_crt) <= current_date - interval '90 day' or vl_rg_ctr.fg_car_lmt_ctr = 'N') loop
          --atualizando o limite do cartao utilizando o tipo de limite e percentual definidos no contrato
          perform sc_opr.atualiza_limite_cartao(vl_rg_crt.cd_crt, vl_rg_crt.cd_tlt, coalesce(vl_rg_crt.vl_prc_lmt,vl_rg_ctr.pr_lmt));
        end loop;
      else
        if vl_rg_ctr.pr_lmt > 0 then
          --iterando sobre todos os cartoes vinculados a empresa e filial do contrato
          for vl_rg_crt in select crt.cd_crt, lmt.cd_tlt, lmt.vl_prc_lmt
                         from sc_opr.tbl_crt crt
                            inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                            left join sc_opr.tbl_lmt lmt on lmt.cd_crt = crt.cd_crt and lmt.cd_tlt = coalesce(vl_rg_ctr.cd_tlt, lmt.cd_tlt)
                         where lmt.fg_alt_lmt = 'S'
                           and crt.cd_ctr = vp_codigo_contrato
                           and fnc.cd_emp = vl_rg_ctr.cd_emp
                           and fnc.cd_fem = vl_rg_ctr.cd_fem  
                           and (COALESCE(fnc.dt_adm_fnc, crt.dt_pri_dps_crt) <= current_date - interval '90 day' or vl_rg_ctr.fg_car_lmt_ctr = 'N') 
          loop
            --atualizando o limite do cartao utilizando o tipo de limite e percentual definidos no contrato
            perform sc_opr.atualiza_limite_cartao(vl_rg_crt.cd_crt, vl_rg_crt.cd_tlt, coalesce(vl_rg_crt.vl_prc_lmt,vl_rg_ctr.pr_lmt));
          end loop;
	else
          -- o limite da empresa foi ZERADO ou filial ainda nao possui REGISTRO DE LIMITE, logo, deverá ser ZERAR o limite de todos os cartões
	  for vl_rg_crt in select distinct crt.cd_crt as cartao, lmt.cd_tlt as tipo_limite, coalesce(lmt.vl_prc_lmt, 0) as perc_limite_cartao
			   from sc_opr.tbl_crt crt
                              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
			      left join sc_opr.tbl_lmt lmt on lmt.cd_crt = crt.cd_crt and lmt.cd_tlt = coalesce(vl_rg_ctr.cd_tlt, lmt.cd_tlt)
			   where crt.cd_ctr = vp_codigo_contrato
                             and fnc.cd_emp = vl_rg_ctr.cd_emp
                             and fnc.cd_fem = vl_rg_ctr.cd_fem
			     and lmt.vl_cnc_lmt > 0 
			     and lmt.fg_alt_lmt = 'S'
	   loop
	     -- zerando o limite do cartao utilizando o tipo de limite e percentual definidos no contrato
	     perform sc_opr.atualiza_limite_cartao(vl_rg_crt.cartao, vl_rg_crt.tipo_limite, 0);


             -- INICIO zerando o limite de compra RETIRAR DEPOIS QUE AJUSTAR
	     select count(*) 
	       into vl_existe_limite_compra 
	     from sc_opr.tbl_lmt 
	     where cd_tlt = 2 
	       and cd_crt = vl_rg_crt.cartao;

	     if vl_existe_limite_compra > 0 then
	        perform sc_opr.atualiza_limite_cartao(vl_rg_crt.cartao, 2, 0);
	     end if;
             -- FINAL zerando o limite de compra RETIRAR DEPOIS QUE AJUSTAR
             

	     -- atualizando o percentual do limite do cartao para nulo
	     if vl_rg_crt.perc_limite_cartao > 0 then
	       update sc_opr.tbl_lmt set vl_prc_lmt = null where cd_crt = vl_rg_crt.cartao and cd_tlt = vl_rg_crt.tipo_limite;
	     end if;
	   end loop;
        end if;
      end if;
  end loop;
end;$$;


ALTER FUNCTION sc_opr.atualiza_limite_contrato(vp_codigo_contrato numeric, vp_data_deposito date) OWNER TO scan;

--
-- TOC entry 7834 (class 0 OID 0)
-- Dependencies: 1850
-- Name: FUNCTION atualiza_limite_contrato(vp_codigo_contrato numeric, vp_data_deposito date); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION atualiza_limite_contrato(vp_codigo_contrato numeric, vp_data_deposito date) IS 'rotina que atualiza o limite de todos os cartoes de um determinado contrato que receberam deposito em um determinado dia (caso a data_deposito seja diferente de nulo), caso a data de depostio seja nula serão atualizados todos os cartões do contrato';


--
-- TOC entry 1397 (class 1255 OID 564460)
-- Name: atualiza_limite_dia(date); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION atualiza_limite_dia(vp_data_deposito date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg_ctr record;

  ct_st_depositado constant numeric = 5;
begin
  --obtendo todos os contratos que tiveram arquivo depositado no dia passado como parametro
  for vl_rg_ctr in select distinct hfe.cd_ctr
                     from sc_adp.tbl_hfe hfe
                     where hfe.st_hfe = ct_st_depositado
                       and hfe.dt_dps_hfe >= vp_data_deposito
                       and hfe.dt_dps_hfe < vp_data_deposito + interval '1 day' loop
      --atualizando o limite dos cartoes vinculados ao contrato
      perform sc_opr.atualiza_limite_contrato(vl_rg_ctr.cd_ctr, vp_data_deposito);
  end loop;
end;$$;


ALTER FUNCTION sc_opr.atualiza_limite_dia(vp_data_deposito date) OWNER TO scan;

--
-- TOC entry 7835 (class 0 OID 0)
-- Dependencies: 1397
-- Name: FUNCTION atualiza_limite_dia(vp_data_deposito date); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION atualiza_limite_dia(vp_data_deposito date) IS 'rotina que atualiza o limite de todos os contratos que receberam deposito em um determinado dia';


--
-- TOC entry 1398 (class 1255 OID 564461)
-- Name: atualiza_limite_job(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION atualiza_limite_job() RETURNS void
    LANGUAGE plpgsql
    AS $$begin
  perform sc_opr.atualiza_limite_dia(current_date - 1);
  --perform sc_opr.zerar_limite();
  perform sc_opr.atualiza_limite_cartao_padrao2(current_date);
end;$$;


ALTER FUNCTION sc_opr.atualiza_limite_job() OWNER TO scan;

--
-- TOC entry 7836 (class 0 OID 0)
-- Dependencies: 1398
-- Name: FUNCTION atualiza_limite_job(); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION atualiza_limite_job() IS 'rotina que sera chamada toda noite para a execucao do job de atualizacao de limite';


--
-- TOC entry 1399 (class 1255 OID 564462)
-- Name: atualiza_numero_saques_cartao(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION atualiza_numero_saques_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$begin

  if date_part('day', current_date) = 1 then
	update sc_opr.tbl_crt set qtd_saq_crt = 0;
  end if;
  
end;$$;


ALTER FUNCTION sc_opr.atualiza_numero_saques_cartao() OWNER TO scan;

--
-- TOC entry 7837 (class 0 OID 0)
-- Dependencies: 1399
-- Name: FUNCTION atualiza_numero_saques_cartao(); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION atualiza_numero_saques_cartao() IS 'zera o numero de saques por cartao no primeiro dia do mes';


--
-- TOC entry 1874 (class 1255 OID 1657044)
-- Name: atualiza_numero_saques_cartao(date); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION atualiza_numero_saques_cartao(vp_data_inicial_saque date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;
  CT_TP_LANC_SAQUE constant numeric := 13;
begin
  for vl_rg in select crt.cd_crt, sum(case when lcn.cd_lcn is null then 0 else 1 end) as qtde_correta, crt.qtd_saq_crt as qtde_atual
               from sc_opr.tbl_crt crt
                    inner join sc_opr.tbl_cnt_crt cnt_crt on crt.cd_crt = cnt_crt.cd_crt
                    left join sc_cnt.tbl_lcn lcn on cnt_crt.cd_cnt = lcn.cd_cnt and lcn.dt_ref_lcn >= vp_data_inicial_saque and lcn.cd_tlc = CT_TP_LANC_SAQUE
               --where crt.cd_crt = 62015587396176
               group by crt.cd_crt, crt.qtd_saq_crt
               having sum(case when lcn.cd_lcn is null then 0 else 1 end) <> crt.qtd_saq_crt
               limit 1000 loop
               
    raise notice 'atualizando o cartao: %, quantidade atual: %, quantidade correta: %', vl_rg.cd_crt, vl_rg.qtde_atual, vl_rg.qtde_correta;
    update sc_opr.tbl_crt set qtd_saq_crt = vl_rg.qtde_correta where cd_crt = vl_rg.cd_crt;
  end loop;
end;$$;


ALTER FUNCTION sc_opr.atualiza_numero_saques_cartao(vp_data_inicial_saque date) OWNER TO scan;

--
-- TOC entry 1648 (class 1255 OID 564463)
-- Name: autoriza_tipo_operacao_cartao(numeric, numeric); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION autoriza_tipo_operacao_cartao(vp_cartao numeric, vp_tipo_operacao numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  vl_qtd_registros  numeric;
BEGIN


  select count(*)
  into vl_qtd_registros
  from sc_opr.tbl_crt crt 
    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
    inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp and fem.cd_fem = fnc.cd_fem
  where exists(select 1 
               from sc_opr.tbl_rst rst 
               where ((rst.nr_nsu_cli_rst = emp.cd_emp and rst.tp_cli_rst =  4) OR 
                     (rst.nr_nsu_cli_rst = fem.cd_emp and rst.nr_nsu2_cli_rst= fem.cd_fem and tp_cli_rst =  5) OR
                     (rst.nr_nsu_cli_rst = emp.cd_gem and rst.tp_cli_rst =  3) OR 
                     (rst.nr_nsu_cli_rst = crt.cd_crt and rst.tp_cli_rst =  6))
                    AND rst.cd_top = vp_tipo_operacao
                    and not exists(select 1 
                                   from sc_opr.tbl_exc exc
                                   where exc.cd_rst = rst.cd_rst
                                     and ((exc.nr_nsu_cli_exc = emp.cd_emp and exc.tp_cli_exc =  4) OR 
					  (exc.nr_nsu_cli_exc = fem.cd_emp and exc.nr_nsu2_cli_exc= fem.cd_fem and tp_cli_exc =  5) OR
                     		          (exc.nr_nsu_cli_exc = emp.cd_gem and exc.tp_cli_exc =  3) OR 
					  (exc.nr_nsu_cli_exc = crt.cd_crt and exc.tp_cli_exc =  6))
				)
               and rst.dt_ini_rst <= current_date
	       and (rst.dt_fin_rst > current_date or rst.dt_fin_rst is null)	
  	      )
  	and crt.cd_crt = vp_cartao;
  
    
    if(vl_qtd_registros > 0) then
      return false;
    else 
      return true;
    end if;
    
END;
$$;


ALTER FUNCTION sc_opr.autoriza_tipo_operacao_cartao(vp_cartao numeric, vp_tipo_operacao numeric) OWNER TO scan;

--
-- TOC entry 1403 (class 1255 OID 564464)
-- Name: autoriza_tipo_operacao_cartao(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION autoriza_tipo_operacao_cartao(vp_plastico numeric, vp_cartao numeric, vp_tipo_operacao numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
 vl_qtd_registros  numeric;
BEGIN


 select count(*)
 into vl_qtd_registros
 from sc_opr.tbl_pls pls 
   inner join sc_opr.tbl_crt crt on pls.cd_crt = crt.cd_crt
   inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
   inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
   inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp and fem.cd_fem = fnc.cd_fem
 where exists(select 1 
              from sc_opr.tbl_rst rst 
              where ((rst.nr_nsu_cli_rst = emp.cd_emp and rst.tp_cli_rst =  4) OR 
                    (rst.nr_nsu_cli_rst = fem.cd_emp and rst.nr_nsu2_cli_rst= fem.cd_fem and tp_cli_rst =  5) OR
                    (rst.nr_nsu_cli_rst = emp.cd_gem and rst.tp_cli_rst =  3) OR 
                    (rst.nr_nsu_cli_rst = crt.cd_crt and rst.tp_cli_rst =  6))
                   AND (rst.cd_top = vp_tipo_operacao or vp_tipo_operacao is null)
                   and not exists(select 1 
                                  from sc_opr.tbl_exc exc
                                  where exc.cd_rst = rst.cd_rst
                                    and ((exc.nr_nsu_cli_exc = emp.cd_emp and exc.tp_cli_exc =  4) OR 
                                        (exc.nr_nsu_cli_exc = fem.cd_emp and exc.nr_nsu2_cli_exc= fem.cd_fem and tp_cli_exc =  5) OR
                                        (exc.nr_nsu_cli_exc = emp.cd_gem and exc.tp_cli_exc =  3) OR 
                                        (exc.nr_nsu_cli_exc = crt.cd_crt and exc.tp_cli_exc =  6))
                                  )
               and rst.dt_ini_rst <= current_date
	       and (rst.dt_fin_rst > current_Date or rst.dt_fin_rst is null)	
 	      )
    and (crt.cd_crt = vp_cartao or vp_cartao is null)
    and (pls.cd_pls = vp_plastico or vp_plastico is null);
 
   
   if(vl_qtd_registros > 0) then
     return false;
   else 
     return true;
   end if;
   
END;
$$;


ALTER FUNCTION sc_opr.autoriza_tipo_operacao_cartao(vp_plastico numeric, vp_cartao numeric, vp_tipo_operacao numeric) OWNER TO scan;

--
-- TOC entry 1652 (class 1255 OID 564465)
-- Name: autoriza_tipo_operacao_cartao_data(numeric, numeric, date); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION autoriza_tipo_operacao_cartao_data(vp_cartao numeric, vp_tipo_operacao numeric, vp_data date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  vl_qtd_registros  numeric;
BEGIN


  select count(*)
  into vl_qtd_registros
  from sc_opr.tbl_crt crt 
    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
    inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp and fem.cd_fem = fnc.cd_fem
  where exists(select 1 
               from sc_opr.tbl_rst rst 
               where ((rst.nr_nsu_cli_rst = emp.cd_emp and rst.tp_cli_rst =  4) OR 
                     (rst.nr_nsu_cli_rst = fem.cd_emp and rst.nr_nsu2_cli_rst= fem.cd_emp and tp_cli_rst =  5) OR
                     (rst.nr_nsu_cli_rst = emp.cd_gem and rst.tp_cli_rst =  3) OR 
                     (rst.nr_nsu_cli_rst = crt.cd_crt and rst.tp_cli_rst =  6))
                    AND rst.cd_top = vp_tipo_operacao
                    and not exists(select 1 
                                   from sc_opr.tbl_exc exc
                                   where exc.cd_rst = rst.cd_rst
                                     and ((exc.nr_nsu_cli_exc = emp.cd_emp and exc.tp_cli_exc =  4) OR 
					  (exc.nr_nsu_cli_exc = fem.cd_emp and exc.nr_nsu2_cli_exc= fem.cd_emp and tp_cli_exc =  5) OR
                     		          (exc.nr_nsu_cli_exc = emp.cd_gem and exc.tp_cli_exc =  3) OR 
					  (exc.nr_nsu_cli_exc = crt.cd_crt and exc.tp_cli_exc =  6))
				)
				
		  and (rst.dt_ini_rst <= vp_data or vp_data is null)
		  and (rst.dt_fin_rst > vp_data or vp_data is null or rst.dt_fin_rst is null)		
  		)
  		
  	and crt.cd_crt = vp_cartao;
  
    
    if(vl_qtd_registros > 0) then
      return false;
    else 
      return true;
    end if;
    
END;
$$;


ALTER FUNCTION sc_opr.autoriza_tipo_operacao_cartao_data(vp_cartao numeric, vp_tipo_operacao numeric, vp_data date) OWNER TO scan;

--
-- TOC entry 1401 (class 1255 OID 564466)
-- Name: bloqueia_cartao_especial(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION bloqueia_cartao_especial() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  RG RECORD;
begin
  for rg in select cn.cd_crt
            from sc_cnt.tbl_cnt c
                 inner join sc_opr.tbl_cnt_crt cn on cn.cd_cnt = c.cd_cnt
            where c.vl_sld_cnt >= 2000 loop
    update sc_opr.tbl_pls 
       set fg_blq_pls = 'S',
           cd_tbl = 7
    where cd_crt = rg.cd_crt;

    insert into sc_opr.tbl_ocr values(nextval('sc_opr.sq_ocr'), 1, rg.cd_crt, (select cd_pls from sc_opr.tbl_pls where cd_crt = rg.cd_crt), 
                                      'BLOQUEIO PROVISORIO DE CARTAO', 'N', 1, NOW());        
  end loop;
end;
$$;


ALTER FUNCTION sc_opr.bloqueia_cartao_especial() OWNER TO scan;

--
-- TOC entry 1402 (class 1255 OID 564467)
-- Name: cancela_operacao(numeric, numeric, character varying); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION cancela_operacao(vp_codigo numeric, vp_usuario numeric, vp_motivo character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_tipo_operacao sc_opr.tbl_top.cd_top%type;
  
begin

  select cd_top
  into vl_tipo_operacao
  from sc_opr.tbl_opr
  where cd_opr = vp_codigo;

  if vl_tipo_operacao = 5 then -- SAQUE EXTRA

     perform sc_opr.cancela_saque_extra(vp_codigo, vp_usuario, vp_motivo);
     
  elsif vl_tipo_operacao = 19 then -- SAQUE ARREDONDADO     

     perform sc_opr.cancela_saque_arredondado(vp_codigo, vp_usuario, vp_motivo);
  
  end if;

  update sc_opr.tbl_opr set st_opr = 3 where cd_opr = vp_codigo;

   
end$$;


ALTER FUNCTION sc_opr.cancela_operacao(vp_codigo numeric, vp_usuario numeric, vp_motivo character varying) OWNER TO scan;

--
-- TOC entry 1404 (class 1255 OID 564468)
-- Name: cancela_saque_arredondado(numeric, numeric, character varying); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION cancela_saque_arredondado(vp_codigo numeric, vp_usuario numeric, vp_motivo character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
 vl_conta_cartao numeric;
 vl_saque_arredondado numeric;
 vl_tarifa_saque_arredondado numeric;
 vl_codigo_tarifa numeric;

begin

   select cnt.cd_cnt,opr.vl_opr - opr.vl_trf_opr,opr.vl_trf_opr, tsc.cd_tsc
   into vl_conta_cartao, vl_saque_arredondado,vl_tarifa_saque_arredondado, vl_codigo_tarifa
   from sc_opr.tbl_opr opr
     inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
     inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
     inner join sc_opr.tbl_cnt_crt cnt on cnt.cd_crt = crt.cd_crt
     left join sc_srv.tbl_tsc tsc on tsc.cd_opr = opr.cd_opr
   where coalesce(tsc.st_tsc,1) = 1
     and opr.st_opr = 2
     and opr.cd_opr = vp_codigo;
     
   if vl_conta_cartao is not null then

      perform sc_cnt.lancar_debito_credito(vl_conta_cartao,13,171,null,vp_motivo,vl_saque_arredondado,now()::timestamp,vp_usuario,3,vp_codigo);
      perform sc_cnt.lancar_debito_credito(37,13,171,null,vp_motivo,vl_tarifa_saque_arredondado,now()::timestamp,vp_usuario,3,vp_codigo);
        
   else
     raise exception 'A tarifa já foi cobrada.';
   end if;  

   if vl_codigo_tarifa is not null then
	update sc_srv.tbl_tsc set st_tsc = 3 where cd_tsc = vl_codigo_tarifa;
   end if;	
     
end$$;


ALTER FUNCTION sc_opr.cancela_saque_arredondado(vp_codigo numeric, vp_usuario numeric, vp_motivo character varying) OWNER TO scan;

--
-- TOC entry 1405 (class 1255 OID 564469)
-- Name: cancela_saque_extra(numeric, numeric, character varying); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION cancela_saque_extra(vp_codigo numeric, vp_usuario numeric, vp_motivo character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_cod_fatura numeric;
  vl_cod_parcela numeric;

  ct_tl_estorno_saque_extra numeric := 189;
  ct_conta_saque_extra numeric := 4;
  ct_conta_receita_juros numeric := 33;
  ct_conta_receita_iof numeric := 32;  
  ct_conta_receita_tarifa numeric := 34;
  vl_codigo_lancamento sc_cnt.tbl_lcn.cd_lcn%type;
  vl_conta_diferenca numeric;
  vl_liquido numeric;
  vl_operacao numeric;
  vl_data_operacao timestamp;
  vl_juros numeric;
  vl_iof numeric;
  vl_tarifa numeric;

begin

   select prc.cd_fcr,prc.cd_prc,opr.vl_opr, opr.dt_opr,opr.vl_jrs_opr,opr.vl_iof_opr,vl_trf_opr,opr.vl_opr-opr.vl_trf_opr-opr.vl_jrs_opr-opr.vl_iof_opr,cd_cnt_dif_atm
   into vl_cod_fatura,vl_cod_parcela,vl_operacao,vl_data_operacao,vl_juros,vl_iof,vl_tarifa,vl_liquido,vl_conta_diferenca
   from sc_opr.tbl_opr opr
      left join sc_fcr.tbl_prc prc on prc.cd_opr = opr.cd_opr
      inner join sc_rds.tbl_atm atm on atm.cd_atm = opr.cd_atm
   where cd_opr = vp_codigo;

   if vl_cod_fatura is not null then
      raise exception 'A operação já foi faturada. Nr da Fatura %', vl_cod_fatura;
   end if;


   perform sc_cnt.lancar_movimento(vl_codigo_lancamento,null,ct_tl_estorno_saque_extra,ct_conta_saque_extra,'C',vl_operacao,vl_data_operacao,vp_usuario,null,vp_motivo,3,vp_codigo);
   perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tl_estorno_saque_extra,ct_conta_receita_juros,'D',vl_juros,vl_data_operacao,vp_usuario,null,vp_motivo,3,vp_codigo);
   perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tl_estorno_saque_extra,ct_conta_receita_iof,'D',vl_iof,vl_data_operacao,vp_usuario,null,vp_motivo,3,vp_codigo);
   perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tl_estorno_saque_extra,ct_conta_receita_tarifa,'D',vl_tarifa,vl_data_operacao,vp_usuario,null,vp_motivo,3,vp_codigo);
   perform sc_cnt.lancar_movimento(null,vl_codigo_lancamento,ct_tl_estorno_saque_extra,vl_conta_diferenca,'D',vl_liquido,vl_data_operacao,vp_usuario,null,vp_motivo,3,vp_codigo);
   

     
end$$;


ALTER FUNCTION sc_opr.cancela_saque_extra(vp_codigo numeric, vp_usuario numeric, vp_motivo character varying) OWNER TO scan;

--
-- TOC entry 1636 (class 1255 OID 975783)
-- Name: cancelar_saque_facil(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION cancelar_saque_facil() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
 
begin

  perform sc_job.executar_java_job('cancelarSaqueFacilExpirados', null);
   
end$$;


ALTER FUNCTION sc_opr.cancelar_saque_facil() OWNER TO scan;

--
-- TOC entry 7838 (class 0 OID 0)
-- Dependencies: 1636
-- Name: FUNCTION cancelar_saque_facil(); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION cancelar_saque_facil() IS 'Rotina que cancelas os saque facils expirados';


--
-- TOC entry 1409 (class 1255 OID 564470)
-- Name: correcao_limite_cartao_padrao(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION correcao_limite_cartao_padrao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;

  ct_tp_ocr_alteracao_limite constant numeric := 4;

  vl_valor_antigo numeric;
begin
  for vl_rg in select cun.cd_crt, lmt.cd_tlt, round(sum(lmt.vl_cnc_lmt), -1) as vl_novo, sum(case when cun.cd_crt <> crt.cd_crt  then 0 else lmt.vl_cnc_lmt end) as limite_atual
               from sc_opr.tbl_lmt lmt
                    inner join sc_opr.tbl_crt crt on lmt.cd_crt = crt.cd_crt
                    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc 
                    inner join sc_cad.tbl_cun cun on fnc.cd_cun = cun.cd_cun
               where cun.cd_crt is not null
                 and lmt.cd_tlt = 1
                 and exists (select 1
                                 from sc_adp.tbl_rdp rdp
                                      inner join sc_adp.tbl_hfe hfe on rdp.cd_hfe = hfe.cd_hfe
                                      inner join sc_opr.tbl_crt crt2 on rdp.cd_crt = crt2.cd_crt
                                      inner join sc_cad.tbl_fnc fnc2 on fnc2.cd_fnc = crt2.cd_fnc 
                                 where hfe.st_hfe = 5
                                   and rdp.st_rdp = 5
                                   and rdp.cd_tdp in (1, 8)
                                   and fnc.cd_cun = cun.cd_cun
                                   and hfe.dt_dps_hfe >= current_date - interval '45 day') 
               group by cun.cd_crt, lmt.cd_tlt
               having round(sum(lmt.vl_cnc_lmt), -1) > 0 and round(sum(case when cun.cd_crt <> crt.cd_crt then 0 else lmt.vl_cnc_lmt end), -1) = 0  loop
    --alterando limite de cartao no banco de dados
    perform sc_opr.altera_limite_cartao(vl_rg.cd_crt, vl_rg.cd_tlt, vl_rg.vl_novo, 'CORRECAO DE ATUALIZACAO ERRADA DE LIMITE DE CARTAO PADRAO');
  end loop;
end;$$;


ALTER FUNCTION sc_opr.correcao_limite_cartao_padrao() OWNER TO scan;

--
-- TOC entry 7839 (class 0 OID 0)
-- Dependencies: 1409
-- Name: FUNCTION correcao_limite_cartao_padrao(); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION correcao_limite_cartao_padrao() IS 'corrigindo limite de cartao padrao zerado de forma errada pela rotina zera_limite';


--
-- TOC entry 1411 (class 1255 OID 564471)
-- Name: corrigir_diferenca_conta_saque(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION corrigir_diferenca_conta_saque() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin

  for rg in select lcn.vl_lcn - (vl_opr - (vl_jrs_opr + vl_trf_opr + vl_iof_opr)) as diferenca,
                   lcn.cd_lcn as codigo
            from sc_opr.tbl_opr opr
	      inner join sc_cnt.tbl_lcn lcn on lcn.nsu_lcn = opr.cd_opr
            where vl_opr - (vl_jrs_opr + vl_trf_opr + vl_iof_opr) <> lcn.vl_lcn
              and opr.cd_top = 5  
              and opr.cd_opr not in (14026, 14033, 14035, 14036, 14039, 14040, 14045, 14046, 14047, 14052) loop

    update sc_cnt.tbl_lcn set vl_lcn = vl_lcn - rg.diferenca where cd_lcn = rg.codigo;
              
  end loop;
  
end;$$;


ALTER FUNCTION sc_opr.corrigir_diferenca_conta_saque() OWNER TO scan;

--
-- TOC entry 1412 (class 1255 OID 564472)
-- Name: corrigir_diferenca_conta_saque_extra(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION corrigir_diferenca_conta_saque_extra() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin

  for rg in select lcn.cd_cnt as conta,
                   sum(opr.vl_opr-(opr.vl_jrs_opr+opr.vl_trf_opr+opr.vl_iof_opr) - round(opr.vl_opr-(opr.vl_jrs_opr+opr.vl_trf_opr+opr.vl_iof_opr))) as diferenca
                   from sc_opr.tbl_opr opr
                     inner join sc_cnt.tbl_lcn lcn on lcn.nsu_lcn = opr.cd_opr and lcn.cd_sst = 3
                   where opr.cd_top = 5
                     and opr.st_opr = 2
                     and opr.vl_opr-(opr.vl_jrs_opr+opr.vl_trf_opr+opr.vl_iof_opr) - trunc(opr.vl_opr-(opr.vl_jrs_opr+opr.vl_trf_opr+opr.vl_iof_opr)) > 0
                     and opr.cd_opr not in (14026, 14033, 14035, 14036, 14039, 14040, 14045, 14046, 14047, 14052)
                   group by lcn.cd_cnt loop

    update sc_cnt.tbl_cnt set
      vl_sld_cnt = vl_sld_cnt + rg.diferenca
    where cd_cnt = rg.conta;

  end loop;

end;$$;


ALTER FUNCTION sc_opr.corrigir_diferenca_conta_saque_extra() OWNER TO scan;

--
-- TOC entry 1413 (class 1255 OID 564473)
-- Name: corrigir_diferenca_lancamento_saque_extra(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION corrigir_diferenca_lancamento_saque_extra() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin

  for rg in select lcn.cd_lcn as lancamento,
                   opr.vl_opr-(opr.vl_jrs_opr+opr.vl_trf_opr+opr.vl_iof_opr) - round(opr.vl_opr-(opr.vl_jrs_opr+opr.vl_trf_opr+opr.vl_iof_opr)) as diferenca
            from sc_opr.tbl_opr opr
              inner join sc_cnt.tbl_lcn lcn on lcn.nsu_lcn = opr.cd_opr and lcn.cd_sst = 3
            where opr.cd_top = 5
              and opr.st_opr = 2
              and opr.vl_opr-(opr.vl_jrs_opr+opr.vl_trf_opr+opr.vl_iof_opr) - trunc(opr.vl_opr-(opr.vl_jrs_opr+opr.vl_trf_opr+opr.vl_iof_opr)) > 0
              and opr.cd_opr not in (14026, 14033, 14035, 14036, 14039, 14040, 14045, 14046, 14047, 14052)
            order by lcn.cd_lcn loop


    update sc_cnt.tbl_lcn set
      vl_lcn = vl_lcn + rg.diferenca
    where cd_lcn = rg.lancamento;
  
  end loop;

end;$$;


ALTER FUNCTION sc_opr.corrigir_diferenca_lancamento_saque_extra() OWNER TO scan;

--
-- TOC entry 1400 (class 1255 OID 564474)
-- Name: corrigir_diferenca_operacao_saque_extra(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION corrigir_diferenca_operacao_saque_extra() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin

  for rg in select opr.cd_opr as operacao,
                   opr.vl_opr-(opr.vl_jrs_opr+opr.vl_trf_opr+opr.vl_iof_opr) - round(opr.vl_opr-(opr.vl_jrs_opr+opr.vl_trf_opr+opr.vl_iof_opr)) as diferenca
            from sc_opr.tbl_opr opr
            where opr.cd_top = 5
              and opr.st_opr = 2
              and opr.vl_opr-(opr.vl_jrs_opr+opr.vl_trf_opr+opr.vl_iof_opr) - trunc(opr.vl_opr-(opr.vl_jrs_opr+opr.vl_trf_opr+opr.vl_iof_opr)) > 0
              and opr.cd_opr not in (14026, 14033, 14035, 14036, 14039, 14040, 14045, 14046, 14047, 14052)
            order by opr.cd_opr loop

   update sc_opr.tbl_opr set
     vl_jrs_opr = vl_jrs_opr + rg.diferenca
   where cd_opr = rg.operacao;

   end loop;

end;$$;


ALTER FUNCTION sc_opr.corrigir_diferenca_operacao_saque_extra() OWNER TO scan;

--
-- TOC entry 1426 (class 1255 OID 1665581)
-- Name: corrigir_limite_utilizado(numeric, boolean); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION corrigir_limite_utilizado(vp_cartao numeric, vp_alterar boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg record;
  vl_utilizado_saque numeric(13, 2) := 0.0;
  vl_utilizado_compra numeric(13, 2) := 0.0;

  vl_utilizado_saque_atual numeric(13, 2) := 0.0;
  vl_utilizado_compra_atual numeric(13, 2) := 0.0;

  CT_LIMITE_SAQUE constant integer := 1;
  CT_LIMITE_COMPRA constant integer := 2;
begin

  --calculando o valor de limite utilizado por operações que ainda não tiveram parcelas geradas
  for vl_rg in select tlt.cd_tlt as tipo_limite, tlt.nm_tlt as nome_tipo_limite, 
                      sum(case when tlt.cd_tlt = 1 then opr.vl_prc_opr else opr.vl_crd_opr end) as valor_utilizado
               from sc_opr.tbl_opr opr
                    inner join sc_opr.tbl_top_tlt top_tlt on opr.cd_top = top_tlt.cd_top
                    inner join sc_opr.tbl_tlt tlt on top_tlt.cd_tlt = tlt.cd_tlt
                    inner join sc_opr.tbl_pls pls on opr.cd_pls = pls.cd_pls
               where opr.dt_prc_opr is null
                 and pls.cd_crt = vp_cartao
                 and opr.st_opr in (1, 2)
               group by tlt.cd_tlt, tlt.nm_tlt loop
    if vl_rg.tipo_limite = CT_LIMITE_SAQUE then
      raise notice 'valor utilizado de saque, referente a operações sem parcelas geradas: %', vl_rg.valor_utilizado;
      vl_utilizado_saque := vl_utilizado_saque + vl_rg.valor_utilizado;
    end if;

    if vl_rg.tipo_limite = CT_LIMITE_COMPRA then
      raise notice 'valor utilizado de compra, referente a operações sem parcelas geradas: %', vl_rg.valor_utilizado;
      vl_utilizado_compra := vl_utilizado_compra + vl_rg.valor_utilizado;
    end if;    
  end loop;

  
  --calculando o valor de limite utilizado por parcelas não faturadas
  for vl_rg in select tlt.cd_tlt as tipo_limite, tlt.nm_tlt as nome_tipo_limite, sum(vl_prc) as valor_utilizado
               from sc_fcr.tbl_prc prc
                    inner join sc_opr.tbl_opr opr on prc.cd_opr = opr.cd_opr
                    inner join sc_opr.tbl_top_tlt top_tlt on opr.cd_top = top_tlt.cd_top
                    inner join sc_opr.tbl_tlt tlt on top_tlt.cd_tlt = tlt.cd_tlt
                    inner join sc_opr.tbl_pls pls on opr.cd_pls = pls.cd_pls
               where pls.cd_crt = vp_cartao
                 and prc.st_prc = 1
               group by tlt.cd_tlt, tlt.nm_tlt loop
     if vl_rg.tipo_limite = CT_LIMITE_SAQUE then
       raise notice 'valor utilizado de saque, referente a parcelas não faturadas: %', vl_rg.valor_utilizado;
       vl_utilizado_saque := vl_utilizado_saque + vl_rg.valor_utilizado;
     end if;

     if vl_rg.tipo_limite = CT_LIMITE_COMPRA then
       raise notice 'valor utilizado de compra, referente a parcelas não faturadas: %', vl_rg.valor_utilizado;
       vl_utilizado_compra := vl_utilizado_compra + vl_rg.valor_utilizado;
     end if; 
   end loop;

  --calculando o valor do limite utilizado por faturas não pagas
  for vl_rg in select tlt.cd_tlt as tipo_limite, tlt.nm_tlt as nome_tipo_limite, sum(vl_rst_fcr_tlt) as valor_utilizado
               from sc_opr.tbl_crt crt
                    inner join sc_fcr.tbl_fcr fcr on crt.cd_fcr = fcr.cd_fcr
                    inner join sc_fcr.tbl_fcr_tlt fcr_tlt on fcr.cd_fcr = fcr_tlt.cd_fcr
                    inner join sc_opr.tbl_tlt tlt on fcr_tlt.cd_tlt = tlt.cd_tlt
               where crt.cd_crt = vp_cartao
               group by tlt.cd_tlt, tlt.nm_tlt loop
     if vl_rg.tipo_limite = CT_LIMITE_SAQUE then
       raise notice 'valor utilizado de saque, referente a parcelas faturadas e ainda não pagas: %', vl_rg.valor_utilizado;
       vl_utilizado_saque := vl_utilizado_saque + vl_rg.valor_utilizado;
     end if;

     if vl_rg.tipo_limite = CT_LIMITE_COMPRA then
       raise notice 'valor utilizado de compra, referente a parcelas faturadas e ainda não pagas: %', vl_rg.valor_utilizado;
       vl_utilizado_compra := vl_utilizado_compra + vl_rg.valor_utilizado;
     end if; 
  end loop;

  --obtendo o valor atual de limite utilizado de saque
  select vl_utl_lmt
    into vl_utilizado_saque_atual
  from sc_opr.tbl_lmt
  where cd_tlt = CT_LIMITE_SAQUE 
    and cd_crt = vp_cartao;

  --obtendo o valor atual de limite utilizado de compra
  select vl_utl_lmt
    into vl_utilizado_compra_atual
  from sc_opr.tbl_lmt
  where cd_tlt = CT_LIMITE_COMPRA 
    and cd_crt = vp_cartao;
  
  raise notice 'valor atual de limite utilizado de compra: %, de saque: %', vl_utilizado_compra_atual, vl_utilizado_saque_atual;
  raise notice 'valor calculado de limite utilizado de compra: %, de saque: %', vl_utilizado_compra, vl_utilizado_saque;
  
  if vp_alterar then
    update sc_opr.tbl_lmt set vl_utl_lmt = vl_utilizado_saque where cd_tlt = CT_LIMITE_SAQUE and cd_crt = vp_cartao;
    update sc_opr.tbl_lmt set vl_utl_lmt = vl_utilizado_compra where cd_tlt = CT_LIMITE_COMPRA and cd_crt = vp_cartao;
  end if;
  
end;$$;


ALTER FUNCTION sc_opr.corrigir_limite_utilizado(vp_cartao numeric, vp_alterar boolean) OWNER TO scan;

--
-- TOC entry 1414 (class 1255 OID 564475)
-- Name: define_cartao_padrao_funcionario_cameron(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION define_cartao_padrao_funcionario_cameron() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  nr_cartao numeric;
  nr_plastico numeric;
  qtde_nr_plastico numeric;
  rg record;
begin
  for rg in select fnc.cd_cun
	    from sc_cad.tbl_fnc fnc
		 inner join sc_opr.tbl_crt crt on fnc.cd_fnc = crt.cd_fnc
		 inner join sc_cad.tbl_cun cun on fnc.cd_cun = cun.cd_cun
		 inner join sc_cad.tbl_emp emp on fnc.cd_emp = emp.cd_emp
            where emp.cd_gem = 1
              and cun.cd_crt is null
              and fnc.cd_emp not in(2599,999)
              and fnc.st_fnc <> 2 -- demitido
              and crt.fg_atv_crt = 'S'
            group by fnc.cd_cun
	    having count(*) > 1 loop
    select cd_crt
    into nr_cartao
    from sc_opr.tbl_crt crt
         inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
         inner join sc_cad.tbl_emp emp on fnc.cd_emp = emp.cd_emp
    where fnc.cd_cun = rg.cd_cun
      and emp.cd_gem = 1
      and fnc.cd_emp not in(2599,999)
      and crt.dt_inc_usr = (select min(crt2.dt_inc_usr)
                            from sc_opr.tbl_crt crt2
                                 inner join sc_cad.tbl_fnc fnc2 on crt2.cd_fnc = fnc2.cd_fnc
				 inner join sc_cad.tbl_emp emp2 on fnc2.cd_emp = emp2.cd_emp
                            where fnc2.cd_cun = rg.cd_cun
                              and emp2.cd_gem = 1
                              and crt2.fg_atv_crt = 'S'
                              and fnc2.cd_emp not in(2599,999));
    select count(*)
      into qtde_nr_plastico
    from sc_opr.tbl_pls pls 
    where pls.cd_crt = nr_cartao
      and pls.fg_blq_pls = 'N';

    if qtde_nr_plastico > 0 then  
       select pls.cd_pls
         into nr_plastico
       from sc_opr.tbl_pls pls 
       where pls.cd_crt = nr_cartao
         and pls.fg_blq_pls = 'N';
   
       perform sc_opr.atualiza_cartao_padrao(nr_plastico, 1);

    end if;
    
  end loop;
end;$$;


ALTER FUNCTION sc_opr.define_cartao_padrao_funcionario_cameron() OWNER TO scan;

--
-- TOC entry 1415 (class 1255 OID 564476)
-- Name: desbloqueia_plastico_erro_pergunta(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION desbloqueia_plastico_erro_pergunta() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin

   for rg in select *
          from sc_opr.tbl_pls
          where cd_tbl=9
            and fg_blq_pls = 'S' loop
            
  update sc_opr.tbl_pls set fg_blq_pls = 'N',cd_tbl=null,nr_tnt_dsb_pls=0 where cd_pls=rg.cd_pls;
  insert into sc_opr.tbl_ocr values(nextval('sc_opr.sq_ocr'),2,rg.cd_crt,rg.cd_pls,'Desbloqueio atomatico temporario','N',1,now());
  

   end loop;

end$$;


ALTER FUNCTION sc_opr.desbloqueia_plastico_erro_pergunta() OWNER TO scan;

--
-- TOC entry 1855 (class 1255 OID 564477)
-- Name: emitir_segunda_via_cartao(numeric, numeric, numeric, character varying, character varying, numeric); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION emitir_segunda_via_cartao(vp_codigo_plastico_atual numeric, vp_codigo_tipo_bloqueio numeric, vp_codigo_usuario numeric, vp_motivo character varying, vp_cobrar_emissao character varying, vp_tp_ssp numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_existe numeric;
  vl_flag_bloqueio_definitivo varchar;
  vl_cd_modelo numeric;
  vl_codigo_cartao numeric;
  vl_nome varchar;
  vl_codigo_cun numeric;
  vl_flag_ativo varchar;
  vl_tipo_bloqueio numeric;
  vl_pls_gerado numeric;
  vl_tipo_ocorrencia numeric;
  vl_senha numeric(4,0);
  vl_cd_ssp numeric;
  vl_valor_opr numeric(13,2);
  vl_cd_ctr numeric;

  ct_emissao_segunda_via numeric := 6;
  ct_tipo_solicitacao_plastico numeric := 1;
  ct_tipo_solicitacao_senha numeric := 2;
  ct_tipo_ocorrencia_plastico numeric := 5;
  ct_tipo_ocorrencia_senha numeric := 8;
  
begin
  select count(*)
  into vl_existe
  from sc_opr.tbl_pls
  where cd_pls = vp_codigo_plastico_atual;
  
  if vl_existe = 0 then
    raise 'PLASTICO NAO ENCONTRADO';
  else
    select COALESCE(tbl.fg_dfn_tbl, 'N'), pls.cd_crt, cun.nm_cun, ctr.cd_mpl, pls.cd_cun, crt.fg_atv_crt, pls.cd_tbl, crt.cd_ctr
    into vl_flag_bloqueio_definitivo, vl_codigo_cartao, vl_nome, vl_cd_modelo, vl_codigo_cun, vl_flag_ativo, vl_tipo_bloqueio, vl_cd_ctr
    from sc_opr.tbl_pls pls
 	 inner join sc_opr.tbl_crt crt on pls.cd_crt = crt.cd_crt	
 	 inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
         inner join sc_cad.tbl_cun cun on pls.cd_cun = cun.cd_cun
         left join sc_opr.tbl_tbl tbl on pls.cd_tbl = tbl.cd_tbl
    where pls.cd_pls = vp_codigo_plastico_atual;

    if vl_tipo_bloqueio = ct_emissao_segunda_via then
      raise 'CARTAO NAO PODE TER SEGUNDA VIA DE SENHA';
    else


      if vl_flag_ativo = 'N' then
	raise 'NAO PODE SER EMITIDA SEGUNDA VIA PARA UM CARTAO INATIVO';
      else

        -- se o tipo for plastico emitir outro plastico se for senha só inserir a solicitacao
        if vp_tp_ssp = ct_tipo_solicitacao_plastico then
          select sc_acc.inclui_plastico(vl_codigo_cartao, vl_cd_modelo, vp_codigo_usuario, vl_nome, vl_codigo_cun, 'N') into vl_pls_gerado;
          vl_tipo_ocorrencia := ct_tipo_ocorrencia_plastico;

          -- ver o tipo de bloqueio do cartão
	  vl_tipo_bloqueio := vp_codigo_tipo_bloqueio;
          if vp_codigo_tipo_bloqueio is null then
             vl_tipo_bloqueio = 6;
	  end if;

          update sc_opr.tbl_pls 
             set fg_blq_pls = 'S',
		 cd_tbl = vl_tipo_bloqueio
          where cd_pls = vp_codigo_plastico_atual;
          
        elsif vp_tp_ssp = ct_tipo_solicitacao_senha then
          select nextval('sc_ssp.sq_ssp') into vl_cd_ssp;
          
          insert into sc_ssp.tbl_ssp(cd_ssp, cd_pls, tp_ssp, st_ssp, cd_mpl, msg_crt_ssp, dt_prv_grc_ssp, dt_grc_ssp, dt_inc_usr)
            values(vl_cd_ssp, vp_codigo_plastico_atual, ct_tipo_solicitacao_senha, 1, vl_cd_modelo, sc_cad.get_parametro_contrato(45, vl_cd_ctr, null), (now() + interval '1 day')::date, null, now());
          vl_pls_gerado := vp_codigo_plastico_atual;
          vl_tipo_ocorrencia := ct_tipo_ocorrencia_senha;

          -- atualizar a senha do cartão e zerando o numero de erros
          vl_senha := sc_acc.gera_numero_aleatorio(4);
          update sc_opr.tbl_pls set nm_snh_pls = vl_senha, nr_err_snh_pls = 0 where cd_pls = vp_codigo_plastico_atual;

          -- inserir tipo de operacao
          vl_valor_opr := replace(replace(sc_cad.get_parametro_contrato_cartao(19, vl_codigo_cartao), '.', ''),',','.')::numeric(13,2);
          
          /*select replace(replace(pce_ctr.vl_pce_ctr, '.', ''),',','.')
            into vl_valor_opr
          from sc_cad.tbl_pce_ctr pce_ctr
          where pce_ctr.cd_ctr = vl_cd_ctr
            and pce_ctr.cd_pce = 19; -- codigo solicitacao de senha*/

          insert into sc_opr.tbl_opr (cd_opr, cd_top, cd_pls, dt_opr, vl_opr, vl_jrs_opr, vl_trf_opr, nr_prc_opr, vl_prc_opr, vl_iof_opr, nr_nsu_org_opr, st_opr)
            values (nextval('sc_opr.sq_opr'), 17, vl_pls_gerado, now(), vl_valor_opr, 0, 0, 1, vl_valor_opr, 0, vl_cd_ssp, 2);
        end if;

        -- inserindo ocorrencia
        insert into sc_opr.tbl_ocr values(nextval('sc_opr.sq_ocr'), vl_tipo_ocorrencia, vl_codigo_cartao, vp_codigo_plastico_atual, vp_motivo, 'S', vp_codigo_usuario, now());

        -- cobrar ou nao cobrar a emissão de plástico
        if vp_cobrar_emissao = 'N' then
          update sc_ssp.tbl_ssp set
            fg_cbr_emi_ssp = 'N'
          where cd_pls = vl_pls_gerado;
        end if;

      end if;	
      
    end if;
  end if;
end;$$;


ALTER FUNCTION sc_opr.emitir_segunda_via_cartao(vp_codigo_plastico_atual numeric, vp_codigo_tipo_bloqueio numeric, vp_codigo_usuario numeric, vp_motivo character varying, vp_cobrar_emissao character varying, vp_tp_ssp numeric) OWNER TO scan;

--
-- TOC entry 7840 (class 0 OID 0)
-- Dependencies: 1855
-- Name: FUNCTION emitir_segunda_via_cartao(vp_codigo_plastico_atual numeric, vp_codigo_tipo_bloqueio numeric, vp_codigo_usuario numeric, vp_motivo character varying, vp_cobrar_emissao character varying, vp_tp_ssp numeric); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION emitir_segunda_via_cartao(vp_codigo_plastico_atual numeric, vp_codigo_tipo_bloqueio numeric, vp_codigo_usuario numeric, vp_motivo character varying, vp_cobrar_emissao character varying, vp_tp_ssp numeric) IS 'rotina que emite uma segunda via de cartao para um determinado cliente passado como parametro';


--
-- TOC entry 1680 (class 1255 OID 998410)
-- Name: emitir_segunda_via_cartao_temp(numeric, numeric, numeric, character varying, character varying, numeric); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION emitir_segunda_via_cartao_temp(vp_codigo_plastico_atual numeric, vp_codigo_tipo_bloqueio numeric, vp_codigo_usuario numeric, vp_motivo character varying, vp_cobrar_emissao character varying, vp_tp_ssp numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_existe numeric;
  vl_flag_bloqueio_definitivo varchar;
  vl_cd_modelo numeric;
  vl_codigo_cartao numeric;
  vl_nome varchar;
  vl_codigo_cun numeric;
  vl_flag_ativo varchar;
  vl_tipo_bloqueio numeric;
  vl_pls_gerado numeric;
  vl_tipo_ocorrencia numeric;
  vl_senha numeric(4,0);
  vl_cd_ssp numeric;
  vl_valor_opr numeric(13,2);
  vl_cd_ctr numeric;

  ct_emissao_segunda_via numeric := 6;
  ct_tipo_solicitacao_plastico numeric := 1;
  ct_tipo_solicitacao_senha numeric := 2;
  ct_tipo_ocorrencia_plastico numeric := 5;
  ct_tipo_ocorrencia_senha numeric := 8;
  
begin
  select count(*)
  into vl_existe
  from sc_opr.tbl_pls
  where cd_pls = vp_codigo_plastico_atual;
  
  if vl_existe = 0 then
    raise 'PLASTICO NAO ENCONTRADO';
  else
    select COALESCE(tbl.fg_dfn_tbl, 'N'), pls.cd_crt, cun.nm_cun, ctr.cd_mpl, pls.cd_cun, crt.fg_atv_crt, pls.cd_tbl, crt.cd_ctr
    into vl_flag_bloqueio_definitivo, vl_codigo_cartao, vl_nome, vl_cd_modelo, vl_codigo_cun, vl_flag_ativo, vl_tipo_bloqueio, vl_cd_ctr
    from sc_opr.tbl_pls pls
 	 inner join sc_opr.tbl_crt crt on pls.cd_crt = crt.cd_crt	
 	 inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
         inner join sc_cad.tbl_cun cun on pls.cd_cun = cun.cd_cun
         left join sc_opr.tbl_tbl tbl on pls.cd_tbl = tbl.cd_tbl
    where pls.cd_pls = vp_codigo_plastico_atual;

    if vl_tipo_bloqueio = ct_emissao_segunda_via then
      raise 'CARTAO NAO PODE TER SEGUNDA VIA DE SENHA';
    else


      if vl_flag_ativo = 'N' then
	raise 'NAO PODE SER EMITIDA SEGUNDA VIA PARA UM CARTAO INATIVO';
      else

        -- se o tipo for plastico emitir outro plastico se for senha só inserir a solicitacao
        if vp_tp_ssp = ct_tipo_solicitacao_plastico then
          select sc_acc.inclui_plastico(vl_codigo_cartao, vl_cd_modelo, vp_codigo_usuario, vl_nome, vl_codigo_cun, 'N') into vl_pls_gerado;
          vl_tipo_ocorrencia := ct_tipo_ocorrencia_plastico;
        end if;

        -- inserindo ocorrencia
        insert into sc_opr.tbl_ocr values(nextval('sc_opr.sq_ocr'), vl_tipo_ocorrencia, vl_codigo_cartao, vp_codigo_plastico_atual, vp_motivo, 'S', vp_codigo_usuario, now());

        -- cobrar ou nao cobrar a emissão de plástico
        if vp_cobrar_emissao = 'N' then
          update sc_ssp.tbl_ssp set
            fg_cbr_emi_ssp = 'N',
            st_ssp = 4
          where cd_pls = vl_pls_gerado;
        end if;

      end if;	
      
    end if;
  end if;
end;$$;


ALTER FUNCTION sc_opr.emitir_segunda_via_cartao_temp(vp_codigo_plastico_atual numeric, vp_codigo_tipo_bloqueio numeric, vp_codigo_usuario numeric, vp_motivo character varying, vp_cobrar_emissao character varying, vp_tp_ssp numeric) OWNER TO scan;

--
-- TOC entry 7841 (class 0 OID 0)
-- Dependencies: 1680
-- Name: FUNCTION emitir_segunda_via_cartao_temp(vp_codigo_plastico_atual numeric, vp_codigo_tipo_bloqueio numeric, vp_codigo_usuario numeric, vp_motivo character varying, vp_cobrar_emissao character varying, vp_tp_ssp numeric); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION emitir_segunda_via_cartao_temp(vp_codigo_plastico_atual numeric, vp_codigo_tipo_bloqueio numeric, vp_codigo_usuario numeric, vp_motivo character varying, vp_cobrar_emissao character varying, vp_tp_ssp numeric) IS 'rotina que emite uma segunda via de cartao para um determinado cliente passado como parametro';


--
-- TOC entry 1542 (class 1255 OID 1668034)
-- Name: get_limite_concedido_tempo(numeric, numeric, date); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION get_limite_concedido_tempo(vp_cartao numeric, vp_tipo_limite numeric, vp_data date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
  vl_codigo_historico numeric;
  vl_limite numeric;
begin
  select coalesce(max(cd_hlm), -1)
    into vl_codigo_historico
  from sc_opr.tbl_hlm
  where cd_crt = vp_cartao
    and cd_tlt = vp_tipo_limite
    and dt_inc_usr < vp_data + interval '1 day';

  if vl_codigo_historico = -1 then
    return 0;
  end if;

  select vl_cnc_lmt_atl
    into vl_limite
  from sc_opr.tbl_hlm
  where cd_hlm = vl_codigo_historico;

  return vl_limite;
end;$$;


ALTER FUNCTION sc_opr.get_limite_concedido_tempo(vp_cartao numeric, vp_tipo_limite numeric, vp_data date) OWNER TO scan;

--
-- TOC entry 7842 (class 0 OID 0)
-- Dependencies: 1542
-- Name: FUNCTION get_limite_concedido_tempo(vp_cartao numeric, vp_tipo_limite numeric, vp_data date); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION get_limite_concedido_tempo(vp_cartao numeric, vp_tipo_limite numeric, vp_data date) IS 'rotina que retorna o valor concedido de limite em uma determinada data';


--
-- TOC entry 1565 (class 1255 OID 564478)
-- Name: inativar_cartao(date); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION inativar_cartao(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  CT_PRM_QTDE_DIAS_CARTAO_INATIVO constant varchar := 'QTDE_DIAS_CARTAO_INATIVO';
  CT_TIPO_OCORRENCIA_INATIVACAO_CARTAO constant numeric := 6;
  CT_TIPO_OCORRENCIA_ATIVACAO_CARTAO constant numeric := 11;
  CT_SITUACAO_DEPOSITADO constant numeric := 5;

  vl_rg record;
  
  vl_numero_dias numeric;
  vl_data_referencia date;
  vl_historico text;
  vl_qtde_operacoes numeric;
  
begin

  -- capturando a quantidade de dias que uma conta deverá estar inativa após não realizar nenhuma operação nem receber depósito
  select vl_prm::numeric
  into vl_numero_dias
  from sc_cad.tbl_prm
  where nm_prm = CT_PRM_QTDE_DIAS_CARTAO_INATIVO;

  vl_data_referencia := vp_data_referencia - interval '1 day' * vl_numero_dias;
  vl_historico := 'O CARTAO ESTA SENDO INATIVADO POIS ESTA COM MAIS DE ' || vl_numero_dias || ' DIAS SEM TER DEPOSITO NEM REALIZAR OPERACAO DE SAQUE E/OU SAQUE EXTRA';
  
  -- trazendo os cartoes ativos que não obtiveram deposito no periodo definido
  for vl_rg in  select ct.cd_crt as cartao, cnt.cd_cnt as conta, ct.fg_atv_crt as flag_ativo
				from sc_opr.tbl_crt ct
					inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = ct.cd_crt and fg_pdr_cnt_crt = 'S' 
					inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cc.cd_cnt
					inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = ct.cd_fnc
				where ct.fg_atv_crt = 'S'
				  and ct.dt_inc_usr < vl_data_referencia
				  and fnc.st_fnc in (1, 2) -- SITUACAO ATIVO OU DEMITIDO
				  and ct.cd_crt not in (62015547278289) -- NAO INATIVAR NUNCA MEU CARTAO - JV
				  and not exists
						(
						select 1
						from sc_adp.tbl_rdp rdp
							inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
							inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
						where crt.cd_crt = ct.cd_crt
						  and hfe.st_hfe in (CT_SITUACAO_DEPOSITADO)
						  and dt_dps_hfe >= vl_data_referencia
						)
				  and not exists 
						(
						select 1
						from sc_opr.tbl_opr opr
							inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
							inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
						where crt.cd_crt = ct.cd_crt
						  and opr.cd_top in (4,5) -- saque, saque extra
						  and dt_opr >= vl_data_referencia
						)
				and not exists 
					       (
					       select 1
					       from sc_opr.tbl_ocr ocr
					       where ocr.cd_crt = ct.cd_crt
						 and ocr.cd_toc = CT_TIPO_OCORRENCIA_ATIVACAO_CARTAO
						 and dt_inc_usr > vp_data_referencia - interval '7 day'
					       )
		      
   loop

       update sc_opr.tbl_crt set fg_atv_crt = 'N' where cd_crt = vl_rg.cartao and fg_atv_crt = 'S';

       insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, 
				 nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		     values (nextval('sc_opr.sq_ocr'), CT_TIPO_OCORRENCIA_INATIVACAO_CARTAO, vl_rg.cartao, null, 
				 vl_historico, 'N', 1, now());
   end loop;
end;$$;


ALTER FUNCTION sc_opr.inativar_cartao(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7843 (class 0 OID 0)
-- Dependencies: 1565
-- Name: FUNCTION inativar_cartao(vp_data_referencia date); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION inativar_cartao(vp_data_referencia date) IS 'rotina que inativa os cartões que não estao operando a um determinado período, ou seja, não tiveram depósito nem realizam saque nem realizaram saque e/ou saque extra.';


--
-- TOC entry 1655 (class 1255 OID 944495)
-- Name: inativar_cartao(numeric, character varying, numeric); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION inativar_cartao(vp_cartao numeric, vp_motivo character varying, vp_usuario numeric DEFAULT 1) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  CT_TIPO_OCORRENCIA_INATIVACAO_CARTAO constant numeric := 6;
 
begin

       -- INATIVANDO O CARTAO
       update sc_opr.tbl_crt set fg_atv_crt = 'N' where cd_crt = vp_cartao and fg_atv_crt = 'S';

       -- INSERINDO OCORRENCIA
       insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, 
				 nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		     values (nextval('sc_opr.sq_ocr'), CT_TIPO_OCORRENCIA_INATIVACAO_CARTAO, vp_cartao, null, 
				vp_motivo, 'N', vp_usuario, now());
   
end;$$;


ALTER FUNCTION sc_opr.inativar_cartao(vp_cartao numeric, vp_motivo character varying, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 7844 (class 0 OID 0)
-- Dependencies: 1655
-- Name: FUNCTION inativar_cartao(vp_cartao numeric, vp_motivo character varying, vp_usuario numeric); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION inativar_cartao(vp_cartao numeric, vp_motivo character varying, vp_usuario numeric) IS 'rotina que inativa o cartao e grava uma ocorrencia';


--
-- TOC entry 1595 (class 1255 OID 1030863)
-- Name: saldo_limite(numeric, numeric, character varying); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION saldo_limite(vp_cartao numeric, vp_tipo_limite numeric, vp_fg_loc character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$declare
  vl_somatorio_bloqueio numeric(13,2) := 0;
  vl_saldo numeric(13,2);
  vl_resultado numeric(13,2);
begin


  -- saldo do limite
  if vp_fg_loc = 'S' then
    select coalesce(vl_cnc_lmt,0) - coalesce(vl_utl_lmt,0)
      into vl_saldo
    from sc_opr.tbl_lmt
    where cd_tlt = vp_tipo_limite 
      and cd_crt = vp_cartao for update nowait;
  else
    select coalesce(vl_cnc_lmt,0) - coalesce(vl_utl_lmt,0)
      into vl_saldo
    from sc_opr.tbl_lmt
    where cd_tlt = vp_tipo_limite 
      and cd_crt = vp_cartao;
  end if;

  vl_resultado := vl_saldo;
  
  return vl_resultado;

end;$$;


ALTER FUNCTION sc_opr.saldo_limite(vp_cartao numeric, vp_tipo_limite numeric, vp_fg_loc character varying) OWNER TO scan;

--
-- TOC entry 1419 (class 1255 OID 564479)
-- Name: simulacao_parcelamento_squadrus(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION simulacao_parcelamento_squadrus() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;

  
  vl_valor_lancamento numeric;
  vl_fatura		numeric;
begin
  for vl_rg in 
	        select crt.cd_crt as cartao, cc.cd_cnt as conta, cnt.vl_sld_cnt as saldo,  fcr.cd_fcr as fatura, st_fcr as situacao_fatura,
			fcr.vl_fcr as valor_fatura, fcr.vl_fcr/2 as valor_parcelado
		from sc_opr.tbl_crt_aux c
			inner join sc_opr.tbl_crt crt on crt.cd_crt = c.cd_crt
			inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt
			inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cc.cd_cnt
			inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
		where exists (select 1 
			      from sc_adp.tbl_hfe hfe 
				inner join sc_adp.tbl_rdp rdp on hfe.cd_hfe = rdp.cd_hfe
			      where rdp.cd_crt = crt.cd_crt and hfe.cd_hfe in (14248))
                
       loop

	-- marcando a fatura para renegociada
	update sc_fcr.tbl_fcr fcr set st_fcr = 4 where cd_fcr = vl_rg.fatura;
	
	-- realizando o lancamento na conta do funcionario simulando o pagamento
	perform sc_cnt.lancar_debito_credito(vl_rg.conta, 5, 15, 'BAIXA FATURA CARTAO MANUAL', 'BAIXA MANUAL', vl_rg.valor_parcelado, now()::timestamp, 9, 5, 14248);

	-- voltando o cartao para ativo
	update sc_opr.tbl_crt set fg_atv_crt = 'S' where cd_crt = vl_rg.cartao;
  end loop;
end;$$;


ALTER FUNCTION sc_opr.simulacao_parcelamento_squadrus() OWNER TO scan;

--
-- TOC entry 7845 (class 0 OID 0)
-- Dependencies: 1419
-- Name: FUNCTION simulacao_parcelamento_squadrus(); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION simulacao_parcelamento_squadrus() IS 'simulando o parcelamento da divida para ser feito uma renegociacao';


--
-- TOC entry 1421 (class 1255 OID 564480)
-- Name: transferir_dinheiro_conta_padrao(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION transferir_dinheiro_conta_padrao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  vl_saldo_bloqueado numeric;
  vl_saldo_a_transferir numeric;
begin
  for rg in select cun.cd_cun, cnt.cd_cnt as conta_origem, cnt_crt2.cd_cnt as conta_destino, cnt.vl_sld_cnt as valor
            from sc_cad.tbl_cun cun
                 inner join sc_cad.tbl_fnc fnc on cun.cd_cun = fnc.cd_cun
                 inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                 inner join sc_opr.tbl_crt crt on fnc.cd_fnc = crt.cd_fnc
                 inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
                 inner join sc_cnt.tbl_cnt cnt on cnt_crt.cd_cnt = cnt.cd_cnt
                 inner join sc_opr.tbl_cnt_crt cnt_crt2 on cun.cd_crt = cnt_crt2.cd_crt and cnt_crt2.tp_cnt_crt = cnt_crt.tp_cnt_crt
                 inner join sc_opr.tbl_crt crt2 on crt2.cd_crt = cnt_crt2.cd_crt
                 inner join sc_cad.tbl_fnc fnc2 on fnc2.cd_fnc = crt2.cd_fnc
                 inner join sc_cad.tbl_emp emp2 on emp2.cd_emp = fnc2.cd_emp
            where cnt.vl_sld_cnt > 0
              and crt.cd_crt <> cun.cd_crt
              and emp.cd_gem = emp2.cd_gem
              --and emp.cd_gem = 1
              and emp.cd_emp not in (2599,999)
               loop
    --calculando a soma do saldo bloqueado da conta de origem
    select sum(vl_blq_tbc_cnt)
    into vl_saldo_bloqueado
    from sc_cnt.tbl_tbc_cnt
    where cd_cnt = rg.conta_origem
      and vl_blq_tbc_cnt > 0;

    vl_saldo_a_transferir := rg.valor - coalesce(vl_saldo_bloqueado,0);

    if vl_saldo_a_transferir > 0 then
      perform sc_cnt.lancar_debito_credito(rg.conta_origem, rg.conta_destino, 51, null, 'TRANSFERENCIA PARA CARTAO PADRAO', vl_saldo_a_transferir, now()::timestamp without time zone, 1, 8, nextval('sc_opr.sq_tcp'));
    end if;
  end loop;
end;$$;


ALTER FUNCTION sc_opr.transferir_dinheiro_conta_padrao() OWNER TO scan;

--
-- TOC entry 7846 (class 0 OID 0)
-- Dependencies: 1421
-- Name: FUNCTION transferir_dinheiro_conta_padrao(); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION transferir_dinheiro_conta_padrao() IS 'transfere todo o recurso presente em outros cartoes para o cartao padrao';


--
-- TOC entry 1767 (class 1255 OID 564481)
-- Name: valida_realizar_saque_extra(numeric); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION valida_realizar_saque_extra(vp_plastico numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

  vl_fg_ind_crt varchar(1);
  vl_fg_atv_crt varchar(1);

  vl_qnt_dias_atraso_cartao numeric;
  vl_qnt_cartoes_fatura_aberto numeric;
  vl_cd_crt numeric;
  vl_nr_cpf_cnpj_cun numeric;

  vl_limite_concedido numeric;

begin

  select cun.nr_cpf_cnpj_cun, crt.cd_crt
    into vl_nr_cpf_cnpj_cun, vl_cd_crt
  from sc_opr.tbl_pls pls
    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
  where pls.cd_pls = vp_plastico;

  -- se os dados estao completos
  if sc_cad.valida_saque_extra(vp_plastico) = 'N' then
    return 'N';
  end if;

  -- se o cartão esta inadimplente e se esta ativo
  select crt.fg_ind_crt, crt.fg_atv_crt
    into vl_fg_ind_crt, vl_fg_atv_crt
  from sc_opr.tbl_crt crt
  where crt.cd_crt = vl_cd_crt;

  if vl_fg_ind_crt = 'S' or vl_fg_atv_crt = 'N' then
    return 'N';
  end if;

  -- quantidades de fatura em aberto de outros cartoes
  select prm.vl_prm
    into vl_qnt_dias_atraso_cartao
  from sc_cad.tbl_prm prm
  where prm.nm_prm = 'QT_DIAS_ATR_CRT';

  select count(*)
    into vl_qnt_cartoes_fatura_aberto
  from sc_opr.tbl_crt crt
    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
    inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
  where cun.nr_cpf_cnpj_cun = vl_nr_cpf_cnpj_cun
    and fcr.st_fcr = 1
    and crt.fg_atv_crt = 'N'
    and crt.cd_crt not in (vl_cd_crt)
    and (case when crt.dt_ini_atr_crt is null or crt.fg_ind_crt = 'N' then 0 else current_date - crt.dt_ini_atr_crt::date end) >= vl_qnt_dias_atraso_cartao;

  if vl_qnt_cartoes_fatura_aberto > 0 then
    return 'N';
  end if;
  
  -- se possui limite
  select coalesce(vl_cnc_lmt - vl_utl_lmt,0)
    into vl_limite_concedido
  from sc_opr.tbl_lmt
  where cd_tlt = 1
    and cd_crt = vl_cd_crt;

  if vl_limite_concedido <= 0 then
    return 'N';
  end if;

  return 'S';

end;$$;


ALTER FUNCTION sc_opr.valida_realizar_saque_extra(vp_plastico numeric) OWNER TO scan;

--
-- TOC entry 7847 (class 0 OID 0)
-- Dependencies: 1767
-- Name: FUNCTION valida_realizar_saque_extra(vp_plastico numeric); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION valida_realizar_saque_extra(vp_plastico numeric) IS 'verificar se o plastico pode realizar o saque extra';


--
-- TOC entry 1422 (class 1255 OID 564482)
-- Name: valida_valor_total_operacao(numeric, numeric, double precision, boolean); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION valida_valor_total_operacao(vp_plastico numeric, vp_tipo_operacao numeric, vp_valor_operacao double precision, vp_ver_saq_manual boolean DEFAULT false) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

  ct_cd_top_saque numeric := 4; -- saque
  ct_sit_opr_confirmada numeric := 2; -- situacao operacao confirmada
  ct_sit_sqm_cadastrada numeric := 1;

  vl_valor_total_operacao_dia_pls numeric := 0;
  vl_valor_total_operacao_dia numeric := 100000;
  vl_valor_total_saque_manual numeric;
  vl_cartao numeric;
  
begin

  select sum(opr.vl_opr)
    into vl_valor_total_operacao_dia_pls
  from sc_opr.tbl_opr opr
  where opr.cd_pls = vp_plastico
    and opr.dt_opr >= current_date
    and opr.dt_opr < current_date + 1
    and opr.st_opr = ct_sit_opr_confirmada
    and opr.cd_top = vp_tipo_operacao;

  if vp_ver_saq_manual then

    select sum(sqm.vl_saq_sqm)
      into vl_valor_total_saque_manual
    from sc_opr.tbl_sqm sqm
	inner join sc_opr.tbl_pls pls on pls.cd_crt = sqm.cd_crt
    where pls.cd_pls = vp_plastico
      and sqm.dt_ref_sqm >= current_date
      and sqm.dt_ref_sqm < current_date + 1
      and sqm.st_sqm in (ct_sit_sqm_cadastrada);

    vl_valor_total_operacao_dia_pls := coalesce(vl_valor_total_operacao_dia_pls, 0) + coalesce(vl_valor_total_saque_manual, 0);
  end if;
  
  if vp_tipo_operacao = ct_cd_top_saque then
    begin
      select replace(replace(pce_ctr.vl_pce_ctr, '.', ''), ',', '.')
        into strict vl_valor_total_operacao_dia
      from sc_cad.tbl_pce_ctr pce_ctr
        inner join sc_opr.tbl_crt crt on crt.cd_ctr = pce_ctr.cd_ctr
        inner join sc_opr.tbl_pls pls on pls.cd_crt = crt.cd_crt
      where pce_ctr.cd_pce = 18 -- maximo saque por dia
        and pls.cd_pls = vp_plastico;
    exception when others then
      vl_valor_total_operacao_dia := 0;
    end;
  end if;

  if coalesce(vl_valor_total_operacao_dia_pls,0) + vp_valor_operacao > vl_valor_total_operacao_dia then
    return 'N';
  end if;

  return 'S';

end;$$;


ALTER FUNCTION sc_opr.valida_valor_total_operacao(vp_plastico numeric, vp_tipo_operacao numeric, vp_valor_operacao double precision, vp_ver_saq_manual boolean) OWNER TO scan;

--
-- TOC entry 1679 (class 1255 OID 1648504)
-- Name: vincular_cartao_ucr(); Type: FUNCTION; Schema: sc_opr; Owner: postgres
--

CREATE FUNCTION vincular_cartao_ucr() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg_ucc record;
  rg_crt record;
  rg_existe_ucc numeric;
  
  CT_PRODUTO_PREMIO numeric := 3;
begin
	FOR rg_ucc IN SELECT crt.cd_crt, fnc.cd_fnc, ucc.cd_ucr FROM sc_sgr.tbl_ucc ucc
	  INNER JOIN sc_opr.tbl_crt crt on ucc.cd_crt = crt.cd_crt
	  INNER JOIN sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc LOOP
	  
	  FOR rg_crt IN SELECT * FROM sc_opr.tbl_crt crt 
	    WHERE crt.cd_fnc = rg_ucc.cd_fnc
	    AND crt.cd_prd = CT_PRODUTO_PREMIO
	    AND crt.cd_crt <> rg_ucc.cd_crt LOOP
	    
	      SELECT count(cd_ucc) INTO rg_existe_ucc
	        FROM sc_sgr.tbl_ucc
	      WHERE cd_crt = rg_crt.cd_crt;
	      
	      IF rg_existe_ucc = 0 THEN
	        INSERT INTO sc_sgr.tbl_ucc VALUES (nextval('sc_sgr.sq_ucc'), rg_ucc.cd_ucr, rg_crt.cd_crt, NULL, now());
	      END IF;
	  END LOOP;
	END LOOP;
	
end;$$;


ALTER FUNCTION sc_opr.vincular_cartao_ucr() OWNER TO postgres;

--
-- TOC entry 1627 (class 1255 OID 1667743)
-- Name: voltar_limite_servnac(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION voltar_limite_servnac() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg record;

  CT_SAQUE_EXTRA constant integer := 5;
  CT_SITUACAO_CONFIRMADA constant integer := 2;
begin

  --zerando os limites dos cartoes comuns
  for vl_rg in select crt.cd_crt as cartao, hlm.vl_cnc_lmt_ant as limite_anterior, hlm.cd_tlt as tipo_limite
               from  sc_opr.tbl_hlm hlm
                     inner join sc_opr.tbl_crt crt on hlm.cd_crt = crt.cd_crt
                     inner join sc_cad.tbl_ctr ctr on crt.cd_ctr = ctr.cd_ctr
                     inner join sc_cad.tbl_emp emp on ctr.cd_emp = emp.cd_emp
               where hlm.vl_cnc_lmt_atl = 0 
                 and emp.cd_gem = 249 
                 and hlm.dt_inc_usr >= to_date('2019-08-30', 'yyyy-mm-dd') + interval '18 hours'
                 and hlm.dt_inc_usr < to_date('2019-08-30', 'yyyy-mm-dd') + interval '19 hours'
                 and exists (select 1 
                             from sc_opr.tbl_opr opr
                                  inner join sc_opr.tbl_pls pls on opr.cd_pls = pls.cd_pls
                             where opr.dt_opr >= '2019-01-01'
                               and opr.cd_top = CT_SAQUE_EXTRA
                               and opr.st_opr = CT_SITUACAO_CONFIRMADA
                               and pls.cd_crt = crt.cd_crt) loop
    --realizando a alteracao de limite no banco de dados
    perform sc_opr.altera_limite_cartao(vl_rg.cartao, vl_rg.tipo_limite, vl_rg.limite_anterior, 'RESTITUICAO DO LIMITE POR HAVER UTILIZACAO NO ANO DE 2019');
    update sc_opr.tbl_lmt set fg_alt_lmt = 'S' where cd_crt = vl_rg.cartao and cd_tlt = vl_rg.tipo_limite;
  end loop;

end;$$;


ALTER FUNCTION sc_opr.voltar_limite_servnac() OWNER TO scan;

--
-- TOC entry 7848 (class 0 OID 0)
-- Dependencies: 1627
-- Name: FUNCTION voltar_limite_servnac(); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION voltar_limite_servnac() IS 'rotina que volta limite dos funcionários da servnac que fizeram saque extra no ano de 2019';


--
-- TOC entry 1424 (class 1255 OID 564483)
-- Name: zerar_limite(); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION zerar_limite() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  ct_parametro_dias constant varchar := 'DIAS_SEM_DEPOSITO_PARA_ZERAR_LIMITE';

  ct_depositado constant numeric := 5;
  
  ct_tdp_salario constant numeric := 1;
  ct_tdp_outros constant numeric := 8;

  vl_numero_dias numeric;

  vl_rg record;

  ct_tp_ocr_alteracao_limite constant numeric := 4;

  vl_valor_antigo numeric;
begin
  select vl_prm::numeric
  into vl_numero_dias
  from sc_cad.tbl_prm
  where nm_prm = ct_parametro_dias;

  --zerando os limites dos cartoes comuns
  for vl_rg in select lmt.cd_crt, lmt.cd_tlt
               from sc_opr.tbl_lmt lmt
               where lmt.vl_cnc_lmt > 0
                 and not exists (select 1
                                 from sc_cad.tbl_cun cun
                                 where cun.cd_crt = lmt.cd_crt)
                 and not exists (select 1
                                 from sc_adp.tbl_rdp rdp
                                      inner join sc_adp.tbl_hfe hfe on rdp.cd_hfe = hfe.cd_hfe
                                 where hfe.st_hfe = ct_depositado
                                   and rdp.st_rdp = ct_depositado
                                   and rdp.cd_tdp in (ct_tdp_salario, ct_tdp_outros)
                                   and rdp.cd_crt = lmt.cd_crt
                                   and hfe.dt_dps_hfe >= current_date - (interval '1 day' * vl_numero_dias)) loop
    --realizando a alteracao de limite no banco de dados
    perform sc_opr.altera_limite_cartao(vl_rg.cd_crt, vl_rg.cd_tlt, 0, 'RETIRADA DE LIMITE POR NAO RECEBER DEPOSITO A MAIS DE ' || vl_numero_dias || ' DIAS');
  end loop;

  --zerando os limites dos cartoes padroes
  for vl_rg in select lmt.cd_crt, lmt.cd_tlt
               from sc_opr.tbl_lmt lmt
                    inner join sc_cad.tbl_cun cun on lmt.cd_crt = cun.cd_crt
               where lmt.vl_cnc_lmt > 0
                 and not exists (select 1
                                 from sc_adp.tbl_rdp rdp
                                      inner join sc_adp.tbl_hfe hfe on rdp.cd_hfe = hfe.cd_hfe
                                      inner join sc_opr.tbl_crt crt on rdp.cd_crt = crt.cd_crt
                                      inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
                                 where hfe.st_hfe = ct_depositado
                                   and rdp.st_rdp = ct_depositado
                                   and rdp.cd_tdp in (ct_tdp_salario, ct_tdp_outros)
                                   and fnc.cd_cun = cun.cd_cun
                                   and hfe.dt_dps_hfe >= current_date - (interval '1 day' * vl_numero_dias)) loop
    --realizando a alteracao de limite no banco de dados
    perform sc_opr.altera_limite_cartao(vl_rg.cd_crt, vl_rg.cd_tlt, 0, 'RETIRADA DE LIMITE POR NAO RECEBER DEPOSITO A MAIS DE ' || vl_numero_dias || ' DIAS');
  end loop;
end;$$;


ALTER FUNCTION sc_opr.zerar_limite() OWNER TO scan;

--
-- TOC entry 7849 (class 0 OID 0)
-- Dependencies: 1424
-- Name: FUNCTION zerar_limite(); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION zerar_limite() IS 'rotina que obtem os cartao com limites que não recebem depositos a mais de X dias definido em parametro';


--
-- TOC entry 1587 (class 1255 OID 1667427)
-- Name: zerar_limite_nao_utilizado(integer); Type: FUNCTION; Schema: sc_opr; Owner: scan
--

CREATE FUNCTION zerar_limite_nao_utilizado(vp_grupo_empresarial integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg record;

  CT_TIPO_LIMITE_SAQUE constant integer := 1;
begin

  --zerando os limites dos cartoes comuns
  for vl_rg in select lmt.cd_crt, lmt.cd_tlt, lmt.fg_alt_lmt
               from sc_opr.tbl_crt crt
		     inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
		     inner join sc_cad.tbl_emp emp on fnc.cd_emp = emp.cd_emp
		     inner join sc_opr.tbl_lmt lmt on crt.cd_crt = lmt.cd_crt
		where emp.cd_gem = vp_grupo_empresarial
		  and lmt.cd_tlt = CT_TIPO_LIMITE_SAQUE
		  and lmt.vl_utl_lmt = 0
		  and lmt.vl_cnc_lmt > 0 loop
    --realizando a alteracao de limite no banco de dados
    perform sc_opr.altera_limite_cartao(vl_rg.cd_crt, vl_rg.cd_tlt, 0, 'RETIRADA DE LIMITE POR NAO HAVER UTILIZACAO DO MESMO');
    if vl_rg.fg_alt_lmt = 'S' then
      update sc_opr.tbl_lmt set fg_alt_lmt = 'N' where cd_crt = vl_rg.cd_crt and cd_tlt = vl_rg.cd_tlt;
    end if;
  end loop;

end;$$;


ALTER FUNCTION sc_opr.zerar_limite_nao_utilizado(vp_grupo_empresarial integer) OWNER TO scan;

--
-- TOC entry 7850 (class 0 OID 0)
-- Dependencies: 1587
-- Name: FUNCTION zerar_limite_nao_utilizado(vp_grupo_empresarial integer); Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON FUNCTION zerar_limite_nao_utilizado(vp_grupo_empresarial integer) IS 'rotina que zera o limite de todos os cartões pertencentes a um grupo empresarial e que não estam utilizando';


SET search_path = sc_pbl, pg_catalog;

--
-- TOC entry 1609 (class 1255 OID 995595)
-- Name: criar_diretorio_sftp(numeric, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION criar_diretorio_sftp(vp_cod_ftp numeric, vp_diretorio character varying, vp_novo_diretorio character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  vl_diretorio_host varchar;
  vl_nm_host varchar;
  vl_porta integer;
  vl_usuario varchar;
  vl_senha varchar;
  
begin
   
   select ftp.nm_dir_hst_ftp,ftp.nm_hst_ftp,ftp.nr_prt_ftp,ftp.nm_usr_ftp,ftp.nm_snh_ftp
   into vl_diretorio_host,vl_nm_host,vl_porta,vl_usuario,vl_senha
   from sc_pbl.tbl_ftp ftp
   where ftp.cd_ftp = vp_cod_ftp;
  
   perform sc_pbl.criar_sftp(vl_nm_host,vl_porta,vl_usuario,vl_senha,vp_diretorio,vp_novo_diretorio);
end
$$;


ALTER FUNCTION sc_pbl.criar_diretorio_sftp(vp_cod_ftp numeric, vp_diretorio character varying, vp_novo_diretorio character varying) OWNER TO scan;

--
-- TOC entry 1683 (class 1255 OID 995594)
-- Name: criar_sftp(character varying, integer, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION criar_sftp(vp_nm_host character varying, vp_porta integer, vp_nm_user character varying, vp_senha character varying, vp_dir_host character varying, vp_new_dir character varying) RETURNS void
    LANGUAGE javau
    AS $$
br.com.aptare.a2pg.Arquivo.criarSftp
$$;


ALTER FUNCTION sc_pbl.criar_sftp(vp_nm_host character varying, vp_porta integer, vp_nm_user character varying, vp_senha character varying, vp_dir_host character varying, vp_new_dir character varying) OWNER TO scan;

--
-- TOC entry 1425 (class 1255 OID 564484)
-- Name: enviar_arquivo_ftp(numeric, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION enviar_arquivo_ftp(vp_cod_ftp numeric, vp_diretorio_local character varying, vp_nm_arquivo character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  vl_diretorio_host varchar;
  vl_nm_host varchar;
  vl_usuario varchar;
  vl_senha varchar;
  
begin
   
   select ftp.nm_dir_hst_ftp,ftp.nm_hst_ftp,ftp.nm_usr_ftp,ftp.nm_snh_ftp
   into vl_diretorio_host,vl_nm_host,vl_usuario,vl_senha
   from sc_pbl.tbl_ftp ftp
   where ftp.cd_ftp = vp_cod_ftp;
   
   perform sc_pbl.enviarftp(vl_nm_host,vl_usuario,vl_senha,vl_diretorio_host,vp_diretorio_local,vp_nm_arquivo );
end
$$;


ALTER FUNCTION sc_pbl.enviar_arquivo_ftp(vp_cod_ftp numeric, vp_diretorio_local character varying, vp_nm_arquivo character varying) OWNER TO scan;

--
-- TOC entry 1677 (class 1255 OID 976431)
-- Name: enviar_arquivo_sftp(numeric, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION enviar_arquivo_sftp(vp_cod_ftp numeric, vp_diretorio_local character varying, vp_nm_arquivo character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  vl_diretorio_host varchar;
  vl_nm_host varchar;
  vl_porta integer;
  vl_usuario varchar;
  vl_senha varchar;
  
begin
   
   select ftp.nm_dir_hst_ftp,ftp.nm_hst_ftp,ftp.nr_prt_ftp,ftp.nm_usr_ftp,ftp.nm_snh_ftp
   into vl_diretorio_host,vl_nm_host,vl_porta,vl_usuario,vl_senha
   from sc_pbl.tbl_ftp ftp
   where ftp.cd_ftp = vp_cod_ftp;
  
   perform sc_pbl.enviar_sftp(vl_nm_host,vl_porta,vl_usuario,vl_senha,vl_diretorio_host,vp_diretorio_local,vp_nm_arquivo);
end
$$;


ALTER FUNCTION sc_pbl.enviar_arquivo_sftp(vp_cod_ftp numeric, vp_diretorio_local character varying, vp_nm_arquivo character varying) OWNER TO scan;

--
-- TOC entry 1669 (class 1255 OID 996048)
-- Name: enviar_arquivos_ftp(character varying, integer, character varying, character varying, character varying, character varying, boolean); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION enviar_arquivos_ftp(vp_nm_host character varying, porta integer, vp_nm_user character varying, vp_senha character varying, vp_dir_host character varying, vp_lista_arquivos character varying, seguro boolean) RETURNS void
    LANGUAGE javau
    AS $$
br.com.aptare.a2pg.Arquivo.enviarArquivosFtp
$$;


ALTER FUNCTION sc_pbl.enviar_arquivos_ftp(vp_nm_host character varying, porta integer, vp_nm_user character varying, vp_senha character varying, vp_dir_host character varying, vp_lista_arquivos character varying, seguro boolean) OWNER TO scan;

--
-- TOC entry 1613 (class 1255 OID 925973)
-- Name: enviar_email(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION enviar_email(vp_remetente character varying, vp_destinatario character varying, vp_destinatario_copia character varying, vp_titulo character varying, vp_mensagem_texto character varying, vp_mensagem_html character varying, vp_cid_image character varying, vp_anexos character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_props varchar(100) := 'saqpag;biODyjFx0717;contato@somacontadigital.com.br';

  vl_retorno text;

begin
  select sc_pbl.enviar_email_java(vl_props, vp_remetente, vp_destinatario, vp_destinatario_copia, vp_titulo, vp_mensagem_texto, vp_mensagem_html, vp_cid_image, vp_anexos)
    into vl_retorno;

  if vl_retorno <> '' then
     raise exception 'erro %', vl_retorno;	
  end if;  

end;$$;


ALTER FUNCTION sc_pbl.enviar_email(vp_remetente character varying, vp_destinatario character varying, vp_destinatario_copia character varying, vp_titulo character varying, vp_mensagem_texto character varying, vp_mensagem_html character varying, vp_cid_image character varying, vp_anexos character varying) OWNER TO scan;

--
-- TOC entry 7851 (class 0 OID 0)
-- Dependencies: 1613
-- Name: FUNCTION enviar_email(vp_remetente character varying, vp_destinatario character varying, vp_destinatario_copia character varying, vp_titulo character varying, vp_mensagem_texto character varying, vp_mensagem_html character varying, vp_cid_image character varying, vp_anexos character varying); Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON FUNCTION enviar_email(vp_remetente character varying, vp_destinatario character varying, vp_destinatario_copia character varying, vp_titulo character varying, vp_mensagem_texto character varying, vp_mensagem_html character varying, vp_cid_image character varying, vp_anexos character varying) IS 'funcao de envio de email';


--
-- TOC entry 1226 (class 1255 OID 1665880)
-- Name: enviar_email_java(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION enviar_email_java(vp_props character varying, vp_remetente character varying, vp_destinatario character varying, vp_destinatario_copia character varying, vp_titulo character varying, vp_mensagem_texto character varying, vp_mensagem_html character varying, vp_cid_image character varying, vp_anexos character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_parametros text := '';

  vl_retorno text;

begin
  vl_parametros := 'remetente==' || coalesce(vp_remetente, '');
  vl_parametros := vl_parametros || ';' || 'destinatario==' || coalesce(vp_destinatario, '');
  vl_parametros := vl_parametros || ';' || 'copia==' || coalesce(vp_destinatario_copia, '');
  vl_parametros := vl_parametros || ';' || 'titulo==' || coalesce(vp_titulo, '');
  vl_parametros := vl_parametros || ';' || 'mensagem==' || coalesce(vp_mensagem_texto, '');
  vl_parametros := vl_parametros || ';' || 'mensagemHtml==' || coalesce(vp_mensagem_html, '');
  vl_parametros := vl_parametros || ';' || 'imagem==' || coalesce(vp_cid_image, '');
  vl_parametros := vl_parametros || ';' || 'anexos==' || coalesce(vp_anexos, '');

  raise notice 'parametros: %', vl_parametros;
  select sc_job.executar_java_job('enviarEmail', vl_parametros)
    into vl_retorno;

  if vl_retorno <> '' then
     raise exception 'erro %', vl_retorno;	
  end if;  

end;$$;


ALTER FUNCTION sc_pbl.enviar_email_java(vp_props character varying, vp_remetente character varying, vp_destinatario character varying, vp_destinatario_copia character varying, vp_titulo character varying, vp_mensagem_texto character varying, vp_mensagem_html character varying, vp_cid_image character varying, vp_anexos character varying) OWNER TO scan;

--
-- TOC entry 7852 (class 0 OID 0)
-- Dependencies: 1226
-- Name: FUNCTION enviar_email_java(vp_props character varying, vp_remetente character varying, vp_destinatario character varying, vp_destinatario_copia character varying, vp_titulo character varying, vp_mensagem_texto character varying, vp_mensagem_html character varying, vp_cid_image character varying, vp_anexos character varying); Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON FUNCTION enviar_email_java(vp_props character varying, vp_remetente character varying, vp_destinatario character varying, vp_destinatario_copia character varying, vp_titulo character varying, vp_mensagem_texto character varying, vp_mensagem_html character varying, vp_cid_image character varying, vp_anexos character varying) IS 'funcao de envio de email usando o backoffice ao invês do java embutido no banco';


--
-- TOC entry 1611 (class 1255 OID 925972)
-- Name: enviar_email_java_locaweb(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION enviar_email_java_locaweb(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying) RETURNS character varying
    LANGUAGE javau
    AS $$br.com.aptare.a2pg.EmailAptare.enviarEmail$$;


ALTER FUNCTION sc_pbl.enviar_email_java_locaweb(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying) OWNER TO scan;

--
-- TOC entry 1832 (class 1255 OID 1668929)
-- Name: enviar_email_java_novo(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION enviar_email_java_novo(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying) RETURNS character varying
    LANGUAGE javau
    AS $$br.com.soma.pljava.email.EnviaEmailJob.executar$$;


ALTER FUNCTION sc_pbl.enviar_email_java_novo(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying) OWNER TO scan;

--
-- TOC entry 1830 (class 1255 OID 564486)
-- Name: enviar_email_saqpag(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION enviar_email_saqpag(vp_destinatario character varying, vp_titulo character varying, vp_mensagem character varying, vp_cidimage character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_props varchar(50) := 'smtp;smtplw.com.br;587';
  vl_autenticacao varchar(50) := 'saqpag;biODyjFx0717';
  vl_remetente varchar(50) := 'contato@somacontadigital.com.br';

  vl_retorno text;

begin
  --jeito antigo de funcionar
  --select sc_pbl.enviaremailnovo(vl_props, vl_autenticacao, vl_remetente, vp_destinatario, vp_titulo, vp_mensagem, vp_cidImage)
  --into vl_retorno;

  --if vl_retorno <> 'Email Enviado' then
  --   raise exception 'erro %', vl_retorno;	
  --end if;  
  
  --jeito novo (enviando o e-mail a partir do servidor de aplicação)
  --select sc_pbl.enviar_email_java_novo(null, vl_remetente, vp_destinatario, null, vp_titulo, null, vp_mensagem, vp_cidImage, null)
  --into vl_retorno;

  --jeito novo (enviando o e-mail a partir do servidor de banco de dados)
  select sc_pbl.enviar_email_java_novo(vl_remetente, vp_destinatario, null, vp_titulo, null, vp_mensagem, null, vp_cidImage)
  into vl_retorno;

  if vl_retorno <> 'ok' then
     raise exception 'erro %', vl_retorno;	
  end if; 
end;$$;


ALTER FUNCTION sc_pbl.enviar_email_saqpag(vp_destinatario character varying, vp_titulo character varying, vp_mensagem character varying, vp_cidimage character varying) OWNER TO scan;

--
-- TOC entry 7853 (class 0 OID 0)
-- Dependencies: 1830
-- Name: FUNCTION enviar_email_saqpag(vp_destinatario character varying, vp_titulo character varying, vp_mensagem character varying, vp_cidimage character varying); Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON FUNCTION enviar_email_saqpag(vp_destinatario character varying, vp_titulo character varying, vp_mensagem character varying, vp_cidimage character varying) IS 'enviar email com os parametros saqpag';


--
-- TOC entry 1629 (class 1255 OID 975740)
-- Name: enviar_sftp(character varying, integer, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION enviar_sftp(vp_nm_host character varying, vp_porta integer, vp_nm_user character varying, vp_senha character varying, vp_dir_host character varying, vp_diretorio_local character varying, vp_nm_arquivo character varying) RETURNS void
    LANGUAGE javau
    AS $$
br.com.aptare.a2pg.Arquivo.enviarSftp
$$;


ALTER FUNCTION sc_pbl.enviar_sftp(vp_nm_host character varying, vp_porta integer, vp_nm_user character varying, vp_senha character varying, vp_dir_host character varying, vp_diretorio_local character varying, vp_nm_arquivo character varying) OWNER TO scan;

--
-- TOC entry 1670 (class 1255 OID 996036)
-- Name: enviar_varios_arquivos_ftp(numeric, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION enviar_varios_arquivos_ftp(vp_cod_ftp numeric, vp_diretorio_remoto character varying, vp_lista_arquivos character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  vl_diretorio_host varchar;
  vl_nm_host varchar;
  vl_usuario varchar;
  vl_senha varchar;
  vl_porta integer;
  vl_seguro boolean := true;
  
begin
   
   select ftp.nm_dir_hst_ftp,ftp.nm_hst_ftp,ftp.nm_usr_ftp,ftp.nm_snh_ftp, ftp.nr_prt_ftp
   into vl_diretorio_host,vl_nm_host,vl_usuario,vl_senha,vl_porta
   from sc_pbl.tbl_ftp ftp
   where ftp.cd_ftp = vp_cod_ftp;
  
   perform sc_pbl.enviar_arquivos_ftp(vl_nm_host,vl_porta,vl_usuario,vl_senha,vp_diretorio_remoto,vp_lista_arquivos, vl_seguro);
end
$$;


ALTER FUNCTION sc_pbl.enviar_varios_arquivos_ftp(vp_cod_ftp numeric, vp_diretorio_remoto character varying, vp_lista_arquivos character varying) OWNER TO scan;

--
-- TOC entry 1661 (class 1255 OID 976044)
-- Name: enviaremailnovo(character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION enviaremailnovo(character varying, character varying, character varying, character varying, character varying, character varying, character varying) RETURNS character varying
    LANGUAGE javau
    AS $$br.com.aptare.a2pg.EmailNovo.enviarEmail$$;


ALTER FUNCTION sc_pbl.enviaremailnovo(character varying, character varying, character varying, character varying, character varying, character varying, character varying) OWNER TO scan;

--
-- TOC entry 1406 (class 1255 OID 564489)
-- Name: enviarftp(character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION enviarftp(vp_nm_host character varying, vp_nm_user character varying, vp_senha character varying, vp_dir_host character varying, vp_diretorio_local character varying, vp_nm_arquivo character varying) RETURNS void
    LANGUAGE javau
    AS $$
br.com.aptare.a2pg.Arquivo.enviarFtp
$$;


ALTER FUNCTION sc_pbl.enviarftp(vp_nm_host character varying, vp_nm_user character varying, vp_senha character varying, vp_dir_host character varying, vp_diretorio_local character varying, vp_nm_arquivo character varying) OWNER TO scan;

--
-- TOC entry 1639 (class 1255 OID 932035)
-- Name: existe_caracter_especial(text); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION existe_caracter_especial(stexto text) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  vl_existe numeric := 0;
BEGIN
  -- Tabela ASCII
  -- Caracteres não imprimiveis, 33 ao total, menos o NUL ficam 32 
                                                    --  hex d abr ctl descricao  
                                                    --  00  0 NUL ^@ Null - Nulo desativado, pois o nulo no postgres funciona em forma de cascata 
  vl_existe := vl_existe + instr(stexto, chr(1));       --  01  1 SOH ^A Start of Header - Início do cabeçalho
  vl_existe := vl_existe + instr(stexto, chr(2));   --  02  2 STX ^B Start of Text - Início do texto
  vl_existe := vl_existe + instr(stexto, chr(3));   --  03  3 ETX ^C End of Text - Fim do texto
  vl_existe := vl_existe + instr(stexto, chr(4));   --  04  4 EOT ^D End of Tape - Fim de fita
  vl_existe := vl_existe + instr(stexto, chr(5));   --  05  5 ENQ ^E Enquire - Interroga identidade do terminal
  vl_existe := vl_existe + instr(stexto, chr(6));   --  06  6 ACK ^F Acknowledge - Reconhecimento
  vl_existe := vl_existe + instr(stexto, chr(7));   --  07  7 BEL ^G Bell - Campainha
  vl_existe := vl_existe + instr(stexto, chr(8));   --  08  8 BS  ^H  Back-space - Espaço atrás
  vl_existe := vl_existe + instr(stexto, chr(9));   --  09  9 HT  ^I  Horizontal Tabulation - Tabulação horizontal
  vl_existe := vl_existe + instr(stexto, chr(10));  --  0A 10 LF  ^J Line-Feed - Alimenta linha
  vl_existe := vl_existe + instr(stexto, chr(11));  --  0B 11 VT  ^K  Vertical Tabulation - Tabulação vertical
  vl_existe := vl_existe + instr(stexto, chr(12));  --  0C 12 FF  ^L Form-Feed - Alimenta formulário
  vl_existe := vl_existe + instr(stexto, chr(13));  --  0D 13 CR  ^M Carriage-Return - Retorno do carro (enter)
  vl_existe := vl_existe + instr(stexto, chr(14));  --  0E 14 SO  ^N Shift-Out - Saída do shift (passa a usar caracteres de baixo da tecla - minúsculas, etc.)
  vl_existe := vl_existe + instr(stexto, chr(15));  --  0F 15 SI  ^O Shift-In-Ent. no shift (passa a usar carac. de cima da tecla: maiúsculas, carac. especiais, etc.)
  vl_existe := vl_existe + instr(stexto, chr(16));  --  10 16 DLE ^P Data-Link Escape
  vl_existe := vl_existe + instr(stexto, chr(17));  --  11 17 DC1 ^Q Device-Control 1
  vl_existe := vl_existe + instr(stexto, chr(18));  --  12 18 DC2 ^R Device-Control 2
  vl_existe := vl_existe + instr(stexto, chr(19));  --  13 19 DC3 ^S Device-Control 3
  vl_existe := vl_existe + instr(stexto, chr(20));  --  14 20 DC4 ^T Device-Control 4
  vl_existe := vl_existe + instr(stexto, chr(21));  --  15 21 NAK ^U Neg-Acknowledge - Não-reconhecimento
  vl_existe := vl_existe + instr(stexto, chr(22));  --  16 22 SYN ^V Synchronous Idle
  vl_existe := vl_existe + instr(stexto, chr(23));  --  17 23 vETB^W  End-of-Transmission Block
  vl_existe := vl_existe + instr(stexto, chr(24));  --  18 24 CAN ^X Cancel
  vl_existe := vl_existe + instr(stexto, chr(25));  --  19 25 EM  ^Y  End-Of-Medium
  vl_existe := vl_existe + instr(stexto, chr(26));  --  1A 26 SUB ^Z Substitute
  vl_existe := vl_existe + instr(stexto, chr(27));  --  1B 27 ESC ^[ Escape
  vl_existe := vl_existe + instr(stexto, chr(28));  --  1C 28 FS  ^\  File Separator
  vl_existe := vl_existe + instr(stexto, chr(29));  --  1D 29 GS  ^] Group Separator
  vl_existe := vl_existe + instr(stexto, chr(30));  --  1E 30 RS  ^^  Record Separator
  vl_existe := vl_existe + instr(stexto, chr(31));  --  1F 31 US  ^_ Unit Separator
  vl_existe := vl_existe + instr(stexto, chr(127)); --  7F127 DEL ^?  Delete
 
  RETURN vl_existe;
END;$$;


ALTER FUNCTION sc_pbl.existe_caracter_especial(stexto text) OWNER TO scan;

--
-- TOC entry 7854 (class 0 OID 0)
-- Dependencies: 1639
-- Name: FUNCTION existe_caracter_especial(stexto text); Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON FUNCTION existe_caracter_especial(stexto text) IS 'verfica se existe caracteres especiais em um texto';


--
-- TOC entry 1356 (class 1255 OID 564490)
-- Name: modulo10(character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION modulo10(vp_numero character varying) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
  vl_num     varchar;
  vl_posicao numeric := 0;
  vl_peso    numeric := 2;
  vl_soma    numeric := 0;
  vl_produto numeric := 0;
  vl_retorno numeric := 0;
  vl_cont    numeric := 0;
begin

  while (vl_cont < length(vp_numero)) loop
     vl_posicao := length(vp_numero) - vl_cont;
     vl_num := substr(vp_numero::text, vl_posicao::integer, 1);
	 vl_produto := to_number(vl_num, '99G999D9S') * vl_peso;
	 if vl_produto >= 10 then
		vl_produto := substr(vl_produto::text, 1, 1)::numeric + substr(vl_produto::text, 2, 1)::numeric;
	 end if;
	 vl_soma := vl_soma + vl_produto;
	 
     if vl_peso = 2 then
        vl_peso := 1;
     else
        vl_peso := 2;
     end if;
     vl_cont := vl_cont + 1;
  end loop;
	
  if vl_soma > 10 then
    vl_retorno := vl_soma % 10;
    if vl_retorno > 0 then
       vl_retorno := 10 - vl_retorno;
    end if;
  else
    vl_retorno := 10 - vl_soma;
  end if;
    
  return vl_retorno;
end$$;


ALTER FUNCTION sc_pbl.modulo10(vp_numero character varying) OWNER TO scan;

--
-- TOC entry 7855 (class 0 OID 0)
-- Dependencies: 1356
-- Name: FUNCTION modulo10(vp_numero character varying); Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON FUNCTION modulo10(vp_numero character varying) IS 'Rotina que calcula realiza calculos para obter digito verificador baseado no modulo 10';


--
-- TOC entry 1357 (class 1255 OID 564491)
-- Name: modulo11(numeric); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION modulo11(vp_numero numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
  vl_num     varchar;
  vl_posicao numeric := 0;
  vl_peso    numeric := 9;
  vl_soma    numeric := 0;
  vl_retorno numeric := 0;
  vl_cont    numeric := 0;
  vl_codigo  varchar;
begin

  vl_codigo := vp_numero || '';
  while (vl_cont < length(vl_codigo)) loop
     vl_posicao := length(vl_codigo) - vl_cont;
     vl_num := substr(vl_codigo::text, vl_posicao::integer, 1);
     vl_soma := vl_soma + (to_number(vl_num, '99G999D9S') * vl_peso);
     vl_peso := vl_peso - 1;
     if vl_peso = 1 then
        vl_peso := 9;
     end if;
     vl_cont := vl_cont + 1;
  end loop;

  vl_retorno := vl_soma % 11;

  if vl_retorno > 9 then
     vl_retorno := 0;
  end if;

  return vl_retorno;
end$$;


ALTER FUNCTION sc_pbl.modulo11(vp_numero numeric) OWNER TO scan;

--
-- TOC entry 7856 (class 0 OID 0)
-- Dependencies: 1357
-- Name: FUNCTION modulo11(vp_numero numeric); Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON FUNCTION modulo11(vp_numero numeric) IS 'Rotina que calcula realiza calculos para obter digito verificador baseado no modulo 11';


--
-- TOC entry 1852 (class 1255 OID 1655006)
-- Name: modulo11_bb(character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION modulo11_bb(vp_numero character varying) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
  vl_num     varchar;
  vl_posicao numeric := 0;
  vl_peso    numeric := 2;
  vl_soma    numeric := 0;
  vl_retorno numeric := 0;
  vl_cont    numeric := 0;
begin

  while (vl_cont < length(vp_numero)) loop
     vl_posicao := length(vp_numero) - vl_cont;
     vl_num := substr(vp_numero::text, vl_posicao::integer, 1);
     vl_soma := vl_soma + (to_number(vl_num, '99G999D9S') * vl_peso);
     if vl_peso = 9 then
        vl_peso := 2;
     else
        vl_peso := vl_peso + 1;
     end if;
     vl_cont := vl_cont + 1;
  end loop;

  vl_retorno := vl_soma % 11;

  vl_retorno := 11 - vl_retorno;   
  
  if vl_retorno in (10,11) then
     vl_retorno := 0;
  end if;

  return vl_retorno;
end$$;


ALTER FUNCTION sc_pbl.modulo11_bb(vp_numero character varying) OWNER TO scan;

--
-- TOC entry 7857 (class 0 OID 0)
-- Dependencies: 1852
-- Name: FUNCTION modulo11_bb(vp_numero character varying); Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON FUNCTION modulo11_bb(vp_numero character varying) IS 'Rotina que calcula realiza calculos para obter digito verificador baseado no modulo 11';


--
-- TOC entry 1363 (class 1255 OID 564492)
-- Name: modulo11_bradesco(numeric); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION modulo11_bradesco(vp_numero numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  vl_num     varchar;
  vl_posicao numeric := 0;
  vl_peso    numeric := 2;
  vl_soma    numeric := 0;
  vl_retorno numeric := 0;
  vl_cont    numeric := 0;
  vl_codigo  varchar;
begin

  vl_codigo := vp_numero || '';
  while (vl_cont < length(vl_codigo)) loop
     vl_posicao := length(vl_codigo) - vl_cont;
     vl_num := substr(vl_codigo::text, vl_posicao::integer, 1);
     vl_soma := vl_soma + (to_number(vl_num, '99G999D9S') * vl_peso);
     vl_peso := vl_peso + 1;
     if vl_peso = 8 then
        vl_peso := 2;
     end if;
     vl_cont := vl_cont + 1;
  end loop;

  vl_retorno := vl_soma % 11;

  if vl_retorno != 0 then
    if vl_retorno = 1 then 
      return 'P';
    else
      vl_retorno := 11 - vl_retorno;
    end if;
  end if;
  
  return vl_retorno;
end$$;


ALTER FUNCTION sc_pbl.modulo11_bradesco(vp_numero numeric) OWNER TO scan;

--
-- TOC entry 7858 (class 0 OID 0)
-- Dependencies: 1363
-- Name: FUNCTION modulo11_bradesco(vp_numero numeric); Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON FUNCTION modulo11_bradesco(vp_numero numeric) IS 'Rotina que calcula realiza calculos para obter digito verificador baseado no modulo 11';


--
-- TOC entry 1373 (class 1255 OID 564493)
-- Name: modulo11_dac(character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION modulo11_dac(vp_numero character varying) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare
  vl_num     varchar;
  vl_posicao numeric := 0;
  vl_peso    numeric := 2;
  vl_soma    numeric := 0;
  vl_retorno numeric := 0;
  vl_cont    numeric := 0;
begin

  while (vl_cont < length(vp_numero)) loop
     vl_posicao := length(vp_numero) - vl_cont;
     vl_num := substr(vp_numero::text, vl_posicao::integer, 1);
     vl_soma := vl_soma + (to_number(vl_num, '99G999D9S') * vl_peso);
     if vl_peso = 9 then
        vl_peso := 2;
     else
        vl_peso := vl_peso + 1;
     end if;
     vl_cont := vl_cont + 1;
  end loop;

  vl_retorno := vl_soma % 11;
  
  if vl_retorno in (0,1,10) then
     vl_retorno := 1;
  else
     vl_retorno := 11 - vl_retorno;   
  end if;

  return vl_retorno;
end$$;


ALTER FUNCTION sc_pbl.modulo11_dac(vp_numero character varying) OWNER TO scan;

--
-- TOC entry 7859 (class 0 OID 0)
-- Dependencies: 1373
-- Name: FUNCTION modulo11_dac(vp_numero character varying); Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON FUNCTION modulo11_dac(vp_numero character varying) IS 'Rotina que calcula realiza calculos para obter digito verificador baseado no modulo 11';


--
-- TOC entry 1848 (class 1255 OID 1655005)
-- Name: modulo11_especial(numeric); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION modulo11_especial(vp_numero numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$ 

declare
  vl_num     varchar;
  vl_posicao numeric := 0;
  vl_peso    numeric := 2;
  vl_soma    numeric := 0;
  vl_retorno numeric := 0;
  vl_cont    numeric := 0;
  vl_codigo  varchar;
begin

  vl_codigo := vp_numero || '';
  while (vl_cont < length(vl_codigo)) loop
     vl_posicao := length(vl_codigo) - vl_cont;
     vl_num := substr(vl_codigo::text, vl_posicao::integer, 1);
     vl_soma := vl_soma + (to_number(vl_num, '99G999D9S') * vl_peso);
     vl_peso := vl_peso + 1;
     if vl_peso = 8 then
        vl_peso := 2;
     end if;
     vl_cont := vl_cont + 1;
  end loop;

  vl_retorno := vl_soma % 11;

  if vl_retorno = 0 then
     vl_retorno := 0;
  else
     vl_retorno = 11 - vl_retorno;   
  end if;

  if vl_retorno = 10 then
    vl_retorno := 0;
  end if;

  return vl_retorno;
end

$$;


ALTER FUNCTION sc_pbl.modulo11_especial(vp_numero numeric) OWNER TO scan;

--
-- TOC entry 7860 (class 0 OID 0)
-- Dependencies: 1848
-- Name: FUNCTION modulo11_especial(vp_numero numeric); Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON FUNCTION modulo11_especial(vp_numero numeric) IS 'Rotina que calcula realiza calculos para obter digito verificador baseado no modulo 11';


--
-- TOC entry 1374 (class 1255 OID 564494)
-- Name: primeiro_nome(character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION primeiro_nome(vp_nome_completo character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
begin
  return substring(vp_nome_completo, 0, position(' ' in vp_nome_completo));
end;$$;


ALTER FUNCTION sc_pbl.primeiro_nome(vp_nome_completo character varying) OWNER TO scan;

--
-- TOC entry 1638 (class 1255 OID 932034)
-- Name: remove_caracter_especial(text); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION remove_caracter_especial(stexto text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  stextonovo TEXT;
BEGIN
  -- Tabela ASCII
  -- Caracteres não imprimiveis, 33 ao total, menos o NUL ficam 32 
                                                    --  hex d abr ctl descricao  
                                                    --  00  0 NUL ^@ Null - Nulo desativado, pois o nulo no postgres funciona em forma de cascata 
  stextonovo := translate(stexto, chr(1),'');       --  01  1 SOH ^A Start of Header - Início do cabeçalho
  stextonovo := translate(stextonovo, chr(2),'');   --  02  2 STX ^B Start of Text - Início do texto
  stextonovo := translate(stextonovo, chr(3),'');   --  03  3 ETX ^C End of Text - Fim do texto
  stextonovo := translate(stextonovo, chr(4),'');   --  04  4 EOT ^D End of Tape - Fim de fita
  stextonovo := translate(stextonovo, chr(5),'');   --  05  5 ENQ ^E Enquire - Interroga identidade do terminal
  stextonovo := translate(stextonovo, chr(6),'');   --  06  6 ACK ^F Acknowledge - Reconhecimento
  stextonovo := translate(stextonovo, chr(7),'');   --  07  7 BEL ^G Bell - Campainha
  stextonovo := translate(stextonovo, chr(8),'');   --  08  8 BS  ^H  Back-space - Espaço atrás
  stextonovo := translate(stextonovo, chr(9),'');   --  09  9 HT  ^I  Horizontal Tabulation - Tabulação horizontal
  stextonovo := translate(stextonovo, chr(10),'');  --  0A 10 LF  ^J Line-Feed - Alimenta linha
  stextonovo := translate(stextonovo, chr(11),'');  --  0B 11 VT  ^K  Vertical Tabulation - Tabulação vertical
  stextonovo := translate(stextonovo, chr(12),'');  --  0C 12 FF  ^L Form-Feed - Alimenta formulário
  stextonovo := translate(stextonovo, chr(13),'');  --  0D 13 CR  ^M Carriage-Return - Retorno do carro (enter)
  stextonovo := translate(stextonovo, chr(14),'');  --  0E 14 SO  ^N Shift-Out - Saída do shift (passa a usar caracteres de baixo da tecla - minúsculas, etc.)
  stextonovo := translate(stextonovo, chr(15),'');  --  0F 15 SI  ^O Shift-In-Ent. no shift (passa a usar carac. de cima da tecla: maiúsculas, carac. especiais, etc.)
  stextonovo := translate(stextonovo, chr(16),'');  --  10 16 DLE ^P Data-Link Escape
  stextonovo := translate(stextonovo, chr(17),'');  --  11 17 DC1 ^Q Device-Control 1
  stextonovo := translate(stextonovo, chr(18),'');  --  12 18 DC2 ^R Device-Control 2
  stextonovo := translate(stextonovo, chr(19),'');  --  13 19 DC3 ^S Device-Control 3
  stextonovo := translate(stextonovo, chr(20),'');  --  14 20 DC4 ^T Device-Control 4
  stextonovo := translate(stextonovo, chr(21),'');  --  15 21 NAK ^U Neg-Acknowledge - Não-reconhecimento
  stextonovo := translate(stextonovo, chr(22),'');  --  16 22 SYN ^V Synchronous Idle
  stextonovo := translate(stextonovo, chr(23),'');  --  17 23 vETB^W  End-of-Transmission Block
  stextonovo := translate(stextonovo, chr(24),'');  --  18 24 CAN ^X Cancel
  stextonovo := translate(stextonovo, chr(25),'');  --  19 25 EM  ^Y  End-Of-Medium
  stextonovo := translate(stextonovo, chr(26),'');  --  1A 26 SUB ^Z Substitute
  stextonovo := translate(stextonovo, chr(27),'');  --  1B 27 ESC ^[ Escape
  stextonovo := translate(stextonovo, chr(28),'');  --  1C 28 FS  ^\  File Separator
  stextonovo := translate(stextonovo, chr(29),'');  --  1D 29 GS  ^] Group Separator
  stextonovo := translate(stextonovo, chr(30),'');  --  1E 30 RS  ^^  Record Separator
  stextonovo := translate(stextonovo, chr(31),'');  --  1F 31 US  ^_ Unit Separator
  stextonovo := translate(stextonovo, chr(127),''); --  7F127 DEL ^?  Delete
 
  RETURN stextonovo;
END;$$;


ALTER FUNCTION sc_pbl.remove_caracter_especial(stexto text) OWNER TO scan;

--
-- TOC entry 7861 (class 0 OID 0)
-- Dependencies: 1638
-- Name: FUNCTION remove_caracter_especial(stexto text); Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON FUNCTION remove_caracter_especial(stexto text) IS 'remove os caracteres especiais de um texto';


--
-- TOC entry 1507 (class 1255 OID 852255)
-- Name: resultado_tabela(character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION resultado_tabela(vp_parametro character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare


  vl_parametros character varying[];
  vl_retorno varchar := ''; 
  rg_tabela record;
  i numeric;
  vl_separador varchar := '';
  vl_campo varchar;
  vl_campos varchar := '';
  vl_condicao varchar;
  vl_tabela varchar;
  
  vl_codigos numeric[];
  vl_descricoes varchar[];

  begin

      vl_parametros := string_to_array(vp_parametro,',');
  
      vl_tabela := vl_parametros[1];
      vl_condicao := vl_parametros[2];

      for i in 3..array_length(vl_parametros,1) loop
        vl_campos := vl_campos || vl_separador || 'array_agg(' || vl_parametros[i] || ')';
        vl_separador := ',';
      end loop;

      vl_separador := '';
      
      if length(vl_condicao) > 0 then
        raise notice '%', 'select ' || vl_campos || ' from ' || vl_tabela || ' where ' || vl_condicao;      
        execute 'select ' || vl_campos || ' from ' || vl_tabela || ' where ' || vl_condicao into vl_codigos, vl_descricoes;
      else
        raise notice '%', 'select ' || vl_campos || ' from ' || vl_tabela;      
        execute 'select ' || vl_campos || ' from ' || vl_tabela into vl_codigos, vl_descricoes;
      end if; 

      for i in 1..array_length(vl_codigos,1) loop

         vl_retorno := vl_retorno || vl_separador || vl_codigos[i] || ':' || vl_descricoes[i];
         vl_separador := '#';
         
      end loop;

  
  return vl_retorno;
end$$;


ALTER FUNCTION sc_pbl.resultado_tabela(vp_parametro character varying) OWNER TO scan;

--
-- TOC entry 7862 (class 0 OID 0)
-- Dependencies: 1507
-- Name: FUNCTION resultado_tabela(vp_parametro character varying); Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON FUNCTION resultado_tabela(vp_parametro character varying) IS 'Rotina que retorna registros de uma tabela em uma unica linha';


--
-- TOC entry 1375 (class 1255 OID 564495)
-- Name: sem_acento(text); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION sem_acento(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$   
select   
translate($1,'áàâãäéèêëíìïóòôõöúùûüÁÀÂÃÄÉÈÊËÍÌÏÓÒÔÕÖÚÙÛÜçÇ','aaaaaeeeeiiiooooouuuuAAAAAEEEEIIIOOOOOUUUUcC');   
$_$;


ALTER FUNCTION sc_pbl.sem_acento(text) OWNER TO scan;

--
-- TOC entry 1499 (class 1255 OID 839939)
-- Name: texto_to_numero(text); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION texto_to_numero(text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$   
select   
translate($1,'abcdefghijklmnopqrstuwvxzABCDEFGHIJKLMNOPQRSTUWVXZáàâãäéèêëíìïóòôõöúùûüÁÀÂÃÄÉÈÊËÍÌÏÓÒÔÕÖÚÙÛÜçÇ-/?)([]{}''"|<>_*&%$#@','');   
$_$;


ALTER FUNCTION sc_pbl.texto_to_numero(text) OWNER TO scan;

--
-- TOC entry 1376 (class 1255 OID 564496)
-- Name: ultimo_dia_mes(date); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION ultimo_dia_mes(vp_data date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

vl_data_referencia date;

begin

 vl_data_referencia := vp_data + interval '1 month';

 vl_data_referencia := to_date ('01/' || to_char(vl_data_referencia,'mm/yyyy'),'dd/mm/yyyy');

 vl_data_referencia := vl_data_referencia - 1;

 return to_char(vl_data_referencia,'dd')::numeric;

end;$$;


ALTER FUNCTION sc_pbl.ultimo_dia_mes(vp_data date) OWNER TO scan;

--
-- TOC entry 1739 (class 1255 OID 564497)
-- Name: valor_formato_ptbr(numeric, character varying); Type: FUNCTION; Schema: sc_pbl; Owner: scan
--

CREATE FUNCTION valor_formato_ptbr(vp_valor numeric, vp_separador_milhar character varying DEFAULT 'S'::character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
begin

  if vp_separador_milhar = 'S' then
    return replace(to_char(vp_valor, '999G999G999G990D99'), ' ', '');
  else
    return replace(to_char(vp_valor, '9999990D99'), ' ', '');
  end if;
  
end;$$;


ALTER FUNCTION sc_pbl.valor_formato_ptbr(vp_valor numeric, vp_separador_milhar character varying) OWNER TO scan;

SET search_path = sc_pgc, pg_catalog;

--
-- TOC entry 1758 (class 1255 OID 1034402)
-- Name: autorizar_agendamento_pagamento(numeric, numeric, character varying, date); Type: FUNCTION; Schema: sc_pgc; Owner: scan
--

CREATE FUNCTION autorizar_agendamento_pagamento(vp_vl_pga numeric, vp_tp_org_pgt numeric, vp_nsu_org_pga character varying, vp_dt_pga date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

declare

  ct_st_autorizado numeric := 2;
  ct_st_n_autorizado numeric := 2;
  ct_st_confirmado numeric := 3;
  ct_st_cadastrado numeric := 1;
  ct_st_pendente_confirmacao numeric := 8;
  ct_st_agendado numeric := 9;
  ct_tipo_origem_pagamento_usuario_cartao numeric := 1;
  ct_parametro_limite_por_pagamento numeric := 38;
  ct_parametro_limite_diario_pagamento numeric := 39;

  vl_vlr_ttl_pga numeric;
  vl_max_pgt numeric;
  vl_max_dia_pgt numeric;
  vl_int_prm_hr_pgt varchar;
  vl_int_hr text[];
  vl_hr_ini timestamp;
  vl_hr_fim timestamp;
  
  vl_retorno varchar := 'PGC_000'; -- sucesso
begin

  -- validar valor do pagamento
  if vp_tp_org_pgt = ct_tipo_origem_pagamento_usuario_cartao then
    vl_max_pgt := replace(replace(sc_cad.get_parametro_contrato_cartao(ct_parametro_limite_por_pagamento, vp_nsu_org_pga::numeric),'.',''),',','.')::numeric;
  end if;

  if vl_max_pgt is null then
    select vl_prm::numeric
      into vl_max_pgt
    from sc_cad.tbl_prm
    where nm_prm = 'VL_MAX_POR_PGC';
  end if;  
  
  if vp_vl_pga > vl_max_pgt then
    vl_retorno := 'PGC_ERR_002';
  end if;
  
  -- validar valor maximo por dia
  if vp_tp_org_pgt = ct_tipo_origem_pagamento_usuario_cartao then
    vl_max_dia_pgt := replace(replace(sc_cad.get_parametro_contrato_cartao(ct_parametro_limite_diario_pagamento, vp_nsu_org_pga::numeric),'.',''),',','.')::numeric;
  end if;

  if vl_max_dia_pgt is null then
    select vl_prm::numeric
      into vl_max_dia_pgt
    from sc_cad.tbl_prm
    where nm_prm = 'VL_MAX_DIA_PGC';
  end if;
  
  select sum(pga.vl_pga)
    into vl_vlr_ttl_pga
  from sc_pgc.tbl_pga pga
  where pga.nsu_org_pga = vp_nsu_org_pga
    and pga.tp_org_pgt = vp_tp_org_pgt
    and pga.dt_pga between vp_dt_pga and (vp_dt_pga + interval '1 day')
  and pga.st_pgt = ct_st_agendado;

  if vl_vlr_ttl_pga > vl_max_dia_pgt then
    vl_retorno := 'PGC_ERR_003';
  end if;
  
  return vl_retorno;

end;

$$;


ALTER FUNCTION sc_pgc.autorizar_agendamento_pagamento(vp_vl_pga numeric, vp_tp_org_pgt numeric, vp_nsu_org_pga character varying, vp_dt_pga date) OWNER TO scan;

--
-- TOC entry 1619 (class 1255 OID 892152)
-- Name: autorizar_pagamento_saqpag(numeric); Type: FUNCTION; Schema: sc_pgc; Owner: scan
--

CREATE FUNCTION autorizar_pagamento_saqpag(vp_cd_pgt numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

declare

  ct_st_autorizado numeric := 2;
  ct_st_n_autorizado numeric := 2;
  ct_st_confirmado numeric := 3;
  ct_st_cadastrado numeric := 1;
  ct_st_pendente_confirmacao numeric := 8;
  ct_tipo_origem_pagamento_usuario_cartao numeric := 1;
  ct_tipo_origem_pagamento_empresa numeric := 2;
  ct_parametro_limite_por_pagamento numeric := 38;
  ct_parametro_limite_diario_pagamento numeric := 39;

  vl_max_pgt numeric;
  vl_max_dia_pgt numeric;
  vl_vlr_ttl_pgt numeric;
  vl_int_prm_hr_pgt varchar;
  vl_int_hr text[];
  vl_hr_ini timestamp;
  vl_hr_fim timestamp;
  
  vl_retorno varchar := 'PGC_000'; -- sucesso
  vl_existe numeric;

  rg_pgt record;
  rg_cnt record;

begin

  select *
    into rg_pgt
  from sc_pgc.tbl_pgt pgt
  where pgt.cd_pgt = vp_cd_pgt;
	
	if rg_pgt.tp_org_pgt = ct_tipo_origem_pagamento_usuario_cartao then	
		-- validar saldo
		select cnt.*
			into rg_cnt
		from sc_opr.tbl_cnt_crt ccr
			inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = ccr.cd_cnt
		where ccr.cd_crt = rg_pgt.nsu_org_pgt::numeric
			and ccr.fg_pdr_cnt_crt = 'S';
		
		if rg_pgt.vl_pgt > rg_cnt.vl_sld_cnt then
			vl_retorno := 'PGC_ERR_001';
		end if;

		-- validar valor do pagamento
		if rg_pgt.tp_org_pgt = ct_tipo_origem_pagamento_usuario_cartao then
			vl_max_pgt := replace(replace(sc_cad.get_parametro_contrato_cartao(ct_parametro_limite_por_pagamento, rg_pgt.nsu_org_pgt::numeric),'.',''),',','.')::numeric;
		end if;

		if vl_max_pgt is null then

			select vl_prm::numeric
				into vl_max_pgt
			from sc_cad.tbl_prm
			where nm_prm = 'VL_MAX_POR_PGC';

		end if;  
		
		if rg_pgt.vl_pgt > vl_max_pgt then
			vl_retorno := 'PGC_ERR_002';
		end if;
		
		-- validar valor maximo por dia
		if rg_pgt.tp_org_pgt = ct_tipo_origem_pagamento_usuario_cartao then
			vl_max_dia_pgt := replace(replace(sc_cad.get_parametro_contrato_cartao(ct_parametro_limite_diario_pagamento, rg_pgt.nsu_org_pgt::numeric),'.',''),',','.')::numeric;
		end if;

		if vl_max_dia_pgt is null then

			select vl_prm::numeric
				into vl_max_dia_pgt
			from sc_cad.tbl_prm
			where nm_prm = 'VL_MAX_DIA_PGC';
			
		end if;
		
		select sum(pgt.vl_pgt)
			into vl_vlr_ttl_pgt
		from sc_pgc.tbl_pgt pgt
		where pgt.nsu_org_pgt = rg_pgt.nsu_org_pgt
			and pgt.tp_org_pgt = rg_pgt.tp_org_pgt
			and pgt.dt_pgt between rg_pgt.dt_pgt::date and (rg_pgt.dt_pgt::date + interval '1 day')
		and pgt.st_pgt in (ct_st_autorizado, ct_st_confirmado, ct_st_cadastrado, ct_st_pendente_confirmacao);

		if vl_vlr_ttl_pgt > vl_max_dia_pgt then
			vl_retorno := 'PGC_ERR_003';
		end if;

		-- validar fila de pagamento
		select count(*)
		  into vl_existe
		  from sc_pgc.tbl_pgt
		where st_pgt in (ct_st_autorizado, ct_st_pendente_confirmacao)
		  and dt_inc_usr >= current_date;

		if vl_existe > 0 then
		  vl_retorno := 'PGC_ERR_005';
		end if;
		  
		    
	elsif rg_pgt.tp_org_pgt = ct_tipo_origem_pagamento_empresa then
	  -- validar saldo empresa
		select cnt.*
			into rg_cnt
	  from sc_cad.tbl_ctr ctr
			inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = ctr.cd_cnt
		where ctr.cd_ctr = rg_pgt.nsu_org_pgt::numeric;
		
		if rg_pgt.vl_pgt > rg_cnt.vl_sld_cnt then
			vl_retorno := 'PGC_ERR_001';
		end if;
	end if;
		
  -- validar horario
  select vl_prm
    into vl_int_prm_hr_pgt
  from sc_cad.tbl_prm
  where nm_prm = 'INT_HORARIO_PGC';
  
  vl_int_hr := string_to_array(vl_int_prm_hr_pgt, '-')::text[];
  
  if rg_pgt.dt_inc_usr::time < to_timestamp(vl_int_hr[1],'hh24-mi')::time 
    or rg_pgt.dt_inc_usr::time > to_timestamp(vl_int_hr[2],'hh24-mi')::time then
    vl_retorno := 'PGC_ERR_004';
  end if;
  
  return vl_retorno;

end;

$$;


ALTER FUNCTION sc_pgc.autorizar_pagamento_saqpag(vp_cd_pgt numeric) OWNER TO scan;

--
-- TOC entry 1671 (class 1255 OID 1666818)
-- Name: cancelar_contabilizacao_pagamentos(date); Type: FUNCTION; Schema: sc_pgc; Owner: scan
--

CREATE FUNCTION cancelar_contabilizacao_pagamentos(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg record;
  --ct_fornecedor_pague_menos numeric := 286;
  
  CT_TIPO_DESPESA_PAGAMENTO_CONTAS constant numeric := 120;
  CT_CENTRO_CUSTO constant numeric := 1;
  CT_USUARIO_ADM constant numeric := 1;
  CT_SITUACAO_AUTORIZADO constant numeric := 2;
  CT_SITUACAO_CANCELADO constant numeric := 4;
  CT_SITUACAO_CONFIRMADO constant numeric := 3;
  CT_TP_PAGTO_TRASF_BANCARIA constant numeric := 3;

  CT_SISTEMA_PAGAMENTO_CONTA constant numeric := 29;
  CT_TP_LANC_ESTORNO_REPASSE_CORRESP constant numeric := 1409;
 
  vl_pagamento numeric;

  vl_existe integer;
begin

  if not sc_grl.eh_dia_util(vp_data_referencia) then
    raise exception 'Não é um dia útil: %', vp_data_referencia;
  end if;

  FOR vl_rg IN select pgt.dt_ctb_pgt::date as data_contabil, crr.cd_crr, crr.ds_crr, crr.cd_frn, cbf.cd_cbf, crr.cd_cnt as conta_correspondente, frn.cd_cnt as conta_fornecedor, sum(vl_pgt) AS valor 
               from sc_pgc.tbl_pgt pgt
                    INNER JOIN sc_pgc.tbl_crr crr ON pgt.cd_crr = crr.cd_crr
                    INNER JOIN sc_cap.tbl_frn frn ON crr.cd_frn = frn.cd_frn
                    INNER JOIN (SELECT cbf.cd_cun, min(cbf.cd_cbf) AS cd_cbf
                                FROM sc_cad.tbl_cbf cbf 
                                WHERE cbf.fg_atv_cbf = 'S'
                                GROUP BY cbf.cd_cun) cbf ON frn.cd_cun = cbf.cd_cun
               where pgt.st_pgt = CT_SITUACAO_CONFIRMADO
                 and pgt.dt_ctb_pgt >= vp_data_referencia
    	         and pgt.dt_ctb_pgt < vp_data_referencia + interval '1 day'
               GROUP BY crr.cd_crr, crr.ds_crr, crr.cd_frn, cbf.cd_cbf, crr.cd_cnt, frn.cd_cnt, pgt.dt_ctb_pgt::date loop

    if coalesce(vl_rg.valor, 0) = 0 THEN
      raise exception 'Não foi encontrado pagamento de contas contabilizados na data: %', vp_data_referencia;
    end if;
    
    select count(*)
      into vl_existe
    from sc_cap.tbl_dsp
    where cd_cdc = CT_CENTRO_CUSTO
      and cd_frn = vl_rg.cd_frn
      and cd_tdp = CT_TIPO_DESPESA_PAGAMENTO_CONTAS
      and st_dsp = CT_SITUACAO_AUTORIZADO
      and vl_dsp = vl_rg.valor
      and tp_pgt_dsp = CT_TP_PAGTO_TRASF_BANCARIA
      and dt_ref_dsp >= vp_data_referencia
      and dt_ref_dsp < vp_data_referencia + interval '1 day';

    if coalesce(vl_existe, 0) = 0 then
      raise exception 'Não foi encontrado o contas a pagar AUTORIZADO referente ao repasse do correspondente. Valor: %, Data: %, Fornecedor: %', 
		vl_rg.valor, vp_data_referencia, vl_rg.cd_frn;
    end if;

    --cancelando a despesa referente ao pagamento do repasse
    update sc_cap.tbl_dsp
       set st_dsp = CT_SITUACAO_CANCELADO,
           cd_cnc_usr = CT_USUARIO_ADM,
           dt_cnc_usr = now()
    where cd_cdc = CT_CENTRO_CUSTO
      and cd_frn = vl_rg.cd_frn
      and cd_tdp = CT_TIPO_DESPESA_PAGAMENTO_CONTAS
      and st_dsp = CT_SITUACAO_AUTORIZADO
      and vl_dsp = vl_rg.valor
      and tp_pgt_dsp = CT_TP_PAGTO_TRASF_BANCARIA
      and dt_ref_dsp >= vp_data_referencia
      and dt_ref_dsp < vp_data_referencia + interval '1 day';
        
      
    --desfazendo a transferencia da conta a repassa para a conta do fornecedor
    perform sc_cnt.lancar_debito_credito(vl_rg.conta_fornecedor, vl_rg.conta_correspondente, 
                                  CT_TP_LANC_ESTORNO_REPASSE_CORRESP,  'ESTORNO REPASSE CORRESPONDENTE',
                                  'ESTORNO REPASSE CORRESPONDENTE', vl_rg.valor,
                                  vl_rg.data_contabil, CT_USUARIO_ADM,
                                  CT_SISTEMA_PAGAMENTO_CONTA, trim(to_char(vl_rg.data_contabil, 'YYYYMMDD'))::numeric);

    --anulando a data de contabilizacao dos pagamentos contabilizados
    update sc_pgc.tbl_pgt 
       set dt_ctb_pgt = null
    where st_pgt = CT_SITUACAO_CONFIRMADO 
      and dt_ctb_pgt >= vp_data_referencia
      and dt_ctb_pgt < vp_data_referencia + interval '1 day'
      AND cd_crr = vl_rg.cd_crr;
  END loop;
end$$;


ALTER FUNCTION sc_pgc.cancelar_contabilizacao_pagamentos(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1787 (class 1255 OID 895429)
-- Name: contabilizar_pagamentos(); Type: FUNCTION; Schema: sc_pgc; Owner: scan
--

CREATE FUNCTION contabilizar_pagamentos() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg record;
  --ct_fornecedor_pague_menos numeric := 286;
  
  CT_TIPO_DESPESA_PAGAMENTO_CONTAS constant numeric := 120;
  CT_CENTRO_CUSTO constant numeric := 1;
  CT_USUARIO_ADM constant numeric := 1;
  CT_SITUACAO_AUTORIZADO constant numeric := 2;
  CT_SITUACAO_CONFIRMADO constant numeric := 3;
  CT_SITUACAO_CANCELADO constant numeric := 7;
  CT_TP_PAGTO_TRASF_BANCARIA constant numeric := 3;
  CT_SEGUNDA_FEIRA constant numeric := 1;

  CT_SISTEMA_PAGAMENTO_CONTA constant numeric := 29;
  CT_TP_LANC_REPASSE_CORRESPONDENTE constant numeric := 1410;
 
  vl_pagamento numeric;

  vl_data_limite date;

  vl_desconto numeric;
begin


  if not sc_grl.eh_dia_util(current_date) then
    return ;
  end if;

  vl_data_limite := current_date;
  if extract(dow from vl_data_limite) = CT_SEGUNDA_FEIRA then
    vl_data_limite := (vl_data_limite - interval '2 day')::date;
  end if;

  FOR vl_rg IN select current_date as data_contabil, crr.cd_crr, crr.ds_crr, crr.cd_frn, cbf.cd_cbf, crr.cd_cnt as conta_correspondente, frn.cd_cnt as conta_fornecedor, sum(vl_pgt) AS valor 
               from sc_pgc.tbl_pgt pgt
                    INNER JOIN sc_pgc.tbl_crr crr ON pgt.cd_crr = crr.cd_crr
                    INNER JOIN sc_cap.tbl_frn frn ON crr.cd_frn = frn.cd_frn
                    INNER JOIN (SELECT cbf.cd_cun, min(cbf.cd_cbf) AS cd_cbf
                                FROM sc_cad.tbl_cbf cbf 
                                WHERE cbf.fg_atv_cbf = 'S'
                                GROUP BY cbf.cd_cun) cbf ON frn.cd_cun = cbf.cd_cun
               where pgt.st_pgt = CT_SITUACAO_CONFIRMADO
                 and pgt.dt_ctb_pgt is null
    	         and pgt.dt_pgt <= vl_data_limite
                 and pgt.dt_inc_usr < vl_data_limite
               GROUP BY crr.cd_crr, crr.ds_crr, crr.cd_frn, cbf.cd_cbf, crr.cd_cnt, frn.cd_cnt, pgt.dt_ctb_pgt::date loop

    select sum(pgt.vl_pgt) as valor_descontar
      into vl_desconto
    from sc_pgc.tbl_pgt pgt
    where pgt.cd_crr = vl_rg.cd_crr
      and pgt.st_pgt = CT_SITUACAO_CANCELADO
      and pgt.dt_ctb_pgt is not null
      and pgt.dt_ctb_cnc_pgt is null;

    vl_pagamento := coalesce(vl_rg.valor, 0) - coalesce(vl_desconto, 0);
    if vl_pagamento > 0 THEN
      --inserindo regstro de despesa para os pagamentos de um determinado correspondente
      insert into sc_cap.tbl_dsp(cd_dsp, cd_cdc, cd_frn, cd_tdp, st_dsp, vl_dsp, dt_ref_dsp,
                                 dt_pgt_dsp, tp_pgt_dsp, ds_dsp, cd_inc_usr, dt_inc_usr, 
                                 nr_prc_dsp, vl_prc_dsp, cd_cbf)
      values(nextval('sc_cap.sq_dsp'), CT_CENTRO_CUSTO, vl_rg.cd_frn, CT_TIPO_DESPESA_PAGAMENTO_CONTAS, CT_SITUACAO_AUTORIZADO, vl_rg.valor, NOW(),
             NOW(), CT_TP_PAGTO_TRASF_BANCARIA, 'REF A PAGAMENTO DE CONTAS REALIZADO ' || vl_rg.ds_crr, CT_USUARIO_ADM, now(),
            1, vl_pagamento, vl_rg.cd_cbf);

      --realizando a transferencia da conta a repassa para a conta do fornecedor
      perform sc_cnt.lancar_debito_credito(vl_rg.conta_correspondente, vl_rg.conta_fornecedor,
                                   CT_TP_LANC_REPASSE_CORRESPONDENTE,  'REPASSE CORRESPONDENTE',
                                   'REPASSE CORRESPONDENTE', vl_pagamento,
                                   vl_rg.data_contabil, CT_USUARIO_ADM,
                                   CT_SISTEMA_PAGAMENTO_CONTA, trim(to_char(vl_rg.data_contabil, 'YYYYMMDD'))::numeric);

      --atualizando a data de contabilizacao dos pagamentos contabilizados
      update sc_pgc.tbl_pgt 
         set dt_ctb_pgt = now() 
      where st_pgt = CT_SITUACAO_CONFIRMADO 
        and dt_ctb_pgt is null 
        and dt_pgt <= vl_data_limite 
        and dt_inc_usr < vl_data_limite
        AND cd_crr = vl_rg.cd_crr;

      --atualizando a data de contabilizacao dos pagamentos cancelados contabilizados
      update sc_pgc.tbl_pgt 
         set dt_ctb_cnc_pgt = now() 
      where st_pgt = CT_SITUACAO_CANCELADO 
        and dt_ctb_pgt is not null 
        and dt_ctb_cnc_pgt is null
        AND cd_crr = vl_rg.cd_crr;
    end if;
  END loop;
end$$;


ALTER FUNCTION sc_pgc.contabilizar_pagamentos() OWNER TO scan;

--
-- TOC entry 1701 (class 1255 OID 1666187)
-- Name: contabilizar_retroativo(); Type: FUNCTION; Schema: sc_pgc; Owner: scan
--

CREATE FUNCTION contabilizar_retroativo() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg record;

  CT_SISTEMA_PAGAMENTO_CONTA constant numeric := 29;
  CT_USUARIO_ADM constant numeric := 1;
  CT_CORRESPONDENTE_CELCOIN constant numeric := 3;
  CT_SITUACAO_CONFIRMADO constant numeric := 3;
  CT_TP_LANC_REPASSE_CORRESPONDENTE constant numeric := 1410;
begin

  FOR vl_rg IN select pgt.dt_ctb_pgt::date as data_contabil, crr.cd_cnt as conta_correspondente, frn.cd_cnt as conta_fornecedor, sum(vl_pgt) AS valor 
               from sc_pgc.tbl_pgt pgt
                    INNER JOIN sc_pgc.tbl_crr crr ON pgt.cd_crr = crr.cd_crr
                    INNER JOIN sc_cap.tbl_frn frn ON crr.cd_frn = frn.cd_frn
                    INNER JOIN (SELECT cbf.cd_cun, min(cbf.cd_cbf) AS cd_cbf
                                FROM sc_cad.tbl_cbf cbf 
                                WHERE cbf.fg_atv_cbf = 'S'
                                GROUP BY cbf.cd_cun) cbf ON frn.cd_cun = cbf.cd_cun
               where pgt.st_pgt = CT_SITUACAO_CONFIRMADO
                 and crr.cd_crr = CT_CORRESPONDENTE_CELCOIN
                 and pgt.dt_ctb_pgt is not null
                 and pgt.dt_pgt <= current_date
                 and pgt.dt_inc_usr < current_date
               GROUP BY pgt.dt_ctb_pgt::date, crr.cd_cnt, frn.cd_cnt
               order by data_contabil loop

    if coalesce(vl_rg.valor, 0) > 0 THEN
      perform sc_cnt.lancar_debito_credito(vl_rg.conta_correspondente, vl_rg.conta_fornecedor,
                                   CT_TP_LANC_REPASSE_CORRESPONDENTE,  'REPASSE CORRESPONDENTE',
                                   'REPASSE CORRESPONDENTE', vl_rg.valor,
                                   vl_rg.data_contabil, CT_USUARIO_ADM,
                                   CT_SISTEMA_PAGAMENTO_CONTA, trim(to_char(vl_rg.data_contabil, 'YYYYMMDD'))::numeric);
    end if;
  END loop;
end$$;


ALTER FUNCTION sc_pgc.contabilizar_retroativo() OWNER TO scan;

--
-- TOC entry 1693 (class 1255 OID 897232)
-- Name: informa_repasse_pms(date); Type: FUNCTION; Schema: sc_pgc; Owner: postgres
--

CREATE FUNCTION informa_repasse_pms(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

ct_st_erro numeric := 3;
rg record;
existe numeric := 1;
texto text;
count numeric := 1;
assunto varchar(100);
rg2 record;
vl_total_saque_facil numeric := 0;
vl_total_pagamento numeric := 0;

begin

  if not sc_grl.eh_dia_util(vp_data_referencia) then
    return;
  end if;


  texto := '<html xmlns="http://www.w3.org/1999/xhtml">
		<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>REPASSE PAGUE MENOS SERVICOS - SAQUEFACIL E LOJA VIRTUAL</title>

		<style>

		.tabela{
			width: 100%;
			font-family:Arial;
			border:1px solid #999;
			border-collapse: collapse;
		}

		.tabela th{
			background:#03F;
		    color:#FFF;
			text-align:center;
			border:1px solid #999;
		}

		.tabela tr td{
			border:1px solid #999;
		}

		.impar{
			background:#CCC;
		}

		</style>

		</head>

		<body>
		<table class="tabela">
			<tr>
			<th>NR CONTROLE</th>
			<th>TIPO</th>
			<th>OBSERVACAO</th>
			<th>DATA</th>
			<th>VALOR</th>
		    </tr>';
		    
  count := 0;
  for rg in select *
            from sc_rds.tbl_sfc s
              inner join sc_opr.tbl_opr opr on opr.cd_opr = s.cd_opr
            where s.dt_ctb_sfc::date = vp_data_referencia loop


 	texto := texto || '<tr class="' || case when mod(count,2) = 0 then '' else 'impar' end || '">';
	texto := texto || '<td>'|| rg.cd_opr ||'</td>';
	texto := texto || '<td> SAQUE FACIL - SMARTPHONE</td>';
	texto := texto || '<td align="center"></td>';
	texto := texto || '<td align="center">'|| to_char(rg.dt_opr,'dd/MM/yyyy HH24:mi:ss') ||'</td>';
	texto := texto || '<td align="right"> '|| trim(to_char(rg.vl_sfc, '999990D99'))||'</td>';
	texto := texto || '</tr>';
	vl_total_saque_facil := vl_total_saque_facil + rg.vl_sfc;

	count := count + 1;
   end loop;

   if vl_total_saque_facil > 0 then
	texto := texto || '<tr style="background-color: black;color: white;" >';
	texto := texto || '<td colspan="4">TOTAL DE SAQUE FACIL</td>';
	texto := texto || '<td align="right">'||trim(to_char(vl_total_saque_facil, '999990D99'))||'</td>';
	texto := texto || '</tr>';
   end if;	
   

  for rg2 in select *
             from sc_pgc.tbl_pgt pgt
             where pgt.dt_ctb_pgt::date = vp_data_referencia loop

 	texto := texto || '<tr class="' || case when mod(count,2) = 0 then '' else 'impar' end || '">';
	texto := texto || '<td>'|| rg2.cd_pgt ||'</td>';
	texto := texto || '<td> PAGAMENTO DE CONTAS</td>';
	texto := texto || '<td align="center"></td>';
	texto := texto || '<td align="center">'|| to_char(rg2.dt_inc_usr,'dd/MM/yyyy HH24:mi:ss') ||'</td>';
	texto := texto || '<td align="right">'|| trim(to_char(rg2.vl_pgt, '999990D99'))||'</td>';
	texto := texto || '</tr>';

	vl_total_pagamento := vl_total_pagamento + rg2.vl_pgt;

	count := count + 1;
   end loop;

   if vl_total_pagamento > 0 then
   
	texto := texto || '<tr  style="background-color: black;color: white;" >';
	texto := texto || '<td colspan="4">TOTAL DE PAGAMENTO DE CONTAS</td>';
	texto := texto || '<td align="right">'||trim(to_char(vl_total_pagamento, '999990D99'))||'</td>';
	texto := texto || '</tr>';
   end if;
   
	texto := texto || '<tr style="background-color: black;color: white;" >';
	texto := texto || '<td colspan="4">TOTAL A REPASSAR EM '|| to_char(vp_data_referencia,'dd/MM/yyyy')  ||'</td>';
	texto := texto || '<td align="right">'||trim(to_char(vl_total_pagamento + vl_total_saque_facil, '999990D99'))||'</td>';
	texto := texto || '</tr>';

   texto := texto || '</table>
		     </body></html>';


   assunto := 'INFORMATIVO REPASSE - SOMA CONTA DIGITAL';


  -- enviando o email
  if vl_total_pagamento + vl_total_saque_facil > 0 then
     perform sc_pbl.enviar_email_saqpag('cleuda@pmgs.com.br;katiane@pmgs.com.br;emanuel@pmgs.com.br;vitor@somacontadigital.com.br;financeiro@saqpag.com.br;laedio@pmgs.com.br;dartagnan.jr@pmgs.com.br',assunto,texto,null);
  end if;   
     
  exception when others then
    raise 'ERRO NO ENVIO DE EMAIL DE JOBS %', sqlerrm;
end;$$;


ALTER FUNCTION sc_pgc.informa_repasse_pms(vp_data_referencia date) OWNER TO postgres;

--
-- TOC entry 1694 (class 1255 OID 998903)
-- Name: informa_repasse_pms(date, date); Type: FUNCTION; Schema: sc_pgc; Owner: postgres
--

CREATE FUNCTION informa_repasse_pms(vp_data_inicial date, vp_data_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

ct_st_erro numeric := 3;
rg record;
existe numeric := 1;
texto text;
count numeric := 1;
assunto varchar(100);
rg2 record;
vl_total_saque_facil numeric := 0;
vl_total_pagamento numeric := 0;

begin


  texto := '<html xmlns="http://www.w3.org/1999/xhtml">
		<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>REPASSE PAGUE MENOS SERVICOS - SAQUEFACIL E LOJA VIRTUAL</title>

		<style>

		.tabela{
			width: 100%;
			font-family:Arial;
			border:1px solid #999;
			border-collapse: collapse;
		}

		.tabela th{
			background:#03F;
		    color:#FFF;
			text-align:center;
			border:1px solid #999;
		}

		.tabela tr td{
			border:1px solid #999;
		}

		.impar{
			background:#CCC;
		}

		</style>

		</head>

		<body>
		<table class="tabela">
			<tr>
			<th>NR CONTROLE</th>
			<th>TIPO</th>
			<th>OBSERVACAO</th>
			<th>DATA</th>
			<th>VALOR</th>
		    </tr>';
		    
  count := 0;
  for rg in select *
            from sc_rds.tbl_sfc s
              inner join sc_opr.tbl_opr opr on opr.cd_opr = s.cd_opr
            where s.dt_ctb_sfc::date >= vp_data_inicial
              and s.dt_ctb_sfc::date  < vp_data_final loop


 	texto := texto || '<tr class="' || case when mod(count,2) = 0 then '' else 'impar' end || '">';
	texto := texto || '<td>'|| rg.cd_opr ||'</td>';
	texto := texto || '<td> SAQUE FACIL - SMARTPHONE</td>';
	texto := texto || '<td align="center"></td>';
	texto := texto || '<td align="center">'|| to_char(rg.dt_ctb_sfc,'dd/MM/yyyy') ||'</td>';
	texto := texto || '<td align="right"> '|| trim(to_char(rg.vl_sfc, '999990D99'))||'</td>';
	texto := texto || '</tr>';
	vl_total_saque_facil := vl_total_saque_facil + rg.vl_sfc;

	count := count + 1;
   end loop;

   if vl_total_saque_facil > 0 then
	texto := texto || '<tr style="background-color: black;color: white;" >';
	texto := texto || '<td colspan="4">TOTAL DE SAQUE FACIL</td>';
	texto := texto || '<td align="right">'||trim(to_char(vl_total_saque_facil, '999990D99'))||'</td>';
	texto := texto || '</tr>';
   end if;	
   

  for rg2 in select *
             from sc_pgc.tbl_pgt pgt
             where pgt.dt_ctb_pgt::date >= vp_data_inicial
               and pgt.dt_ctb_pgt::date < vp_data_final loop

 	texto := texto || '<tr class="' || case when mod(count,2) = 0 then '' else 'impar' end || '">';
	texto := texto || '<td>'|| rg2.cd_pgt ||'</td>';
	texto := texto || '<td> PAGAMENTO DE CONTAS</td>';
	texto := texto || '<td align="center"></td>';
	texto := texto || '<td align="center">'|| to_char(rg2.dt_ctb_pgt,'dd/MM/yyyy') ||'</td>';
	texto := texto || '<td align="right">'|| trim(to_char(rg2.vl_pgt, '999990D99'))||'</td>';
	texto := texto || '</tr>';

	vl_total_pagamento := vl_total_pagamento + rg2.vl_pgt;

	count := count + 1;
   end loop;

   if vl_total_pagamento > 0 then
   
	texto := texto || '<tr  style="background-color: black;color: white;" >';
	texto := texto || '<td colspan="4">TOTAL DE PAGAMENTO DE CONTAS</td>';
	texto := texto || '<td align="right">'||trim(to_char(vl_total_pagamento, '999990D99'))||'</td>';
	texto := texto || '</tr>';
   end if;
   
	texto := texto || '<tr style="background-color: black;color: white;" >';
	texto := texto || '<td colspan="4">TOTAL A REPASSAR EM '|| to_char(rg2.dt_ctb_pgt,'dd/MM/yyyy')  ||'</td>';
	texto := texto || '<td align="right">'||trim(to_char(vl_total_pagamento + vl_total_saque_facil, '999990D99'))||'</td>';
	texto := texto || '</tr>';

   texto := texto || '</table>
		     </body></html>';


   assunto := 'INFORMATIVO REPASSE - SOMA CONTA DIGITAL';


  -- enviando o email
  if vl_total_pagamento + vl_total_saque_facil > 0 then
     perform sc_pbl.enviar_email_saqpag('vitor@somacontadigital.com.br;financeiro@somacontadigital.com.br',assunto,texto,null);
  end if;   
     
  exception when others then
    raise 'ERRO NO ENVIO DE EMAIL DE JOBS %', sqlerrm;
end;$$;


ALTER FUNCTION sc_pgc.informa_repasse_pms(vp_data_inicial date, vp_data_final date) OWNER TO postgres;

--
-- TOC entry 1760 (class 1255 OID 1034228)
-- Name: realizar_pagamentos_agendados(date); Type: FUNCTION; Schema: sc_pgc; Owner: scan
--

CREATE FUNCTION realizar_pagamentos_agendados(data_pagamento date) RETURNS void
    LANGUAGE plpgsql
    AS $$ 

declare
  vl_parametros varchar;
begin

  if date_part('hour', clock_timestamp()) <= 7 or date_part('hour', clock_timestamp()) >= 18 then
    return;
  end if;

  IF data_pagamento is not null THEN
    vl_parametros := 'dataPagamento==' || to_char(data_pagamento, 'yyyy/MM/dd');
  END IF;
  
  --perform sc_job.job_java('efetuarPagamentosAgendados', vl_parametros);
  perform sc_job.executar_java_job('efetuarPagamentosAgendados',vl_parametros);
  
end;

$$;


ALTER FUNCTION sc_pgc.realizar_pagamentos_agendados(data_pagamento date) OWNER TO scan;

--
-- TOC entry 1302 (class 1255 OID 1665312)
-- Name: resolver_pendencia_celcoin(); Type: FUNCTION; Schema: sc_pgc; Owner: scan
--

CREATE FUNCTION resolver_pendencia_celcoin() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin
  perform sc_job.executar_java_job('resolverPendenciaCelcoin', null);
end;$$;


ALTER FUNCTION sc_pgc.resolver_pendencia_celcoin() OWNER TO scan;

--
-- TOC entry 1073 (class 1255 OID 1004144)
-- Name: sonda(); Type: FUNCTION; Schema: sc_pgc; Owner: scan
--

CREATE FUNCTION sonda() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
 
begin

  perform sc_job.executar_java_job('sondaPagamentoConta', null);
  
   
end$$;


ALTER FUNCTION sc_pgc.sonda() OWNER TO scan;

--
-- TOC entry 7863 (class 0 OID 0)
-- Dependencies: 1073
-- Name: FUNCTION sonda(); Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON FUNCTION sonda() IS 'Rotina que atualiza os pagamentos de contas';


SET search_path = sc_rcg, pg_catalog;

--
-- TOC entry 1288 (class 1255 OID 1631345)
-- Name: atualiza_feriado(); Type: FUNCTION; Schema: sc_rcg; Owner: scan
--

CREATE FUNCTION atualiza_feriado() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;
vl_sql varchar := '';
_conn varchar;

begin

  -- enquanto nao libera para aptare direto
  _conn := 'hostaddr=69.64.33.141 port=5432 dbname=pna user=pna password=pna';
  --_conn := 'hostaddr=192.168.1.6 port=5432 dbname=sca user=sca password=sca';
 
  for rg in select * 
             from sc_pbl.tbl_frd
             where dt_frd >= '01/08/2018'  
              loop

        -- enquanto nao libera para aptare direto 
        vl_sql := vl_sql || 'insert into sc_grl.tbl_frd values (''' || to_char(rg.dt_frd,'dd/mm/yyyy') || ''',''' || rg.ds_frd || ''',''' || rg.tp_frd || ''',1,now(),null,null);';
        --raise notice '%', vl_sql;
 
  end loop;
  raise notice '%', vl_sql;
  --execute dblink( _conn, vl_sql);   

end$$;


ALTER FUNCTION sc_rcg.atualiza_feriado() OWNER TO scan;

--
-- TOC entry 1771 (class 1255 OID 1666542)
-- Name: atualiza_operadoras(); Type: FUNCTION; Schema: sc_rcg; Owner: scan
--

CREATE FUNCTION atualiza_operadoras() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin
  perform sc_job.executar_java_job('atualizarOperadorasCelcoin', null);
end;$$;


ALTER FUNCTION sc_rcg.atualiza_operadoras() OWNER TO scan;

--
-- TOC entry 7864 (class 0 OID 0)
-- Dependencies: 1771
-- Name: FUNCTION atualiza_operadoras(); Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON FUNCTION atualiza_operadoras() IS 'rotina que atualiza as informações das operadoras de recarga';


--
-- TOC entry 1637 (class 1255 OID 1667128)
-- Name: cancelar_contabilizacao_recargas(date); Type: FUNCTION; Schema: sc_rcg; Owner: scan
--

CREATE FUNCTION cancelar_contabilizacao_recargas(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg record;
  --ct_fornecedor_pague_menos numeric := 286;
  
  CT_TIPO_DESPESA_RECARGA_CELULAR constant numeric := 72;
  CT_CENTRO_CUSTO constant numeric := 1;
  CT_USUARIO_ADM constant numeric := 1;
  CT_SITUACAO_AUTORIZADO constant numeric := 2;
  CT_SITUACAO_CANCELADO constant numeric := 4;
  CT_SITUACAO_CONFIRMADO constant numeric := 2;
  CT_TP_PAGTO_TRASF_BANCARIA constant numeric := 3;

  CT_SISTEMA_RECARGA_CELULAR constant numeric := 24;
  CT_TP_LANC_ESTORNO_REPASSE_CORRESP constant numeric := 1001;
 
  vl_pagamento numeric;

  vl_existe integer;
begin

  if not sc_grl.eh_dia_util(vp_data_referencia) then
    raise exception 'Não é um dia útil: %', vp_data_referencia;
  end if;

  FOR vl_rg IN select rcg.dt_ctb_rcg::date as data_contabil, crr.cd_crr, crr.ds_crr, crr.cd_frn, cbf.cd_cbf, crr.cd_cnt as conta_correspondente, frn.cd_cnt as conta_fornecedor, sum(vl_rcg) AS valor 
               from sc_rcg.tbl_rcg rcg
                    INNER JOIN sc_pgc.tbl_crr crr ON rcg.cd_crr = crr.cd_crr
                    INNER JOIN sc_cap.tbl_frn frn ON crr.cd_frn = frn.cd_frn
                    INNER JOIN (SELECT cbf.cd_cun, min(cbf.cd_cbf) AS cd_cbf
                                FROM sc_cad.tbl_cbf cbf 
                                WHERE cbf.fg_atv_cbf = 'S'
                                GROUP BY cbf.cd_cun) cbf ON frn.cd_cun = cbf.cd_cun
               where rcg.st_rcg = CT_SITUACAO_CONFIRMADO
                 and rcg.dt_ctb_rcg >= vp_data_referencia
    	         and rcg.dt_ctb_rcg < vp_data_referencia + interval '1 day'
               GROUP BY crr.cd_crr, crr.ds_crr, crr.cd_frn, cbf.cd_cbf, crr.cd_cnt, frn.cd_cnt, rcg.dt_ctb_rcg::date loop

    if coalesce(vl_rg.valor, 0) = 0 THEN
      raise exception 'Não foi encontrado pagamento de contas contabilizados na data: %', vp_data_referencia;
    end if;
    
    select count(*)
      into vl_existe
    from sc_cap.tbl_dsp
    where cd_cdc = CT_CENTRO_CUSTO
      and cd_frn = vl_rg.cd_frn
      and cd_tdp = CT_TIPO_DESPESA_RECARGA_CELULAR
      and st_dsp = CT_SITUACAO_AUTORIZADO
      and vl_dsp = vl_rg.valor
      and tp_pgt_dsp = CT_TP_PAGTO_TRASF_BANCARIA
      and dt_ref_dsp >= vp_data_referencia
      and dt_ref_dsp < vp_data_referencia + interval '1 day';

    if coalesce(vl_existe, 0) = 0 then
      raise exception 'Não foi encontrado o contas a pagar AUTORIZADO referente ao repasse do correspondente. Valor: %, Data: %, Fornecedor: %', 
		vl_rg.valor, vp_data_referencia, vl_rg.cd_frn;
    end if;

    --cancelando a despesa referente ao pagamento do repasse
    update sc_cap.tbl_dsp
       set st_dsp = CT_SITUACAO_CANCELADO,
           cd_cnc_usr = CT_USUARIO_ADM,
           dt_cnc_usr = now()
    where cd_cdc = CT_CENTRO_CUSTO
      and cd_frn = vl_rg.cd_frn
      and cd_tdp = CT_TIPO_DESPESA_RECARGA_CELULAR
      and st_dsp = CT_SITUACAO_AUTORIZADO
      and vl_dsp = vl_rg.valor
      and tp_pgt_dsp = CT_TP_PAGTO_TRASF_BANCARIA
      and dt_ref_dsp >= vp_data_referencia
      and dt_ref_dsp < vp_data_referencia + interval '1 day';
        
      
    --desfazendo a transferencia da conta a repassa para a conta do fornecedor
    perform sc_cnt.lancar_debito_credito(vl_rg.conta_fornecedor, vl_rg.conta_correspondente, 
                                  CT_TP_LANC_ESTORNO_REPASSE_CORRESP,  'ESTORNO REPASSE CORRESPONDENTE',
                                  'ESTORNO REPASSE CORRESPONDENTE', vl_rg.valor,
                                  vl_rg.data_contabil, CT_USUARIO_ADM,
                                  CT_SISTEMA_RECARGA_CELULAR, trim(to_char(vl_rg.data_contabil, 'YYYYMMDD'))::numeric);

    --anulando a data de contabilizacao dos pagamentos contabilizados
    update sc_rcg.tbl_rcg 
       set dt_ctb_rcg = null
    where st_rcg = CT_SITUACAO_CONFIRMADO 
      and dt_ctb_rcg >= vp_data_referencia
      and dt_ctb_rcg < vp_data_referencia + interval '1 day'
      AND cd_crr = vl_rg.cd_crr;
  END loop;
end$$;


ALTER FUNCTION sc_rcg.cancelar_contabilizacao_recargas(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1572 (class 1255 OID 564498)
-- Name: contabilizar_recarga(date, date); Type: FUNCTION; Schema: sc_rcg; Owner: scan
--

CREATE FUNCTION contabilizar_recarga(vp_data_inicial date, vp_data_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg_recarga record;
  rg_operacao record;
  vl_conta_receita_recarga numeric := 19438;
  vl_tipo_lancamento numeric := 1345;
  vl_codigo_sistema_recarga numeric := 24;
begin

  --esta rotina não deve ser mais usada, ver a rotina sc_rcg.contabilizar_recargas() - Alexandre 20/08/2019
  return;

  /*
    for rg_recarga in select rcg.cd_rcg,opr.cd_opr
	      from sc_rcg.tbl_rcg rcg
	         left join sc_opr.tbl_opr opr on opr.dt_opr = rcg.dt_rcg and rcg.cd_crt = substring(opr.cd_pls::varchar,0,15)::numeric and opr.vl_opr = rcg.vl_rcg
	      where opr.cd_top = 20 
	      and rcg.cd_opr is null loop

         update sc_rcg.tbl_rcg set cd_opr=rg_recarga.cd_opr where cd_rcg = rg_recarga.cd_rcg;
	      
    end loop;	      

    for rg_operacao in select (vl_rcg - vl_prc_rcg) vl_valor_receita,dt_rcg,rcg.*
              from sc_rcg.tbl_rcg rcg
                inner join sc_opr.tbl_opr opr on opr.cd_opr = rcg.cd_opr
              where opr.st_opr = 2
                and rcg.dt_ctb_rcg is null 
                and rcg.dt_rcg >= '01-09-2015'
                and (vp_data_incicial is null or rcg.dt_rcg > vp_data_incicial)
                and (vp_data_final is null or rcg.dt_rcg < vp_data_final)
                order by cd_rcg loop

         perform sc_cnt.lancar_debito_credito(19446,vl_conta_receita_recarga, vl_tipo_lancamento, null, 'REF A RECARGA NR '||rg_operacao.cd_rcg, rg_operacao.vl_valor_receita, rg_operacao.dt_rcg, 1, vl_codigo_sistema_recarga, rg_operacao.cd_rcg);
         update sc_rcg.tbl_rcg set dt_ctb_rcg=now() where cd_rcg = rg_operacao.cd_rcg;
                
    end loop;              
*/

end$$;


ALTER FUNCTION sc_rcg.contabilizar_recarga(vp_data_inicial date, vp_data_final date) OWNER TO scan;

--
-- TOC entry 1765 (class 1255 OID 1666831)
-- Name: contabilizar_recargas(); Type: FUNCTION; Schema: sc_rcg; Owner: scan
--

CREATE FUNCTION contabilizar_recargas() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg record;
  
  CT_TIPO_DESPESA_RECARGA_CELULAR constant numeric := 72;
  CT_CENTRO_CUSTO constant numeric := 1;
  CT_USUARIO_ADM constant numeric := 1;
  CT_SITUACAO_AUTORIZADO constant numeric := 2;
  CT_SITUACAO_CONFIRMADO constant numeric := 2;
  CT_TP_PAGTO_TRASF_BANCARIA constant numeric := 3;
  CT_SEGUNDA_FEIRA constant numeric := 1;

  CT_SISTEMA_RECARGA_CELULAR constant numeric := 24;
  CT_TP_LANC_REPASSE_CORRESPONDENTE constant numeric := 1000;
 
  vl_pagamento numeric;

  vl_data_limite date;
begin

  if not sc_grl.eh_dia_util(current_date) then
    return ;
  end if;

  vl_data_limite := current_date;
  if extract(dow from vl_data_limite) = CT_SEGUNDA_FEIRA then
    vl_data_limite := (vl_data_limite - interval '2 day')::date;
  end if;

  FOR vl_rg IN select current_date as data_contabil, crr.cd_crr, crr.ds_crr, crr.cd_frn, cbf.cd_cbf, crr.cd_cnt as conta_correspondente, frn.cd_cnt as conta_fornecedor, sum(vl_rcg) AS valor 
               from sc_rcg.tbl_rcg rcg
                    INNER JOIN sc_pgc.tbl_crr crr ON rcg.cd_crr = crr.cd_crr
                    INNER JOIN sc_cap.tbl_frn frn ON crr.cd_frn = frn.cd_frn
                    INNER JOIN (SELECT cbf.cd_cun, min(cbf.cd_cbf) AS cd_cbf
                                FROM sc_cad.tbl_cbf cbf 
                                WHERE cbf.fg_atv_cbf = 'S'
                                GROUP BY cbf.cd_cun) cbf ON frn.cd_cun = cbf.cd_cun
               where rcg.st_rcg = CT_SITUACAO_CONFIRMADO
                 and rcg.dt_ctb_rcg is null
    			 and rcg.dt_rcg <= vl_data_limite
               GROUP BY crr.cd_crr, crr.ds_crr, crr.cd_frn, cbf.cd_cbf, crr.cd_cnt, frn.cd_cnt loop

    if coalesce(vl_rg.valor, 0) > 0 THEN
      --inserindo regstro de despesa para os pagamentos de um determinado correspondente
      insert into sc_cap.tbl_dsp(cd_dsp, cd_cdc, cd_frn, cd_tdp, st_dsp, vl_dsp, dt_ref_dsp,
                                 dt_pgt_dsp, tp_pgt_dsp, ds_dsp, cd_inc_usr, dt_inc_usr, 
                                 nr_prc_dsp, vl_prc_dsp, cd_cbf)
      values(nextval('sc_cap.sq_dsp'), CT_CENTRO_CUSTO, vl_rg.cd_frn, CT_TIPO_DESPESA_RECARGA_CELULAR, CT_SITUACAO_AUTORIZADO, vl_rg.valor, NOW(),
             NOW(), CT_TP_PAGTO_TRASF_BANCARIA, 'REF A RECARGAS REALIZADAS ' || vl_rg.ds_crr, CT_USUARIO_ADM, now(),
            1, vl_rg.valor, vl_rg.cd_cbf);

      --realizando a transferencia da conta a repassa para a conta do fornecedor
      perform sc_cnt.lancar_debito_credito(vl_rg.conta_correspondente, vl_rg.conta_fornecedor,
                                   CT_TP_LANC_REPASSE_CORRESPONDENTE,  'REPASSE CORRESPONDENTE',
                                   'REPASSE CORRESPONDENTE', vl_rg.valor,
                                   vl_rg.data_contabil, CT_USUARIO_ADM,
                                   CT_SISTEMA_RECARGA_CELULAR, trim(to_char(vl_rg.data_contabil, 'YYYYMMDD'))::numeric);

      --atualizando a data de contabilizacao dos pagamentos contabilizados
      update sc_rcg.tbl_rcg 
         set dt_ctb_rcg = now() 
      where st_rcg = CT_SITUACAO_CONFIRMADO 
        and dt_ctb_rcg is null 
        and dt_rcg <= vl_data_limite 
        AND cd_crr = vl_rg.cd_crr;
    end if;
  END loop;
end$$;


ALTER FUNCTION sc_rcg.contabilizar_recargas() OWNER TO scan;

--
-- TOC entry 1774 (class 1255 OID 1666543)
-- Name: resolve_pendencias(); Type: FUNCTION; Schema: sc_rcg; Owner: scan
--

CREATE FUNCTION resolve_pendencias() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin
  perform sc_job.executar_java_job('resolverPendenciaRecargaCelcoin', null);
end;$$;


ALTER FUNCTION sc_rcg.resolve_pendencias() OWNER TO scan;

--
-- TOC entry 7865 (class 0 OID 0)
-- Dependencies: 1774
-- Name: FUNCTION resolve_pendencias(); Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON FUNCTION resolve_pendencias() IS 'rotina que resolve as pendências de recarga';


--
-- TOC entry 1483 (class 1255 OID 838240)
-- Name: sonda(); Type: FUNCTION; Schema: sc_rcg; Owner: scan
--

CREATE FUNCTION sonda() RETURNS void
    LANGUAGE plpgsql
    AS $$declare


ct_situacao_recarga_cadastrada numeric := 1;
ct_situacao_recarga_confirmada numeric := 2;
ct_situacao_recarga_cancelada numeric := 3;

rg record;
vl_sql varchar;
_conn varchar;
vl_situacao numeric;

begin

  -- enquanto nao libera para aptare direto
  _conn := 'host=b4b.aptare.com.br port=5432 dbname=rca user=rca password=rca';
  --_conn := 'hostaddr=192.168.1.6 port=5432 dbname=sca user=sca password=sca';
 
  for rg in select rcg.cd_rqs, rcg.cd_rcg
             from sc_opr.tbl_opr opr
             inner join sc_rdc.tbl_rqs rqs on rqs.cd_opr = opr.cd_opr
             inner join sc_rcg.tbl_rcg rcg on rcg.cd_rqs = rqs.cd_rqs
             where opr.st_opr = 1 
             and opr.cd_top = 20
             and rcg.cd_rqs is not null loop

        -- enquanto nao libera para aptare direto 
        vl_sql := 'select st_rcg from sc_rcg.tbl_rcg where nsu_org_rcg = ' || rg.cd_rcg;     
        --vl_sql := 'select sc_rcg.sonda('|| rg.cd_rcg ||')';

        select r.* 
	 into vl_situacao
	 from dblink( _conn, vl_sql) as r(st_rcg numeric);

         vl_situacao := coalesce(vl_situacao,ct_situacao_recarga_cancelada);

         --raise notice 'recarga: %, situacao: %', rg.cd_rcg, vl_situacao;

         if vl_situacao in (ct_situacao_recarga_cancelada) then

	   perform sc_rdc.tr_desfaz_compra(rg.cd_rqs);        
	   
	 elsif vl_situacao = ct_situacao_recarga_confirmada then

	   perform sc_rdc.tr_confirma_compra(rg.cd_rqs);        
	   
	 end if;

	 update sc_rcg.tbl_rcg set st_rcg = vl_situacao where cd_rcg = rg.cd_rcg;

  end loop;

  -- atualizando as recargas de acordo com a situacao da operacao
  update sc_rcg.tbl_rcg r set st_rcg = case when opr.st_opr = 2 then 2 else 3 end
   from sc_opr.tbl_opr opr
   inner join sc_rdc.tbl_rqs rqs on rqs.cd_opr = opr.cd_opr
   inner join sc_rcg.tbl_rcg rcg on rcg.cd_rqs = rqs.cd_rqs
   where rcg.st_rcg is null
   and opr.st_opr <> 1 
   and opr.cd_top = 20
   and rcg.cd_rqs is not null
   and r.cd_rcg = rcg.cd_rcg;

end$$;


ALTER FUNCTION sc_rcg.sonda() OWNER TO scan;

SET search_path = sc_rct, pg_catalog;

--
-- TOC entry 1427 (class 1255 OID 564499)
-- Name: gerar_receita(date, date); Type: FUNCTION; Schema: sc_rct; Owner: scan
--

CREATE FUNCTION gerar_receita(vp_data_inicio date, vp_data_fim date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

vl_data_referencia date;

vl_dias numeric := vp_data_fim - vp_data_inicio;
vl_contador numeric := 0;
  
begin
  while vl_contador < vl_dias loop
    vl_data_referencia := vp_data_inicio + interval '1 day' * vl_contador;
    perform sc_rct.gerar_receita_cartao(vl_data_referencia);
    perform sc_rct.gerar_receita_empresa(vl_data_referencia);
    perform sc_rct.gerar_receita_prorrogacao(vl_data_referencia);
    perform sc_rct.gerar_receita_servicos(vl_data_referencia);
    vl_contador := vl_contador + 1;

    raise notice '% *** Processado', vl_data_referencia;
  end loop;
end;$$;


ALTER FUNCTION sc_rct.gerar_receita(vp_data_inicio date, vp_data_fim date) OWNER TO scan;

--
-- TOC entry 1428 (class 1255 OID 564500)
-- Name: gerar_receita_cartao(date); Type: FUNCTION; Schema: sc_rct; Owner: scan
--

CREATE FUNCTION gerar_receita_cartao(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

-- tipo origem
ct_tp_org_rct_cartao numeric := 1;
ct_saque_extra numeric := 5;

rg_fcr record;
rg_opr record;

vl_valor_principal numeric(13,2);
vl_valor_pago numeric(13,2);
vl_valor_pago_anterior numeric (13,2);
vl_valor_receita numeric(13,2);
vl_valor_restituido numeric(13,2);

begin
  for rg_fcr in select pfc.cd_fcr as fatura, sum(pfc.vl_pfc) as valor_pago
                from sc_fcr.tbl_pfc pfc
                where pfc.dt_rcb_pfc = vp_data_referencia
                  and pfc.st_pfc = 1
                group by pfc.cd_fcr loop

    vl_valor_pago := rg_fcr.valor_pago;

    -- valor pago anterior
      begin
        select sum(pfc.vl_pfc)
          into vl_valor_pago_anterior
        from sc_fcr.tbl_pfc pfc
        where pfc.cd_fcr = rg_fcr.fatura
          and pfc.dt_rcb_pfc < vp_data_referencia;
      exception when others then
        vl_valor_pago_anterior := 0;
      end;

    -- 

    vl_valor_pago := vl_valor_pago + coalesce(vl_valor_pago_anterior,0);

    for rg_opr in select *
                  from sc_fcr.tbl_fcr_top ftp
                    inner join sc_rct.tbl_trt_top trt_top on trt_top.cd_top = ftp.cd_top
                  where ftp.cd_fcr = rg_fcr.fatura 
                  order by trt_top.nr_prp_trt_top loop

      if vl_valor_pago <= 0 then
        exit;
      end if;

      vl_valor_receita := 0;

      -- valor a ser restituido
      begin
        select sum(vrc.vl_vrc)
          into vl_valor_restituido
        from sc_rct.tbl_vrc vrc
        where vrc.cd_fcr = rg_fcr.fatura
          and vrc.cd_top = rg_opr.cd_top
          and vrc.dt_vrc < vp_data_referencia;
      exception when others then
        vl_valor_restituido := 0;
      end;

      -- verifica se o valor principal do tipo de operacao foi pago
      if rg_opr.cd_top = ct_saque_extra then
         vl_valor_principal := rg_opr.vl_ttl_fcr_top - rg_opr.vl_rct_fcr_top;

	 if vl_valor_pago >= vl_valor_principal then
	    if vl_valor_pago >= rg_opr.vl_ttl_fcr_top then
		vl_valor_receita := rg_opr.vl_rct_fcr_top;
	    else
		vl_valor_receita := vl_valor_pago - vl_valor_principal;
	    end if;
	 end if;
         
       else
	   if vl_valor_pago >= rg_opr.vl_ttl_fcr_top then
		vl_valor_receita := rg_opr.vl_rct_fcr_top;
	    else
		vl_valor_receita := rg_opr.vl_rct_fcr_top - vl_valor_pago;
	    end if;
      end if;

      vl_valor_receita := vl_valor_receita - coalesce(vl_valor_restituido, 0);

      if vl_valor_receita > 0 then
        -- inserir receita
        insert into sc_rct.tbl_rct (cd_rct, cd_trt, tp_org_rct, cd_sst, nsu_org_rct, dt_ctb_rct, usr_dt_inc, vl_rct)
          values (nextval('sc_rct.sq_rct'), rg_opr.cd_trt, ct_tp_org_rct_cartao, 1, rg_fcr.fatura, vp_data_referencia, now(), vl_valor_receita);

        -- inserir valor resituido da fatura por tipo de operacao
        insert into sc_rct.tbl_vrc (cd_vrc, cd_fcr, cd_top, dt_vrc, vl_vrc)
          values (nextval('sc_rct.sq_vrc'), rg_fcr.fatura, rg_opr.cd_top, vp_data_referencia, vl_valor_receita);

      end if;

        vl_valor_pago = coalesce(vl_valor_pago,0) - coalesce(rg_opr.vl_ttl_fcr_top,0);

    end loop;

  end loop;
end;$$;


ALTER FUNCTION sc_rct.gerar_receita_cartao(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1429 (class 1255 OID 564501)
-- Name: gerar_receita_empresa(date); Type: FUNCTION; Schema: sc_rct; Owner: scan
--

CREATE FUNCTION gerar_receita_empresa(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  TP_ORIGEM_EMPRESA numeric := 2;
BEGIN

  -- RECEITAS BASEADAS NOS SERVICOS DE FATURA DE EMPRESA.
  -- EM CASO DE FATURAS COM MAIS DE UMA BAIXA ESTA SENDO CONSIDERADO COMO DATA DA RECEITA 
  -- A DATA DA ULTIMA BAIXA.
  -- SO ESTAO SENDO CONSIDERADOS AS RECEITAS ORIUNDAS DE FATURAS COM SITUACAO "PAGA".
  for rg in  select 
                   fep.cd_fep fatura,
                   sum(fep_sfe.vl_ttl_fep_sfe) valor_receita,
                   date_trunc('day',pfe.dt_rcb_pfe) data_receita,
                   fep_sfe.cd_sfe codigo_servico,
                   trt_sfe.cd_trt tipo_receita
            from sc_fep.tbl_fep fep
              inner join sc_fep.tbl_pfe pfe on pfe.cd_fep = fep.cd_fep
              inner join sc_fep.tbl_fep_sfe fep_sfe on fep_sfe.cd_fep = pfe.cd_fep
              inner join sc_rct.tbl_trt_sfe trt_sfe on trt_sfe.cd_sfe = fep_sfe.cd_sfe
            where ( (pfe.dt_rcb_pfe >= vp_data
              and pfe.dt_rcb_pfe < (vp_data + interval '1 day')) or vp_data is null)
              and fep.st_fep = 2 -- PAGA
              and pfe.cd_tpe <> 1 -- DESCONTO
              and pfe.st_pfe = 1 -- CADASTRADO 
              and pfe.cd_pfe = ( select max(p.cd_pfe) 
                                 from sc_fep.tbl_pfe p 
                                 where p.cd_fep = fep.cd_fep
                                   and p.cd_tpe <> 1) 
            group by fep.cd_fep,date_trunc('day',pfe.dt_rcb_pfe),fep_sfe.cd_sfe,trt_sfe.cd_trt loop
            
           insert into sc_rct.tbl_rct (cd_rct, cd_trt, tp_org_rct, cd_sst, nsu_org_rct, dt_ctb_rct, usr_dt_inc, vl_rct)
          values (nextval('sc_rct.sq_rct'), rg.tipo_receita, TP_ORIGEM_EMPRESA, 1, rg.fatura, rg.data_receita, now(), rg.valor_receita);
            
  end loop;

END;
$$;


ALTER FUNCTION sc_rct.gerar_receita_empresa(vp_data date) OWNER TO scan;

--
-- TOC entry 1430 (class 1255 OID 564502)
-- Name: gerar_receita_prorrogacao(date); Type: FUNCTION; Schema: sc_rct; Owner: scan
--

CREATE FUNCTION gerar_receita_prorrogacao(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  TIPO_RECEITA_JUROS numeric := 8;
  TIPO_RECEITA_MULTA numeric := 9;
  
  TP_ORIGEM_EMPRESA numeric := 2;
  
BEGIN
  
  for rg in select pfe.cd_fep fatura,
                   date_trunc('day',pfe.dt_rcb_pfe) data_receita,
                   sum(coalesce(apf.vl_mlt_apf,0)) valor_juros,
                   sum(coalesce(apf.vl_jrs_apf,0)) valor_multa
            from sc_fep.tbl_apf apf
              inner join sc_fep.tbl_pfe pfe on pfe.cd_fep = apf.cd_fep
            where ( (pfe.dt_rcb_pfe >= vp_data
                 and pfe.dt_rcb_pfe < (vp_data + interval '1 day')) or
                 vp_data is null)
               and pfe.cd_pfe = ( select max(p.cd_pfe) 
                                 from sc_fep.tbl_pfe p 
                                 where p.cd_fep = apf.cd_fep
                                   and p.cd_tpe <> 1)
              group by pfe.cd_fep,
                   date_trunc('day',pfe.dt_rcb_pfe) loop
                                   
      if(rg.valor_juros > 0) then
      
        insert into sc_rct.tbl_rct (cd_rct, cd_trt, tp_org_rct, cd_sst, nsu_org_rct, dt_ctb_rct, usr_dt_inc, vl_rct)
          values (nextval('sc_rct.sq_rct'), TIPO_RECEITA_JUROS, TP_ORIGEM_EMPRESA, 1, rg.fatura, rg.data_receita, now(), rg.valor_juros);

      end if;
      
      if(rg.valor_multa > 0) then
      
        insert into sc_rct.tbl_rct (cd_rct, cd_trt, tp_org_rct, cd_sst, nsu_org_rct, dt_ctb_rct, usr_dt_inc, vl_rct)
          values (nextval('sc_rct.sq_rct'), TIPO_RECEITA_MULTA, TP_ORIGEM_EMPRESA, 1, rg.fatura, rg.data_receita, now(), rg.valor_multa);

      end if;


  end loop;                                   
END;
$$;


ALTER FUNCTION sc_rct.gerar_receita_prorrogacao(vp_data date) OWNER TO scan;

--
-- TOC entry 1386 (class 1255 OID 564503)
-- Name: gerar_receita_servicos(date); Type: FUNCTION; Schema: sc_rct; Owner: scan
--

CREATE FUNCTION gerar_receita_servicos(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  TP_ORIGEM_SERVICO numeric := 3;
BEGIN

  -- RECEITAS BASEADAS NAS TARIFAS DE SERVICOS DE CARTAO
  
  insert into sc_rct.tbl_rct (cd_rct, cd_trt, tp_org_rct, cd_sst, nsu_org_rct, dt_ctb_rct, usr_dt_inc, vl_rct)
   select nextval('sc_rct.sq_rct') as cd_rct, trt_srv.cd_trt as cd_trt, TP_ORIGEM_SERVICO as tp_org_rct, 1 as cd_sst, tsc.cd_tsc as nsu_org_rct,
          date_trunc('day',tsc.dt_pgto_tsc) as dt_ctb_rct, now() as usr_dt_inc, 
          sum(case when tsc.cd_srv in (4,6) then opr.vl_trf_opr else tsc.vl_tsc end) as vl_rct
            from sc_srv.tbl_tsc tsc
              inner join sc_opr.tbl_opr opr on opr.cd_opr = tsc.cd_opr
              inner join sc_rct.tbl_trt_srv trt_srv on trt_srv.cd_srv = tsc.cd_srv
            where ((tsc.dt_pgto_tsc >= vp_data
              and tsc.dt_pgto_tsc < (vp_data + interval '1 day')) or vp_data is null)
              and tsc.st_tsc = 2 -- COBRADO
              and tsc.vl_tsc > 0
          group by tsc.cd_tsc, date_trunc('day',tsc.dt_pgto_tsc), trt_srv.cd_trt
          order by trt_srv.cd_trt,date_trunc('day',tsc.dt_pgto_tsc);

END;
$$;


ALTER FUNCTION sc_rct.gerar_receita_servicos(vp_data date) OWNER TO scan;

SET search_path = sc_rdc, pg_catalog;

--
-- TOC entry 1390 (class 1255 OID 564504)
-- Name: calcular_data_repasse(numeric, timestamp without time zone); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION calcular_data_repasse(vp_filial_estabelecimento numeric, vp_data_operacao timestamp without time zone) RETURNS timestamp without time zone
    LANGUAGE plpgsql
    AS $$
DECLARE
  vl_qtd_dias_repasse sc_rdc.tbl_etb.qtd_dia_rps%type;
BEGIN

  select etb.qtd_dia_rps
  into vl_qtd_dias_repasse
  from sc_rdc.tbl_etb etb
    inner join sc_rdc.tbl_fet fet on fet.cd_etb = etb.cd_etb
  where fet.cd_fet = vp_filial_estabelecimento;  
  
  return vp_data_operacao + interval '1' day * vl_qtd_dias_repasse;
  
END;
$$;


ALTER FUNCTION sc_rdc.calcular_data_repasse(vp_filial_estabelecimento numeric, vp_data_operacao timestamp without time zone) OWNER TO scan;

--
-- TOC entry 1757 (class 1255 OID 1033421)
-- Name: calcular_data_repasse(numeric, numeric, timestamp without time zone); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION calcular_data_repasse(vp_tipo_operacao numeric, vp_filial_estabelecimento numeric, vp_data_operacao timestamp without time zone) RETURNS timestamp without time zone
    LANGUAGE plpgsql
    AS $$
DECLARE
  vl_qtd_dias_repasse sc_rdc.tbl_etb.qtd_dia_rps%type;
BEGIN

  select etb.qtd_dia_rps
  into vl_qtd_dias_repasse
  from sc_rdc.tbl_etb etb
    inner join sc_rdc.tbl_fet fet on fet.cd_etb = etb.cd_etb
  where fet.cd_fet = vp_filial_estabelecimento;  

  if vp_tipo_operacao = 4 then
    vl_qtd_dias_repasse := 1;
  end if;
  
  return vp_data_operacao + interval '1' day * vl_qtd_dias_repasse;
  
END;
$$;


ALTER FUNCTION sc_rdc.calcular_data_repasse(vp_tipo_operacao numeric, vp_filial_estabelecimento numeric, vp_data_operacao timestamp without time zone) OWNER TO scan;

--
-- TOC entry 1389 (class 1255 OID 564505)
-- Name: calcular_taxa_administracao(numeric, numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION calcular_taxa_administracao(vp_filial_estabelecimento numeric, vp_valor numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  vl_taxa numeric;
BEGIN

  select etb.tx_adm_etb
  into vl_taxa
  from sc_rdc.tbl_etb etb
    inner join sc_rdc.tbl_fet fet on fet.cd_etb = etb.cd_etb
  where fet.cd_fet = vp_filial_estabelecimento;
  
  return (vp_valor * vl_taxa) / 100;
  
END;
$$;


ALTER FUNCTION sc_rdc.calcular_taxa_administracao(vp_filial_estabelecimento numeric, vp_valor numeric) OWNER TO scan;

--
-- TOC entry 1873 (class 1255 OID 1655375)
-- Name: cancelar_operacao_compra(numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION cancelar_operacao_compra(vp_operacao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  CT_TP_OPR_CANCELAMENTO constant numeric := 26;
  CT_TP_OPR_COMPRA_DEBITO constant numeric := 25;
  CT_TP_OPR_COMPRA_CREDITO_AVISTA constant numeric := 27;
  CT_TP_LANC_ESTORNO_COMPRA constant numeric := 1447;
  
  CT_ST_OPR_CONFIRMADA constant numeric := 2;
  CT_ST_OPR_CANCELADA constant numeric := 3;
  
  vl_situacao sc_opr.tbl_opr.st_opr%type;
  vl_valor sc_opr.tbl_opr.vl_opr%type;
  vl_valor_credito sc_opr.tbl_opr.vl_crd_opr%type;
  vl_valor_debito sc_opr.tbl_opr.vl_crd_opr%type;
  vl_data sc_opr.tbl_opr.dt_opr%type;
  vl_estabelecimento sc_opr.tbl_opr.cd_fet%type;
  vl_conta_cartao sc_cnt.tbl_cnt.cd_cnt%type;
  vl_conta_estabelecimento sc_cnt.tbl_cnt.cd_cnt%type;
  vl_plastico sc_opr.tbl_opr.cd_pls%type;
  vl_cartao sc_opr.tbl_pls.cd_crt%type;
  vl_tipo_operacao sc_opr.tbl_opr.cd_top%type;

  vl_operacao_cancelamento sc_opr.tbl_opr.cd_opr%type;
begin

  select opr.st_opr, opr.cd_top, opr.vl_opr, coalesce(opr.vl_crd_opr, 0), opr.dt_opr, pls.cd_crt, pls.cd_pls, opr.cd_fet, cnt_crt.cd_cnt, etb.cd_cnt
    into vl_situacao, vl_tipo_operacao, vl_valor, vl_valor_credito, vl_data, vl_cartao, vl_plastico, vl_estabelecimento, vl_conta_cartao, vl_conta_estabelecimento
  from sc_opr.tbl_opr opr
       inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
       inner join sc_opr.tbl_cnt_crt cnt_crt on pls.cd_crt = cnt_crt.cd_crt
       inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
       inner join sc_rdc.tbl_etb etb on etb.cd_etb = fet.cd_etb
  where opr.cd_opr = vp_operacao;

  if vl_situacao <> CT_ST_OPR_CONFIRMADA then
     raise exception 'SÓ É POSSÍVEL CANCELAR UMA OPERAÇÃO COM A SITUAÇÃO CONFIRMADA';
  end if;

  select nextval('sc_opr.sq_opr') into vl_operacao_cancelamento;

  -- gravando a operacao de cancelamento
  insert into sc_opr.tbl_opr(cd_opr, cd_pls, cd_top, dt_opr, vl_opr, vl_jrs_opr, vl_trf_opr, nr_prc_opr,
			     vl_prc_opr, vl_iof_opr, nr_nsu_org_opr, st_opr, cd_fet, cd_pai_opr, vl_crd_opr)
  values(vl_operacao_cancelamento, vl_plastico, CT_TP_OPR_CANCELAMENTO, now(), vl_valor, 0, 0, 0,
         vl_valor, 0, vp_operacao, CT_ST_OPR_CONFIRMADA, vl_estabelecimento, vp_operacao, vl_valor_credito);
         
  --marcando a operacao original como cancelada
  update sc_opr.tbl_opr set st_opr = CT_ST_OPR_CANCELADA where cd_opr = vp_operacao;

  if vl_tipo_operacao = CT_TP_OPR_COMPRA_DEBITO then
    --realizando o lancamento de estorno
    perform sc_cnt.lancar_debito_credito(vl_conta_estabelecimento, vl_conta_cartao, CT_TP_LANC_ESTORNO_COMPRA, null, 
                                         'REF A ESTORN DE COMPRA A VISTA OPERACAO ' || vp_operacao, vl_valor, 
                                         now()::timestamp, 1, 1:: numeric, vp_operacao::numeric);
  elsif vl_tipo_operacao = CT_TP_OPR_COMPRA_CREDITO_AVISTA then
    vl_valor_debito := vl_valor - vl_valor_credito;
    if vl_valor_debito > 0 then
      --realizando o lancamento de estorno
      perform sc_cnt.lancar_debito_credito(vl_conta_estabelecimento, vl_conta_cartao, CT_TP_LANC_ESTORNO_COMPRA, null, 
                                          'REF A ESTORN DE COMPRA A VISTA OPERACAO ' || vp_operacao, vl_valor_debito, 
                                          now()::timestamp, 1, 1:: numeric, vp_operacao::numeric);
    end if;

    --restituindo o limite de credito
    if vl_valor_credito > 0 then
      update sc_opr.tbl_lmt
	set vl_utl_lmt = coalesce(vl_utl_lmt,0) - vl_valor_credito
      where cd_crt = vl_cartao
	and cd_tlt = 2;
    end if;
  else
     raise exception 'TIPO DE OPERACAO NAO PERMITIDA';
  end if;
end$$;


ALTER FUNCTION sc_rdc.cancelar_operacao_compra(vp_operacao numeric) OWNER TO scan;

--
-- TOC entry 1339 (class 1255 OID 1664115)
-- Name: cancelar_segunda_via(numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION cancelar_segunda_via(vp_operacao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  CT_ST_OPR_CONFIRMADA constant numeric := 2;
  CT_ST_OPR_CANCELADA constant numeric := 3;
  
  CT_ST_PRC_A_FATURAR constant numeric := 1;
  CT_ST_PRC_CANCELADO constant numeric := 3;
  
  CT_TP_OPERACAO_SEGUNDA_VIA_SENHA constant numeric := 17;
  
  
  vl_situacao_opr sc_opr.tbl_opr.st_opr%type;
  vl_tipo_operacao sc_opr.tbl_opr.cd_top%type;
  vl_situacao_prc sc_fcr.tbl_prc.st_prc%type;
  vl_data_prc sc_opr.tbl_opr.dt_prc_opr%type;

begin

  select opr.st_opr, opr.cd_top, opr.dt_prc_opr
    into vl_situacao_opr, vl_tipo_operacao, vl_data_prc 
  from sc_opr.tbl_opr opr
  where opr.cd_opr = vp_operacao;

  if vl_situacao_opr <> CT_ST_OPR_CONFIRMADA then
     raise exception 'SÓ É POSSÍVEL CANCELAR UMA OPERAÇÃO COM A SITUAÇÃO CONFIRMADA';
  end if;
  
  if vl_tipo_operacao <> CT_TP_OPERACAO_SEGUNDA_VIA_SENHA then
	raise exception 'SÓ É POSSÍVEL REALIZAR O CANCELAMENTO DE SEGUNDA VIA DE SENHA';
	end if;
	
	update sc_opr.tbl_opr set st_opr = CT_ST_OPR_CANCELADA where cd_opr = vp_operacao;
	
	if vl_data_prc is not null then
	
	select prc.st_prc
		into vl_situacao_prc
	from sc_fcr.tbl_prc prc
	where cd_opr = vp_operacao;
	
	if vl_situacao_prc <> CT_ST_PRC_A_FATURAR then
		raise exception 'SÓ É POSSÍVEL REALIZAR O CANCELAMENTO DE UMA PARCELA COM SITUAÇÃO A FATURAR';
	end if;
	
	update sc_fcr.tbl_prc set st_prc = CT_ST_PRC_CANCELADO where cd_opr = vp_operacao;
	end if;
   
end$$;


ALTER FUNCTION sc_rdc.cancelar_segunda_via(vp_operacao numeric) OWNER TO scan;

--
-- TOC entry 1113 (class 1255 OID 1664651)
-- Name: cancelar_segunda_via_cartao(numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION cancelar_segunda_via_cartao(vp_operacao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  CT_ST_OPR_CONFIRMADA constant numeric := 2;
  CT_ST_OPR_CANCELADA constant numeric := 3;
  
  CT_ST_PRC_A_FATURAR constant numeric := 1;
  CT_ST_PRC_CANCELADO constant numeric := 3;
  
  CT_TP_OPERACAO_SEGUNDA_VIA_CARTAO constant numeric := 11;
  
  
  vl_situacao_opr sc_opr.tbl_opr.st_opr%type;
  vl_tipo_operacao sc_opr.tbl_opr.cd_top%type;
  vl_situacao_prc sc_fcr.tbl_prc.st_prc%type;
  vl_data_prc sc_opr.tbl_opr.dt_prc_opr%type;

begin

  select opr.st_opr, opr.cd_top, opr.dt_prc_opr
    into vl_situacao_opr, vl_tipo_operacao, vl_data_prc 
  from sc_opr.tbl_opr opr
  where opr.cd_opr = vp_operacao;

  if vl_situacao_opr <> CT_ST_OPR_CONFIRMADA then
     raise exception 'SÓ É POSSÍVEL CANCELAR UMA OPERAÇÃO COM A SITUAÇÃO CONFIRMADA';
  end if;
  
  if vl_tipo_operacao <> CT_TP_OPERACAO_SEGUNDA_VIA_CARTAO then
	raise exception 'SÓ É POSSÍVEL REALIZAR O CANCELAMENTO DE SEGUNDA VIA DE CARTÃO';
	end if;
	
	update sc_opr.tbl_opr set st_opr = CT_ST_OPR_CANCELADA where cd_opr = vp_operacao;
	
	if vl_data_prc is not null then
	
	select prc.st_prc
		into vl_situacao_prc
	from sc_fcr.tbl_prc prc
	where cd_opr = vp_operacao;
	
	if vl_situacao_prc <> CT_ST_PRC_A_FATURAR then
		raise exception 'SÓ É POSSÍVEL REALIZAR O CANCELAMENTO DE UMA PARCELA COM SITUAÇÃO A FATURAR';
	end if;
	
	update sc_fcr.tbl_prc set st_prc = CT_ST_PRC_CANCELADO where cd_opr = vp_operacao;
	end if;
   
end$$;


ALTER FUNCTION sc_rdc.cancelar_segunda_via_cartao(vp_operacao numeric) OWNER TO scan;

--
-- TOC entry 1837 (class 1255 OID 1634843)
-- Name: confirma_transacao_cielo(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION confirma_transacao_cielo() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg2 record;
  rg record;
begin

	for rg2 in 
		select r2.cd_rqs
		from sc_rdc.tbl_rqs r
		  inner join sc_iso8583.tbl_msg8583 m on m.bit011::numeric = r.nr_nsu_org and m.bit001='0x420'and m.dt_msg::date=r.dt_rqs::date
		  inner join sc_iso8583.tbl_msg8583 m2 on m2.bit001 = '0x210' and m2.bit011 = trim(substring(m.bit090,21,6))   
		  --inner join sc_rdc.tbl_rqs r2 on m2.bit011::numeric = r2.nr_nsu_org and m2.bit001='0x210'and m2.dt_msg=r2.dt_rqs
		  inner join sc_rdc.tbl_rqs r2 on m2.bit011::numeric = r2.nr_nsu_org and m2.bit001='0x210' and 	m2.bit032::numeric=r2.nsu_rede_rqs and m2.dt_msg::date = r2.dt_rqs::date
		  inner join sc_opr.tbl_opr opr on opr.cd_opr = r2.cd_opr
		--  left join sc_rdc.tbl_rqs r2 on r2.cd_rqs = 
		where r.tp_rqs = 3
		  and r.cd_opr is null
		  and opr.st_opr = 1
		  and m.bit032 is not null
		order by m.bit002,r.dt_rqs loop

          perform sc_rdc.tr_desfaz_compra_rdc(rg2.cd_rqs);
	
	end loop;


   for rg in select rqs.* 
             from sc_opr.tbl_opr opr
	      inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
	      inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
	      inner join sc_rdc.tbl_etb etb on etb.cd_etb = fet.cd_etb
	      inner join sc_rdc.tbl_rqs rqs on rqs.cd_opr = opr.cd_opr
             where cd_top=27 
               and vl_opr>1 
               and st_opr=1 
               and dt_opr<current_date 
               and dt_opr < now() - interval '5 minutes'
             order by opr.cd_opr desc  
            loop

      perform sc_rdc.tr_confirma_compra_rdc(rg.cd_rqs);       
   end loop;

   --select sc_rdc.desfaz_compra_autorizada() 
   
end$$;


ALTER FUNCTION sc_rdc.confirma_transacao_cielo() OWNER TO scan;

--
-- TOC entry 1861 (class 1255 OID 1042367)
-- Name: contabilizar_compra_credito(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION contabilizar_compra_credito() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  ct_conta_compras_afaturar numeric := 201772;
  vl_data date;
  TIPO_LANCAMENTO_COMPRA_A_VISTA numeric := 1446;
  
begin

   for rg in select etb.cd_cnt vl_conta_estabelecimento,
		    opr.dt_opr::date data_operacao,
		    sum(vl_crd_opr) valor
		from sc_opr.tbl_opr opr
		  inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
		  inner join sc_rdc.tbl_etb etb on etb.cd_etb = fet.cd_etb
		where cd_top = 27
		  and vl_crd_opr > 0
                  and st_opr = 2
                  and dt_opr < current_date
		  and dt_ctb_opr is null
		group by etb.cd_cnt,opr.dt_opr::date
		order by data_operacao loop

         if(rg.data_operacao < to_date('01-09-2018','dd-mm-yyyy')) then
            vl_data := to_date('01-10-2018','dd-mm-yyyy');
         else   
            vl_data := rg.data_operacao;
         end if;
         
         perform sc_cnt.lancar_debito_credito(ct_conta_compras_afaturar, rg.vl_conta_estabelecimento, TIPO_LANCAMENTO_COMPRA_A_VISTA, null, 'REF A COMPRAS A CREDITO DO DIA '||to_char(rg.data_operacao,'dd/mm/yyyy'), rg.valor, vl_data::timestamp, 1, 16:: numeric, to_char(current_date,'yyyymmdd')::numeric);

    end loop;		
    
    update sc_opr.tbl_opr
    set dt_ctb_opr = now()
    where cd_top = 27
      and vl_crd_opr > 0
      and st_opr = 2
      and dt_ctb_opr is null;

--      select * from sc_cnt.tbl_sst
    
end$$;


ALTER FUNCTION sc_rdc.contabilizar_compra_credito() OWNER TO scan;

--
-- TOC entry 1431 (class 1255 OID 564506)
-- Name: contabilizar_compras(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION contabilizar_compras() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  TIPO_OPERACAO_COMPRA_A_VISTA numeric := 20;
  SITUACAO_OPERACAO_CONFIRMADA numeric := 2;
  COD_SISTEMA_REDE_COMPRA numeric := 16;
  TIPO_LANCAMENTO_COMPRA_A_VISTA numeric := 1001;
  vl_nr_lancamento sc_cnt.tbl_lcn.cd_lcn%type;
BEGIN
  for rg in select sum(opr.vl_opr) valor,
                   opr.cd_fet,
                   fet.cd_cnt
            from sc_opr.tbl_opr opr
              inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
            where opr.cd_top in (TIPO_OPERACAO_COMPRA_A_VISTA)
              and opr.st_opr = SITUACAO_OPERACAO_CONFIRMADA            
              and opr.dt_ctb_opr is null
              group by opr.cd_fet,fet.cd_cnt loop
              
    vl_nr_lancamento := null;              
    perform sc_cnt.lancar_movimento(vl_nr_lancamento,NULL,TIPO_LANCAMENTO_COMPRA_A_VISTA,rg.cd_cnt,'C',
                             rg.valor,now()::timestamp without time zone,1, NULL,'REF A COMPRA A DEBITO',
                             COD_SISTEMA_REDE_COMPRA,9999);

              
  end loop;
  
  update sc_opr.tbl_opr
  set dt_ctb_opr = now()
  where cd_top in (TIPO_OPERACAO_COMPRA_A_VISTA)
        and st_opr = SITUACAO_OPERACAO_CONFIRMADA            
        and dt_ctb_opr is null;

END;
$$;


ALTER FUNCTION sc_rdc.contabilizar_compras() OWNER TO scan;

--
-- TOC entry 1746 (class 1255 OID 1023472)
-- Name: contabilizar_repasse(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION contabilizar_repasse() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   ct_tipo_lancamento_repasse numeric := 1450;
   rg record;
begin
   for rg in select rps.cd_rps as codigo,
                    rps.vl_rps as valor_repasse,
                    rps.vl_tx_adm_rps as valor_receita,
                    etb.cd_cnt conta_estabelecimento,
                    fet.cd_cnt conta_filial
             from sc_rdc.tbl_rps rps
               inner join sc_rdc.tbl_fet fet on fet.cd_fet = rps.cd_fet
               inner join sc_rdc.tbl_etb etb on etb.cd_etb = fet.cd_etb
             where dt_ctb_rps is null loop


       -- LANCANDO O PRINCIPAL
       perform sc_cnt.lancar_debito_credito(rg.conta_estabelecimento,rg.conta_filial, ct_tipo_lancamento_repasse ,null,'REF A REPASSE NR '||rg.codigo, rg.valor_repasse, now()::timestamp, 1, 34, RG.CODIGO);
       -- LANCANDO A RECEITA
       perform sc_cnt.lancar_debito_credito(rg.conta_estabelecimento,191283, 1451 ,null,'REF A REPASSE NR '||rg.codigo, rg.valor_receita, now()::timestamp, 1, 34, RG.CODIGO);

       update sc_rdc.tbl_rps 
       set dt_ctb_rps = now()
       where cd_rps = rg.codigo;

   end loop;          
end$$;


ALTER FUNCTION sc_rdc.contabilizar_repasse() OWNER TO scan;

--
-- TOC entry 1722 (class 1255 OID 1011008)
-- Name: decripta3des(character varying, character varying, character varying); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION decripta3des(character varying, character varying, character varying) RETURNS character varying
    LANGUAGE javau
    AS $$br.com.aptare.tripledes.EncriptaDecripta.decripta3des$$;


ALTER FUNCTION sc_rdc.decripta3des(character varying, character varying, character varying) OWNER TO scan;

--
-- TOC entry 1863 (class 1255 OID 1622687)
-- Name: desfaz_compra_autorizada(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION desfaz_compra_autorizada() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin

   for rg in select cc.cd_cnt,opr.*,pls.cd_crt
             from sc_opr.tbl_opr opr
                inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
                inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = pls.cd_crt
                inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
             where cd_top = 27
               and st_opr = 1
               and dt_opr < now() - interval '5 minutes'
               and exists(select 1 from sc_rdc.tbl_rqs r where r.cd_opr = opr.cd_opr and r.tp_rqs = 4 and r.nsu_rede_rqs is null)
               and fet.nr_lgc_cel_fet is null loop

      if coalesce(rg.vl_crd_opr,0) > 0 then         
	      update sc_opr.tbl_lmt 
	      set vl_utl_lmt = vl_utl_lmt - coalesce(rg.vl_crd_opr,0)
	      where cd_tlt=2 
		and cd_crt = rg.cd_crt;
      end if;	
        
      update sc_opr.tbl_opr 
         set st_opr = 4
       where cd_opr = rg.cd_opr;

       if (rg.vl_opr - coalesce(rg.vl_crd_opr,0)) > 0 then

          update sc_cnt.tbl_tbc_cnt 
          set vl_blq_tbc_cnt=coalesce(vl_blq_tbc_cnt,0) - (rg.vl_opr - coalesce(rg.vl_crd_opr,0)) 
          where cd_cnt = rg.cd_cnt 
            and cd_tbc = 7;
       end if;
               
   end loop;

   --select sc_rdc.desfaz_compra_autorizada() 
   
end$$;


ALTER FUNCTION sc_rdc.desfaz_compra_autorizada() OWNER TO scan;

--
-- TOC entry 1864 (class 1255 OID 1637099)
-- Name: enviar_arquivo_habilita_produto_cielo(numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION enviar_arquivo_habilita_produto_cielo(vp_cod_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  ST_AHP_GERADO sc_ssp.tbl_haep.st_haep%type := 2;
  ST_AHP_ENVIADO sc_ssp.tbl_haep.st_haep%type := 3;
  ST_AHP_CANCELADO sc_ssp.tbl_haep.st_haep%type := 4;
  
  COD_FTP_ARQ_HAB_PRODUTO sc_pbl.tbl_ftp.cd_ftp%type := 5;
  
  vl_nm_diretorio varchar;
  vl_nm_arquivo varchar;
  rg record;


  
begin

   select vl_prm 
   into vl_nm_diretorio
   from sc_cad.tbl_prm
   where nm_prm = 'ARQUIVO_HABILITACAO_CIELO';

        
      select lcl_arq_ahp
      into vl_nm_arquivo
      from sc_rdc.tbl_ahp
      where (cd_ahp = vp_cod_arquivo or vp_cod_arquivo is null)
        and st_ahp = ST_AHP_GERADO
        and dt_env_ahp is null;

      if vl_nm_arquivo is not null then
         perform sc_pbl.enviar_arquivo_sftp(COD_FTP_ARQ_HAB_PRODUTO,vl_nm_diretorio,vl_nm_arquivo);

         update sc_rdc.tbl_ahp set st_ahp = ST_AHP_ENVIADO,dt_env_ahp = now() where cd_ahp = vp_cod_arquivo;
      end if;   
             
exception 
     
   when others then
     raise exception 'PROBLEMA AO ENVIAR O ARQUIVO DE HABILITACAO DE PRODUTO CIELO NR. %', sqlerrm;
     
end
$$;


ALTER FUNCTION sc_rdc.enviar_arquivo_habilita_produto_cielo(vp_cod_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1859 (class 1255 OID 1084723)
-- Name: gerar_arquivo_extrato(date); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_arquivo_extrato(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  rg record;
  rg_etb record;

  ct_DIREITA numeric:= 1;
  ct_ESQUERDA numeric:= 2;
  ct_CENTRALIZADO numeric:= 3;

  vl_sequencial_registro numeric:= 1;
  vl_total_registro numeric := 0;
  vl_valor_total numeric(13,2) := 0;

  ct_tipo_residencial constant numeric := 1;
  ct_tipo_celular constant numeric := 2;
  ct_tipo_comercial constant numeric := 3;

  separador varchar := ';';

  vl_diretorio varchar;
  vl_nome_arquivo varchar;
  vl_local_arquivo varchar;
  vl_local_diretorio varchar;

  vl_codigo_arquivo numeric;
  vl_data_referencia date;

  linha varchar;

  vl_existe_extrato numeric;
  vl_existe_operacao numeric;

  vl_nsu_origem varchar;
  vl_codigo_requisicao numeric;

begin
  select count(rps.cd_rps)
    into vl_existe_extrato
  from sc_rdc.tbl_rps rps
       inner join sc_rdc.tbl_fet fet on fet.cd_fet = rps.cd_fet
  where rps.dt_rps::date = vp_data_referencia;

  select count(opr.cd_opr)
    into vl_existe_operacao
  from sc_opr.tbl_opr opr
       inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
  where opr.dt_opr::date = vp_data_referencia - 1;

  if vl_existe_extrato = 0 and vl_existe_operacao = 0 then
    return;
  end if;

  -- para cada estabelecimento
  for rg_etb in select distinct cd_etb 
                from (
                       select fet.cd_etb
                       from sc_rdc.tbl_rps rps
                            inner join sc_rdc.tbl_fet fet on fet.cd_fet = rps.cd_fet
                       where rps.dt_rps::date = vp_data_referencia
                       
                       union all
                       
                       select fet.cd_etb
                       from sc_opr.tbl_opr opr
                            inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
                       where opr.dt_opr::date = vp_data_referencia - 1) x 
    /*where cd_etb = 50*/ loop
    perform sc_rdc.gerar_arquivo_extrato_estab(rg_etb.cd_etb, vp_data_referencia);
  end loop;

exception 
when others then
  perform sc_arq.excluirArquivo(vl_nome_arquivo); 
  RAISE EXCEPTION 'Problema na geração do arquivo de emissão de plastico. NUM:%, DETAILS:%', SQLSTATE, SQLERRM;
end;
$$;


ALTER FUNCTION sc_rdc.gerar_arquivo_extrato(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1550 (class 1255 OID 1632352)
-- Name: gerar_arquivo_extrato(date, numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_arquivo_extrato(vp_data_referencia date, vp_codigo_estabelecimento numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare


rg record;
rg_etb record;

ct_DIREITA numeric:= 1;
ct_ESQUERDA numeric:= 2;
ct_CENTRALIZADO numeric:= 3;

vl_sequencial_registro numeric:= 1;
vl_total_registro numeric := 0;
vl_valor_total numeric(13,2) := 0;

ct_tipo_residencial constant numeric := 1;
ct_tipo_celular constant numeric := 2;
ct_tipo_comercial constant numeric := 3;

  CT_COMPRA_DEBITO constant numeric := 25;
  CT_SAQUE_DEBITO constant numeric := 4;

separador varchar := ';';

vl_diretorio varchar;
vl_local_diretorio varchar;
vl_nome_arquivo varchar;
vl_local_arquivo varchar;

vl_codigo_arquivo numeric;
vl_data_referencia date;

linha varchar;

vl_existe_extrato numeric;
vl_existe_operacao numeric;

begin
  perform sc_rdc.gerar_arquivo_extrato_estab(vp_codigo_estabelecimento, vp_data_referencia);
  return;

  /*
  select count(rps.cd_rps)
    into vl_existe_extrato
      from sc_rdc.tbl_rps rps
      inner join sc_rdc.tbl_fet fet on fet.cd_fet = rps.cd_fet
    where rps.dt_rps::date = vp_data_referencia
      and (fet.cd_etb = vp_codigo_estabelecimento or vp_codigo_estabelecimento is null);

  select count(opr.cd_opr)
    into vl_existe_operacao
       from sc_opr.tbl_opr opr
       inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
    where opr.dt_prc_opr::date = vp_data_referencia
      and (fet.cd_etb = vp_codigo_estabelecimento or vp_codigo_estabelecimento is null);

  if vl_existe_extrato = 0 and vl_existe_operacao = 0 then
    return;
  end if;

  -- para cada estabelecimento
  for rg_etb in select distinct cd_etb from (
    select fet.cd_etb
      from sc_rdc.tbl_rps rps
      inner join sc_rdc.tbl_fet fet on fet.cd_fet = rps.cd_fet
    where rps.dt_rps::date = vp_data_referencia
           and (fet.cd_etb = vp_codigo_estabelecimento or vp_codigo_estabelecimento is null)

    union all
    select fet.cd_etb
       from sc_opr.tbl_opr opr
       inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
    where opr.dt_prc_opr::date = vp_data_referencia
            and (fet.cd_etb = vp_codigo_estabelecimento or vp_codigo_estabelecimento is null))  x
  loop
  

  -- inicializando os totalizadores
  vl_sequencial_registro := 1;
  vl_total_registro := 0;
  vl_valor_total := 0;

  --definindo o nome do arquivo
  vl_nome_arquivo := 'SOMA' || to_char(vp_data_referencia, 'yyyymmdd') || '000001' || '.txt';

  --definindo onde o arquivo sera gravado
  vl_local_diretorio := E'c:\\arquivo_scan\\envio\\redeCompra\\extrato\\' || rg_etb.cd_etb;
  
  --criando o diretorio caso nao exista
  perform sc_arq.criardiretorio(vl_local_diretorio);

  --definindo onde o arquivo sera gravado
  vl_local_arquivo := vl_local_diretorio || E'\\' || vl_nome_arquivo;
  
  --deleta o arquivo caso exista
  perform sc_arq.excluirarquivo(vl_local_arquivo);

       -- HEADER DO ARQUIVO
       -- campo codigo do registro
       linha := 'A0';

       -- campo versao do layout
       linha := linha || '001.6a';

       -- campo data geracao
       linha := linha || to_char(vp_data_referencia,'yyyymmdd');

       -- campo hora de geracao
       linha := linha || to_char(current_date,'hh24miss');

       -- campo id do movimento
       linha := linha || sc_arq.preencher(6,1,'0',ct_ESQUERDA);

       -- nome da administradora
       linha := linha || sc_arq.preencher(30,'SOMA',' ',ct_DIREITA);

       -- id do remetente
       linha := linha || sc_arq.preencher(4,1,'0',ct_ESQUERDA);

       -- id do destinatario
       linha := linha || sc_arq.preencher(6,'',' ',ct_ESQUERDA);

       -- campo sequencial do registro
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

       perform sc_arq.gravarlinha(vl_local_arquivo, linha);
    
       -- HEADER DO ARQUIVO DO LOTE DE VENDAS

       vl_sequencial_registro := vl_sequencial_registro + 1;
       
       -- campo codigo do registro
       linha := 'L0';

       -- campo data do movimento
       linha := linha || to_char(vp_data_referencia,'yyyymmdd');

       -- campo indicacao da moeda
       linha := linha || 'RE';

       -- campo sequencial do registro
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);


       perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

       -- DETALHE COMPROVANTE DE VENDAS
       -- PREVISAO

       for rg in select  cun.nr_cpf_cnpj_cun, opr.dt_opr, opr.vl_opr, opr.cd_top, opr.cd_pls, pet.*, fet.cd_bnc_fet, fet.cd_agn_fet, fet.nr_cc_fet, fet.dg_cc_fet, rqs.cd_rqs, iso.bit011
                      from sc_rdc.tbl_pet pet 
                        inner join sc_rdc.tbl_fet fet on fet.cd_fet = pet.cd_fet
                        inner join sc_cad.tbl_cun cun on cun.cd_cun = fet.cd_cun
                        inner join sc_opr.tbl_opr opr on opr.cd_opr = pet.cd_opr
                        inner join sc_rdc.tbl_rqs rqs on rqs.cd_opr = opr.cd_opr
                        inner join sc_iso8583.tbl_msg8583 iso on iso.bit127 = rqs.cd_rqs::varchar
                    where opr.dt_prc_opr::date = vp_data_referencia
                      and fet.cd_etb = rg_etb.cd_etb
                      order by fet.cd_fet, opr.dt_opr loop


       vl_sequencial_registro := vl_sequencial_registro + 1;
       vl_total_registro := vl_total_registro + 1;
       vl_valor_total := vl_valor_total + rg.vl_opr;
       
       -- campo codigo do registro
       linha := 'CV';

       -- campo codigo do estabelecimento(CNPJ)
       linha := linha || sc_arq.preencher(15,rg.nr_cpf_cnpj_cun,'0',ct_ESQUERDA);

       -- campo nsu do host
       linha := linha || sc_arq.preencher(12,rg.cd_rqs,'0',ct_ESQUERDA);

       -- campo data transacao
       linha := linha || to_char(rg.dt_opr,'yyyymmdd');

       -- campo hora de transacao
       linha := linha || to_char(rg.dt_opr,'hh24miss');

       -- campo tipo de lancamento
       linha := linha || '0';

       -- campo data do lancamento
       linha := linha || to_char(rg.dt_prv_rps_pet,'yyyymmdd');

       -- campo tipo de produto
       if rg.cd_top IN (CT_COMPRA_DEBITO, CT_SAQUE_DEBITO) then
         linha := linha || 'D';
       else
         linha := linha || 'C';
       end if;

       -- campo meio de captura
       linha := linha || '3';

       -- campo valor bruto da venda
       linha := linha || sc_arq.formatar_moeda(rg.vl_opr, 9, 2, '');

       -- campo valor do desconto
       linha := linha || sc_arq.formatar_moeda(rg.vl_opr - rg.vl_rps_pet, 9, 2, '');

       -- campo valor liquido
       linha := linha || sc_arq.formatar_moeda(rg.vl_rps_pet, 9, 2, '');

       -- campo numero do cartao
       linha := linha || substr(rg.cd_pls::varchar,1,6) || '******' || substr(rg.cd_pls::varchar,13,16);

       -- campo numero de parcelas
       linha := linha || '00';

       -- campo numero total de parcelas
       linha := linha || '00';

       -- campo nsu do host da parcela
       linha := linha || sc_arq.preencher(12,0,'0',ct_ESQUERDA);

       -- campo valor bruto da parcela
       --linha := linha || sc_arq.formatar_moeda(0, 11, 2, '');
       linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

       -- campo valor do desconto da parcela
       --linha := linha || sc_arq.formatar_moeda(0, 11, 2, '');
        linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

       -- campo valor liquido da parcela
       --linha := linha || sc_arq.formatar_moeda(0, 11, 2, '');
        linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

       -- campo banco
       linha := linha || sc_arq.preencher(3,rg.cd_bnc_fet,'0',ct_ESQUERDA);

       -- campo agencia
       linha := linha || sc_arq.preencher(6,rg.cd_agn_fet,'0',ct_ESQUERDA);

       -- campo conta
       linha := linha || sc_arq.preencher(11,rg.nr_cc_fet || rg.dg_cc_fet,'0',ct_ESQUERDA);

       -- campo nsu do SITEF
       linha := linha || sc_arq.preencher(12,rg.bit011,'0',ct_ESQUERDA);

       -- campo sequencial do registro
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

       perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

       end loop;


       -- DETALHE COMPROVANTE DE VENDAS
       -- LIQUIDACAO

      -- iterando nos registros do arquivo
      for rg in select  cun.nr_cpf_cnpj_cun, opr.dt_opr, opr.vl_opr, opr.cd_top, opr.cd_pls, pet.*, fet.cd_bnc_fet, fet.cd_agn_fet, fet.nr_cc_fet, fet.dg_cc_fet, rqs.cd_rqs, iso.bit011
                      from sc_rdc.tbl_rps rps
                        inner join sc_rdc.tbl_pet pet on pet.cd_rps = rps.cd_rps
                        inner join sc_rdc.tbl_fet fet on fet.cd_fet = pet.cd_fet
                        inner join sc_cad.tbl_cun cun on cun.cd_cun = fet.cd_cun
                        inner join sc_opr.tbl_opr opr on opr.cd_opr = pet.cd_opr
                        inner join sc_rdc.tbl_rqs rqs on rqs.cd_opr = opr.cd_opr
                        inner join sc_iso8583.tbl_msg8583 iso on iso.bit127 = rqs.cd_rqs::varchar
                    where rps.dt_rps::date = vp_data_referencia
                      and fet.cd_etb = rg_etb.cd_etb
                      order by fet.cd_fet
       loop


       vl_sequencial_registro := vl_sequencial_registro + 1;
       vl_total_registro := vl_total_registro + 1;
       vl_valor_total := vl_valor_total + rg.vl_opr;
       
       -- campo codigo do registro
       linha := 'CV';

       -- campo codigo do estabelecimento(CNPJ)
       linha := linha || sc_arq.preencher(15,rg.nr_cpf_cnpj_cun,'0',ct_ESQUERDA);

       -- campo nsu do host
       linha := linha || sc_arq.preencher(12,rg.cd_rqs,'0',ct_ESQUERDA);

       -- campo data transacao
       linha := linha || to_char(rg.dt_opr,'yyyymmdd');

       -- campo hora de transacao
       linha := linha || to_char(rg.dt_opr,'hh24miss');

       -- campo tipo de lancamento
       linha := linha || '1';

       -- campo data do lancamento
       linha := linha || to_char(vp_data_referencia,'yyyymmdd');

       -- campo tipo de produto
       if rg.cd_top IN (CT_COMPRA_DEBITO, CT_SAQUE_DEBITO) then
         linha := linha || 'D';
       else
         linha := linha || 'C';
       end if;

       -- campo meio de captura
       linha := linha || '3';

       -- campo valor bruto da venda
       linha := linha || sc_arq.formatar_moeda(rg.vl_opr, 9, 2, '');

       -- campo valor do desconto
       linha := linha || sc_arq.formatar_moeda(rg.vl_opr - rg.vl_rps_pet, 9, 2, '');

       -- campo valor liquido
       linha := linha || sc_arq.formatar_moeda(rg.vl_rps_pet, 9, 2, '');

       -- campo numero do cartao
       linha := linha || substr(rg.cd_pls::varchar,1,6) || '******' || substr(rg.cd_pls::varchar,13,16);

       -- campo numero de parcelas
       linha := linha || '00';

       -- campo numero total de parcelas
       linha := linha || '00';

       -- campo nsu do host da parcela
       linha := linha || sc_arq.preencher(12,0,'0',ct_ESQUERDA);

       -- campo valor bruto da parcela
       linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

       -- campo valor do desconto da parcela
       linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

       -- campo valor liquido da parcela
       linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

       -- campo banco
       linha := linha || sc_arq.preencher(3,rg.cd_bnc_fet,'0',ct_ESQUERDA);

       -- campo agencia
       linha := linha || sc_arq.preencher(6,rg.cd_agn_fet,'0',ct_ESQUERDA);

       -- campo conta
       linha := linha || sc_arq.preencher(11,rg.nr_cc_fet || rg.dg_cc_fet,'0',ct_ESQUERDA);

       -- campo nsu do SITEF
       linha := linha || sc_arq.preencher(12,rg.bit011,'0',ct_ESQUERDA);

       -- campo sequencial do registro
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

       perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

       end loop;

       -- TRAILER DO ARQUIVO DO LOTE DE VENDAS

       vl_sequencial_registro := vl_sequencial_registro + 1;
       
       -- campo codigo do registro
       linha := 'L9';

       -- campo total de registros de transacao
       linha := linha || sc_arq.preencher(6,vl_total_registro,'0',ct_ESQUERDA);

       -- campo total de valores
       linha := linha || sc_arq.formatar_moeda(vl_valor_total, 9, 2, '');

       -- campo sequencial do registro
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

       perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

       -- TRAILER DO ARQUIVO

       vl_sequencial_registro := vl_sequencial_registro + 1;
       
       -- campo codigo do registro
       linha := 'A9';

       -- campo total de registros do arquivo (linhas)
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

       -- campo sequencial do registro
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);


       perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

  end loop;
  */
exception 
when others then
  --perform sc_arq.excluirArquivo(vl_nome_arquivo); 
  RAISE EXCEPTION 'Problema na geração do arquivo de emissão de plastico. NUM:%, DETAILS:%', SQLSTATE, SQLERRM;
end;
$$;


ALTER FUNCTION sc_rdc.gerar_arquivo_extrato(vp_data_referencia date, vp_codigo_estabelecimento numeric) OWNER TO scan;

--
-- TOC entry 1769 (class 1255 OID 1657310)
-- Name: gerar_arquivo_extrato(numeric, date, date); Type: FUNCTION; Schema: sc_rdc; Owner: scaen
--

CREATE FUNCTION gerar_arquivo_extrato(vp_estabelecimento numeric, vp_data_inicial date, vp_data_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_data_atual date;
  ct_cod_etb_sobral_palacio numeric:= 65;
begin
  vl_data_atual := vp_data_inicial;
  while vp_data_final >= vl_data_atual loop
    raise notice 'gerando o arquivo do estabelecimento: % e data: %', vp_estabelecimento, vl_data_atual;

    if vp_estabelecimento = ct_cod_etb_sobral_palacio then 
	perform sc_rdc.gerar_arquivo_extrato_sobral_e_palacio(vl_data_atual);	
    else
	perform sc_rdc.gerar_arquivo_extrato(vl_data_atual, vp_estabelecimento);
    end if;
    
    vl_data_atual := vl_data_atual + interval '1 day';
  end loop; 
end;$$;


ALTER FUNCTION sc_rdc.gerar_arquivo_extrato(vp_estabelecimento numeric, vp_data_inicial date, vp_data_final date) OWNER TO scaen;

--
-- TOC entry 7866 (class 0 OID 0)
-- Dependencies: 1769
-- Name: FUNCTION gerar_arquivo_extrato(vp_estabelecimento numeric, vp_data_inicial date, vp_data_final date); Type: COMMENT; Schema: sc_rdc; Owner: scaen
--

COMMENT ON FUNCTION gerar_arquivo_extrato(vp_estabelecimento numeric, vp_data_inicial date, vp_data_final date) IS 'rotina que gerar os arquivos de extrato de um determinado período e estabelecimento';


--
-- TOC entry 1819 (class 1255 OID 1637616)
-- Name: gerar_arquivo_extrato_auttar(date); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_arquivo_extrato_auttar(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare


rg record;
rg_etb record;

ct_DIREITA numeric:= 1;
ct_ESQUERDA numeric:= 2;
ct_CENTRALIZADO numeric:= 3;

vl_sequencial_registro numeric:= 0;
vl_total_registro numeric := 0;
vl_valor_total numeric(13,2) := 0;

ct_tipo_residencial constant numeric := 1;
ct_tipo_celular constant numeric := 2;
ct_tipo_comercial constant numeric := 3;

separador varchar := ';';

vl_diretorio varchar;
vl_nome_arquivo varchar;
vl_local_arquivo varchar;
vl_local_diretorio varchar;

vl_codigo_arquivo numeric;
vl_data_referencia date;

linha varchar;

vl_existe_extrato numeric;
vl_existe_operacao numeric;
vl_codigo_matriz varchar;

rg_fet record;
rg_trs record;
begin


  for rg_etb in select distinct etb.*
                from sc_opr.tbl_opr o
                  inner join sc_rdc.tbl_fet fet on fet.cd_fet = o.cd_fet
                  inner join sc_rdc.tbl_etb etb on etb.cd_etb = fet.cd_etb
                where dt_opr::date = vp_data_referencia
                  and cd_top = 27 
                  and etb.cd_etb = 50 loop

                
      vl_sequencial_registro := 0;           

      select coalesce(nr_lgc_cel_fet||'',nr_lgc_fet||'')
      into strict vl_codigo_matriz
      from sc_rdc.tbl_fet
      where cd_etb = rg_etb.cd_etb
        and fg_mtz_fet = 'S';

      vl_nome_arquivo := 'SOMA_AUTTAR_VENDA_' || to_char(vp_data_referencia, 'yyyymmdd') || '.txt';
      --definindo onde o arquivo sera gravado
      vl_local_diretorio := 'c:\\arquivo_scan\\envio\\redeCompra\\extrato\\' || rg_etb.cd_etb;
      --criando o diretorio caso nao exista
      perform sc_arq.criardiretorio(vl_local_diretorio);
      --definindo onde o arquivo sera gravado
      vl_local_arquivo := vl_local_diretorio || '\\' || vl_nome_arquivo;  
      --deleta o arquivo caso exista
      perform sc_arq.excluirarquivo(vl_local_arquivo);

       -- HEADER DO ARQUIVO
       -- campo codigo do registro
       linha := '0';
       -- Data de Criação do arquivo
       linha := linha || to_char(now(),'ddmmyyyyhhmmss');
       -- Data de Referencia do movimento
       linha := linha || to_char(vp_data_referencia,'ddmmyyyy');
       -- Versao
       linha := linha || 'CEADM100';
       -- Codigo da matriz
       linha := linha || sc_arq.preencher(15,vl_codigo_matriz,'0',ct_esquerda);
       -- CNPJ da SOMA
       linha := linha || '99099099000199';
       -- Nome da SOMA
       linha := linha || 'SOMA MEIOS ELETRONIO';
       -- Número Sequencial da Remessa
       linha := linha || '000000001';
       -- Código da Administradora
       linha := linha || '99';
       -- Codigo da matriz
       linha := linha || sc_arq.repetir(' ', 109);

       perform sc_arq.gravarlinha(vl_local_arquivo, linha);
       vl_sequencial_registro := vl_sequencial_registro + 1;

       for rg_fet in select coalesce(fet.nr_lgc_cel_fet||'',nr_lgc_fet||'') codigo_estabelecimento,
                            fet.cd_bnc_fet,
                            fet.cd_agn_fet,
                            fet.nr_cc_fet,
                            pet.dt_prv_rps_pet,
                            fet.cd_fet,
                            sum(case when opr.st_opr=2 then 1 else 0 end) qtd_operacao_aprovada,
                            max(pet.cd_pet) codigo_resumo,
                            sum(opr.vl_opr) valor_bruto,
                            sum(opr.vl_opr - coalesce(opr.vl_tx_adm_opr,0)) valor_liquido,
                            sum(coalesce(opr.vl_tx_adm_opr,0)) valor_taxa_adm
                     from sc_opr.tbl_opr opr
                       inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
                       inner join sc_rdc.tbl_pet pet on pet.cd_opr = opr.cd_opr
                     where fet.cd_etb = rg_etb.cd_etb
                       and opr.dt_opr::date = vp_data_referencia
                       and opr.cd_top = 27
                       and opr.st_opr = 2
                       and opr.nr_prc_opr = 1 --Por enquaanto só funciona para compras nao parceladas
                     group by fet.cd_fet,coalesce(fet.nr_lgc_cel_fet||'',nr_lgc_fet||''),fet.cd_bnc_fet,fet.cd_agn_fet,nr_cc_fet,pet.dt_prv_rps_pet  loop

	       -- campo codigo do registro
	       linha := '1';
	       -- Data de Criação do arquivo
	       linha := linha || sc_arq.preencher(15,rg_fet.codigo_estabelecimento,'0',ct_esquerda);
	       -- Código do Produto
	       linha := linha || 'CC';
	       -- Forma de Captura
	       linha := linha || '   ';
	       -- Numero do RV
	       linha := linha || sc_arq.preencher(9,rg_fet.codigo_resumo,'0',ct_esquerda);
	       -- Data do RV
	       linha := linha || to_char(vp_data_referencia, 'ddmmyyyy');
	       -- Data do Pagamento
	       linha := linha || to_char(rg_fet.dt_prv_rps_pet, 'ddmmyyyy');
	       -- Banco
	       linha := linha || sc_arq.preencher(3,rg_fet.cd_bnc_fet,'0',ct_esquerda);
	       -- Agencia
	       linha := linha || sc_arq.preencher(6,rg_fet.cd_agn_fet,'0',ct_esquerda);
	       -- Conta Corrente
	       linha := linha || sc_arq.preencher(11,rg_fet.nr_cc_fet,'0',ct_esquerda);
	       -- Transacaoes efetivadas
	       linha := linha || sc_arq.preencher(9,rg_fet.qtd_operacao_aprovada,'0',ct_esquerda);
	       -- Transacaoes nao efetivadas
	       linha := linha || sc_arq.preencher(9,0,'0',ct_esquerda);
	       -- valor bruto
               linha := linha || sc_arq.formatar_moeda(12,rg_fet.valor_bruto); 
	       -- valor liquido
               linha := linha || sc_arq.formatar_moeda(12,rg_fet.valor_liquido); 
	       -- valor taxa servico
               linha := linha || sc_arq.formatar_moeda(12,rg_fet.valor_taxa_adm); 
	       -- valor comissao
               linha := linha || sc_arq.formatar_moeda(12,0); 
	       -- valor rejeitado
               linha := linha || sc_arq.formatar_moeda(12,0); 
	       -- valor credito
               linha := linha || sc_arq.formatar_moeda(12,rg_fet.valor_liquido); 
	       -- valor encargos
               linha := linha || sc_arq.formatar_moeda(12,0); 
	       -- indicador tipo de pagamento
               linha := linha || 'PF';
	       -- Número da Parcela
	       linha := linha || '01';
	       -- Quantidade da Parcela
	       linha := linha || '01';
	       -- Data do Pagamento Prevista
	       linha := linha || to_char(rg_fet.dt_prv_rps_pet, 'ddmmyyyy');
	       -- uso futuro
	       linha := linha || sc_arq.repetir(' ',18);

               perform sc_arq.gravarlinha(vl_local_arquivo, linha);
               vl_sequencial_registro := vl_sequencial_registro + 1;
               

	       for rg_trs in select *
	                     from sc_Opr.tbl_opr opr
                               inner join sc_rdc.tbl_rqs rqs on rqs.cd_opr = opr.cd_opr
                               inner join sc_iso8583.tbl_msg8583 iso on iso.bit127 = rqs.cd_rqs::varchar
                               inner join sc_rdc.tbl_pet pet on pet.cd_opr = opr.cd_opr
	                     where opr.dt_opr::date = vp_data_referencia
                               and opr.cd_top = 27
                               and opr.st_opr = 2
                               and opr.nr_prc_opr = 1 --Por enquaanto só funciona para compras nao parceladas
                               and opr.cd_fet = rg_fet.cd_fet loop

		       -- campo codigo do registro
		       linha := '2';
		       -- Data de Criação do arquivo
		       linha := linha || sc_arq.preencher(15,rg_fet.codigo_estabelecimento,'0',ct_esquerda);
		       -- Numero do RV
		       linha := linha || sc_arq.preencher(9,rg_fet.codigo_resumo,'0',ct_esquerda);
		       -- campo nsu do host
		       linha := linha || sc_arq.preencher(12,rg_trs.cd_rqs,'0',ct_ESQUERDA);
		       -- Data e Hora da transacao
		       linha := linha || to_char(rg_trs.dt_opr,'ddmmyyyyhhmmss');
		       -- Numero do cartao
		       linha := linha || substr(rg_trs.cd_pls::varchar,1,6) || '*********' || substr(rg_trs.cd_pls::varchar,13,16);
		       -- valor da transacao
		      linha := linha || sc_arq.formatar_moeda(12,rg_trs.vl_opr);
		       -- valor do saque
		      linha := linha || sc_arq.formatar_moeda(12,0);
		       -- valor comissao
		      linha := linha || sc_arq.formatar_moeda(12,rg_trs.vl_tx_adm_opr);
		       -- Numero de Parcela
		      linha := linha || '01';
		       -- Numero da Parcela
		      linha := linha || '01';
		       -- Valor da Parcela Paga
		      linha := linha || sc_arq.formatar_moeda(12,rg_trs.vl_opr - rg_trs.vl_tx_adm_opr);
	               -- Data do Pagamento
	              linha := linha || to_char(rg_trs.dt_prv_rps_pet, 'ddmmyyyy');
	              -- Codigo de Autorizacao
                      linha := linha || sc_arq.preencher(10,rg_trs.bit011,'0',ct_ESQUERDA);
	              -- Codigo de Captura
                      linha := linha || 'TEF';
	              -- Status
                      linha := linha || 'C';
	              -- Modalidade
                      linha := linha || '03';--Dinheiro
		       -- uso futuro
		       linha := linha || sc_arq.repetir(' ',54);

		       perform sc_arq.gravarlinha(vl_local_arquivo, linha);
                       vl_sequencial_registro := vl_sequencial_registro + 1;
		       
		       
                               
               end loop;--Loop de transacoes                

              

                     
       end loop;--Loop do resumo de vendas por filial

       linha := '9';
       -- Quantidade de Registro
       linha := linha || sc_arq.preencher(09,vl_sequencial_registro,'0',ct_ESQUERDA);
       -- uso futuro
       linha := linha || sc_arq.repetir(' ',190);
       perform sc_arq.gravarlinha(vl_local_arquivo, linha);

        
            
  end loop;--Loop do estabelecimento

/*exception 
when others then
  perform sc_arq.excluirArquivo(vl_nome_arquivo); 
  RAISE EXCEPTION 'Problema na geração do arquivo de geracao do arquivo da auttar. NUM:%, DETAILS:%', SQLSTATE, SQLERRM;*/
end;
$$;


ALTER FUNCTION sc_rdc.gerar_arquivo_extrato_auttar(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1543 (class 1255 OID 1672247)
-- Name: gerar_arquivo_extrato_estab(numeric, date); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_arquivo_extrato_estab(vp_codigo_estabelecimento numeric, vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg record;

  ct_DIREITA numeric:= 1;
  ct_ESQUERDA numeric:= 2;
  ct_CENTRALIZADO numeric:= 3;

  vl_sequencial_registro numeric:= 1;
  vl_total_registro numeric := 0;
  vl_valor_total numeric(13,2) := 0;

  ct_tipo_residencial constant numeric := 1;
  ct_tipo_celular constant numeric := 2;
  ct_tipo_comercial constant numeric := 3;

  CT_COMPRA_DEBITO constant numeric := 25;
  CT_SAQUE_DEBITO constant numeric := 4;

  separador varchar := ';';

  vl_diretorio varchar;
  vl_local_diretorio varchar;
  vl_nome_arquivo varchar;
  vl_local_arquivo varchar;

  vl_codigo_arquivo numeric;
  vl_data_referencia date;

  linha varchar;

  vl_existe_extrato numeric;
  vl_existe_operacao numeric;
  vl_codigo_requisicao numeric;
  vl_nsu_origem varchar;
begin
  if vp_codigo_estabelecimento is null then
    raise exception 'código do estabelecimento é obrigatório';
  end if;
  
  if vp_data_referencia is null then
    raise exception 'data de referência é obrigatório';
  end if;
  
  --definindo o nome do arquivo
  vl_nome_arquivo := 'SOMA' || to_char(vp_data_referencia, 'yyyymmdd') || '000001' || '.txt';

  --definindo onde o arquivo sera gravado
  vl_local_diretorio := E'c:\\arquivo_scan\\envio\\redeCompra\\extrato\\' || vp_codigo_estabelecimento;
  
  --criando o diretorio caso nao exista
  perform sc_arq.criardiretorio(vl_local_diretorio);

  --definindo onde o arquivo sera gravado
  vl_local_arquivo := vl_local_diretorio || '\\' || vl_nome_arquivo;
  
  --deleta o arquivo caso exista
  perform sc_arq.excluirarquivo(vl_local_arquivo);

  -- HEADER DO ARQUIVO
  -- campo codigo do registro
  linha := 'A0';

  -- campo versao do layout
  linha := linha || '001.6a';

  -- campo data geracao
  linha := linha || to_char(vp_data_referencia,'yyyymmdd');

  -- campo hora de geracao
  linha := linha || to_char(current_date,'hh24miss');

  -- campo id do movimento
  linha := linha || sc_arq.preencher(6,1,'0',ct_ESQUERDA);

  -- nome da administradora
  linha := linha || sc_arq.preencher(30,'SOMA',' ',ct_DIREITA);

  -- id do remetente
  linha := linha || sc_arq.preencher(4,1,'0',ct_ESQUERDA);

  -- id do destinatario
  linha := linha || sc_arq.preencher(6,'',' ',ct_ESQUERDA);

  -- campo sequencial do registro
  linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

  perform sc_arq.gravarlinha(vl_local_arquivo, linha);
    
  -- HEADER DO ARQUIVO DO LOTE DE VENDAS
  vl_sequencial_registro := vl_sequencial_registro + 1;
       
  -- campo codigo do registro
  linha := 'L0';

  -- campo data do movimento
  linha := linha || to_char(vp_data_referencia,'yyyymmdd');

  -- campo indicacao da moeda
  linha := linha || 'RE';

  -- campo sequencial do registro
  linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

  perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

  -- DETALHE COMPROVANTE DE VENDAS
  -- PREVISAO
  for rg in select opr.cd_opr, cun.nr_cpf_cnpj_cun, opr.dt_opr, opr.vl_opr, opr.cd_top, opr.cd_pls, pet.*, fet.cd_bnc_fet, fet.cd_agn_fet, fet.nr_cc_fet, fet.dg_cc_fet--, rqs.cd_rqs, rqs.nr_nsu_org
            from sc_rdc.tbl_pet pet 
                 inner join sc_rdc.tbl_fet fet on fet.cd_fet = pet.cd_fet
                 inner join sc_cad.tbl_cun cun on cun.cd_cun = fet.cd_cun
                 inner join sc_opr.tbl_opr opr on opr.cd_opr = pet.cd_opr
                 --inner join sc_rdc.tbl_rqs rqs on rqs.cd_opr = opr.cd_opr
            where /*rqs.tp_rqs in (2, 4) -- CONFIRMACAO DE COMPRA
              and*/ opr.dt_opr::date = vp_data_referencia - 1
              and fet.cd_etb = vp_codigo_estabelecimento
            order by fet.cd_fet, opr.dt_opr loop

    vl_sequencial_registro := vl_sequencial_registro + 1;
    vl_total_registro := vl_total_registro + 1;
    vl_valor_total := vl_valor_total + rg.vl_opr;
       
    -- campo codigo do registro
    linha := 'CV';

    -- campo codigo do estabelecimento(CNPJ)
    linha := linha || sc_arq.preencher(15,rg.nr_cpf_cnpj_cun,'0',ct_ESQUERDA);

    -- campo nsu do host
    select max(cd_rqs), max(nr_nsu_org)
      into vl_codigo_requisicao, vl_nsu_origem
    from sc_rdc.tbl_rqs rqs
    where rqs.cd_opr = rg.cd_opr
      and rqs.tp_rqs in (2, 4);
         
    linha := linha || sc_arq.preencher(12,vl_codigo_requisicao,'0',ct_ESQUERDA);
    --linha := linha || sc_arq.preencher(12,rg.cd_rqs,'0',ct_ESQUERDA);

    -- campo data transacao
    linha := linha || to_char(rg.dt_opr,'yyyymmdd');

    -- campo hora de transacao
    linha := linha || to_char(rg.dt_opr,'hh24miss');

    -- campo tipo de lancamento
    linha := linha || '0';

    -- campo data do lancamento
    linha := linha || to_char(rg.dt_prv_rps_pet,'yyyymmdd');

    -- campo tipo de produto
    if rg.cd_top = 25 then
      linha := linha || 'D';
    else
      linha := linha || 'C';
    end if;

    -- campo meio de captura
    linha := linha || '3';

    -- campo valor bruto da venda
    linha := linha || sc_arq.formatar_moeda(rg.vl_opr, 9, 2, '');

    -- campo valor do desconto
    linha := linha || sc_arq.formatar_moeda(rg.vl_opr - rg.vl_rps_pet, 9, 2, '');

    -- campo valor liquido
    linha := linha || sc_arq.formatar_moeda(rg.vl_rps_pet, 9, 2, '');

    -- campo numero do cartao
    linha := linha || substr(rg.cd_pls::varchar,1,6) || '*********' || substr(rg.cd_pls::varchar,13,16);

    -- campo numero de parcelas
    linha := linha || '00';

    -- campo numero total de parcelas
    linha := linha || '00';

    -- campo nsu do host da parcela
    linha := linha || sc_arq.preencher(12,0,'0',ct_ESQUERDA);

    -- campo valor bruto da parcela
    linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

    -- campo valor do desconto da parcela
    linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

    -- campo valor liquido da parcela
    linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

    -- campo banco
    linha := linha || sc_arq.preencher(3,rg.cd_bnc_fet,'0',ct_ESQUERDA);

    -- campo agencia
    linha := linha || sc_arq.preencher(6,rg.cd_agn_fet,'0',ct_ESQUERDA);

    -- campo conta
    linha := linha || sc_arq.preencher(11,rg.nr_cc_fet || rg.dg_cc_fet,'0',ct_ESQUERDA);

    -- campo nsu do SITEF
    linha := linha || sc_arq.preencher(12,vl_nsu_origem,'0',ct_ESQUERDA);
    --linha := linha || sc_arq.preencher(12,rg.nr_nsu_org,'0',ct_ESQUERDA);

    -- campo sequencial do registro
    linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

    perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

  end loop;


  -- DETALHE COMPROVANTE DE VENDAS
  -- LIQUIDACAO
  -- iterando nos registros do arquivo
  for rg in select opr.cd_opr, cun.nr_cpf_cnpj_cun, opr.dt_opr, opr.vl_opr, opr.cd_top, opr.cd_pls, pet.*, fet.cd_bnc_fet, fet.cd_agn_fet, fet.nr_cc_fet, fet.dg_cc_fet--, rqs.cd_rqs, rqs.nr_nsu_org
            from sc_rdc.tbl_rps rps
                 inner join sc_rdc.tbl_pet pet on pet.cd_rps = rps.cd_rps
                 inner join sc_rdc.tbl_fet fet on fet.cd_fet = pet.cd_fet
                 inner join sc_cad.tbl_cun cun on cun.cd_cun = fet.cd_cun
                 inner join sc_opr.tbl_opr opr on opr.cd_opr = pet.cd_opr
            where /*rqs.tp_rqs in (2, 4) -- CONFIRMACAO DE COMPRA
              and*/ rps.dt_rps::date = vp_data_referencia
              and fet.cd_etb = vp_codigo_estabelecimento
            order by fet.cd_fet loop
    vl_sequencial_registro := vl_sequencial_registro + 1;
    vl_total_registro := vl_total_registro + 1;
    vl_valor_total := vl_valor_total + rg.vl_opr;
       
    -- campo codigo do registro
    linha := 'CV';

    -- campo codigo do estabelecimento(CNPJ)
    linha := linha || sc_arq.preencher(15,rg.nr_cpf_cnpj_cun,'0',ct_ESQUERDA);

    -- campo nsu do host
    select max(cd_rqs), max(nr_nsu_org)
      into vl_codigo_requisicao, vl_nsu_origem
    from sc_rdc.tbl_rqs rqs
    where rqs.cd_opr = rg.cd_opr
      and rqs.tp_rqs in (2, 4);
         
    linha := linha || sc_arq.preencher(12,vl_codigo_requisicao,'0',ct_ESQUERDA);
    --linha := linha || sc_arq.preencher(12,rg.cd_rqs,'0',ct_ESQUERDA);

    -- campo data transacao
    linha := linha || to_char(rg.dt_opr,'yyyymmdd');

    -- campo hora de transacao
    linha := linha || to_char(rg.dt_opr,'hh24miss');

    -- campo tipo de lancamento
    linha := linha || '1';

    -- campo data do lancamento
    linha := linha || to_char(vp_data_referencia,'yyyymmdd');

    -- campo tipo de produto
    if rg.cd_top = 25 then
      linha := linha || 'D';
    else
      linha := linha || 'C';
    end if;

    -- campo meio de captura
    linha := linha || '3';

    -- campo valor bruto da venda
    linha := linha || sc_arq.formatar_moeda(rg.vl_opr, 9, 2, '');

    -- campo valor do desconto
    linha := linha || sc_arq.formatar_moeda(rg.vl_opr - rg.vl_rps_pet, 9, 2, '');

    -- campo valor liquido
    linha := linha || sc_arq.formatar_moeda(rg.vl_rps_pet, 9, 2, '');

    -- campo numero do cartao
    linha := linha || substr(rg.cd_pls::varchar,1,6) || '*********' || substr(rg.cd_pls::varchar,13,16);

    -- campo numero de parcelas
    linha := linha || '00';

    -- campo numero total de parcelas
    linha := linha || '00';

    -- campo nsu do host da parcela
    linha := linha || sc_arq.preencher(12,0,'0',ct_ESQUERDA);

    -- campo valor bruto da parcela
    linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

    -- campo valor do desconto da parcela
    linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

    -- campo valor liquido da parcela
    linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

    -- campo banco
    linha := linha || sc_arq.preencher(3,rg.cd_bnc_fet,'0',ct_ESQUERDA);

    -- campo agencia
    linha := linha || sc_arq.preencher(6,rg.cd_agn_fet,'0',ct_ESQUERDA);

    -- campo conta
    linha := linha || sc_arq.preencher(11,rg.nr_cc_fet || rg.dg_cc_fet,'0',ct_ESQUERDA);

    -- campo nsu do SITEF
    linha := linha || sc_arq.preencher(12,vl_nsu_origem,'0',ct_ESQUERDA);
    --linha := linha || sc_arq.preencher(12,rg.nr_nsu_org,'0',ct_ESQUERDA);

    -- campo sequencial do registro
    linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

    perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

  end loop;

  -- TRAILER DO ARQUIVO DO LOTE DE VENDAS
  vl_sequencial_registro := vl_sequencial_registro + 1;
       
  -- campo codigo do registro
  linha := 'L9';

  -- campo total de registros de transacao
  linha := linha || sc_arq.preencher(6,vl_total_registro,'0',ct_ESQUERDA);

  -- campo total de valores
  linha := linha || sc_arq.formatar_moeda(vl_valor_total, 9, 2, '');

  -- campo sequencial do registro
  linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

  perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

  -- TRAILER DO ARQUIVO
  vl_sequencial_registro := vl_sequencial_registro + 1;
       
  -- campo codigo do registro
  linha := 'A9';

  -- campo total de registros do arquivo (linhas)
  linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

  -- campo sequencial do registro
  linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

  perform sc_arq.gravarlinha(vl_local_arquivo, linha); 
end;
$$;


ALTER FUNCTION sc_rdc.gerar_arquivo_extrato_estab(vp_codigo_estabelecimento numeric, vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1849 (class 1255 OID 1650819)
-- Name: gerar_arquivo_extrato_sobral_e_palacio(date); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_arquivo_extrato_sobral_e_palacio(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

rg record;
rg_etb record;

ct_DIREITA numeric:= 1;
ct_ESQUERDA numeric:= 2;
ct_CENTRALIZADO numeric:= 3;

vl_sequencial_registro numeric:= 1;
vl_total_registro numeric := 0;
vl_valor_total numeric(13,2) := 0;

ct_tipo_residencial constant numeric := 1;
ct_tipo_celular constant numeric := 2;
ct_tipo_comercial constant numeric := 3;

separador varchar := ';';

vl_diretorio varchar;
vl_nome_arquivo varchar;
vl_local_arquivo varchar;
vl_local_diretorio varchar;

vl_codigo_arquivo numeric;
vl_data_referencia date;

linha varchar;

vl_existe_extrato numeric;
vl_existe_operacao numeric;

begin


  select count(rps.cd_rps)
    into vl_existe_extrato
      from sc_rdc.tbl_rps rps
      inner join sc_rdc.tbl_fet fet on fet.cd_fet = rps.cd_fet
    where rps.dt_rps::date = vp_data_referencia
      and fet.cd_etb=65;

  select count(opr.cd_opr)
    into vl_existe_operacao
       from sc_opr.tbl_opr opr
       inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
    where opr.dt_opr::date = vp_data_referencia - 1
     and fet.cd_etb=65;

  if vl_existe_extrato = 0 and vl_existe_operacao = 0 then
    return;
  end if;

  -- para cada estabelecimento
  for rg_etb in select distinct cd_etb from (
    select fet.cd_etb
      from sc_rdc.tbl_rps rps
      inner join sc_rdc.tbl_fet fet on fet.cd_fet = rps.cd_fet
    where rps.dt_rps::date = vp_data_referencia
    union all
    select fet.cd_etb
       from sc_opr.tbl_opr opr
       inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
    where opr.dt_opr::date = vp_data_referencia - 1) x 
    where cd_etb = 65
    
  loop
  
  -- inicializando os totalizadores
  vl_sequencial_registro := 1;
  vl_total_registro := 0;
  vl_valor_total := 0;

  --definindo o nome do arquivo
  vl_nome_arquivo := 'SOMA' || to_char(vp_data_referencia, 'yyyymmdd') || '000001' || '.txt';

  --definindo onde o arquivo sera gravado
  vl_local_diretorio := 'c:\\arquivo_scan\\envio\\redeCompra\\extrato\\' || rg_etb.cd_etb;
  
  --criando o diretorio caso nao exista
  perform sc_arq.criardiretorio(vl_local_diretorio);

  --definindo onde o arquivo sera gravado
  vl_local_arquivo := vl_local_diretorio || '\\' || vl_nome_arquivo;
  
  --deleta o arquivo caso exista
  perform sc_arq.excluirarquivo(vl_local_arquivo);

       -- HEADER DO ARQUIVO
       -- campo codigo do registro
       linha := 'A0';

       -- campo versao do layout
       linha := linha || '001.6a';

       -- campo data geracao
       linha := linha || to_char(vp_data_referencia,'yyyymmdd');

       -- campo hora de geracao
       linha := linha || to_char(current_date,'hh24miss');

       -- campo id do movimento
       linha := linha || sc_arq.preencher(6,1,'0',ct_ESQUERDA);

       -- nome da administradora
       linha := linha || sc_arq.preencher(30,'SOMA',' ',ct_DIREITA);

       -- id do remetente
       linha := linha || sc_arq.preencher(4,1,'0',ct_ESQUERDA);

       -- id do destinatario
       linha := linha || sc_arq.preencher(6,'',' ',ct_ESQUERDA);

       -- campo sequencial do registro
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

       perform sc_arq.gravarlinha(vl_local_arquivo, linha);
    
       -- HEADER DO ARQUIVO DO LOTE DE VENDAS

       vl_sequencial_registro := vl_sequencial_registro + 1;
       
       -- campo codigo do registro
       linha := 'L0';

       -- campo data do movimento
       linha := linha || to_char(vp_data_referencia,'yyyymmdd');

       -- campo indicacao da moeda
       linha := linha || 'RE';

       -- campo sequencial do registro
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);


       perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

       -- DETALHE COMPROVANTE DE VENDAS
       -- PREVISAO

       for rg in select  cun.nr_cpf_cnpj_cun, opr.dt_opr, opr.vl_opr, opr.cd_top, opr.cd_pls, pet.*, fet.cd_bnc_fet, fet.cd_agn_fet, fet.nr_cc_fet, fet.dg_cc_fet, rqs.cd_rqs, rqs.nr_nsu_org
                      from sc_rdc.tbl_pet pet 
                        inner join sc_rdc.tbl_fet fet on fet.cd_fet = pet.cd_fet
                        inner join sc_cad.tbl_cun cun on cun.cd_cun = fet.cd_cun
                        inner join sc_opr.tbl_opr opr on opr.cd_opr = pet.cd_opr
                        inner join sc_rdc.tbl_rqs rqs on rqs.cd_opr = opr.cd_opr
                    where rqs.tp_rqs in(4,10) -- REQUISICAO DE COMPRA E SAQUE
                      and opr.st_opr = 2
                      and opr.dt_opr::date = vp_data_referencia - 1
                      and fet.cd_etb = rg_etb.cd_etb
                      order by fet.cd_fet, opr.dt_opr loop


       vl_sequencial_registro := vl_sequencial_registro + 1;
       vl_total_registro := vl_total_registro + 1;
       vl_valor_total := vl_valor_total + rg.vl_opr;
       
       -- campo codigo do registro
       linha := 'CV';

       -- campo codigo do estabelecimento(CNPJ)
       linha := linha || sc_arq.preencher(15,rg.nr_cpf_cnpj_cun,'0',ct_ESQUERDA);

       -- campo nsu do host
       linha := linha || sc_arq.preencher(12,rg.cd_rqs,'0',ct_ESQUERDA);

       -- campo data transacao
       linha := linha || to_char(rg.dt_opr,'yyyymmdd');

       -- campo hora de transacao
       linha := linha || to_char(rg.dt_opr,'hh24miss');

       -- campo tipo de lancamento
       linha := linha || '0';

       -- campo data do lancamento
       linha := linha || to_char(rg.dt_prv_rps_pet,'yyyymmdd');

       -- campo tipo de produto
       if rg.cd_top = 25 then
         linha := linha || 'D';
       else
         linha := linha || 'C';
       end if;

       -- campo meio de captura
       linha := linha || '3';

       -- campo valor bruto da venda
       linha := linha || sc_arq.formatar_moeda(rg.vl_opr, 9, 2, '');

       -- campo valor do desconto
       linha := linha || sc_arq.formatar_moeda(rg.vl_opr - rg.vl_rps_pet, 9, 2, '');

       -- campo valor liquido
       linha := linha || sc_arq.formatar_moeda(rg.vl_rps_pet, 9, 2, '');

       -- campo numero do cartao
       linha := linha || substr(rg.cd_pls::varchar,1,6) || '*********' || substr(rg.cd_pls::varchar,13,16);

       -- campo numero de parcelas
       linha := linha || '00';

       -- campo numero total de parcelas
       linha := linha || '00';

       -- campo nsu do host da parcela
       linha := linha || sc_arq.preencher(12,0,'0',ct_ESQUERDA);

       -- campo valor bruto da parcela
       linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

       -- campo valor do desconto da parcela
       linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

       -- campo valor liquido da parcela
       linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

       -- campo banco
       linha := linha || sc_arq.preencher(3,rg.cd_bnc_fet,'0',ct_ESQUERDA);

       -- campo agencia
       linha := linha || sc_arq.preencher(6,rg.cd_agn_fet,'0',ct_ESQUERDA);

       -- campo conta
       linha := linha || sc_arq.preencher(11,rg.nr_cc_fet || rg.dg_cc_fet,'0',ct_ESQUERDA);

       -- campo nsu do SITEF
       linha := linha || sc_arq.preencher(12,rg.nr_nsu_org,'0',ct_ESQUERDA);

       -- campo sequencial do registro
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

       perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

       end loop;


       -- DETALHE COMPROVANTE DE VENDAS
       -- LIQUIDACAO

      -- iterando nos registros do arquivo
      for rg in select  cun.nr_cpf_cnpj_cun, opr.dt_opr, opr.vl_opr, opr.cd_top, opr.cd_pls, pet.*, fet.cd_bnc_fet, fet.cd_agn_fet, fet.nr_cc_fet, fet.dg_cc_fet, rqs.cd_rqs, rqs.nr_nsu_org
                      from sc_rdc.tbl_rps rps
                        inner join sc_rdc.tbl_pet pet on pet.cd_rps = rps.cd_rps
                        inner join sc_rdc.tbl_fet fet on fet.cd_fet = pet.cd_fet
                        inner join sc_cad.tbl_cun cun on cun.cd_cun = fet.cd_cun
                        inner join sc_opr.tbl_opr opr on opr.cd_opr = pet.cd_opr
                        inner join sc_rdc.tbl_rqs rqs on rqs.cd_opr = opr.cd_opr
                    where rqs.tp_rqs in(4,10) -- CONFIRMACAO DE COMPRA
                      and opr.st_opr = 2
                      and rps.dt_rps::date = vp_data_referencia
                      and fet.cd_etb = rg_etb.cd_etb
                      order by fet.cd_fet
       loop


       vl_sequencial_registro := vl_sequencial_registro + 1;
       vl_total_registro := vl_total_registro + 1;
       vl_valor_total := vl_valor_total + rg.vl_opr;
       
       -- campo codigo do registro
       linha := 'CV';

       -- campo codigo do estabelecimento(CNPJ)
       linha := linha || sc_arq.preencher(15,rg.nr_cpf_cnpj_cun,'0',ct_ESQUERDA);

       -- campo nsu do host
       linha := linha || sc_arq.preencher(12,rg.cd_rqs,'0',ct_ESQUERDA);

       -- campo data transacao
       linha := linha || to_char(rg.dt_opr,'yyyymmdd');

       -- campo hora de transacao
       linha := linha || to_char(rg.dt_opr,'hh24miss');

       -- campo tipo de lancamento
       linha := linha || '1';

       -- campo data do lancamento
       linha := linha || to_char(vp_data_referencia,'yyyymmdd');

       -- campo tipo de produto
       if rg.cd_top = 25 then
         linha := linha || 'D';
       else
         linha := linha || 'C';
       end if;

       -- campo meio de captura
       linha := linha || '3';

       -- campo valor bruto da venda
       linha := linha || sc_arq.formatar_moeda(rg.vl_opr, 9, 2, '');

       -- campo valor do desconto
       linha := linha || sc_arq.formatar_moeda(rg.vl_opr - rg.vl_rps_pet, 9, 2, '');

       -- campo valor liquido
       linha := linha || sc_arq.formatar_moeda(rg.vl_rps_pet, 9, 2, '');

       -- campo numero do cartao
       linha := linha || substr(rg.cd_pls::varchar,1,6) || '*********' || substr(rg.cd_pls::varchar,13,16);

       -- campo numero de parcelas
       linha := linha || '00';

       -- campo numero total de parcelas
       linha := linha || '00';

       -- campo nsu do host da parcela
       linha := linha || sc_arq.preencher(12,0,'0',ct_ESQUERDA);

       -- campo valor bruto da parcela
       linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

       -- campo valor do desconto da parcela
       linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

       -- campo valor liquido da parcela
       linha := linha || sc_arq.formatar_moeda(0, 9, 2, '');

       -- campo banco
       linha := linha || sc_arq.preencher(3,rg.cd_bnc_fet,'0',ct_ESQUERDA);

       -- campo agencia
       linha := linha || sc_arq.preencher(6,rg.cd_agn_fet,'0',ct_ESQUERDA);

       -- campo conta
       linha := linha || sc_arq.preencher(11,rg.nr_cc_fet || rg.dg_cc_fet,'0',ct_ESQUERDA);

       -- campo nsu do SITEF
       linha := linha || sc_arq.preencher(12,rg.nr_nsu_org,'0',ct_ESQUERDA);

       -- campo sequencial do registro
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

       perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

       end loop;

       -- TRAILER DO ARQUIVO DO LOTE DE VENDAS

       vl_sequencial_registro := vl_sequencial_registro + 1;
       
       -- campo codigo do registro
       linha := 'L9';

       -- campo total de registros de transacao
       linha := linha || sc_arq.preencher(6,vl_total_registro,'0',ct_ESQUERDA);

       -- campo total de valores
       linha := linha || sc_arq.formatar_moeda(vl_valor_total, 9, 2, '');

       -- campo sequencial do registro
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

       perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

       -- TRAILER DO ARQUIVO

       vl_sequencial_registro := vl_sequencial_registro + 1;
       
       -- campo codigo do registro
       linha := 'A9';

       -- campo total de registros do arquivo (linhas)
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);

       -- campo sequencial do registro
       linha := linha || sc_arq.preencher(6,vl_sequencial_registro,'0',ct_ESQUERDA);


       perform sc_arq.gravarlinha(vl_local_arquivo, linha);      

  end loop;

exception 
when others then
  perform sc_arq.excluirArquivo(vl_nome_arquivo); 
  RAISE EXCEPTION 'Problema na geração do arquivo de emissão de extrato. NUM:%, DETAILS:%', SQLSTATE, SQLERRM;
end;
$$;


ALTER FUNCTION sc_rdc.gerar_arquivo_extrato_sobral_e_palacio(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 1860 (class 1255 OID 1633073)
-- Name: gerar_arquivo_habilita_produto(numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scaen
--

CREATE FUNCTION gerar_arquivo_habilita_produto(vp_codigo_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   rg record;
   vl_linha varchar;
   vl_nome_arquivo varchar;
   vl_diretorio varchar;
   vl_parametro_diretorio varchar := 'ARQUIVO_HABILITACAO_CIELO';
   vl_seq_arquivo numeric;
   vl_seq_linha numeric;
   vl_nome_arquivo_dwn varchar;

  ALINHAMENTO_DIREITA numeric := 1;
  ALINHAMENTO_ESQUERDA numeric := 2;
   
begin
   select count(*)
   into vl_seq_arquivo
   from sc_rdc.tbl_ahp
   where dt_grc_ahp >= current_date;

   vl_nome_arquivo_dwn := to_char(current_date,'yyyymmdd') ||'HP' ||'605868'||trim(to_char(vl_seq_arquivo,'000'))||'.ENV';
   
   select vl_prm || '\\' || vl_nome_arquivo_dwn
   into vl_nome_arquivo
   from sc_cad.tbl_prm
   where nm_prm = 'ARQUIVO_HABILITACAO_CIELO';

   vl_seq_linha := 1;

   
   -- HEADER
    vl_linha := '0'; -- Identificador do Registro

    vl_linha := vl_linha || to_char(current_date,'yyyymmdd'); -- Data

    vl_linha := vl_linha || '605868'; -- BIN

    vl_linha := vl_linha || sc_arq.repetir(' ',279); --Brancos

    vl_linha := vl_linha || sc_arq.preencher(6, vl_seq_linha,'0',ALINHAMENTO_ESQUERDA); -- Sequencial

    perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

    for rg in select *
              from sc_rdc.tbl_dah
              where cd_ahp = vp_codigo_arquivo loop

      vl_seq_linha := vl_seq_linha + 1;
      vl_linha := '1'; -- Fixo
      vl_linha := vl_linha || '1'; -- Tipo do Processo
      vl_linha := vl_linha || sc_arq.preencher(15, rg.nr_lgc_cel_dah,'0',ALINHAMENTO_ESQUERDA); -- Numero cielo
      vl_linha := vl_linha || sc_arq.preencher(4, rg.prd_dah,'0',ALINHAMENTO_ESQUERDA); -- Produto
      vl_linha := vl_linha || sc_arq.preencher(14, rg.nr_cpf_cnpj_dah,'0',ALINHAMENTO_ESQUERDA); -- Produto
      vl_linha := vl_linha || sc_arq.preencher(40, rg.nm_dah,' ',ALINHAMENTO_DIREITA); -- Produto
      vl_linha := vl_linha || sc_arq.preencher(11, rg.tlf1_dah,'0',ALINHAMENTO_ESQUERDA); -- Produto
      vl_linha := vl_linha || sc_arq.preencher(11, rg.tlf2_dah,'0',ALINHAMENTO_ESQUERDA); -- Produto
      vl_linha := vl_linha || sc_arq.preencher(30, rg.nm_ctt_dah,' ',ALINHAMENTO_DIREITA); -- Produto
      vl_linha := vl_linha || sc_arq.preencher(50, rg.edr_dah,' ',ALINHAMENTO_DIREITA); -- Produto
      vl_linha := vl_linha || sc_arq.preencher(30, rg.brr_dah,' ',ALINHAMENTO_DIREITA); -- Produto
      vl_linha := vl_linha || sc_arq.preencher(30, rg.cdd_dah,' ',ALINHAMENTO_DIREITA); -- Produto
      vl_linha := vl_linha || sc_arq.preencher(2, rg.uf_dah,' ',ALINHAMENTO_DIREITA); -- Produto
      vl_linha := vl_linha || sc_arq.preencher(8, rg.cep_dah,'0',ALINHAMENTO_ESQUERDA); -- Produto
      vl_linha := vl_linha || sc_arq.repetir(' ',47); --Brancos
      vl_linha := vl_linha || sc_arq.preencher(6, vl_seq_linha,'0',ALINHAMENTO_ESQUERDA); -- Sequencial
      
      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
               
    end loop;          
    
      vl_seq_linha := vl_seq_linha + 1;
      vl_linha := '9'; --Fixo
      vl_linha := vl_linha || sc_arq.repetir(' ',293); --Brancos
      vl_linha := vl_linha || sc_arq.preencher(6, vl_seq_linha,'0',ALINHAMENTO_ESQUERDA); -- Sequencial

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

     update sc_rdc.tbl_ahp set st_ahp = 2,lcl_arq_ahp = vl_nome_arquivo_dwn  where cd_ahp = vp_codigo_arquivo;

     insert into sc_dwn.tbl_dwa(cd_dwa,nm_dwa,dt_grc_dwa,dt_ref_dwa,cd_tda,st_dwa)
          values(nextval('sc_dwn.sq_dwa'),vl_nome_arquivo_dwn,now(),now(),16,1);


end$$;


ALTER FUNCTION sc_rdc.gerar_arquivo_habilita_produto(vp_codigo_arquivo numeric) OWNER TO scaen;

--
-- TOC entry 1206 (class 1255 OID 1633490)
-- Name: gerar_arquivo_habilita_produto_job(); Type: FUNCTION; Schema: sc_rdc; Owner: scaen
--

CREATE FUNCTION gerar_arquivo_habilita_produto_job() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   vl_codigo_arquivo numeric;
begin

   select sc_rdc.gerar_dados_arquivo_habilita_produto() into vl_codigo_arquivo;

   if vl_codigo_arquivo is not null then
      perform sc_rdc.gerar_arquivo_habilita_produto(vl_codigo_arquivo);
   end if;
end$$;


ALTER FUNCTION sc_rdc.gerar_arquivo_habilita_produto_job() OWNER TO scaen;

--
-- TOC entry 1868 (class 1255 OID 1633489)
-- Name: gerar_dados_arquivo_habilita_produto(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_dados_arquivo_habilita_produto() RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare
   rg record;
   vl_qtd numeric;
begin

	select count(*)
	into vl_qtd
	from sc_rdc.tbl_fet fet
	   inner join sc_cad.tbl_cun cun on cun.cd_cun = fet.cd_cun
	   LEFT JOIN sc_cad.vw_edr e ON e.cd_cun = fet.cd_cun
	where nr_lgc_cel_fet is not null 
	  and fg_env_hpc_fet = 'S';--not exists(select 1 from sc_rdc.tbl_dah where cd_fet = fet.cd_fet);

	if vl_qtd > 0 then
	  insert into sc_rdc.tbl_ahp(cd_ahp,dt_grc_ahp,st_ahp) values(nextval('sc_rdc.sq_ahp'),now(),1);
	else 
	  return null;  
	end if;  


   for rg in select *
             from sc_rdc.tbl_fet fet
               inner join sc_cad.tbl_cun cun on cun.cd_cun = fet.cd_cun
               LEFT JOIN sc_cad.vw_edr e ON e.cd_cun = fet.cd_cun
             where nr_lgc_cel_fet is not null
               and fg_env_hpc_fet = 'S'--not exists(select 1 from sc_rdc.tbl_dah where cd_fet = fet.cd_fet) 
               and (e.cd_edr IS NULL OR e.cd_edr = ( SELECT max(ee.cd_edr) AS max
                                                      FROM sc_cad.tbl_edr ee
                                                      WHERE fet.cd_cun = ee.cd_cun 
                                                        AND ee.fg_atv_edr = 'S'::bpchar )) loop

        insert into sc_rdc.tbl_dah(cd_dah,cd_ahp, prd_dah,nr_cpf_cnpj_dah,nm_dah,edr_dah,brr_dah,cdd_dah,uf_dah,cep_dah,cd_fet, nr_lgc_cel_dah)
           values(nextval('sc_rdc.sq_dah'),currval('sc_rdc.sq_ahp'),0141,rg.nr_cpf_cnpj_cun,rg.nm_cun,rg.logradouro,rg.bairro,rg.localidade,rg.uf,rg.cep_edr,rg.cd_fet,rg.nr_lgc_cel_fet);

        insert into sc_rdc.tbl_oet(cd_oet,cd_toe,ds_oet,cd_fet,cd_inc_usr,dt_inc_usr)
             values(nextval('sc_rdc.sq_oet'),5,'GERACAO DO ARQUIVO DE HABILITACAO',rg.cd_fet,1,now());   

        update sc_rdc.tbl_fet set fg_env_hpc_fet = 'N' where cd_fet = rg.cd_fet;    
                
   end loop;

   return currval('sc_rdc.sq_ahp');            
end$$;


ALTER FUNCTION sc_rdc.gerar_dados_arquivo_habilita_produto() OWNER TO scan;

--
-- TOC entry 1136 (class 1255 OID 1036216)
-- Name: gerar_limite_compra(numeric, numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_limite_compra(vp_empresa numeric, vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   rg record;

   vl_prc_limite numeric := 0.5;

   vl_existe numeric;

   vl_limite_compra numeric := 0;

   vl_resto numeric;
   
begin

   for rg in select c.cd_crt,l.vl_cnc_lmt
             from sc_opr.tbl_crt c
               inner join sc_opr.tbl_lmt l on l.cd_crt = c.cd_crt
               inner join sc_cad.tbl_fnc f on f.cd_fnc = c.cd_fnc
             where l.cd_tlt = 1
               and c.fg_atv_crt = 'S' 
               and l.vl_cnc_lmt > 50
               and (vp_empresa is null or f.cd_emp = vp_empresa)
               and (vp_cartao is null or c.cd_crt = vp_cartao) 
               /*and not exists(select l 
                              from sc_opr.tbl_lmt l2 
                              where l2.cd_crt = c.cd_crt 
                                and l2.cd_tlt = 2)*/ loop

         select count(*)
         into vl_existe
         from sc_opr.tbl_lmt
         where cd_crt = rg.cd_crt
           and cd_tlt = 2;

         vl_limite_compra := rg.vl_cnc_lmt*vl_prc_limite;

         if vl_limite_compra < 50 then
            vl_limite_compra := 50;
         end if;

         vl_resto := mod(vl_limite_compra,10);

         vl_limite_compra := vl_limite_compra - vl_resto;
         
         if vl_existe > 0 then
            update sc_opr.tbl_lmt set vl_cnc_lmt = vl_limite_compra where cd_crt = rg.cd_crt and cd_tlt=2;
         else
            insert into sc_opr.tbl_lmt values(rg.cd_crt,2,vl_limite_compra,0.0,null,'S','S');
         end if;
         
   end loop;
   
end$$;


ALTER FUNCTION sc_rdc.gerar_limite_compra(vp_empresa numeric, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1745 (class 1255 OID 1023370)
-- Name: gerar_parcela_cancelamento_compra(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_parcela_cancelamento_compra() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  SITUACAO_OPERACAO_CONFIRMADA numeric := 2;
  rg record;
  rg_pet record;
  TIPO_OPERACAO_CANCELAMENTO_COMPRA_CREDITO_A_VISTA numeric := 26;
  
  vl_taxa_administracao numeric;
  vl_data_repasse date;
  vl_repasse numeric;

   VL_SITUACAO_PARCELA_CADASTRADA numeric := 1;
   VL_SITUACAO_PARCELA_REPASSADA numeric := 2;
   VL_SITUACAO_PARCELA_CANCELADA numeric := 3;
  
BEGIN

  for rg in select opr.dt_opr,
                   opr.cd_fet,
                   opr.vl_opr,
                   opr.cd_opr,
                   opr.cd_pai_opr
            from sc_opr.tbl_opr opr
            where opr.dt_pet_opr is null
              and opr.st_opr = SITUACAO_OPERACAO_CONFIRMADA
              and opr.cd_top = TIPO_OPERACAO_CANCELAMENTO_COMPRA_CREDITO_A_VISTA
              and opr.dt_opr < current_date loop

              
        for rg_pet in select *
                      from sc_rdc.tbl_pet pet
                      where pet.cd_opr = rg.cd_pai_opr loop

             if rg_pet.st_pet = VL_SITUACAO_PARCELA_REPASSADA then
             
		   insert into sc_rdc.tbl_pet(cd_pet,cd_fet,vl_tx_adm_pet,vl_rps_pet,dt_grc_pet,dt_prv_rps_pet,st_pet,fg_dcr_pet,cd_opr)
		      values(nextval('sc_rdc.sq_pet'),rg.cd_fet,0,rg.vl_opr,now(),now(),1,'D',rg.cd_opr);
	     else
	         update sc_rdc.tbl_pet set st_pet = VL_SITUACAO_PARCELA_CANCELADA where cd_pet = rg_pet.cd_pet;
             end if;         

             --ALTERA SOMENTE AS OPERACOES QUE TIVERAM SEUS PAIS PROCESSADOS
 	     update sc_opr.tbl_opr opr
	     set dt_pet_opr = now()
	     where opr.cd_opr = rg.cd_opr;
             
        end loop;                    
          
          
  end loop;            
  
              
END;
$$;


ALTER FUNCTION sc_rdc.gerar_parcela_cancelamento_compra() OWNER TO scan;

--
-- TOC entry 1825 (class 1255 OID 1023345)
-- Name: gerar_parcela_compra_a_vista(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_parcela_compra_a_vista() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  SITUACAO_OPERACAO_CONFIRMADA numeric := 2;
  rg record;
  TIPO_OPERACAO_COMPRA_CREDITO_A_VISTA numeric := 25;
  
  vl_taxa_administracao numeric;
  vl_data_repasse date;
  vl_repasse numeric;
  
BEGIN

  for rg in select opr.dt_opr,
                   opr.cd_fet,
                   opr.vl_opr,
                   opr.cd_opr
            from sc_opr.tbl_opr opr
            where opr.dt_pet_opr is null
              and opr.st_opr = SITUACAO_OPERACAO_CONFIRMADA
              and opr.cd_top = TIPO_OPERACAO_COMPRA_CREDITO_A_VISTA
              and opr.dt_opr < current_date loop
              
     vl_taxa_administracao := sc_rdc.calcular_taxa_administracao(rg.cd_fet,rg.vl_opr);
     vl_data_repasse := sc_rdc.calcular_data_repasse(TIPO_OPERACAO_COMPRA_CREDITO_A_VISTA,rg.cd_fet,rg.dt_opr);
     
     vl_repasse := rg.vl_opr - vl_taxa_administracao;
     
     insert into sc_rdc.tbl_pet(cd_pet,cd_fet,vl_tx_adm_pet,vl_rps_pet,dt_grc_pet,dt_prv_rps_pet,st_pet,fg_dcr_pet,cd_opr)
        values(nextval('sc_rdc.sq_pet'),rg.cd_fet,vl_taxa_administracao,vl_repasse,now(),vl_data_repasse,1,'C',rg.cd_opr);
          
  end loop;            
  
  update sc_opr.tbl_opr opr
  set dt_pet_opr = now(),
      vl_tx_adm_opr = vl_taxa_administracao
  where opr.dt_pet_opr is null
    and opr.st_opr = SITUACAO_OPERACAO_CONFIRMADA
    and opr.cd_top = TIPO_OPERACAO_COMPRA_CREDITO_A_VISTA
    and opr.dt_opr < current_date ;
              
END;
$$;


ALTER FUNCTION sc_rdc.gerar_parcela_compra_a_vista() OWNER TO scan;

--
-- TOC entry 1835 (class 1255 OID 1032601)
-- Name: gerar_parcela_compra_credito_avista(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_parcela_compra_credito_avista() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  SITUACAO_OPERACAO_CONFIRMADA numeric := 2;
  rg record;
  TIPO_OPERACAO_COMPRA_CREDITO_A_VISTA numeric := 27;
  
  vl_taxa_administracao numeric;
  vl_data_repasse date;
  vl_repasse numeric;
  
BEGIN

  for rg in select opr.dt_opr,
                   opr.cd_fet,
                   opr.vl_opr,
                   opr.cd_opr
            from sc_opr.tbl_opr opr
            where opr.dt_pet_opr is null
              and opr.st_opr = SITUACAO_OPERACAO_CONFIRMADA
              and opr.cd_top = TIPO_OPERACAO_COMPRA_CREDITO_A_VISTA
              and opr.dt_opr < current_date loop
              
     vl_taxa_administracao := sc_rdc.calcular_taxa_administracao(rg.cd_fet,rg.vl_opr);
     vl_data_repasse := sc_rdc.calcular_data_repasse(TIPO_OPERACAO_COMPRA_CREDITO_A_VISTA,rg.cd_fet,rg.dt_opr);
     
     vl_repasse := rg.vl_opr - vl_taxa_administracao;
     
     insert into sc_rdc.tbl_pet(cd_pet,cd_fet,vl_tx_adm_pet,vl_rps_pet,dt_grc_pet,dt_prv_rps_pet,st_pet,fg_dcr_pet,cd_opr)
        values(nextval('sc_rdc.sq_pet'),rg.cd_fet,vl_taxa_administracao,vl_repasse,now(),vl_data_repasse,1,'C',rg.cd_opr);

     update sc_opr.tbl_opr opr
     set dt_pet_opr = now(),
        vl_tx_adm_opr = vl_taxa_administracao
     where cd_opr = rg.cd_opr;
        
          
  end loop;            
                
END;
$$;


ALTER FUNCTION sc_rdc.gerar_parcela_compra_credito_avista() OWNER TO scan;

--
-- TOC entry 1599 (class 1255 OID 1033420)
-- Name: gerar_parcela_saque(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_parcela_saque() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  SITUACAO_OPERACAO_CONFIRMADA numeric := 2;
  rg record;
  TIPO_OPERACAO_SAQUE numeric := 4;
  
  vl_taxa_administracao numeric;
  vl_data_repasse date;
  vl_repasse numeric;

BEGIN

  for rg in select opr.dt_opr,
                   opr.cd_fet,
                   opr.vl_opr,
                   opr.cd_opr
            from sc_opr.tbl_opr opr
            where opr.dt_pet_opr is null
              and opr.st_opr = SITUACAO_OPERACAO_CONFIRMADA
              and opr.cd_top = TIPO_OPERACAO_SAQUE 
              and opr.cd_fet is not null
              and opr.dt_opr >= '01-01-2018' 
              and opr.dt_opr < current_date loop
              
     vl_taxa_administracao := 0;
     vl_data_repasse := sc_rdc.calcular_data_repasse(TIPO_OPERACAO_SAQUE,rg.cd_fet,rg.dt_opr);
     
     vl_repasse := rg.vl_opr - vl_taxa_administracao;
     
     insert into sc_rdc.tbl_pet(cd_pet,cd_fet,vl_tx_adm_pet,vl_rps_pet,dt_grc_pet,dt_prv_rps_pet,st_pet,fg_dcr_pet,cd_opr)
        values(nextval('sc_rdc.sq_pet'),rg.cd_fet,vl_taxa_administracao,vl_repasse,now(),vl_data_repasse,1,'C',rg.cd_opr);
          
  end loop;            
  
  update sc_opr.tbl_opr opr
  set dt_pet_opr = now()
  where opr.dt_pet_opr is null
    and opr.st_opr = SITUACAO_OPERACAO_CONFIRMADA
    and opr.cd_top = TIPO_OPERACAO_SAQUE
    and opr.cd_fet is not null
     and opr.dt_opr >= '01-01-2018'
     and opr.dt_opr < current_Date;
              
END;
$$;


ALTER FUNCTION sc_rdc.gerar_parcela_saque() OWNER TO scan;

--
-- TOC entry 1744 (class 1255 OID 564507)
-- Name: gerar_parcelas_estabelecimento(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_parcelas_estabelecimento() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  
BEGIN

    perform sc_rdc.gerar_parcela_compra_a_vista();
    perform sc_rdc.gerar_parcela_compra_credito_avista();
    perform sc_rdc.gerar_parcela_cancelamento_compra();
    perform sc_rdc.gerar_parcela_saque();

END;
$$;


ALTER FUNCTION sc_rdc.gerar_parcelas_estabelecimento() OWNER TO scan;

--
-- TOC entry 1618 (class 1255 OID 564508)
-- Name: gerar_repasse(date); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION gerar_repasse(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   rg record;

   VL_SITUACAO_PARCELA_CADASTRADA numeric := 1;
   VL_SITUACAO_PARCELA_REPASSADA numeric := 2;

   VL_SITUACAO_REPASSE_CADASTRADO numeric := 1;

   

   vl_codigo_repasse sc_rdc.tbl_rps.cd_rps%type;
   
begin

    if( not sc_grl.eh_dia_util(vp_data)) then
       return ;
    end if;   


    for rg in select sum(pet.vl_rps_pet) valor_repasse,
                     sum(pet.vl_tx_adm_pet) valor_taxa_adm,
                     pet.cd_fet
              from sc_rdc.tbl_pet pet
              where pet.st_pet = VL_SITUACAO_PARCELA_CADASTRADA
                and pet.dt_prv_rps_pet <= vp_data
                --and pet.cd_fet = 152
              group by pet.cd_fet   loop 
              
       select nextval('sc_rdc.sq_rps')
       into vl_codigo_repasse;

       insert into sc_rdc.tbl_rps(cd_rps,cd_fet,dt_rps,st_rps,vl_rps,dt_ctb_rps, vl_tx_adm_rps) 
             values(vl_codigo_repasse,rg.cd_fet,current_date,VL_SITUACAO_REPASSE_CADASTRADO,rg.valor_repasse,null, rg.valor_taxa_adm);

       update sc_rdc.tbl_pet
       set st_pet = VL_SITUACAO_PARCELA_REPASSADA,
           cd_rps = vl_codigo_repasse
       where cd_fet = rg.cd_fet
         and st_pet = VL_SITUACAO_PARCELA_CADASTRADA     
         and dt_prv_rps_pet <= vp_data;

    end loop;          


end$$;


ALTER FUNCTION sc_rdc.gerar_repasse(vp_data date) OWNER TO scan;

--
-- TOC entry 1181 (class 1255 OID 1622644)
-- Name: popula_numero_logico(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION popula_numero_logico() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin
  update sc_rdc.tbl_fet set nr_lgc_fet='201801'||trim(to_char(cd_fet,'0000'))||trim(to_char(cd_fet,'00000')) where  nr_lgc_fet is null or trim(nr_lgc_fet) = '';


end$$;


ALTER FUNCTION sc_rdc.popula_numero_logico() OWNER TO scan;

--
-- TOC entry 1290 (class 1255 OID 1648918)
-- Name: processar_arquivo_retorno_habilitacao_produto(numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION processar_arquivo_retorno_habilitacao_produto(vp_cd_rahp numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
	rg_rahp record;
	ds_oet varchar;
	cd_fet_atual numeric;
	CT_SITUACAO_CADASTRADO numeric := 1;
	CT_SITUACAO_PROCESSADO numeric := 2;

   	CT_SITUACAO_HABLITACAO_NAO_HABILITADO numeric := 1;
   	CT_SITUACAO_HABLITACAO_HABILITADO numeric := 2;
   	CT_SITUACAO_HABLITACAO_ERRO_NA_HABILITACAO numeric := 3;
   	CT_SITUACAO_HABLITACAO_CANCELADO numeric := 4;
   	
begin
	
	FOR rg_rahp IN 
		SELECT *
		  FROM sc_rdc.tbl_rahp rahp
		INNER JOIN sc_rdc.tbl_rdah rdah ON rdah.cd_rahp = rahp.cd_rahp
		WHERE rahp.st_rahp = CT_SITUACAO_CADASTRADO
		AND (CASE WHEN vp_cd_rahp IS NOT NULL THEN rahp.cd_rahp = vp_cd_rahp ELSE 1 = 1 END)
	LOOP
		SELECT cd_fet INTO cd_fet_atual
		FROM sc_rdc.tbl_fet fet
		  INNER JOIN sc_cad.tbl_cun cun ON cun.cd_cun = fet.cd_cun
		WHERE cun.NR_CPF_CNPJ_CUN = rg_rahp.nr_cpf_cnpj_rdah;
		
		IF cd_fet_atual IS NOT NULL THEN
			IF rg_rahp.cd_rsp_rdah = 6 THEN
				UPDATE sc_rdc.tbl_fet 
					SET st_hpc_fet = CT_SITUACAO_HABLITACAO_NAO_HABILITADO,
					ds_hpc_fet = rg_rahp.msg_rsp_rdah,
					fg_env_hpc_fet = 'S'
				WHERE cd_fet = cd_fet_atual;

				ds_oet := 'ESTABELECIMENTO NÃO HABILITADO: ' || rg_rahp.msg_rsp_rdah;
			ELSIF rg_rahp.cd_rsp_rdah = 7 THEN
				UPDATE sc_rdc.tbl_fet 
					SET st_hpc_fet = CT_SITUACAO_HABLITACAO_HABILITADO,
					ds_hpc_fet = rg_rahp.msg_rsp_rdah,
					fg_env_hpc_fet = 'S'
				WHERE cd_fet = cd_fet_atual;
				
				ds_oet := 'ESTABELECIMENTO HABILITADO';
			ELSE
				UPDATE sc_rdc.tbl_fet 
					SET st_hpc_fet = CT_SITUACAO_HABLITACAO_ERRO_NA_HABILITACAO,
					ds_hpc_fet = rg_rahp.msg_rsp_rdah,
					fg_env_hpc_fet = 'N'
				WHERE cd_fet = cd_fet_atual;
				
				ds_oet := 'ESTABELECIMENTO COM ERRO NA HABILITACAO: ' || rg_rahp.msg_rsp_rdah;
			END IF;
			
			INSERT INTO sc_rdc.tbl_oet VALUES (nextval('sc_rdc.sq_oet'), 5, ds_oet, cd_fet_atual, 1, now());
		END IF;
		
		UPDATE sc_rdc.tbl_rahp 
		  SET st_rahp = CT_SITUACAO_PROCESSADO
		WHERE cd_rahp = rg_rahp.cd_rahp;
	end LOOP;
end;$$;


ALTER FUNCTION sc_rdc.processar_arquivo_retorno_habilitacao_produto(vp_cd_rahp numeric) OWNER TO scan;

--
-- TOC entry 1434 (class 1255 OID 564509)
-- Name: processar_requisicao(numeric, numeric, character varying, numeric, numeric, double precision, numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION processar_requisicao(vp_filial_estabelecimento numeric, vp_nsu_org numeric, vp_nsu_terminal character varying, vp_plastico numeric, vp_tipo_requisicao numeric, vp_valor double precision DEFAULT NULL::double precision, vp_qtd_parcelas numeric DEFAULT NULL::numeric, OUT vp_codigo_requisicao numeric, OUT vp_codigo_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
-- Vitor A. Vasconcelos
-- Em 12/09/2013

DECLARE

 TIPO_REQUISICAO_AUT_COMPRA_DEBITO numeric := 1;
 TIPO_REQUISICAO_CONFIRMA_COMPRA  numeric := 2;
 TIPO_REQUISICAO_DESFAZ_COMPRA  numeric := 3;
 
 COD_RETORNO_SUCESSO numeric := 0; 
 COD_RETORNO_SALDO_INSUFICIENTE numeric := 2;
 COD_RETORNO_EQUIPAMENTO_INVALIDO numeric := 3;
 COD_RETORNO_ERRO_INESPERADO numeric := 99;
 
 vl_codigo_retorno sc_rdc.tbl_rqs.cd_ret_rqs%type;
 vl_qtd_parcelas sc_rdc.tbl_rqs.nr_prc_rqs%type;
 vl_codigo_equipamento sc_rdc.tbl_eqp.cd_eqp%type;

 vl_codigo_operacao sc_opr.tbl_opr.cd_opr%type;
BEGIN

  vp_codigo_retorno := 0; 

  -- Obtendo o codigo da requisicao
  select nextval('sc_rdc.sq_rqs')
  into vp_codigo_requisicao;

  if(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_DEBITO) then
     vl_qtd_parcelas := 1;
  else
     vl_qtd_parcelas := vp_qtd_parcelas;
  end if;
  
  -- Inserindo a requisição
  insert into sc_rdc.tbl_rqs(cd_rqs,nr_nsu_org,dt_rqs,tp_rqs,cd_pls,cd_fet,vl_rqs,nr_prc_rqs,nsu_eqp_rqs)
  values(vp_codigo_requisicao,vp_nsu_org,now(),vp_tipo_requisicao,vp_plastico,vp_filial_estabelecimento,vp_valor,vl_qtd_parcelas,vp_nsu_terminal);

  -- ** VALIDANDO EQUIPAMENTO **
  select eqp.cd_eqp
    into vl_codigo_equipamento
  from sc_rdc.tbl_eqp eqp
  where eqp.nsu_eqp = vp_nsu_terminal;

  if(vl_codigo_equipamento is null) then
    vp_codigo_retorno := COD_RETORNO_EQUIPAMENTO_INVALIDO;
  end if;

  -- ** FIM VALIDACAO EQUIPAMENTO **
  
  if(vp_codigo_retorno = 0) then
  
	  -- Chamando a funcao adequada para cada tipo de requisicao
	  if(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_DEBITO) then
	  
	    select * from sc_rdc.tr_aut_compra_debito(vp_plastico,vp_valor,vp_filial_estabelecimento,vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno;
	    
	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_CONFIRMA_COMPRA) then
	  
	    select * from sc_rdc.tr_confirma_compra(vp_nsu_org)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_DESFAZ_COMPRA) then  

	    select * from sc_rdc.tr_desfaz_compra(vp_nsu_org)
	    into vl_codigo_operacao, vp_codigo_retorno;
	      
	  end if;
	  
  end if; 	  
  
  -- Atualizando o retorno da requisição
  update sc_rdc.tbl_rqs
  set cd_ret_rqs = vp_codigo_retorno,
      cd_eqp = vl_codigo_equipamento,
      cd_opr = vl_codigo_operacao
  where cd_rqs = vp_codigo_requisicao;
  
  
/*EXCEPTION
WHEN others THEN

  update sc_rdc.tbl_rqs
  set cd_ret_rqs = COD_RETORNO_ERRO_INESPERADO
  where cd_rqs = vp_codigo_requisicao;
  
  vp_codigo_retorno := COD_RETORNO_ERRO_INESPERADO;*/
END;
$$;


ALTER FUNCTION sc_rdc.processar_requisicao(vp_filial_estabelecimento numeric, vp_nsu_org numeric, vp_nsu_terminal character varying, vp_plastico numeric, vp_tipo_requisicao numeric, vp_valor double precision, vp_qtd_parcelas numeric, OUT vp_codigo_requisicao numeric, OUT vp_codigo_retorno numeric) OWNER TO scan;

--
-- TOC entry 1856 (class 1255 OID 1636293)
-- Name: processar_requisicao_rdc(character varying, numeric, character varying, numeric, numeric, character varying, character varying, double precision, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_rdc; Owner: postgres
--

CREATE FUNCTION processar_requisicao_rdc(vp_logico_filial_estabelecimento character varying, vp_nsu_org numeric, vp_nsu_terminal character varying, vp_plastico numeric, vp_tipo_requisicao numeric, vp_validade character varying DEFAULT NULL::character varying, vp_codigo_seguranca character varying DEFAULT NULL::character varying, vp_valor double precision DEFAULT NULL::double precision, vp_qtd_parcelas numeric DEFAULT NULL::numeric, vp_nsu_autorizador numeric DEFAULT NULL::numeric, vp_codigo_rede numeric DEFAULT NULL::numeric, OUT vp_codigo_requisicao numeric, OUT vp_codigo_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
-- Vitor A. Vasconcelos
-- Em 12/09/2013

DECLARE

 TIPO_REQUISICAO_AUT_COMPRA_DEBITO numeric   := 1;
 TIPO_REQUISICAO_CONFIRMA_COMPRA  numeric    := 2;
 TIPO_REQUISICAO_DESFAZ_COMPRA  numeric      := 3;
 TIPO_REQUISICAO_AUT_COMPRA_CREDITO  numeric := 4;
 TIPO_REQUISICAO_CANCELAMENTO_COMPRA numeric := 5;
 TIPO_REQUISICAO_CONSULTA_SALDO numeric      := 6;
 TIPO_REQUISICAO_CONSULTA_PARCELA numeric    := 7;
 TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_SEM_JUROS numeric := 8;
 TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_COM_JUROS numeric := 9;
 TIPO_REQUISICAO_SAQUE_DEBITO numeric := 10;
 TIPO_REQUISICAO_SAQUE_CREDITO numeric := 11;
 TIPO_REQUISICAO_PGTO_FATURA numeric := 12;
 TIPO_REQUISICAO_CONSULTA_SALDO_CREDITO numeric  := 13;
 TIPO_REQUISICAO_CONFIRMA_CANCELAMENTO_COMPRA  numeric    := 14;
 TIPO_REQUISICAO_AUT_COMPRA_DEB_PARC_SEM_JUROS numeric := 15;
 TIPO_REQUISICAO_AUT_COMPRA_DEB_PARC_COM_JUROS numeric := 16;
 TIPO_REQUISICAO_CONSULTA_PARCELA_DEBITO numeric := 17;
 
 COD_RETORNO_SUCESSO numeric := 0; 
 COD_RETORNO_CARTAO_INVALIDO numeric := 14;
 COD_RETORNO_SALDO_INSUFICIENTE numeric := 51;
 COD_RETORNO_LIMITE_COMPRA_INSUFICIENTE numeric := 61;
 COD_RETORNO_CARTAO_BLOQUEADO numeric := 14;
 COD_RETORNO_EQUIPAMENTO_INVALIDO numeric := 3;
 COD_RETORNO_ERRO_INESPERADO numeric := 99;
 COD_RETORNO_ESTABELECIMENTO_INVALIDO numeric := 69;
 COD_RETORNO_TRANSACAO_NAO_PERMITIDA numeric := 53;
 
 vl_codigo_retorno sc_rdc.tbl_rqs.cd_ret_rqs%type;
 vl_qtd_parcelas sc_rdc.tbl_rqs.nr_prc_rqs%type;
 vl_codigo_equipamento sc_rdc.tbl_eqp.cd_eqp%type;

 vl_codigo_operacao sc_opr.tbl_opr.cd_opr%type;

 vl_inativo varchar;
 vl_bloqueado varchar;
 vl_existe_estabelecimento numeric;
 vl_validade varchar;
 vl_validade2 varchar;
 vl_cod_seguranca varchar;

 vl_codigo_filial numeric;

 vl_flag_permite_digitada varchar;
BEGIN

  vp_codigo_retorno := 0; 

  -- Obtendo o codigo da requisicao
  select nextval('sc_rdc.sq_rqs')
  into vp_codigo_requisicao;

  if(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_DEBITO) then
     vl_qtd_parcelas := 1;
  else
     vl_qtd_parcelas := vp_qtd_parcelas;
  end if;

  -- Inserindo a requisição
  insert into sc_rdc.tbl_rqs(cd_rqs,nr_nsu_org,dt_rqs,tp_rqs,cd_pls,nr_lgc_fet_rqs,vl_rqs,nr_prc_rqs,nsu_eqp_rqs, dt_vld_pls_rqs, nr_scc_pls_rqs, nsu_rede_rqs)
   values(vp_codigo_requisicao,vp_nsu_org,now(),vp_tipo_requisicao,vp_plastico,vp_logico_filial_estabelecimento,vp_valor,vl_qtd_parcelas,vp_nsu_terminal, vp_validade, vp_codigo_seguranca,vp_codigo_rede);
  
  
  -- Validando o Estabelecimento
  select cd_fet,fg_trs_dgt_fet
  into vl_codigo_filial,vl_flag_permite_digitada
  from sc_rdc.tbl_fet
  where (nr_lgc_fet = vp_logico_filial_estabelecimento
     or  nr_lgc_cel_fet = vp_logico_filial_estabelecimento::numeric);

  if vl_codigo_filial is null then
    vp_codigo_retorno := COD_RETORNO_ESTABELECIMENTO_INVALIDO;
  end if;

  if vl_flag_permite_digitada = 'N' then

     if vp_codigo_seguranca is not null then
         vp_codigo_retorno := COD_RETORNO_TRANSACAO_NAO_PERMITIDA;
     end if;
  
  end if;
  

  -- ** VALIDANDO O CARTAO E O PLASTICO **
  if vp_tipo_requisicao not in
     (TIPO_REQUISICAO_DESFAZ_COMPRA,
     TIPO_REQUISICAO_CONFIRMA_COMPRA,
     TIPO_REQUISICAO_CONFIRMA_CANCELAMENTO_COMPRA) then
  
	  if vp_codigo_retorno = 0 then
	  
		  select pls.fg_blq_pls, crt.fg_atv_crt, to_char(pls.dt_vld_pls,'yymm'), nr_scc_pls
		  into vl_bloqueado, vl_inativo, vl_validade,vl_cod_seguranca
		  from sc_opr.tbl_pls pls
		    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
		  where pls.cd_pls = vp_plastico;

		  if vl_inativo = 'N' then
		     --vp_codigo_retorno := COD_RETORNO_CARTAO_INVALIDO;
		  end if;

		  if vl_bloqueado = 'S' then
		     vp_codigo_retorno := COD_RETORNO_CARTAO_BLOQUEADO;
		  end if;

		  if vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_DEBITO or vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_CREDITO then
		    --if vp_validade is not null and vp_codigo_seguranca is not null then
		      if vl_validade <> vp_validade or vl_cod_seguranca <> vp_codigo_seguranca then
			vp_codigo_retorno := COD_RETORNO_CARTAO_INVALIDO;
		      end if;
		    --end if;
		  end if;
		  
	   end if;	  
  end if;	   
 
  -- ** ----
  -- ** VALIDANDO EQUIPAMENTO **
  /*if vp_codigo_retorno = 0 then

	  select eqp.cd_eqp
	    into vl_codigo_equipamento
	  from sc_rdc.tbl_eqp eqp
	  where eqp.nsu_eqp = vp_nsu_terminal;

	  if(vl_codigo_equipamento is null) then
	    vp_codigo_retorno := COD_RETORNO_EQUIPAMENTO_INVALIDO;
	  end if;
   end if;	  
  */
  -- ** FIM VALIDACAO EQUIPAMENTO **
  
  if(vp_codigo_retorno = 0) then
  
	  -- Chamando a funcao adequada para cada tipo de requisicao
	  if(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_DEBITO) then
	  
	    /*select * from sc_rdc.tr_aut_compra_debito_rdc(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno;*/
            vp_codigo_retorno = COD_RETORNO_TRANSACAO_NAO_PERMITIDA ;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_CREDITO) then
	  
	    select * from sc_rdc.tr_aut_compra_credito_avista_rdc(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno;
	    
	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_CONFIRMA_COMPRA) then
	  
	    select * from sc_rdc.tr_confirma_compra_rdc(vp_nsu_autorizador)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_CONFIRMA_CANCELAMENTO_COMPRA) then
	  
	    select * from sc_rdc.tr_confirma_cancelamento_compra_rdc(vp_nsu_autorizador)
	    into vl_codigo_operacao, vp_codigo_retorno;  

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_DESFAZ_COMPRA) then  

	    select * from sc_rdc.tr_desfaz_compra_rdc(vp_nsu_autorizador)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_CANCELAMENTO_COMPRA) then  

	    select * from sc_rdc.tr_cancela_compra_rdc(vp_codigo_requisicao, vp_nsu_autorizador)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_CONSULTA_SALDO) then  

            select * from sc_rdc.tr_consulta_saldo(vp_plastico, vl_codigo_filial, vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_CONSULTA_SALDO_CREDITO) then  

            select * from sc_rdc.tr_consulta_saldo_credito(vp_plastico, vl_codigo_filial, vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno;         
            
          elsif(vp_tipo_requisicao in (TIPO_REQUISICAO_CONSULTA_PARCELA,TIPO_REQUISICAO_CONSULTA_PARCELA_DEBITO)) then  

            select * from sc_rdc.tr_consulta_parcela(vp_plastico, vl_codigo_filial, vp_codigo_requisicao, vp_valor, vl_qtd_parcelas)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_SEM_JUROS) then 

            vp_codigo_retorno = COD_RETORNO_TRANSACAO_NAO_PERMITIDA ;
            
            /*select * from sc_rdc.tr_aut_compra_credito_parcelada(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao,vp_qtd_parcelas,false)
	    into vl_codigo_operacao, vp_codigo_retorno;*/

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_COM_JUROS) then  

	    vp_codigo_retorno = COD_RETORNO_TRANSACAO_NAO_PERMITIDA ;


            /*select * from sc_rdc.tr_aut_compra_credito_parcelada(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao,vp_qtd_parcelas,true)
	    into vl_codigo_operacao, vp_codigo_retorno;*/

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_SAQUE_DEBITO) then  

            select * from sc_rdc.tr_aut_saque_debito_rdc(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno; 

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_SAQUE_CREDITO) then  

            /*select * from sc_rdc.tr_aut_saque_credito(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao,vp_qtd_parcelas)
	    into vl_codigo_operacao, vp_codigo_retorno;*/

            select * from sc_rdc.tr_aut_saque_debito_rdc(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno; 
	    

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_PGTO_FATURA) then  

            select * from sc_rdc.tr_aut_pagamento_fatura(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno;                 

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_DEB_PARC_SEM_JUROS) then  

            vp_codigo_retorno = COD_RETORNO_TRANSACAO_NAO_PERMITIDA ;

            --select * from sc_rdc.tr_aut_compra_debito_parcelada(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao,vp_qtd_parcelas,false)
	    --into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_DEB_PARC_COM_JUROS) then 

            vp_codigo_retorno = COD_RETORNO_TRANSACAO_NAO_PERMITIDA ;

            --select * from sc_rdc.tr_aut_compra_debito_parcelada(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao,vp_qtd_parcelas,true)
	    --into vl_codigo_operacao, vp_codigo_retorno;
	          
	  end if;
	  
  end if; 	  
  
  -- Atualizando o retorno da requisição
  update sc_rdc.tbl_rqs
  set cd_ret_rqs = vp_codigo_retorno,
      cd_eqp = vl_codigo_equipamento,
      cd_opr = vl_codigo_operacao,
      cd_fet = vl_codigo_filial
  where cd_rqs = vp_codigo_requisicao;
  
  
EXCEPTION
WHEN others THEN

  update sc_rdc.tbl_rqs
  set cd_ret_rqs = COD_RETORNO_ERRO_INESPERADO,
      cd_fet = vl_codigo_filial
  where cd_rqs = vp_codigo_requisicao;
  
  vp_codigo_retorno := COD_RETORNO_ERRO_INESPERADO;
END;
$$;


ALTER FUNCTION sc_rdc.processar_requisicao_rdc(vp_logico_filial_estabelecimento character varying, vp_nsu_org numeric, vp_nsu_terminal character varying, vp_plastico numeric, vp_tipo_requisicao numeric, vp_validade character varying, vp_codigo_seguranca character varying, vp_valor double precision, vp_qtd_parcelas numeric, vp_nsu_autorizador numeric, vp_codigo_rede numeric, OUT vp_codigo_requisicao numeric, OUT vp_codigo_retorno numeric) OWNER TO postgres;

--
-- TOC entry 1733 (class 1255 OID 1012792)
-- Name: processar_requisicao_rdc_old(character varying, numeric, character varying, numeric, numeric, character varying, character varying, double precision, numeric, numeric); Type: FUNCTION; Schema: sc_rdc; Owner: postgres
--

CREATE FUNCTION processar_requisicao_rdc_old(vp_logico_filial_estabelecimento character varying, vp_nsu_org numeric, vp_nsu_terminal character varying, vp_plastico numeric, vp_tipo_requisicao numeric, vp_validade character varying DEFAULT NULL::character varying, vp_codigo_seguranca character varying DEFAULT NULL::character varying, vp_valor double precision DEFAULT NULL::double precision, vp_qtd_parcelas numeric DEFAULT NULL::numeric, vp_nsu_autorizador numeric DEFAULT NULL::numeric, OUT vp_codigo_requisicao numeric, OUT vp_codigo_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
-- Vitor A. Vasconcelos
-- Em 12/09/2013

DECLARE

 TIPO_REQUISICAO_AUT_COMPRA_DEBITO numeric   := 1;
 TIPO_REQUISICAO_CONFIRMA_COMPRA  numeric    := 2;
 TIPO_REQUISICAO_DESFAZ_COMPRA  numeric      := 3;
 TIPO_REQUISICAO_AUT_COMPRA_CREDITO  numeric := 4;
 TIPO_REQUISICAO_CANCELAMENTO_COMPRA numeric := 5;
 TIPO_REQUISICAO_CONSULTA_SALDO numeric      := 6;
 TIPO_REQUISICAO_CONSULTA_PARCELA numeric    := 7;
 TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_SEM_JUROS numeric := 8;
 TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_COM_JUROS numeric := 9;
 TIPO_REQUISICAO_SAQUE_DEBITO numeric := 10;
 TIPO_REQUISICAO_SAQUE_CREDITO numeric := 11;
 TIPO_REQUISICAO_PGTO_FATURA numeric := 12;
 TIPO_REQUISICAO_CONSULTA_SALDO_CREDITO numeric  := 13;
 TIPO_REQUISICAO_CONFIRMA_CANCELAMENTO_COMPRA  numeric    := 14;
 TIPO_REQUISICAO_AUT_COMPRA_DEB_PARC_SEM_JUROS numeric := 15;
 TIPO_REQUISICAO_AUT_COMPRA_DEB_PARC_COM_JUROS numeric := 16;
 TIPO_REQUISICAO_CONSULTA_PARCELA_DEBITO numeric := 17;
 
 COD_RETORNO_SUCESSO numeric := 0; 
 COD_RETORNO_CARTAO_INVALIDO numeric := 14;
 COD_RETORNO_SALDO_INSUFICIENTE numeric := 51;
 COD_RETORNO_LIMITE_COMPRA_INSUFICIENTE numeric := 61;
 COD_RETORNO_CARTAO_BLOQUEADO numeric := 14;
 COD_RETORNO_EQUIPAMENTO_INVALIDO numeric := 3;
 COD_RETORNO_ERRO_INESPERADO numeric := 99;
 COD_RETORNO_ESTABELECIMENTO_INVALIDO numeric := 69;
 COD_RETORNO_TRANSACAO_NAO_PERMITIDA numeric := 53;
 
 vl_codigo_retorno sc_rdc.tbl_rqs.cd_ret_rqs%type;
 vl_qtd_parcelas sc_rdc.tbl_rqs.nr_prc_rqs%type;
 vl_codigo_equipamento sc_rdc.tbl_eqp.cd_eqp%type;

 vl_codigo_operacao sc_opr.tbl_opr.cd_opr%type;

 vl_inativo varchar;
 vl_bloqueado varchar;
 vl_existe_estabelecimento numeric;
 vl_validade varchar;
 vl_validade2 varchar;
 vl_cod_seguranca varchar;

 vl_codigo_filial numeric;

 vl_flag_permite_digitada varchar;
BEGIN

  vp_codigo_retorno := 0; 

  -- Obtendo o codigo da requisicao
  select nextval('sc_rdc.sq_rqs')
  into vp_codigo_requisicao;

  if(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_DEBITO) then
     vl_qtd_parcelas := 1;
  else
     vl_qtd_parcelas := vp_qtd_parcelas;
  end if;

  -- Inserindo a requisição
  insert into sc_rdc.tbl_rqs(cd_rqs,nr_nsu_org,dt_rqs,tp_rqs,cd_pls,nr_lgc_fet_rqs,vl_rqs,nr_prc_rqs,nsu_eqp_rqs, dt_vld_pls_rqs, nr_scc_pls_rqs)
   values(vp_codigo_requisicao,vp_nsu_org,now(),vp_tipo_requisicao,vp_plastico,vp_logico_filial_estabelecimento,vp_valor,vl_qtd_parcelas,vp_nsu_terminal, vp_validade, vp_codigo_seguranca);
  
  
  -- Validando o Estabelecimento
  select cd_fet,fg_trs_dgt_fet
  into vl_codigo_filial,vl_flag_permite_digitada
  from sc_rdc.tbl_fet
  where (nr_lgc_fet = vp_logico_filial_estabelecimento
     or  nr_lgc_cel_fet = vp_logico_filial_estabelecimento::numeric);

  if vl_codigo_filial is null then
    vp_codigo_retorno := COD_RETORNO_ESTABELECIMENTO_INVALIDO;
  end if;

  if vl_flag_permite_digitada = 'N' then

     if vp_codigo_seguranca is not null then
         vp_codigo_retorno := COD_RETORNO_TRANSACAO_NAO_PERMITIDA;
     end if;
  
  end if;
  

  -- ** VALIDANDO O CARTAO E O PLASTICO **
  if vp_tipo_requisicao not in
     (TIPO_REQUISICAO_DESFAZ_COMPRA,
     TIPO_REQUISICAO_CONFIRMA_COMPRA,
     TIPO_REQUISICAO_CONFIRMA_CANCELAMENTO_COMPRA) then
  
	  if vp_codigo_retorno = 0 then
	  
		  select pls.fg_blq_pls, crt.fg_atv_crt, to_char(pls.dt_vld_pls,'yymm'), nr_scc_pls
		  into vl_bloqueado, vl_inativo, vl_validade,vl_cod_seguranca
		  from sc_opr.tbl_pls pls
		    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
		  where pls.cd_pls = vp_plastico;

		  if vl_inativo = 'N' then
		     --vp_codigo_retorno := COD_RETORNO_CARTAO_INVALIDO;
		  end if;

		  if vl_bloqueado = 'S' then
		     vp_codigo_retorno := COD_RETORNO_CARTAO_BLOQUEADO;
		  end if;

		  if vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_DEBITO or vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_CREDITO then
		    --if vp_validade is not null and vp_codigo_seguranca is not null then
		      if vl_validade <> vp_validade or vl_cod_seguranca <> vp_codigo_seguranca then
			vp_codigo_retorno := COD_RETORNO_CARTAO_INVALIDO;
		      end if;
		    --end if;
		  end if;
		  
	   end if;	  
  end if;	   
 
  -- ** ----
  -- ** VALIDANDO EQUIPAMENTO **
  /*if vp_codigo_retorno = 0 then

	  select eqp.cd_eqp
	    into vl_codigo_equipamento
	  from sc_rdc.tbl_eqp eqp
	  where eqp.nsu_eqp = vp_nsu_terminal;

	  if(vl_codigo_equipamento is null) then
	    vp_codigo_retorno := COD_RETORNO_EQUIPAMENTO_INVALIDO;
	  end if;
   end if;	  
  */
  -- ** FIM VALIDACAO EQUIPAMENTO **
  
  if(vp_codigo_retorno = 0) then
  
	  -- Chamando a funcao adequada para cada tipo de requisicao
	  if(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_DEBITO) then
	  
	    /*select * from sc_rdc.tr_aut_compra_debito_rdc(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno;*/
            vp_codigo_retorno = COD_RETORNO_TRANSACAO_NAO_PERMITIDA ;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_CREDITO) then
	  
	    select * from sc_rdc.tr_aut_compra_credito_avista_rdc(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno;
	    
	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_CONFIRMA_COMPRA) then
	  
	    select * from sc_rdc.tr_confirma_compra_rdc(vp_nsu_autorizador)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_CONFIRMA_CANCELAMENTO_COMPRA) then
	  
	    select * from sc_rdc.tr_confirma_cancelamento_compra_rdc(vp_nsu_autorizador)
	    into vl_codigo_operacao, vp_codigo_retorno;  

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_DESFAZ_COMPRA) then  

	    select * from sc_rdc.tr_desfaz_compra_rdc(vp_nsu_autorizador)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_CANCELAMENTO_COMPRA) then  

	    select * from sc_rdc.tr_cancela_compra_rdc(vp_codigo_requisicao, vp_nsu_autorizador)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_CONSULTA_SALDO) then  

            select * from sc_rdc.tr_consulta_saldo(vp_plastico, vl_codigo_filial, vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_CONSULTA_SALDO_CREDITO) then  

            select * from sc_rdc.tr_consulta_saldo_credito(vp_plastico, vl_codigo_filial, vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno;         
            
          elsif(vp_tipo_requisicao in (TIPO_REQUISICAO_CONSULTA_PARCELA,TIPO_REQUISICAO_CONSULTA_PARCELA_DEBITO)) then  

            select * from sc_rdc.tr_consulta_parcela(vp_plastico, vl_codigo_filial, vp_codigo_requisicao, vp_valor, vl_qtd_parcelas)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_SEM_JUROS) then  

            select * from sc_rdc.tr_aut_compra_credito_parcelada(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao,vp_qtd_parcelas,false)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_CRED_PARC_COM_JUROS) then  

            select * from sc_rdc.tr_aut_compra_credito_parcelada(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao,vp_qtd_parcelas,true)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_SAQUE_DEBITO) then  

            select * from sc_rdc.tr_aut_saque_debito_rdc(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno; 

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_SAQUE_CREDITO) then  

            /*select * from sc_rdc.tr_aut_saque_credito(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao,vp_qtd_parcelas)
	    into vl_codigo_operacao, vp_codigo_retorno;*/

            select * from sc_rdc.tr_aut_saque_debito_rdc(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno; 
	    

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_PGTO_FATURA) then  

            select * from sc_rdc.tr_aut_pagamento_fatura(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao)
	    into vl_codigo_operacao, vp_codigo_retorno;                 

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_DEB_PARC_SEM_JUROS) then  

            select * from sc_rdc.tr_aut_compra_debito_parcelada(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao,vp_qtd_parcelas,false)
	    into vl_codigo_operacao, vp_codigo_retorno;

	  elsif(vp_tipo_requisicao = TIPO_REQUISICAO_AUT_COMPRA_DEB_PARC_COM_JUROS) then  

            select * from sc_rdc.tr_aut_compra_debito_parcelada(vp_plastico,vp_valor,vl_codigo_filial,vp_codigo_requisicao,vp_qtd_parcelas,true)
	    into vl_codigo_operacao, vp_codigo_retorno;
	          
	  end if;
	  
  end if; 	  
  
  -- Atualizando o retorno da requisição
  update sc_rdc.tbl_rqs
  set cd_ret_rqs = vp_codigo_retorno,
      cd_eqp = vl_codigo_equipamento,
      cd_opr = vl_codigo_operacao,
      cd_fet = vl_codigo_filial
  where cd_rqs = vp_codigo_requisicao;
  
  
EXCEPTION
WHEN others THEN

  update sc_rdc.tbl_rqs
  set cd_ret_rqs = COD_RETORNO_ERRO_INESPERADO,
      cd_fet = vl_codigo_filial
  where cd_rqs = vp_codigo_requisicao;
  
  vp_codigo_retorno := COD_RETORNO_ERRO_INESPERADO;
END;
$$;


ALTER FUNCTION sc_rdc.processar_requisicao_rdc_old(vp_logico_filial_estabelecimento character varying, vp_nsu_org numeric, vp_nsu_terminal character varying, vp_plastico numeric, vp_tipo_requisicao numeric, vp_validade character varying, vp_codigo_seguranca character varying, vp_valor double precision, vp_qtd_parcelas numeric, vp_nsu_autorizador numeric, OUT vp_codigo_requisicao numeric, OUT vp_codigo_retorno numeric) OWNER TO postgres;

--
-- TOC entry 1838 (class 1255 OID 1030864)
-- Name: tr_aut_compra_credito_avista_rdc(numeric, double precision, numeric, numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION tr_aut_compra_credito_avista_rdc(vp_plastico numeric, vp_valor double precision, vp_filial_estabelecimento numeric, vp_cod_requisicao numeric, OUT vp_cod_operacao numeric, OUT vp_cod_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
-- Função responsável por realizar a autorização de uma Operação de Compra de credito A Vista
-- Grava Operacão, se for autorizada
-- Realizar os lançamentos necessários

DECLARE


  COD_RETORNO_SALDO_INSUFICIENTE numeric := 51;
  COD_RETORNO_SUCESSO numeric := 0;
  TIPO_OPERACAO_COMPRA_CREDITO_AVISTA numeric := 27;
  SITUACAO_OPERACAO_AUTORIZADA numeric := 1;
  
  
  vl_cartao sc_opr.tbl_crt.cd_crt%type;
  vl_saldo_conta sc_cnt.tbl_cnt.vl_sld_cnt%type;
  vl_saldo_limite numeric;
  
  vl_conta_debito sc_cnt.tbl_cnt.cd_cnt%type;
 
  vl_nr_lancamento sc_cnt.tbl_lcn.cd_lcn%type;

  vl_credito numeric;
  vl_debito numeric;
  vl_flag_ativo varchar;
  
BEGIN

  select p.cd_crt,c.fg_atv_crt
  into vl_cartao,vl_flag_ativo
  from sc_opr.tbl_pls p
    inner join sc_opr.tbl_crt c on c.cd_crt = p.cd_crt
  where p.cd_pls = vp_plastico;

  select COALESCE(sc_opr.saldo_limite(vl_cartao,2,'S'),0)
  into vl_saldo_limite;

  if vl_flag_ativo = 'N' then

     vl_saldo_limite := 0;     
     
  end if;

  if vl_saldo_limite < 0 then 
    vl_saldo_limite := 0;
  end if;
  
  select sc_cnt.get_saldo_cartao_sem_bloqueio(vl_cartao,Array[9],'S')
  into vl_saldo_conta;

  if vl_saldo_conta < 0 then
    vl_saldo_conta := 0;
  end if;
  
  if(coalesce(vl_saldo_conta,0) + coalesce(vl_saldo_limite,0) >= vp_valor) then

    if vl_saldo_limite >= vp_valor then
      vl_credito := vp_valor;
      vl_debito := 0;
    else
      vl_credito := vl_saldo_limite;
      vl_debito := vp_valor - vl_credito; 
    end if; 

    select nextval('sc_opr.sq_opr')
    into vp_cod_operacao;
    
  
    -- Gravando operacao de compra de credito a vista
    insert into sc_opr.tbl_opr(cd_opr,cd_pls,cd_top,dt_opr,vl_opr,vl_jrs_opr,vl_trf_opr,nr_prc_opr,
                               vl_prc_opr,vl_iof_opr,nr_nsu_org_opr,st_opr,cd_fet, vl_crd_opr)
                values(vp_cod_operacao,vp_plastico,TIPO_OPERACAO_COMPRA_CREDITO_AVISTA,now(),vp_valor,
                       0,0,1,vp_valor,0,vp_cod_requisicao,SITUACAO_OPERACAO_AUTORIZADA,vp_filial_estabelecimento, vl_credito);

                       
    if vl_debito > 0 then                     
	    -- Obtendo conta do cartão para realizar o débito
	    select c.cd_cnt
	    into strict vl_conta_debito
	    from sc_opr.tbl_cnt_crt c
	    where c.cd_crt = vl_cartao;

	    -- bloqueando o saldo do cartao para realizar o debito na confirmacao
	    perform sc_cnt.bloqueio_saldo_conta(vl_conta_debito::numeric,7::numeric,vl_debito::numeric); 
    end if;	    

    if vl_credito > 0 then
	    update sc_opr.tbl_lmt
	    set vl_utl_lmt = coalesce(vl_utl_lmt,0) + vl_credito
	    where cd_crt = vl_cartao
	      and cd_tlt = 2;
    end if;	      


      begin
        if vp_valor >= 100 then 
		-- caso haja problema no envio do sms NAO criticar a autorizacao
		perform sc_msg.enviar_mensagem_operacao_compra(vp_cod_operacao);
        end if;

      exception when others then

      end;
        
    vp_cod_retorno := COD_RETORNO_SUCESSO;               
  else
    vp_cod_retorno := COD_RETORNO_SALDO_INSUFICIENTE;  
  end if;
  

END;
$$;


ALTER FUNCTION sc_rdc.tr_aut_compra_credito_avista_rdc(vp_plastico numeric, vp_valor double precision, vp_filial_estabelecimento numeric, vp_cod_requisicao numeric, OUT vp_cod_operacao numeric, OUT vp_cod_retorno numeric) OWNER TO scan;

--
-- TOC entry 1810 (class 1255 OID 564510)
-- Name: tr_aut_compra_debito(numeric, double precision, numeric, numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION tr_aut_compra_debito(vp_plastico numeric, vp_valor double precision, vp_filial_estabelecimento numeric, vp_cod_requisicao numeric, OUT vp_cod_operacao numeric, OUT vp_cod_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
-- Função responsável por realizar a autorização de uma Operação de Compra A Vista
-- Grava Operacão, se for autorizada
-- Realizar os lançamentos necessários
-- Obs: Essa função considera que o cartão só possui uma conta

DECLARE


  CT_CONTA_CREDITO_RECARGA numeric := 19446;
  COD_RETORNO_SALDO_INSUFICIENTE numeric := 2;
  COD_RETORNO_SUCESSO numeric := 0;
  TIPO_OPERACAO_COMPRA_A_VISTA numeric := 20;
  SITUACAO_OPERACAO_AUTORIZADA numeric := 1;
  COD_SISTEMA_REDE_COMPRA numeric := 16;
  
  TIPO_LANCAMENTO_COMPRA_A_VISTA numeric := 1000;
  
  vl_cartao sc_opr.tbl_crt.cd_crt%type;
  vl_saldo_conta sc_cnt.tbl_cnt.vl_sld_cnt%type;
  
  vl_conta_debito sc_cnt.tbl_cnt.cd_cnt%type;
 
  vl_nr_lancamento sc_cnt.tbl_lcn.cd_lcn%type;
  
BEGIN

  select cd_crt
  into vl_cartao
  from sc_opr.tbl_pls
  where cd_pls = vp_plastico;
  
  select sc_cnt.get_saldo_cartao_sem_bloqueio(vl_cartao,Array[9],'S')
  into vl_saldo_conta;
  
  if(vl_saldo_conta >= vp_valor) then

    select nextval('sc_opr.sq_opr')
    into vp_cod_operacao;
    
  
    -- Gravando operacao de compra a vista
    insert into sc_opr.tbl_opr(cd_opr,cd_pls,cd_top,dt_opr,vl_opr,vl_jrs_opr,vl_trf_opr,nr_prc_opr,
                               vl_prc_opr,vl_iof_opr,nr_nsu_org_opr,st_opr,cd_fet)
                values(vp_cod_operacao,vp_plastico,TIPO_OPERACAO_COMPRA_A_VISTA,now(),vp_valor,
                       0,0,1,vp_valor,0,vp_cod_requisicao,SITUACAO_OPERACAO_AUTORIZADA,vp_filial_estabelecimento);

                       
                       
    -- Obtendo conta do cartão para realizar o débito
    select c.cd_cnt
    into strict vl_conta_debito
    from sc_opr.tbl_cnt_crt c
    where c.cd_crt = vl_cartao;

    perform sc_cnt.lancar_debito_credito(vl_conta_debito, CT_CONTA_CREDITO_RECARGA, TIPO_LANCAMENTO_COMPRA_A_VISTA, null, 'REF A COMPRA A VISTA OPERACAO '||currval('sc_opr.sq_opr')::varchar, vp_valor, now()::timestamp, 1, 3:: numeric, vp_cod_operacao::numeric);
    
    -- Efetuando lançamento de débito no cartão
--   perform sc_cnt.lancar_movimento(vl_nr_lancamento, null, TIPO_LANCAMENTO_COMPRA_A_VISTA, vl_conta_debito, 'D', vp_valor, now()::timestamp, 1::numeric, null, 'REF A COMPRA A VISTA OPERACAO '||currval('sc_opr.sq_opr')::varchar, 3::numeric, vp_cod_operacao::numeric);

        
    vp_cod_retorno := COD_RETORNO_SUCESSO;               
  else
    vp_cod_retorno := COD_RETORNO_SALDO_INSUFICIENTE;  
  end if;
  

END;
$$;


ALTER FUNCTION sc_rdc.tr_aut_compra_debito(vp_plastico numeric, vp_valor double precision, vp_filial_estabelecimento numeric, vp_cod_requisicao numeric, OUT vp_cod_operacao numeric, OUT vp_cod_retorno numeric) OWNER TO scan;

--
-- TOC entry 1725 (class 1255 OID 1012201)
-- Name: tr_aut_compra_debito_rdc(numeric, double precision, numeric, numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION tr_aut_compra_debito_rdc(vp_plastico numeric, vp_valor double precision, vp_filial_estabelecimento numeric, vp_cod_requisicao numeric, OUT vp_cod_operacao numeric, OUT vp_cod_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
-- Função responsável por realizar a autorização de uma Operação de Compra A Vista
-- Grava Operacão, se for autorizada
-- Realizar os lançamentos necessários
-- Obs: Essa função considera que o cartão só possui uma conta

DECLARE


  COD_RETORNO_SALDO_INSUFICIENTE numeric := 2;
  COD_RETORNO_SUCESSO numeric := 0;
  TIPO_OPERACAO_COMPRA_A_VISTA numeric := 25;
  SITUACAO_OPERACAO_AUTORIZADA numeric := 1;
  
  
  vl_cartao sc_opr.tbl_crt.cd_crt%type;
  vl_saldo_conta sc_cnt.tbl_cnt.vl_sld_cnt%type;
  
  vl_conta_debito sc_cnt.tbl_cnt.cd_cnt%type;
 
  vl_nr_lancamento sc_cnt.tbl_lcn.cd_lcn%type;
  
BEGIN

  select cd_crt
  into vl_cartao
  from sc_opr.tbl_pls
  where cd_pls = vp_plastico;
  
  select sc_cnt.get_saldo_cartao(vl_cartao,'S','S')
  into vl_saldo_conta;
  
  if(vl_saldo_conta >= vp_valor) then

    select nextval('sc_opr.sq_opr')
    into vp_cod_operacao;
    
  
    -- Gravando operacao de compra a vista
    insert into sc_opr.tbl_opr(cd_opr,cd_pls,cd_top,dt_opr,vl_opr,vl_jrs_opr,vl_trf_opr,nr_prc_opr,
                               vl_prc_opr,vl_iof_opr,nr_nsu_org_opr,st_opr,cd_fet)
                values(vp_cod_operacao,vp_plastico,TIPO_OPERACAO_COMPRA_A_VISTA,now(),vp_valor,
                       0,0,1,vp_valor,0,vp_cod_requisicao,SITUACAO_OPERACAO_AUTORIZADA,vp_filial_estabelecimento);

                       
                       
    -- Obtendo conta do cartão para realizar o débito
    select c.cd_cnt
    into strict vl_conta_debito
    from sc_opr.tbl_cnt_crt c
    where c.cd_crt = vl_cartao;

    -- bloqueando o saldo do cartao para realizar o debito na confirmacao
    perform sc_cnt.bloqueio_saldo_conta(vl_conta_debito::numeric,7::numeric,vp_valor::numeric);  


      begin
        -- caso haja problema no envio do sms NAO criticar a autorizacao
        perform sc_msg.enviar_mensagem_operacao_compra(vp_cod_operacao);

      exception when others then

      end;
      

        
    vp_cod_retorno := COD_RETORNO_SUCESSO;               
  else
    vp_cod_retorno := COD_RETORNO_SALDO_INSUFICIENTE;  
  end if;
  

END;
$$;


ALTER FUNCTION sc_rdc.tr_aut_compra_debito_rdc(vp_plastico numeric, vp_valor double precision, vp_filial_estabelecimento numeric, vp_cod_requisicao numeric, OUT vp_cod_operacao numeric, OUT vp_cod_retorno numeric) OWNER TO scan;

--
-- TOC entry 1828 (class 1255 OID 1015025)
-- Name: tr_aut_saque_debito_rdc(numeric, double precision, numeric, numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION tr_aut_saque_debito_rdc(vp_plastico numeric, vp_valor double precision, vp_filial_estabelecimento numeric, vp_cod_requisicao numeric, OUT vp_cod_operacao numeric, OUT vp_cod_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$
-- Função responsável por realizar a autorização de uma Operação de Compra A Vista
-- Grava Operacão, se for autorizada
-- Realizar os lançamentos necessários
-- Obs: Essa função considera que o cartão só possui uma conta

DECLARE

  TIPO_OPERACAO_SAQUE_DEBITO numeric := 4;
  SITUACAO_OPERACAO_AUTORIZADA numeric := 1;
  
  COD_RETORNO_SALDO_INSUFICIENTE numeric := 51;
  COD_RETORNO_SUCESSO numeric := 0;
  
  vl_cartao sc_opr.tbl_crt.cd_crt%type;
  vl_saldo_conta sc_cnt.tbl_cnt.vl_sld_cnt%type;
  vl_conta_debito sc_cnt.tbl_cnt.cd_cnt%type;
  vl_nr_lancamento sc_cnt.tbl_lcn.cd_lcn%type;
  
BEGIN
   
  select crt.cd_crt
    into vl_cartao
  from sc_opr.tbl_pls pls
    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
    
  where cd_pls = vp_plastico;

  select sc_cnt.get_saldo_cartao_sem_bloqueio(vl_cartao,Array[9],'S')
  into vl_saldo_conta;
  
  if(vl_saldo_conta >= vp_valor) then

    select nextval('sc_opr.sq_opr')
    into vp_cod_operacao;
    
  
    -- Gravando operacao de compra a vista
    insert into sc_opr.tbl_opr(cd_opr,cd_pls,cd_top,dt_opr,vl_opr,vl_jrs_opr,vl_trf_opr,nr_prc_opr,
                               vl_prc_opr,vl_iof_opr,nr_nsu_org_opr,st_opr,cd_fet)
                values(vp_cod_operacao,vp_plastico,TIPO_OPERACAO_SAQUE_DEBITO,now(),vp_valor,
                       0,0,1,vp_valor,0,vp_cod_requisicao,SITUACAO_OPERACAO_AUTORIZADA,vp_filial_estabelecimento);
                       
    -- Obtendo conta do cartão para realizar o débito
    select c.cd_cnt
    into strict vl_conta_debito
    from sc_opr.tbl_cnt_crt c
    where c.cd_crt = vl_cartao;
                       
    -- bloqueando o saldo do cartao para realizar o debito na confirmacao
    perform sc_cnt.bloqueio_saldo_conta(vl_conta_debito::numeric,7::numeric,vp_valor::numeric);    
    
        
    vp_cod_retorno := COD_RETORNO_SUCESSO;               
  else
    vp_cod_retorno := COD_RETORNO_SALDO_INSUFICIENTE;  
  end if;
  

END;
$$;


ALTER FUNCTION sc_rdc.tr_aut_saque_debito_rdc(vp_plastico numeric, vp_valor double precision, vp_filial_estabelecimento numeric, vp_cod_requisicao numeric, OUT vp_cod_operacao numeric, OUT vp_cod_retorno numeric) OWNER TO scan;

--
-- TOC entry 1731 (class 1255 OID 1013022)
-- Name: tr_cancela_compra_rdc(numeric, numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION tr_cancela_compra_rdc(vp_cod_requisicao numeric, vp_nsu_autorizador numeric, OUT vp_operacao numeric, OUT vp_cod_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
  TIPO_REQUISICAO_AUT_COMPRA_DEBITO numeric := 1;
  TIPO_REQUISICAO_CONFIRMA_COMPRA  numeric := 2;
  TIPO_REQUISICAO_DESFAZ_COMPRA  numeric := 3;
  TIPO_REQUISICAO_AUT_COMPRA_CREDITO  numeric := 4;
  TIPO_REQUISICAO_SAQUE_DEBITO  numeric := 10;
  TIPO_REQUISICAO_SAQUE_CREDITO  numeric := 11;
  TIPO_REQUISICAO_PGTO_FATURA  numeric := 12;

  TIPO_OPERACAO_CANCELAMENTO numeric := 26;
  SITUACAO_OPERACAO_AUTORIZADA sc_opr.tbl_opr.st_opr%type := 1;
  SITUACAO_OPERACAO_CONFIRMADA sc_opr.tbl_opr.st_opr%type := 2;
  SITUACAO_OPERACAO_CANCELADA sc_opr.tbl_opr.st_opr%type := 3;
  SITUACAO_OPERACAO_DESFEITA sc_opr.tbl_opr.st_opr%type := 4;

  COD_RETORNO_SUCESSO numeric := 0;
  COD_RETORNO_TRANSACAO_INEXISTENTE numeric := 4;
  

  vl_operacao_pai sc_opr.tbl_opr.cd_opr%type;
  vl_situacao_operacao sc_opr.tbl_opr.st_opr%type;
  vl_cd_crt sc_opr.tbl_pls.cd_crt%type;
  vl_operacao sc_opr.tbl_opr.vl_opr%type;
  vl_data_operacao timestamp;
  vl_codigo_estabelecimento numeric;
  vl_tipo_requisicao numeric;
  vl_conta_cartao numeric;
  vl_cod_equipamento numeric;
  vl_plastico numeric;
  
begin

    vp_cod_retorno := COD_RETORNO_SUCESSO; 

    select opr.cd_opr, opr.st_opr, opr.vl_opr, opr.dt_opr, pls.cd_crt, pls.cd_pls, rqs.tp_rqs, opr.cd_fet
    into vl_operacao_pai, vl_situacao_operacao, vl_operacao, vl_data_operacao, vl_cd_crt, vl_plastico, vl_tipo_requisicao, vl_codigo_estabelecimento
    from sc_opr.tbl_opr opr
      inner join sc_rdc.tbl_rqs rqs on rqs.cd_opr = opr.cd_opr
      inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
      inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
    where rqs.cd_rqs = vp_nsu_autorizador;

    -- se operacao ja foi cancelada
    if vl_situacao_operacao = SITUACAO_OPERACAO_CANCELADA then
      vp_operacao := vl_operacao_pai;
      return;
    end if;


    if vl_operacao_pai is null then
       vp_cod_retorno := COD_RETORNO_TRANSACAO_INEXISTENTE;
    end if ; 

    if vp_cod_retorno = COD_RETORNO_SUCESSO then

          select nextval('sc_opr.sq_opr')
          into vp_operacao;
          
	     -- Gravando operacao de cancelamento
  	     insert into sc_opr.tbl_opr(cd_opr,cd_pls,cd_top,dt_opr,vl_opr,vl_jrs_opr,vl_trf_opr,nr_prc_opr,
			       vl_prc_opr,vl_iof_opr,nr_nsu_org_opr,st_opr,cd_fet,cd_pai_opr)
		values(vp_operacao,vl_plastico,TIPO_OPERACAO_CANCELAMENTO,now(),vl_operacao,
		       0,0,0,vl_operacao,0,vp_cod_requisicao,SITUACAO_OPERACAO_AUTORIZADA,vl_codigo_estabelecimento,vl_operacao_pai);
		       		
      end if;
end$$;


ALTER FUNCTION sc_rdc.tr_cancela_compra_rdc(vp_cod_requisicao numeric, vp_nsu_autorizador numeric, OUT vp_operacao numeric, OUT vp_cod_retorno numeric) OWNER TO scan;

--
-- TOC entry 1734 (class 1255 OID 1013054)
-- Name: tr_confirma_cancelamento_compra_rdc(numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION tr_confirma_cancelamento_compra_rdc(vp_nsu_autorizador numeric, OUT vp_operacao numeric, OUT vp_cod_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare

   SITUACAO_OPERACAO_CONFIRMADA numeric := 2;
   SITUACAO_OPERACAO_CANCELADA  numeric := 3;


   TIPO_OPER_COMPRA_DEBITO numeric := 25;
   TIPO_OPER_COMPRA_CREDITO_AVISTA numeric := 27;
   TIPO_LANCAMENTO_ESTORNO_COMPRA numeric := 1447;

   vl_situacao_operacao numeric;
   COD_RETORNO_TRANSACAO_INEXISTENTE numeric := 4;

   vl_operacao_pai numeric;  
   vl_cd_crt numeric;
   vl_operacao numeric;
   vl_tipo_operacao numeric;
   vl_valor_operacao numeric;
   vl_conta_estabelecimento numeric;
   vl_conta_debito numeric;
   vl_credito numeric;
begin

    vp_cod_retorno := 0;
    
    select opr.cd_opr, opr.st_opr, opr.cd_pai_opr, pls.cd_crt, opr.vl_opr, opr_p.cd_top, etb.cd_cnt, opr.vl_opr
    into vp_operacao, vl_situacao_operacao, vl_operacao_pai, vl_cd_crt, vl_operacao, vl_tipo_operacao, vl_conta_estabelecimento, vl_valor_operacao
    from sc_opr.tbl_opr opr
      inner join sc_rdc.tbl_rqs rqs on rqs.cd_opr = opr.cd_opr
      inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
      inner join sc_opr.tbl_opr opr_p on opr_p.cd_opr = opr.cd_pai_opr
      inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
      inner join sc_rdc.tbl_etb etb on etb.cd_etb = fet.cd_etb
    where rqs.cd_rqs = vp_nsu_autorizador;

    if vp_operacao is null then
       vp_cod_retorno := COD_RETORNO_TRANSACAO_INEXISTENTE;
    end if;

    if vp_cod_retorno = 0 then

	    if vl_situacao_operacao <> SITUACAO_OPERACAO_CONFIRMADA then

	      update sc_opr.tbl_opr set st_opr = SITUACAO_OPERACAO_CONFIRMADA where cd_opr = vp_operacao;

              update sc_opr.tbl_opr set st_opr = SITUACAO_OPERACAO_CANCELADA where cd_opr = vl_operacao_pai;

	      if vl_tipo_operacao = TIPO_OPER_COMPRA_DEBITO then

		      -- Obtendo conta do cartão para realizar o débito
		      select c.cd_cnt
		      into strict vl_conta_debito
		      from sc_opr.tbl_cnt_crt c
		      where c.cd_crt = vl_cd_crt;

		      perform sc_cnt.lancar_debito_credito(vl_conta_estabelecimento,vl_conta_debito, TIPO_LANCAMENTO_ESTORNO_COMPRA, null, 'REF A ESTORN DE COMPRA A VISTA OPERACAO '||vp_operacao, vl_valor_operacao, now()::timestamp, 1, 1:: numeric, vp_operacao::numeric);
	      elsif vl_tipo_operacao = TIPO_OPER_COMPRA_CREDITO_AVISTA then

	         select vl_crd_opr
	         into vl_credito
	         from sc_opr.tbl_opr
	         where cd_opr = vl_operacao_pai; 

	         if (vl_valor_operacao - coalesce(vl_credito,0)) > 0 then
		      -- Obtendo conta do cartão para realizar o débito
		      select c.cd_cnt
		      into strict vl_conta_debito
		      from sc_opr.tbl_cnt_crt c
		      where c.cd_crt = vl_cd_crt;

		      perform sc_cnt.lancar_debito_credito(vl_conta_estabelecimento,vl_conta_debito, TIPO_LANCAMENTO_ESTORNO_COMPRA, null, 'REF A ESTORN DE COMPRA A VISTA OPERACAO '||vp_operacao, vl_valor_operacao - coalesce(vl_credito,0), now()::timestamp, 1, 1:: numeric, vp_operacao::numeric);
	         end if;

	         if coalesce(vl_credito,0) > 0 then
		    update sc_opr.tbl_lmt
		    set vl_utl_lmt = coalesce(vl_utl_lmt,0) - vl_credito
		    where cd_crt = vl_cd_crt
		      and cd_tlt = 2;
	         end if;

	      
	      else
	         raise exception 'TIPO DE OPERACAO NAO PERMITIDA';
	      end if;	      
	      
							    
            end if;	      

    end if;	    

      
end$$;


ALTER FUNCTION sc_rdc.tr_confirma_cancelamento_compra_rdc(vp_nsu_autorizador numeric, OUT vp_operacao numeric, OUT vp_cod_retorno numeric) OWNER TO scan;

--
-- TOC entry 1435 (class 1255 OID 564511)
-- Name: tr_confirma_compra(numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION tr_confirma_compra(vp_requisicao numeric, OUT vp_operacao numeric, OUT vp_cod_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare

   SITUACAO_OPERACAO_CONFIRMADA numeric := 2;
   
begin

    select cd_opr
    into vp_operacao
    from sc_rdc.tbl_rqs 
    where cd_rqs = vp_requisicao;

    update sc_opr.tbl_opr set st_opr = SITUACAO_OPERACAO_CONFIRMADA where cd_opr = vp_operacao;

    vp_cod_retorno := 0;
      
end$$;


ALTER FUNCTION sc_rdc.tr_confirma_compra(vp_requisicao numeric, OUT vp_operacao numeric, OUT vp_cod_retorno numeric) OWNER TO scan;

--
-- TOC entry 1755 (class 1255 OID 1012221)
-- Name: tr_confirma_compra_rdc(numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION tr_confirma_compra_rdc(vp_nsu_autorizador numeric, OUT vp_operacao numeric, OUT vp_cod_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare

  SITUACAO_OPERACAO_CONFIRMADA numeric := 2;
  SITUACAO_OPERACAO_AUTORIZADA numeric := 1;

  vl_situacao_operacao numeric;
  vl_tipo_operacao numeric;
  vl_cartao numeric;
  vl_conta_estabelecimento numeric;
  COD_RETORNO_TRANSACAO_INEXISTENTE numeric := 4;
  TIPO_LANCAMENTO_COMPRA_A_VISTA numeric := 1446;
  TIPO_LANCAMENTO_SAQUE numeric := 13;

  TIPO_OPERACAO_COMPRA_A_VISTA numeric := 25;
  TIPO_OPERACAO_COMPRA_CREDITO_AVISTA numeric := 27;
  TIPO_OPERACAO_SAQUE_A_DEBITO numeric := 4;

  vl_conta_debito numeric;
  vl_valor numeric;

  vl_credito numeric;
  
begin

    vp_cod_retorno := 0;
    
    select opr.cd_opr, opr.st_opr, opr.cd_top, pls.cd_crt,etb.cd_cnt, opr.vl_opr, opr.vl_crd_opr 
    into vp_operacao, vl_situacao_operacao, vl_tipo_operacao,vl_cartao, vl_conta_estabelecimento, vl_valor, vl_credito
    from sc_opr.tbl_opr opr
      inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
      inner join sc_rdc.tbl_fet fet on fet.cd_fet = opr.cd_fet
      inner join sc_rdc.tbl_etb etb on etb.cd_etb = fet.cd_etb
      inner join sc_rdc.tbl_rqs rqs on rqs.cd_opr = opr.cd_opr
    where rqs.cd_rqs = vp_nsu_autorizador;
    
    if vp_operacao is null then
       vp_cod_retorno := COD_RETORNO_TRANSACAO_INEXISTENTE;
    end if;

    if vp_cod_retorno = 0 then

	    if vl_situacao_operacao = SITUACAO_OPERACAO_AUTORIZADA then

	      update sc_opr.tbl_opr set st_opr = SITUACAO_OPERACAO_CONFIRMADA where cd_opr = vp_operacao;

	      if vl_tipo_operacao = TIPO_OPERACAO_COMPRA_A_VISTA then

		    -- Obtendo conta do cartão para realizar o débito
		    select c.cd_cnt
		    into strict vl_conta_debito
		    from sc_opr.tbl_cnt_crt c
		    where c.cd_crt = vl_cartao;

		    perform sc_cnt.desbloqueio_saldo_conta(vl_conta_debito::numeric,7::numeric,vl_valor::numeric);    
		    perform sc_cnt.lancar_debito_credito(vl_conta_debito, vl_conta_estabelecimento, TIPO_LANCAMENTO_COMPRA_A_VISTA, null, 'REF A COMPRA A VISTA OPERACAO '||vp_operacao, vl_valor, now()::timestamp, 1, 1:: numeric, vp_operacao::numeric);
		    
               elsif vl_tipo_operacao = TIPO_OPERACAO_SAQUE_A_DEBITO then

		    select c.cd_cnt
		    into strict vl_conta_debito
		    from sc_opr.tbl_cnt_crt c
		    where c.cd_crt = vl_cartao;

		    perform sc_cnt.desbloqueio_saldo_conta(vl_conta_debito::numeric,7::numeric,vl_valor::numeric);    
		    perform sc_cnt.lancar_debito_credito(vl_conta_debito, vl_conta_estabelecimento, TIPO_LANCAMENTO_SAQUE, null, 'REF A SAQUE A VISTA OPERACAO '||vp_operacao, vl_valor, now()::timestamp, 1, 1:: numeric, vp_operacao::numeric);

	       elsif vl_tipo_operacao = TIPO_OPERACAO_COMPRA_CREDITO_AVISTA then

	            if vl_valor - coalesce(vl_credito,0) > 0 then
	            
		       -- Obtendo conta do cartão para realizar o débito
		       select c.cd_cnt
		       into strict vl_conta_debito
		       from sc_opr.tbl_cnt_crt c
		       where c.cd_crt = vl_cartao;
	            
		       perform sc_cnt.desbloqueio_saldo_conta(vl_conta_debito::numeric,7::numeric,(vl_valor - coalesce(vl_credito,0))::numeric);
		       perform sc_cnt.lancar_debito_credito(vl_conta_debito, vl_conta_estabelecimento, TIPO_LANCAMENTO_COMPRA_A_VISTA, null, 'REF A COMPRA A VISTA OPERACAO '||vp_operacao, vl_valor - coalesce(vl_credito,0), now()::timestamp, 1, 1:: numeric, vp_operacao::numeric);
	            end if;
                    	            
	       else
		   raise exception 'TIPO DE OPERACAO NAO LIBERADA PARA SOMA CONTA DIGITAL';
	       end if;		    

	      end if;
	      
    end if;	    

      
end$$;


ALTER FUNCTION sc_rdc.tr_confirma_compra_rdc(vp_nsu_autorizador numeric, OUT vp_operacao numeric, OUT vp_cod_retorno numeric) OWNER TO scan;

--
-- TOC entry 1696 (class 1255 OID 564512)
-- Name: tr_desfaz_compra(numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION tr_desfaz_compra(vp_requisicao numeric, OUT vp_operacao numeric, OUT vp_cod_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare

  CT_CONTA_CREDITO_RECARGA numeric := 19446;
  SITUACAO_OPERACAO_AUTORIZADA sc_opr.tbl_opr.st_opr%type := 1;
  SITUACAO_OPERACAO_DESFEITA sc_opr.tbl_opr.st_opr%type := 4;

  COD_RETORNO_SUCESSO numeric := 0;

  TIPO_LANCAMENTO_ESTORNO_COMPRA_A_VISTA numeric := 1001;

  vl_situacao_operacao sc_opr.tbl_opr.st_opr%type;
  
  vl_nr_lancamento sc_cnt.tbl_lcn.cd_lcn%type;

  vl_conta_debito sc_cnt.tbl_cnt.cd_cnt%type;

  vl_operacao sc_opr.tbl_opr.vl_opr%type;
  vl_data_operacao timestamp;
begin

    select opr.cd_opr,opr.st_opr,cnt.cd_cnt,opr.vl_opr,opr.dt_opr
    into vp_operacao,vl_situacao_operacao,vl_conta_debito, vl_operacao, vl_data_operacao
    from sc_rdc.tbl_rqs rqs
       inner join sc_opr.tbl_opr opr on opr.cd_opr = rqs.cd_opr
       inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
       inner join sc_opr.tbl_cnt_crt cnt on cnt.cd_crt = pls.cd_crt
    where rqs.cd_rqs = vp_requisicao;

    if( vl_situacao_operacao = SITUACAO_OPERACAO_AUTORIZADA ) then

	update sc_opr.tbl_opr set st_opr = SITUACAO_OPERACAO_DESFEITA where cd_opr = vp_operacao;
	
        perform sc_cnt.lancar_debito_credito(CT_CONTA_CREDITO_RECARGA, vl_conta_debito, TIPO_LANCAMENTO_ESTORNO_COMPRA_A_VISTA, null, 'REF A COMPRA A VISTA OPERACAO '||vp_operacao, vl_operacao, vl_data_operacao::timestamp, 1, 3::numeric, vp_operacao::numeric);
        
--	perform sc_cnt.lancar_movimento(vl_nr_lancamento, null, TIPO_LANCAMENTO_ESTORNO_COMPRA_A_VISTA, vl_conta_debito, 'C', vl_operacao, vl_data_operacao::timestamp, 1::numeric, null, 'REF A COMPRA A VISTA OPERACAO '||vp_operacao, 1::numeric, 1::numeric);
        
    end if;

    vp_cod_retorno := COD_RETORNO_SUCESSO; 

end$$;


ALTER FUNCTION sc_rdc.tr_desfaz_compra(vp_requisicao numeric, OUT vp_operacao numeric, OUT vp_cod_retorno numeric) OWNER TO scan;

--
-- TOC entry 1296 (class 1255 OID 1012448)
-- Name: tr_desfaz_compra_rdc(numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION tr_desfaz_compra_rdc(vp_requisicao numeric, OUT vp_operacao numeric, OUT vp_cod_retorno numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare

  CT_CONTA_CREDITO_RECARGA numeric := 19446;
  SITUACAO_OPERACAO_AUTORIZADA sc_opr.tbl_opr.st_opr%type := 1;
  SITUACAO_OPERACAO_DESFEITA sc_opr.tbl_opr.st_opr%type := 4;


  TIPO_OPERACAO_SAQUE numeric := 4;
  TIPO_OPERACAO_COMPRA_A_VISTA numeric := 25;
  TIPO_OPERACAO_COMPRA_CREDITO_AVISTA numeric := 27;
  TIPO_OPERACAO_ESTORNO numeric := 26;

  COD_RETORNO_SUCESSO numeric := 0;

  TIPO_LANCAMENTO_ESTORNO_COMPRA_A_VISTA numeric := 1001;

  vl_situacao_operacao sc_opr.tbl_opr.st_opr%type;
  
  vl_nr_lancamento sc_cnt.tbl_lcn.cd_lcn%type;

  vl_conta_debito sc_cnt.tbl_cnt.cd_cnt%type;

  vl_operacao sc_opr.tbl_opr.vl_opr%type;
  vl_data_operacao timestamp;
  vl_tipo_operacao numeric;
  vl_credito numeric;
  vl_cartao numeric;
begin

    select opr.cd_opr,opr.st_opr,cnt.cd_cnt,opr.vl_opr,opr.dt_opr, opr.cd_top,opr.vl_crd_opr, pls.cd_crt
    into vp_operacao,vl_situacao_operacao,vl_conta_debito, vl_operacao, vl_data_operacao,vl_tipo_operacao, vl_credito, vl_cartao
    from sc_rdc.tbl_rqs rqs
       inner join sc_opr.tbl_opr opr on opr.cd_opr = rqs.cd_opr
       inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
       inner join sc_opr.tbl_cnt_crt cnt on cnt.cd_crt = pls.cd_crt
    where rqs.cd_rqs = vp_requisicao;

    if( vl_situacao_operacao = SITUACAO_OPERACAO_AUTORIZADA ) then

	update sc_opr.tbl_opr set st_opr = SITUACAO_OPERACAO_DESFEITA where cd_opr = vp_operacao;

        if vl_tipo_operacao = TIPO_OPERACAO_COMPRA_A_VISTA then 
        
	    perform sc_cnt.desbloqueio_saldo_conta(vl_conta_debito::numeric,7::numeric,vl_operacao::numeric); 
	    
	elsif vl_tipo_operacao = TIPO_OPERACAO_COMPRA_CREDITO_AVISTA or vl_tipo_operacao = TIPO_OPERACAO_SAQUE then
	
	    perform sc_cnt.desbloqueio_saldo_conta(vl_conta_debito::numeric,7::numeric,(coalesce(vl_operacao,0) - coalesce(vl_credito,0))::numeric);   
	    
	    if coalesce(vl_credito,0) > 0 then
	        update sc_opr.tbl_lmt set vl_utl_lmt = vl_utl_lmt - vl_credito where cd_tlt = 2 and cd_crt = vl_cartao;
	    end if;
	    
	elsif vl_tipo_operacao <> TIPO_OPERACAO_ESTORNO then
	    raise exception 'TIPO DE OPERACAO NAO CONFIGURADA PARA SOMA CONTA DIGITAL';    
	end if;    
                
    end if;

    vp_cod_retorno := COD_RETORNO_SUCESSO; 

end$$;


ALTER FUNCTION sc_rdc.tr_desfaz_compra_rdc(vp_requisicao numeric, OUT vp_operacao numeric, OUT vp_cod_retorno numeric) OWNER TO scan;

--
-- TOC entry 1836 (class 1255 OID 1027087)
-- Name: transfererir_repasse(); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION transfererir_repasse() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  vl_codigo_conta_bancaria numeric;
  vl_codigo_fornecedor numeric;

  vl_cun_transf numeric;
  vl_banco_transf numeric;
  vl_agencia_transf numeric;
  vl_conta_transf numeric;
  vl_dg_conta_transf varchar;
  vl_cpf_cnpj_transf numeric;
  vl_tp_pss_transf varchar;
  vl_nome_transf  varchar;

  vl_qtd_matriz numeric;
  vl_transferencia numeric;

  vl_minimo_transferencia numeric := 0;
  
begin

   for rg in select *
             from sc_rdc.tbl_etb loop
 
      select count(*)
      into vl_qtd_matriz
      from sc_rdc.tbl_fet
      where cd_etb = rg.cd_etb
        and fg_mtz_fet = 'S';

      if vl_qtd_matriz > 1 then
        raise exception 'ESTABELECIMENTO POSSUI MAIS DE UMA FILIAL MATRIZ: %',rg.cd_etb;
      end if;  

      select sum(cnt.vl_sld_cnt)
      into vl_transferencia
      from sc_rdc.tbl_fet fet
        inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = fet.cd_cnt
      where cnt.vl_sld_cnt > 0  
        and fet.cd_etb = rg.cd_etb;

      if vl_transferencia > vl_minimo_transferencia  then

         if vl_qtd_matriz = 0 and rg.fg_dbc_mtz_etb = 'S' then
           raise exception 'ESTABELECIMENTO NAO POSSUI MATRIZ: %',rg.cd_etb;
         end if;
      
         perform sc_rdc.transfererir_repasse_matriz(rg.cd_etb);
      end if;
             
   end loop;          

end$$;


ALTER FUNCTION sc_rdc.transfererir_repasse() OWNER TO scan;

--
-- TOC entry 1418 (class 1255 OID 1042807)
-- Name: transfererir_repasse_matriz(numeric); Type: FUNCTION; Schema: sc_rdc; Owner: scan
--

CREATE FUNCTION transfererir_repasse_matriz(vp_codigo_estabelecimento numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  vl_codigo_conta_bancaria numeric;
  vl_codigo_fornecedor numeric;

  vl_cun_transf numeric;
  vl_banco_transf numeric;
  vl_agencia_transf numeric;
  vl_conta_transf numeric;
  vl_dg_conta_transf varchar;
  vl_cpf_cnpj_transf numeric;
  vl_tp_pss_transf varchar;
  vl_nome_transf  varchar;
  
begin

    if( not sc_grl.eh_dia_util(CURRENT_DATE)) then
       return ;
    end if;   


   for rg in select cnt.vl_sld_cnt,
                    cnt.cd_cnt,
                    cun.nm_cun,
                    cun.tp_pss_cun,
                    cun.nr_cpf_cnpj_cun,
                    cun.cd_cun,
                    etb.fg_dbc_mtz_etb,
                    fet.*
             from sc_cnt.tbl_cnt cnt
               inner join sc_rdc.tbl_fet fet on fet.cd_cnt = cnt.cd_cnt
               inner join sc_rdc.tbl_etb etb on etb.cd_etb = fet.cd_etb
               inner join sc_cad.tbl_cun cun on cun.cd_cun = fet.cd_cun
             where fet.cd_etb = vp_codigo_estabelecimento 
               and cd_scn = 282 
               and cnt.vl_sld_cnt > 0 loop

      vl_codigo_fornecedor := null;         
      vl_codigo_conta_bancaria := null;
      vl_cun_transf := null;
      vl_banco_transf := null;
      vl_agencia_transf := null;
      vl_conta_transf := null;
      vl_dg_conta_transf := null;
      vl_cpf_cnpj_transf := null;
      vl_tp_pss_transf := null;
      vl_nome_transf := null;

      select c.cd_cun,
             cd_bnc_fet,
             cd_agn_fet,
             nr_cc_fet,
             dg_cc_fet,
             c.nr_cpf_cnpj_cun,
             c.tp_pss_cun,
             c.nm_cun
      into vl_cun_transf,
           vl_banco_transf,
           vl_agencia_transf,
           vl_conta_transf,
           vl_dg_conta_transf,
           vl_cpf_cnpj_transf,
           vl_tp_pss_transf,
           vl_nome_transf      
      from sc_rdc.tbl_fet f
        inner join sc_cad.tbl_cun c on c.cd_cun = f.cd_cun
      where cd_etb = rg.cd_etb
        and ((fg_mtz_fet = 'S' and rg.fg_dbc_mtz_etb = 'S') or (rg.fg_dbc_mtz_etb = 'N' and f.cd_fet = rg.cd_fet));

      if vl_cun_transf is null then
         raise exception 'NAO FOI POSSIVEL IDENTIFICAR O DOMICILIO BANCARIO. ESTAB:%,FILIAL:%',rg.cd_etb,rg.cd_fet;
      end if;
      
      
      select cd_cbf
      into vl_codigo_conta_bancaria
      from sc_cad.tbl_cbf cbf
      where cd_cun = vl_cun_transf
        and cbf.cd_bnc = vl_banco_transf
        and cbf.nr_agc_cbf = vl_agencia_transf
        and cbf.nr_cba_cbf = vl_conta_transf
        and cbf.fg_atv_cbf = 'S';

      if vl_codigo_conta_bancaria is null then
      
        select nextval('sc_cad.sq_cbf') into vl_codigo_conta_bancaria;
        
        insert into sc_cad.tbl_cbf(cd_cbf,cd_bnc,nr_agc_cbf,nr_dgt_agc_cbf,nr_cba_cbf,nr_dgt_cba_cbf,tp_cba_cbf,fg_atv_cbf,nr_cpf_cnpj_cbf,tp_pss_cbf,nm_cbf,pc_dps_cbf,cd_inc_usr,dt_inc_usr,cd_cun)
         values(vl_codigo_conta_bancaria,vl_banco_transf,vl_agencia_transf,0,vl_conta_transf,vl_dg_conta_transf,1,'S',vl_cpf_cnpj_transf,vl_tp_pss_transf,vl_nome_transf,0,1,now(),vl_cun_transf);
         
      end if;

      
      insert into sc_atb.tbl_tba(cd_tba, cd_ccr, cd_bnc, nr_agc_tba, nr_dgt_agc_tba, nr_cba_tba, nr_dgt_cba_tba, nr_cpf_cnpj_tba,
			     nm_tba, tp_pss_tba, cd_sst, nr_nsu_org_tba, cd_dbt_cnt, cd_crd_cnt, ds_mtv_cad_tba,
			     vl_tba, vl_trf_tba, tp_cba_tba, cd_inc_usr, dt_inc_usr)
      values (nextval('sc_atb.sq_tba'), 6, vl_banco_transf, vl_agencia_transf, 0, vl_conta_transf, vl_dg_conta_transf, vl_cpf_cnpj_transf,
	      vl_nome_transf, vl_tp_pss_transf, 34, rg.cd_fet, rg.cd_cnt,469, 'REF A TRANSFERENCIA AUTOMATICA PARA ESTAB CREDENCIADO '||rg.nm_fet,
	      rg.vl_sld_cnt, 0, 1, 1, now());

     perform sc_cnt.lancar_debito_credito(rg.cd_cnt, 5751, 93,
                                        null, 'TRANSFERENCIA AUTOMATICA', rg.vl_sld_cnt, current_timestamp::timestamp without time zone,
                                       1, 11, currval('sc_atb.sq_tba'));

   end loop;    


end$$;


ALTER FUNCTION sc_rdc.transfererir_repasse_matriz(vp_codigo_estabelecimento numeric) OWNER TO scan;

SET search_path = sc_rds, pg_catalog;

--
-- TOC entry 1766 (class 1255 OID 564513)
-- Name: alerta_sem_comunicacao(); Type: FUNCTION; Schema: sc_rds; Owner: scan
--

CREATE FUNCTION alerta_sem_comunicacao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  cd_st_alt_aberto numeric := 1;
  cd_st_alt_aguardando_info numeric := 3; 
  cd_tal_sem_comunicacao numeric := 1;

  vl_cd_tms numeric := 6;
  vl_ddd_msg numeric := 85;

  vl_numeros varchar;

  rg_atm record;
  rg_celular record;
  rg_alt record;

  PRM_NR_CELULAR_ALERTA_ATM sc_cad.tbl_prm.nm_prm%type := 'NR_CELULAR_ALERTA_ATM';

begin

  if(to_char(current_timestamp,'hh24')::numeric > 6 and to_char(current_timestamp,'hh24')::numeric < 22) then
  
	  select vl_prm
	  into vl_numeros
	  from sc_cad.tbl_prm 
	  where nm_prm = PRM_NR_CELULAR_ALERTA_ATM; 

	  --ALTERANDO OS ALERTA EM ABERTO CUJO ATM JÁ VOLTOU
	  for rg_alt in SELECT alt.*
			FROM sc_rds.tbl_alt alt
			  inner join sc_rds.tbl_atm atm on atm.cd_atm = alt.cd_atm
			where st_alt = cd_st_alt_aberto
			  and atm.dt_ult_atu_atm > alt.dt_inc_usr loop

	     update sc_rds.tbl_alt set st_alt = cd_st_alt_aguardando_info,dt_st_alt=now() where cd_alt = rg_alt.cd_alt;		  

			
	  end loop;		
			  

	  for rg_atm in select *
			from sc_rds.tbl_atm atm
			where atm.fg_atv_atm = 'S'
			  and now() - atm.dt_ult_atu_atm > interval '7 minutes' 
			  and est_atm <> 2
			  and not exists (select 1
					  from sc_rds.tbl_alt alt
					  where alt.cd_atm = atm.cd_atm
					    and alt.cd_tal = cd_tal_sem_comunicacao
					    and alt.st_alt = cd_st_alt_aberto) loop 
	  
		  insert into sc_rds.tbl_alt (cd_alt, cd_tal, cd_atm, st_alt, cd_inc_usr, dt_inc_usr)
		    values (nextval('sc_rds.sq_alt'), cd_tal_sem_comunicacao, rg_atm.cd_atm, cd_st_alt_aberto, 1, now());

		  for rg_celular in select celular.* 
				    from regexp_split_to_table(vl_numeros,';') as celular loop

		      insert into sc_msg.tbl_msg (cd_msg, cd_tms, ddd_msg, nr_msg, prm_msg, fg_atv_msg, fg_env_msg, cd_inc_usr, dt_inc_usr)
		    values (nextval('sc_msg.sq_msg'), vl_cd_tms, vl_ddd_msg, rg_celular.celular::numeric, rg_atm.nm_atm, 'S', 'N', 1, now());
	  
		  end loop;


	  end loop;

	  perform sc_msg.enviar_mensagem(6);
	  
    end if;
    
end;$$;


ALTER FUNCTION sc_rds.alerta_sem_comunicacao() OWNER TO scan;

--
-- TOC entry 1437 (class 1255 OID 564514)
-- Name: atualizar_valores_monitor(); Type: FUNCTION; Schema: sc_rds; Owner: scan
--

CREATE FUNCTION atualizar_valores_monitor() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  rg_vma record;
  
begin

   for rg_vma in select *
                 from sc_rds.tbl_vma loop
    
    execute 'update sc_rds.tbl_vma set vl_vma=('|| rg_vma.SQL_VMA ||'),dt_ult_atl_vma=now() where cd_vma='||rg_vma.cd_vma;
    
  end loop; 
   
end
$$;


ALTER FUNCTION sc_rds.atualizar_valores_monitor() OWNER TO scan;

--
-- TOC entry 1438 (class 1255 OID 564515)
-- Name: cancelar_abastecimento(numeric, numeric); Type: FUNCTION; Schema: sc_rds; Owner: scan
--

CREATE FUNCTION cancelar_abastecimento(vp_abastecimento numeric, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

ct_conta_tesouraria numeric  := 2;
ct_conta_numerario numeric := 3;

ct_sistema numeric := 6;
ct_tipo_lanc_estorno_aprovacao numeric := 4;
ct_tipo_lanc_estorno_alivio_finalizacao numeric := 12;

ct_sit_aprovado numeric := 2;
ct_sit_cancelado numeric := 3;
ct_sit_processado numeric := 4;
ct_sit_finalizado numeric := 5;
ct_sit_confirmado numeric := 6;

rg_abs sc_rds.tbl_abs%rowtype;

vl_lancamento numeric;
vl_nova_situacao numeric;
vl_conta_diferenca numeric;

begin


  select *
    into rg_abs
  from sc_rds.tbl_abs
  where cd_abs = vp_abastecimento;


  -- SE APROVADO
  if rg_abs.st_abs = ct_sit_aprovado then

    perform sc_cnt.lancar_debito_credito(ct_conta_tesouraria, ct_conta_numerario, ct_tipo_lanc_estorno_aprovacao, null, 'CANCELAMENTO DE APROVACAO ABASTECIMENTO NSU ' || rg_abs.cd_abs, rg_abs.vl_abs, rg_abs.dt_apr_abs, vp_usuario, ct_sistema, rg_abs.cd_abs);

    update sc_rds.tbl_abs set st_abs = ct_sit_cancelado, cd_cnc_usr = vp_usuario, cd_alt_usr = vp_usuario, dt_alt_usr = clock_timestamp() where cd_abs = rg_abs.cd_abs; 
    
  end if;
 

  -- SE PROCESSADO
  if rg_abs.st_abs = ct_sit_processado then
    
    raise exception 'Não é possível cancelar um abastecimento com situação PROCESSADO';

  end if;


  -- SE FINALIZADO
  if rg_abs.st_abs = ct_sit_finalizado then

    select cd_cnt_dif_atm
      into vl_conta_diferenca
    from sc_rds.tbl_atm
    where cd_atm = rg_abs.cd_atm;  
    

    -- caso o retorno seja igual ao processamento
    if rg_abs.vl_ret_fnl_abs = rg_abs.vl_ret_prc_abs then

       perform sc_cnt.lancar_debito_credito(ct_conta_numerario, ct_conta_tesouraria, ct_tipo_lanc_estorno_alivio_finalizacao, null, 'CANCELAMENTO DA FINALIZACAO ABASTECIMENTO NSU ' || rg_abs.cd_abs, rg_abs.vl_ret_fnl_abs, rg_abs.dt_fnz_abs, vp_usuario, ct_sistema, rg_abs.cd_abs);

    end if;

    -- caso a diferenca seja a MENOR
    if rg_abs.vl_ret_fnl_abs < rg_abs.vl_ret_prc_abs then 
  
       -- debitando o numerario em transito pelo valor processado
       select nr_lanc
       into vl_lancamento
       from sc_cnt.lancar_movimento(null, null, ct_tipo_lanc_estorno_alivio_finalizacao, ct_conta_numerario, 'D', rg_abs.vl_ret_prc_abs, rg_abs.dt_fnz_abs, vp_usuario, null, 'CANCELAMENTO DA FINALIZACAO ABASTECIMENTO NSU ' || rg_abs.cd_abs, ct_sistema, rg_abs.cd_abs);

       -- creditando a tesouraria pelo valor finalizado
       perform sc_cnt.lancar_movimento(null, vl_lancamento, ct_tipo_lanc_estorno_alivio_finalizacao, ct_conta_tesouraria, 'C', rg_abs.vl_ret_fnl_abs, rg_abs.dt_fnz_abs, vp_usuario, null, 'CANCELAMENTO DA FINALIZACAO ABASTECIMENTO NSU ' || rg_abs.cd_abs, ct_sistema, rg_abs.cd_abs);

       -- creditando a conta de diferenca pelo valor da diferenca a MENOR
       perform sc_cnt.lancar_movimento(null, vl_lancamento, ct_tipo_lanc_estorno_alivio_finalizacao, vl_conta_diferenca, 'C', rg_abs.vl_ret_prc_abs - rg_abs.vl_ret_fnl_abs, rg_abs.dt_fnz_abs, vp_usuario, null, 'CANCELAMENTO DA FINALIZACAO ABASTECIMENTO NSU ' || rg_abs.cd_abs, ct_sistema, rg_abs.cd_abs);

    end if;


    -- caso a diferenca seja a MAIOR
    if rg_abs.vl_ret_fnl_abs > rg_abs.vl_ret_prc_abs then 
  
       -- creditando a tesouraria pelo valor finalizado
       select nr_lanc
         into vl_lancamento
       from sc_cnt.lancar_movimento(null, null, ct_tipo_lanc_estorno_alivio_finalizacao, ct_conta_tesouraria, 'C', rg_abs.vl_ret_fnl_abs, rg_abs.dt_fnz_abs, vp_usuario, null, 'CANCELAMENTO DA FINALIZACAO ABASTECIMENTO NSU ' || rg_abs.cd_abs, ct_sistema, rg_abs.cd_abs);

       -- debitando o numerario pelo valor retirado
       perform sc_cnt.lancar_movimento(null, vl_lancamento, ct_tipo_lanc_estorno_alivio_finalizacao, ct_conta_numerario, 'D', rg_abs.vl_ret_prc_abs, rg_abs.dt_fnz_abs, vp_usuario, null, 'CANCELAMENTO DA FINALIZACAO ABASTECIMENTO NSU ' || rg_abs.cd_abs, ct_sistema, rg_abs.cd_abs);

       -- debitando a conta de diferenca pelo valor da diferenca a MAIOR
       perform sc_cnt.lancar_movimento(null, vl_lancamento, ct_tipo_lanc_estorno_alivio_finalizacao, vl_conta_diferenca, 'D', rg_abs.vl_ret_fnl_abs - rg_abs.vl_ret_prc_abs, rg_abs.dt_fnz_abs, vp_usuario, null, 'CANCELAMENTO DA FINALIZACAO ABASTECIMENTO NSU ' || rg_abs.cd_abs, ct_sistema, rg_abs.cd_abs);

    end if;

    update sc_rds.tbl_abs set st_abs = ct_sit_confirmado, cd_cnc_usr = vp_usuario, cd_alt_usr = vp_usuario, dt_alt_usr = clock_timestamp() where cd_abs = rg_abs.cd_abs;  
    
  end if;

end
$$;


ALTER FUNCTION sc_rds.cancelar_abastecimento(vp_abastecimento numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1705 (class 1255 OID 1004129)
-- Name: cancelar_saque_facil_expiradas(); Type: FUNCTION; Schema: sc_rds; Owner: scan
--

CREATE FUNCTION cancelar_saque_facil_expiradas() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
 
begin

  perform sc_job.executar_java_job('cancelarSaqueFacilExpirados', null);
  
   
end$$;


ALTER FUNCTION sc_rds.cancelar_saque_facil_expiradas() OWNER TO scan;

--
-- TOC entry 7867 (class 0 OID 0)
-- Dependencies: 1705
-- Name: FUNCTION cancelar_saque_facil_expiradas(); Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON FUNCTION cancelar_saque_facil_expiradas() IS 'Rotina que cancela os saque facil ja expirados';


--
-- TOC entry 1562 (class 1255 OID 881702)
-- Name: contabilizar_saque_facil(); Type: FUNCTION; Schema: sc_rds; Owner: scan
--

CREATE FUNCTION contabilizar_saque_facil() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg record;
  ct_fornecedor_pague_menos numeric := 286;
  ct_tipo_despesa_saque_facil numeric := 111;
  vl_saque numeric;
begin

  if not sc_grl.eh_dia_util(current_date) then
    return ;
  end if;

   select sum(sfc.vl_sfc)
   into vl_saque
   from sc_rds.tbl_sfc sfc
   where sfc.st_sfc = 3
     and dt_ctb_sfc is null;

   if coalesce(vl_saque,0) > 0 then  

      insert 
      into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp,cd_cbf)
      values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_pague_menos,ct_tipo_despesa_saque_facil,2,vl_saque,NOW(),NOW(),3,'REF A PAGAMENTO DE SAQUE FACIL REALIZADO',1,now(),1,1,1,vl_saque,7169);

      update sc_rds.tbl_sfc set dt_ctb_sfc=now() where st_sfc=3 and dt_ctb_sfc is null;
      
  end if;

end$$;


ALTER FUNCTION sc_rds.contabilizar_saque_facil() OWNER TO scan;

--
-- TOC entry 1546 (class 1255 OID 564516)
-- Name: fechanento_valores_atm(); Type: FUNCTION; Schema: sc_rds; Owner: scan
--

CREATE FUNCTION fechanento_valores_atm() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
begin
  
   -- calculando a disponibilidade
   perform sc_dsp.processar_variaveis(current_date - 1);
   --perform sc_dsp.processar_disponibilidade(current_date - 1);
   
   perform sc_rds.atualizar_valores_monitor();

   for rg in select *
             from sc_rds.tbl_vma loop
   
	   insert into sc_rds.tbl_fva(cd_fva, cd_vma, dt_fva, vl_fva) values(nextval('sc_rds.sq_fva'), rg.cd_vma, now(), rg.vl_vma);
   end loop;	   

   
end$$;


ALTER FUNCTION sc_rds.fechanento_valores_atm() OWNER TO scan;

--
-- TOC entry 1708 (class 1255 OID 1004571)
-- Name: gerar_plastico_operador(character varying, character varying); Type: FUNCTION; Schema: sc_rds; Owner: scan
--

CREATE FUNCTION gerar_plastico_operador(vp_nome_impresso character varying, vp_nome_operador character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg record;
  ct_fornecedor_pague_menos numeric := 286;
  ct_tipo_despesa_saque_facil numeric := 111;
  vl_saque numeric;

  vl_codigo_plastico numeric;
begin

   vl_codigo_plastico := sc_acc.gera_numero_plastico_operador();

   -- inserindo o registro
   insert into sc_rds.tbl_pop (cd_pop,dt_vld_pop,nm_snh_pop,nm_pop,ds_pop,nr_scc_pop,fg_blq_pop,cd_inc_usr,dt_inc_usr,fg_ems_pop,fg_snh_pop,cd_mpl) 
       values (vl_codigo_plastico,current_date + interval '2 year',
               sc_acc.gera_numero_aleatorio(4),vp_nome_impresso, vp_nome_operador,
               sc_acc.gera_numero_aleatorio(3),'S',1,now(),'N','S',3);

  -- atualizando a senha para os 4 ultimos numeros do plastico
  update sc_rds.tbl_pop set nm_snh_pop = SUBSTRING(cd_pop::text,13,4) where cd_pop = vl_codigo_plastico;

  -- solicitar emissao de plastico 
  perform sc_ssp.solicitar_emissao_plastico_senha_operador(vl_codigo_plastico);


end$$;


ALTER FUNCTION sc_rds.gerar_plastico_operador(vp_nome_impresso character varying, vp_nome_operador character varying) OWNER TO scan;

--
-- TOC entry 1432 (class 1255 OID 564517)
-- Name: mensagem_alerta_valida_senha(numeric); Type: FUNCTION; Schema: sc_rds; Owner: scan
--

CREATE FUNCTION mensagem_alerta_valida_senha(vp_plastico numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

  vl_msg_retorno varchar(15000);

  vl_qnt_dias_atraso_cartao numeric;
  vl_qnt_cartoes_fatura_aberto numeric;
  vl_cd_crt numeric;
  vl_nr_cpf_cnpj_cun numeric;
  vl_limite_saque_extra numeric;
begin

  select cun.nr_cpf_cnpj_cun, crt.cd_crt
    into vl_nr_cpf_cnpj_cun, vl_cd_crt
  from sc_opr.tbl_pls pls
    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
  where pls.cd_pls = vp_plastico;

  -- dados atualizados
  if sc_cad.valida_saque_extra(vp_plastico) = 'N' then
    select prm.vl_prm
      into vl_msg_retorno
    from sc_cad.tbl_prm prm
    where prm.nm_prm = 'MENSAGEM_SAQUE_EXTRA';

    return vl_msg_retorno;
  end if;

  -- quantidades de fatura em aberto de outros cartoes
  select prm.vl_prm
    into vl_qnt_dias_atraso_cartao
  from sc_cad.tbl_prm prm
  where prm.nm_prm = 'QT_DIAS_ATR_CRT';

  select count(*)
    into vl_qnt_cartoes_fatura_aberto
  from sc_opr.tbl_crt crt
    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
    inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
  where cun.nr_cpf_cnpj_cun = vl_nr_cpf_cnpj_cun
    and fcr.st_fcr = 1
    and crt.fg_atv_crt = 'N'
    and crt.cd_crt not in (vl_cd_crt)
    and (case when crt.dt_ini_atr_crt is null or crt.fg_ind_crt = 'N' then 0 else current_date - crt.dt_ini_atr_crt::date end) >= vl_qnt_dias_atraso_cartao;

  if vl_qnt_cartoes_fatura_aberto > 0 then
    select prm.vl_prm
      into vl_msg_retorno
    from sc_cad.tbl_prm prm
    where prm.nm_prm = 'MSG_ALERTA_FATURA_ATRASO';

    return vl_msg_retorno;
  end if;

  --estana campanha saque extra com cinquentao
  
  -- nunca fez uma operacao de saque extra

  vl_limite_saque_extra := 0;
  
  select 1
    into vl_limite_saque_extra
  from sc_opr.tbl_pls pls
    inner join sc_opr.tbl_lmt lmt on lmt.cd_crt = pls.cd_crt
    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
  where pls.cd_pls = vp_plastico
    and lmt.vl_cnc_lmt - lmt.vl_utl_lmt > 0
    and crt.cd_tvt = 3
    and sc_opr.autoriza_tipo_operacao_cartao(pls.cd_crt, 5) = true;

  vl_limite_saque_extra := coalesce(vl_limite_saque_extra,0);

  if vl_limite_saque_extra > 0 then
    return 'VOCÊ ACABOU DE GANHAR 50% DE DESCONTO NO SEU SAQUE EXTRA. SAQUE JÁ!';
  end if; 
  
  return 'N';

end;$$;


ALTER FUNCTION sc_rds.mensagem_alerta_valida_senha(vp_plastico numeric) OWNER TO scan;

--
-- TOC entry 7868 (class 0 OID 0)
-- Dependencies: 1432
-- Name: FUNCTION mensagem_alerta_valida_senha(vp_plastico numeric); Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON FUNCTION mensagem_alerta_valida_senha(vp_plastico numeric) IS 'mensagem de alerta depois de validar a senha no atm';


SET search_path = sc_rnc, pg_catalog;

--
-- TOC entry 1439 (class 1255 OID 564518)
-- Name: confirma_cancela_renegociacao(); Type: FUNCTION; Schema: sc_rnc; Owner: scan
--

CREATE FUNCTION confirma_cancela_renegociacao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_st_pendente constant numeric := 1;
  ct_st_confirmada constant numeric := 2;
  ct_st_cancelada constant numeric := 3;
  ct_st_pagamento_fatura_cadastrado numeric := 1;
  ct_tp_operacao_renegociacao constant numeric := 15; 
  ct_tp_ocorrencia_renegociacao constant numeric := 7;
  ct_tp_limite_saque_extra constant numeric := 1;  
  ct_st_fatura_renegociada constant numeric := 4; 

  
  vl_situacao_cartao varchar;
  vl_valor_pagamento_entrada numeric;
  vl_estado_renegociacao numeric;  
  vl_cartao numeric;
  vl_plastico_atual numeric;
  vl_cod_operacao numeric;
  vl_juros_renegociacao numeric;
  vl_saldo_devedor numeric;

  rg record;
begin

   for rg in select * 
             from sc_rnc.tbl_rnc 
             where st_rnc = ct_st_pendente
               and cd_emc = 1
   loop

   --zerando variaveis de controle
   vl_estado_renegociacao := ct_st_pendente;
   vl_valor_pagamento_entrada := 0;

   -- consultando situacao do cartao e saldo devedor da fatura
   select crt.cd_crt, crt.fg_atv_crt, fcr.vl_sld_dvd_fcr
     into vl_cartao, vl_situacao_cartao, vl_saldo_devedor
   from sc_fcr.tbl_fcr fcr 
     inner join sc_opr.tbl_crt crt on crt.cd_crt = fcr.cd_crt
   where fcr.cd_fcr = rg.cd_fcr;

   -- pegando o plastico atual
   select cd_pls
     into vl_plastico_atual
   from sc_opr.tbl_pls pls
   where cd_crt = vl_cartao 
     and pls.dt_inc_usr = (select max(dt_inc_usr)
                          from sc_opr.tbl_pls
                          where cd_crt = vl_cartao);


   -- verificando se renegociacao possui entrada
   if rg.vl_ent_rnc > 0 then

      -- verificando se somatorio de pagamentos da fatura foi efetuado antes do vencimento da entrada
      -- ou efetuado até 4 dias úteis após vencimento da entrada

      select coalesce(sum(vl_pfc),0)
        into vl_valor_pagamento_entrada
       from sc_fcr.tbl_pfc 
       where cd_fcr = rg.cd_fcr
         and st_pfc = ct_st_pagamento_fatura_cadastrado
         and dt_pgt_pfc >= rg.dt_grc_rnc::date
         and dt_pgt_pfc <= rg.dt_vnc_ent_rnc + interval '4 day';

      
      if (vl_valor_pagamento_entrada > 0 and vl_valor_pagamento_entrada >= rg.vl_ent_rnc) then
  
	vl_estado_renegociacao := ct_st_confirmada;	

      elsif (current_date > rg.dt_vnc_ent_rnc + interval '4 day') then

        vl_estado_renegociacao := ct_st_cancelada;

      end if;
   
   elsif vl_situacao_cartao = 'S' then
     
	raise exception 'Não é possível confirmar renegociacao para cartão ATIVO';
   
   end if;


   if vl_estado_renegociacao = ct_st_confirmada then
      -- insere uma operacao de renegociacao   
      select nextval('sc_opr.sq_opr')
        into vl_cod_operacao;

      vl_juros_renegociacao := rg.vl_rnc - (vl_saldo_devedor + rg.vl_ent_rnc + rg.vl_dsc_rnc + rg.vl_trf_rnc + rg.vl_iof_rnc);

      insert into sc_opr.tbl_opr(cd_opr,cd_top,cd_pls,cd_atm,dt_opr,vl_opr,vl_jrs_opr,vl_trf_opr,
                    nr_nsu_org_opr,nr_prc_opr,vl_prc_opr,vl_iof_opr,st_opr)
             values(vl_cod_operacao,ct_tp_operacao_renegociacao,vl_plastico_atual,null,now(),rg.vl_rnc,vl_juros_renegociacao,
                    rg.vl_trf_rnc,rg.cd_rnc,rg.nr_prc_rnc,rg.vl_prc_rnc,rg.vl_iof_rnc,2);

      -- atualizando estado da fatura
      update sc_fcr.tbl_fcr set st_fcr = ct_st_fatura_renegociada where cd_fcr = rg.cd_fcr;
  
      -- atualizando limite utilizado
      update sc_opr.tbl_lmt set vl_utl_lmt = rg.vl_rnc where cd_crt = vl_cartao and cd_tlt = ct_tp_limite_saque_extra;

      -- inserindo ocorrencia de cartao
      insert into sc_opr.tbl_ocr (cd_ocr,cd_toc,cd_crt,cd_pls,nm_his_ocr,fg_atm_ocr,cd_inc_usr,dt_inc_usr) 
           values(nextval('sc_opr.sq_ocr'), ct_tp_ocorrencia_renegociacao, vl_cartao, vl_plastico_atual, 'CONFIRMACAO DE RENEGOCIACAO', 'S', 1, now());	

      -- atualizando data do proximo corte e vencimento do cartao
      update sc_opr.tbl_crt 
         set dt_prx_apr_crt = rg.dt_vnc_prc_rnc - interval '15 day' , dt_prx_vnc_crt = rg.dt_vnc_prc_rnc
       where cd_crt = vl_cartao;

      --atualizando renegociacao
     update sc_rnc.tbl_rnc 
       set cd_opr = vl_cod_operacao,
           st_rnc = vl_estado_renegociacao,
           cd_cfc_usr = 1,
           dt_cfc_usr = now() 
     where cd_rnc = rg.cd_rnc; 
      
   end if;
   

   -- cancelando renegociacao
   if vl_estado_renegociacao = ct_st_cancelada then
    
     -- inserindo ocorrencia de cartao
     insert into sc_opr.tbl_ocr (cd_ocr,cd_toc,cd_crt,cd_pls,nm_his_ocr,fg_atm_ocr,cd_inc_usr,dt_inc_usr) 
           values(nextval('sc_opr.sq_ocr'), ct_tp_ocorrencia_renegociacao, vl_cartao, vl_plastico_atual, 'CANCELAMENTO DE RENEGOCIACAO NESTA DATA', 'S', 1, now());	
     
     --atualizando renegociacao
     update sc_rnc.tbl_rnc 
       set st_rnc = vl_estado_renegociacao ,
           cd_cnc_usr = 1,
           dt_cnc_usr = now() 
     where cd_rnc = rg.cd_rnc;

   end if;

             
   end loop;

end;$$;


ALTER FUNCTION sc_rnc.confirma_cancela_renegociacao() OWNER TO scan;

--
-- TOC entry 7869 (class 0 OID 0)
-- Dependencies: 1439
-- Name: FUNCTION confirma_cancela_renegociacao(); Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON FUNCTION confirma_cancela_renegociacao() IS 'funcao que confirma ou cancela as renegociacoes pendentes de confirmacao';


--
-- TOC entry 1440 (class 1255 OID 564519)
-- Name: corrige_vencimento_cartao(); Type: FUNCTION; Schema: sc_rnc; Owner: scan
--

CREATE FUNCTION corrige_vencimento_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

data_vencimento date;

begin

  for rg in select distinct crt.dt_prx_vnc_crt, crt.cd_crt
     from sc_fcr.tbl_prc prc
      inner join sc_opr.tbl_crt crt on crt.cd_crt = prc.cd_crt
      where prc.dt_vnc_prc < current_date and prc.cd_fcr is null and st_prc = 1
        and crt.dt_prx_vnc_crt < current_date loop

       data_vencimento := rg.dt_prx_vnc_crt;

        while (data_vencimento < to_date('05/03/2013','dd/mm/yyyy')) loop

            perform sc_fcr.gerar_fatura_cartao(rg.cd_crt, data_vencimento, data_vencimento,true,false);

            data_vencimento := data_vencimento + INTERVAL '1 month';
        
        end loop;
   end loop;     

end;$$;


ALTER FUNCTION sc_rnc.corrige_vencimento_cartao() OWNER TO scan;

--
-- TOC entry 1441 (class 1255 OID 564520)
-- Name: processar_renegociacao_externa(); Type: FUNCTION; Schema: sc_rnc; Owner: scan
--

CREATE FUNCTION processar_renegociacao_externa() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin

  for rg in select *
            from sc_rnc.tbl_rnc rnc 
            where rnc.cd_emc = 2 -- empresa fama
              and st_rnc = 1 -- pendente de confirmacao
  loop

    perform sc_rnc.processar_renegociacao_externa(rg.cd_rnc);
           
  end loop;     

end;$$;


ALTER FUNCTION sc_rnc.processar_renegociacao_externa() OWNER TO scan;

--
-- TOC entry 7870 (class 0 OID 0)
-- Dependencies: 1441
-- Name: FUNCTION processar_renegociacao_externa(); Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON FUNCTION processar_renegociacao_externa() IS 'rotina que processa as renegociacoes realizadas na empresa de cobranca tercerizada';


--
-- TOC entry 1442 (class 1255 OID 564521)
-- Name: processar_renegociacao_externa(numeric); Type: FUNCTION; Schema: sc_rnc; Owner: scan
--

CREATE FUNCTION processar_renegociacao_externa(vp_codigo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

CT_TIPO_PGTO_RENEGOCIACAO_EXTERNA 	numeric := 5;
CT_SITUACAO_FATURA_RENEGOCIADA 		numeric := 4;
CT_TIPO_OPERACAO_RENEGOCIACAO		numeric := 15;
CT_SITUACAO_OPERACAO_CONFIRMADA		numeric := 2;
CT_TIPO_OCORRENCIA_RENEGOCIACAO		numeric := 7; 
CT_EMPRESA_COBRANCA_FAMA		numeric := 2;


vl_cartao  		numeric := 0;
vl_fatura_atual   	numeric := 0;
vl_plastico		numeric := 0;
vl_numero_parcelas	numeric := 0;
vl_valor_entrada	numeric := 0;
vl_data_vencimento	date;
vl_cod_operacao		numeric := 0;
vl_valor_operacao	numeric := 0;
vl_valor_juros		numeric := 0;
vl_valor_parcela	numeric := 0;
vl_quitou_divida	boolean := false;
vl_data_vencimento_cartao date;

begin

  for rg in select *
            from sc_rnc.tbl_rnc rnc 
            where rnc.cd_emc = 2 -- empresa fama
              and st_rnc = 1 -- pendente de confirmacao
              and rnc.cd_rnc = vp_codigo
  loop
    
    vl_quitou_divida := true;

    -- pegando a fatura atual do cliente - inicio
    select cd_crt
      into vl_cartao 
    from sc_fcr.tbl_fcr fcr
    where cd_fcr = rg.cd_fcr;

    select crt.cd_fcr, pls.cd_pls
      into vl_fatura_atual, vl_plastico 
    from sc_opr.tbl_crt crt
	inner join sc_opr.tbl_pls pls on pls.cd_crt = crt.cd_crt
    where crt.cd_crt = vl_cartao;
    -- pegando a fatura atual do cliente - fim

    -- verificando o valor da entrada e o numero de parcelas correto para gerar a operacao de renegociacao - inicio
    vl_data_vencimento := rg.dt_vnc_ent_rnc;
    vl_numero_parcelas := rg.nr_prc_rnc;
    vl_valor_entrada := rg.vl_ent_rnc;

    if vl_numero_parcelas > 1 then
       -- cliente renegociou a divida
       vl_quitou_divida := false;
       vl_data_vencimento := vl_data_vencimento + interval '1 month';
       while vl_data_vencimento <= current_date and vl_numero_parcelas > 0 loop
         vl_valor_entrada := vl_valor_entrada + rg.vl_prc_rnc;
         vl_numero_parcelas := vl_numero_parcelas - 1;
         vl_data_vencimento := vl_data_vencimento + interval '1 month';
       end loop;

       if vl_numero_parcelas = 0 then
          vl_quitou_divida := true;
       else
          vl_quitou_divida := false;
       end if;
    else
      if vl_valor_entrada = 0 then
         -- cliente pagou tudo de uma só vez
         vl_valor_entrada := rg.vl_prc_rnc;
         vl_quitou_divida := true;
      else
         -- cliente pagou somente a entrada e ainda ira pagar mais uma parcela
         vl_data_vencimento := vl_data_vencimento + interval '1 month';
         vl_quitou_divida := false;
      end if;
    end if;
    -- verificando o valor da entrada e o numero de parcelas correto para gerar a operacao de renegociacao - fim
    
    -- inserindo pagamento da entrada caso tenha
    if not vl_quitou_divida then
      perform sc_fcr.contabilizar_baixar_cartao(vl_cartao, vl_valor_entrada, CT_TIPO_PGTO_RENEGOCIACAO_EXTERNA, current_date, 1, null);
    end if;

    -- atualizando a fatura atual como RENEGOCIADA e incluindo o valor da entrada, se existir
    update sc_fcr.tbl_fcr set st_fcr = CT_SITUACAO_FATURA_RENEGOCIADA where cd_fcr = vl_fatura_atual;
    
    -- gerando a operacao de renegociacao
    if vl_numero_parcelas = 0 then
       vl_numero_parcelas := 1;
       vl_valor_parcela := vl_valor_entrada;
    else
      vl_valor_parcela := rg.vl_prc_rnc;
    end if;

    select nextval('sc_opr.sq_opr') into vl_cod_operacao;
    vl_valor_juros := rg.vl_rnc - rg.vl_prp_rnc;
    vl_valor_operacao := vl_valor_parcela * vl_numero_parcelas;
    
    insert into sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, 
			vl_trf_opr, nr_nsu_org_opr, nr_prc_opr, vl_prc_opr, vl_iof_opr, st_opr)
         values(vl_cod_operacao, CT_TIPO_OPERACAO_RENEGOCIACAO, vl_plastico, null, now(), vl_valor_operacao, vl_valor_juros, 
			0, rg.cd_rnc, vl_numero_parcelas, vl_valor_parcela, 0, CT_SITUACAO_OPERACAO_CONFIRMADA);

    -- inserindo ocorrencia de RENEGOCIACAO
     insert into sc_opr.tbl_ocr (cd_ocr,cd_toc,cd_crt,cd_pls,nm_his_ocr,fg_atm_ocr,cd_inc_usr,dt_inc_usr) 
           values(nextval('sc_opr.sq_ocr'), CT_TIPO_OCORRENCIA_RENEGOCIACAO, vl_cartao, vl_plastico, 'CONFIRMACAO DE RENEGOCIACAO', 'S', 1, now());	
    
    -- gerando a parcela, fatura e realizando o pagamento em caso da divida ter sido liquidada
    if vl_quitou_divida then
      perform sc_fcr.gerar_parcelas(vl_cartao, null);
  
      perform sc_fcr.gerar_fatura_cartao(vl_cartao, null, current_date, false, false);

      perform sc_fcr.contabilizar_baixar_cartao(vl_cartao, vl_valor_operacao, CT_TIPO_PGTO_RENEGOCIACAO_EXTERNA, current_date, 1, null);
    end if;

    -- excluindo o cliente da cobranca e retirando do spc, caso esteja
    perform sc_cci.excluir_cartao_cobranca(vl_cartao, CT_EMPRESA_COBRANCA_FAMA);

    -- atualizando data do proximo corte e vencimento do cartao
    vl_data_vencimento_cartao := rg.dt_vnc_ent_rnc + interval '1 month';
    
    update sc_opr.tbl_crt 
       set dt_prx_apr_crt = vl_data_vencimento_cartao - interval '5 day', 
           dt_prx_vnc_crt = vl_data_vencimento_cartao
    where cd_crt = vl_cartao;
       	
    -- CONFIRMANDO a renegociacao
    update sc_rnc.tbl_rnc 
       set cd_opr = vl_cod_operacao,
	   cd_fcr = vl_fatura_atual,
           st_rnc = 2,
           cd_cfc_usr = 1,
           dt_cfc_usr = now() 
    where cd_rnc = rg.cd_rnc;
           
  end loop;     

end;$$;


ALTER FUNCTION sc_rnc.processar_renegociacao_externa(vp_codigo numeric) OWNER TO scan;

--
-- TOC entry 7871 (class 0 OID 0)
-- Dependencies: 1442
-- Name: FUNCTION processar_renegociacao_externa(vp_codigo numeric); Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON FUNCTION processar_renegociacao_externa(vp_codigo numeric) IS 'rotina que processa uma determinanda renegociacao realizada na empresa de cobranca tercerizada';


--
-- TOC entry 1445 (class 1255 OID 564524)
-- Name: processar_renegociacao_interna_extra(numeric); Type: FUNCTION; Schema: sc_rnc; Owner: scan
--

CREATE FUNCTION processar_renegociacao_interna_extra(vp_codigo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  
  CT_TIPO_BAIXA_CONTA_CARTAO sc_fcr.tbl_tpc.cd_tpc%type := 1;
  CT_SITUACAO_FATURA_RENEGOCIADA 		numeric := 4;
  CT_TIPO_OPERACAO_RENEGOCIACAO			numeric := 15;
  CT_SITUACAO_OPERACAO_CONFIRMADA		numeric := 2;
  CT_TIPO_OCORRENCIA_RENEGOCIACAO		numeric := 7; 
  CT_SITUACAO_RENEGOCIACAO_CONFIRMADA		numeric := 2;

  vl_fatura_atual 				numeric;
  vl_valor_parcela				numeric;
  vl_codigo_operacao				numeric;
  vl_codigo_renegociacao			numeric;
  vl_data_vencimento_entrada			date;
  vl_plastico					numeric;
  vl_empresa_cobranca_atual			numeric;
  vl_cartao_em_cobranca				varchar;
begin
   for rg in 
       select * from sc_rnc.tbl_rnc_aux ra where st_rnc = 1 and ra.cd_rnc = COALESCE(vp_codigo, ra.cd_rnc) -- pendente
   loop
     -- inserindo pagamento da entrada, caso tenha
     if rg.vl_ent_rnc is not null and rg.vl_ent_rnc > 0 then
       perform sc_fcr.contabilizar_baixar_cartao(rg.cd_crt, rg.vl_ent_rnc, CT_TIPO_BAIXA_CONTA_CARTAO, current_date, 1, null);
       vl_data_vencimento_entrada := current_date;
     else
       vl_data_vencimento_entrada := null;
     end if;

     -- capturando algumas variaveis necessarias para gravar a operacao, renegociacao e ocorrencia
     select nextval('sc_opr.sq_opr') into vl_codigo_operacao;

     select nextval('sc_rnc.sq_rnc') into vl_codigo_renegociacao;

     if COALESCE(rg.vl_prc_rnc, 0) = 0  then
       vl_valor_parcela := rg.vl_rnc / rg.nr_prc_rnc;
     else
       vl_valor_parcela := rg.vl_prc_rnc;
     end if;

     select crt.cd_fcr, pls.cd_pls
       into vl_fatura_atual, vl_plastico 
     from sc_opr.tbl_crt crt
	inner join sc_opr.tbl_pls pls on pls.cd_crt = crt.cd_crt
     where crt.cd_crt = rg.cd_crt;
     
     -- marcando a fatura como RENEGOCIADA
     update sc_fcr.tbl_fcr set st_fcr = CT_SITUACAO_FATURA_RENEGOCIADA where cd_fcr = vl_fatura_atual;

      -- gravando a renegociacao
     insert into sc_rnc.tbl_rnc(cd_rnc, cd_fcr, cd_opr, dt_grc_rnc, dt_vnc_prc_rnc, dt_vnc_ent_rnc, 
			    vl_dsc_rnc, vl_rnc, vl_ent_rnc, nr_prc_rnc, vl_prc_rnc, st_rnc, 
			    tx_jrs_rnc, vl_trf_rnc, cd_inc_usr, dt_inc_usr, cd_cfc_usr, dt_cfc_usr, vl_iof_rnc, vl_prp_rnc, 
			    pc_dsc_rnc, vl_jrs_rnc, nr_ctr_ext_rnc, cd_emc)
	    values (vl_codigo_renegociacao, vl_fatura_atual, vl_codigo_operacao, now(), rg.dt_vnc_prc_rnc, vl_data_vencimento_entrada, 
		    0, rg.vl_rnc, rg.vl_ent_rnc, rg.nr_prc_rnc, vl_valor_parcela, CT_SITUACAO_RENEGOCIACAO_CONFIRMADA, 
		    0, 0, 1, now(), 1, now(), 0, rg.vl_rnc, 
		    0, 0, null, rg.cd_emc);
     
     -- gravando a operacao
     insert into sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, 
			vl_trf_opr, nr_nsu_org_opr, nr_prc_opr, vl_prc_opr, vl_iof_opr, st_opr)
         values(vl_codigo_operacao, CT_TIPO_OPERACAO_RENEGOCIACAO, vl_plastico, null, now(), rg.vl_rnc, 0, 
			0, rg.cd_rnc, rg.nr_prc_rnc, vl_valor_parcela, 0, CT_SITUACAO_OPERACAO_CONFIRMADA);

     -- gravando a ocorrencia
     insert into sc_opr.tbl_ocr (cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
           values(nextval('sc_opr.sq_ocr'), CT_TIPO_OCORRENCIA_RENEGOCIACAO, rg.cd_crt, vl_plastico, 'CONFIRMACAO DA RENEGOCIACAO ACERTADA COM A EMPRESA', 'S', 1, now());

     -- excluindo o cliente da cobranca e retirando do spc, caso esteja
     select cd_emc, fg_atv_cci
       into vl_empresa_cobranca_atual, vl_cartao_em_cobranca
     from sc_cci.tbl_cci cci 
     where cci.cd_crt = rg.cd_crt;

     if vl_cartao_em_cobranca = 'S' then
        perform sc_cci.excluir_cartao_cobranca(rg.cd_crt, vl_empresa_cobranca_atual);
     end if;

     -- atualizando data do proximo corte e vencimento do cartao
     update sc_opr.tbl_crt 
        set dt_prx_apr_crt = rg.dt_vnc_prc_rnc - interval '5 day', 
            dt_prx_vnc_crt = rg.dt_vnc_prc_rnc
     where cd_crt = rg.cd_crt;
          
     -- marcando a renegociação como processada
     update sc_rnc.tbl_rnc_aux 
        set st_rnc = 2 
     where cd_rnc = rg.cd_rnc;
   end loop;

end;$$;


ALTER FUNCTION sc_rnc.processar_renegociacao_interna_extra(vp_codigo numeric) OWNER TO scan;

--
-- TOC entry 7872 (class 0 OID 0)
-- Dependencies: 1445
-- Name: FUNCTION processar_renegociacao_interna_extra(vp_codigo numeric); Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON FUNCTION processar_renegociacao_interna_extra(vp_codigo numeric) IS 'rotina que processa uma determinanda renegociacao interna acordada com a empresa dos funcionarios';


--
-- TOC entry 1446 (class 1255 OID 564525)
-- Name: processar_retorno_pagamento_cobranca_tercerizada(numeric); Type: FUNCTION; Schema: sc_rnc; Owner: scan
--

CREATE FUNCTION processar_retorno_pagamento_cobranca_tercerizada(vp_codigo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

CT_SITUACAO_PENDENTE numeric := 1;
CT_SITUACAO_PROCESSADO numeric := 2;
CT_SITUACAO_PROCESSADO_COM_ERRO numeric := 3;

CT_TIPO_PGTO_RENEGOCIACAO_EXTERNA numeric := 5;

vl_retorno numeric := 0;
vl_situacao numeric := 0;
vl_conta_origem numeric;
begin

   for rg in select *
             from sc_rnc.tbl_rpc rpc
             where rpc.st_rpc = CT_SITUACAO_PENDENTE
               and rpc.cd_rpc = COALESCE (vp_codigo, rpc.cd_rpc)
   loop

     select sc_rnc.validar_retorno_pagamento_cobranca_tercerizada(rg.cd_rpc) into vl_retorno;

     if vl_retorno = 0 then
        -- rotina para lancar o credito no cartao do cliente e jÃ¡ realizar a baixa da fatura do cliente
        --perform sc_fcr.contabilizar_baixar_cartao(rg.cd_crt, rg.vl_pgt_rpc, CT_TIPO_PGTO_RENEGOCIACAO_EXTERNA, rg.dt_pgt_rpc, 1, null);

	-- caso seja necessário apenas lançar o credito na conta do funcionario, pois a parcela já foi paga devido a captura ao receber depósito
	select sc_fcr.contabilizar_baixa_por_tipo(rg.cd_crt,rg.vl_pgt_rpc,CT_TIPO_PGTO_RENEGOCIACAO_EXTERNA,1,null) into vl_conta_origem;

        vl_situacao := CT_SITUACAO_PROCESSADO;
     else
        vl_situacao := CT_SITUACAO_PROCESSADO_COM_ERRO;
     end if;
     
     update sc_rnc.tbl_rpc rpc
        set st_rpc = vl_situacao,
            cd_err_prc_rpc = vl_retorno,
            dt_prc_rpc = now()
     where cd_rpc = rg.cd_rpc;
      
   end loop;

end;$$;


ALTER FUNCTION sc_rnc.processar_retorno_pagamento_cobranca_tercerizada(vp_codigo numeric) OWNER TO scan;

--
-- TOC entry 7873 (class 0 OID 0)
-- Dependencies: 1446
-- Name: FUNCTION processar_retorno_pagamento_cobranca_tercerizada(vp_codigo numeric); Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON FUNCTION processar_retorno_pagamento_cobranca_tercerizada(vp_codigo numeric) IS 'rotina que processa os pagamentos recebidos da cobranca tercerizada e realiza o credito no cartao do cliente para baixar sua divida';


--
-- TOC entry 1456 (class 1255 OID 564526)
-- Name: processar_retorno_pagamento_cobranca_tercerizada(numeric, boolean); Type: FUNCTION; Schema: sc_rnc; Owner: scan
--

CREATE FUNCTION processar_retorno_pagamento_cobranca_tercerizada(vp_codigo numeric, vp_baixa_fatura boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

CT_SITUACAO_PENDENTE numeric := 1;
CT_SITUACAO_PROCESSADO numeric := 2;
CT_SITUACAO_PROCESSADO_COM_ERRO numeric := 3;

CT_TIPO_PGTO_RENEGOCIACAO_EXTERNA numeric := 5;

vl_retorno numeric := 0;
vl_situacao numeric := 0;
vl_conta_origem numeric;
begin

   for rg in select *
             from sc_rnc.tbl_rpc rpc
             where rpc.st_rpc = CT_SITUACAO_PENDENTE
               and rpc.cd_rpc = COALESCE (vp_codigo, rpc.cd_rpc)
   loop

     select sc_rnc.validar_retorno_pagamento_cobranca_tercerizada(rg.cd_rpc) into vl_retorno;

     if vl_retorno = 0 then

        if COALESCE(vp_baixa_fatura, TRUE) then
          -- rotina para lancar o credito no cartao do cliente e ja realizar a baixa da fatura do cliente
          perform sc_fcr.contabilizar_baixar_cartao(rg.cd_crt, rg.vl_pgt_rpc, CT_TIPO_PGTO_RENEGOCIACAO_EXTERNA, rg.dt_pgt_rpc, 1, null);
        else
	  -- caso seja necessário apenas lançar o credito na conta do funcionario, pois a parcela já foi paga devido a captura ao receber depósito
	  select sc_fcr.contabilizar_baixa_por_tipo(rg.cd_crt,rg.vl_pgt_rpc,CT_TIPO_PGTO_RENEGOCIACAO_EXTERNA,1,null) into vl_conta_origem;
        end if; 
        
        vl_situacao := CT_SITUACAO_PROCESSADO;
     else
        vl_situacao := CT_SITUACAO_PROCESSADO_COM_ERRO;
     end if;
     
     update sc_rnc.tbl_rpc rpc
        set st_rpc = vl_situacao,
            cd_err_prc_rpc = vl_retorno,
            dt_prc_rpc = now()
     where cd_rpc = rg.cd_rpc;
      
   end loop;

end;$$;


ALTER FUNCTION sc_rnc.processar_retorno_pagamento_cobranca_tercerizada(vp_codigo numeric, vp_baixa_fatura boolean) OWNER TO scan;

--
-- TOC entry 7874 (class 0 OID 0)
-- Dependencies: 1456
-- Name: FUNCTION processar_retorno_pagamento_cobranca_tercerizada(vp_codigo numeric, vp_baixa_fatura boolean); Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON FUNCTION processar_retorno_pagamento_cobranca_tercerizada(vp_codigo numeric, vp_baixa_fatura boolean) IS 'rotina que processa os pagamentos recebidos da cobranca tercerizada e realiza o credito no cartao do cliente para baixar sua divida';


--
-- TOC entry 1457 (class 1255 OID 564527)
-- Name: validar_retorno_pagamento_cobranca_tercerizada(numeric); Type: FUNCTION; Schema: sc_rnc; Owner: scan
--

CREATE FUNCTION validar_retorno_pagamento_cobranca_tercerizada(vp_codigo numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

rg record;

CT_SITUACAO_PENDENTE numeric := 1;
CT_SITUACAO_CONFIRMADA numeric := 2;
CT_TIPO_PGTO_RENEGOCIACAO_EXTERNA numeric := 5;

vl_qtde    numeric := 0;
vl_retorno numeric := 99;
begin

   for rg in select * 
             from sc_rnc.tbl_rpc
             where cd_rpc = vp_codigo
   loop
      -- se o cartao possui alguma renegociacao confirmada para a empresa de cobranca que enviou o pagamento
     select count(*)
       into vl_qtde
     from sc_rnc.tbl_rnc rnc
	inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = rnc.cd_fcr
     where fcr.cd_crt = rg.cd_crt
       and rnc.cd_emc = rg.cd_emc
       and rnc.st_rnc = CT_SITUACAO_CONFIRMADA;

      if vl_qtde = 0 then
        return 1; 
      end if;

      -- se o valor enviado é maior do que zero
      if rg.vl_pgt_rpc <= 0 then
        return 2; 
      end if;

      -- se o numero da parcela enviado é maior ou igual a zero
      if rg.nr_prc_rpc < 0 then
        return 3; 
      end if;

      -- se a situacao do pagamento esta como PENDENTE
      if rg.st_rpc <> 1 then
        return 4; 
      end if;

      vl_retorno := 0;
   end loop;

   return vl_retorno;
end;$$;


ALTER FUNCTION sc_rnc.validar_retorno_pagamento_cobranca_tercerizada(vp_codigo numeric) OWNER TO scan;

--
-- TOC entry 7875 (class 0 OID 0)
-- Dependencies: 1457
-- Name: FUNCTION validar_retorno_pagamento_cobranca_tercerizada(vp_codigo numeric); Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON FUNCTION validar_retorno_pagamento_cobranca_tercerizada(vp_codigo numeric) IS 'rotina que valida se os pagamentos recebidos da cobranca tercerizada estao corretos para fazer o credito no cartao do cliente';


SET search_path = sc_rsc, pg_catalog;

--
-- TOC entry 1520 (class 1255 OID 564528)
-- Name: efetuar_baixa_cartao_rescisao(numeric, numeric, boolean); Type: FUNCTION; Schema: sc_rsc; Owner: scan
--

CREATE FUNCTION efetuar_baixa_cartao_rescisao(vp_cartao numeric, vp_valor_baixa numeric, vp_eh_baixa_rescisao boolean) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE

  ST_RSC_CADASTRADA sc_rsc.tbl_rsc.st_rsc%type := 1;
  ST_RSC_CANCELADA sc_rsc.tbl_rsc.st_rsc%type := 2;
  ST_RSC_PAGA sc_rsc.tbl_rsc.st_rsc%type := 3;
  ST_RSC_PAGA_PARCIAL sc_rsc.tbl_rsc.st_rsc%type := 4;

  vl_divida_funcionario numeric;
  vl_qtd_rescisao numeric;
  vl_qtd_parcelas_a_vencer numeric;
  vl_restante_rescisao numeric;
  vl_pagamento_total_rescisao numeric;
  vl_data_apuracao date;
  vl_situacao_rescisao sc_rsc.tbl_rsc.st_rsc%type;
  vl_valor_baixa_rescisao sc_rsc.tbl_rsc.vl_pgt_rsc%type := 0;
  
  rt_rescisao sc_rsc.tbl_rsc%rowtype;

BEGIN

  -- Verificando se existe rescisao a ser baixada
  select count(*)
  into vl_qtd_rescisao
  from sc_rsc.tbl_rsc rsc
  where rsc.cd_crt = vp_cartao
    and rsc.st_rsc not in( ST_RSC_CANCELADA,ST_RSC_PAGA)
    and coalesce(rsc.vl_dsc_rsc,0) > 0;
  
  
  if vl_qtd_rescisao > 0 then

   --*RETIRADO A CHECAGEM DE PARCELAS A VENCER PARA GERAR FATURA
   --*ISSO GARANTE QUE A FATURA DE RESCISAO SEMPRE SERA A DIVIDA TOTAL ATUAL
    -- Verificando se existe parcelas a vencer
    --select count(*)
    --into vl_qtd_parcelas_a_vencer
    --from sc_fcr.tbl_prc prc
    --where st_prc = 1
    --  and prc.cd_crt = vp_cartao;
    
    -- Se existe parcelas a vencer consolida a dívida  
    --if vl_qtd_parcelas_a_vencer > 0 then

    /*
       COMENTARIO REALIZADO POR VITOR VASCONCELOS EM 14/04/2016. 
       MOTIVO: NA REALIZACAO DA RESCISAO ESTAVAM SENDO GERADAS DUAS FATURAS E O PAGAMENTO DE PARCELAS ESTAVA FICANDO ERRADO
     
    
    vl_data_apuracao := (now() + interval '12 month')::date;
    perform sc_fcr.gerar_fatura_cartao(vp_cartao, vl_data_apuracao, current_date,false);
    
    */
       
    --end if;
    --*JOAO VICTOR EM 22/10/2013
    
    -- Obtendo os dados da rescisao  
    select * 
    into rt_rescisao
    from sc_rsc.tbl_rsc rsc
    where rsc.cd_crt = vp_cartao
      and rsc.st_rsc <> ST_RSC_CANCELADA;
      
    -- Obtendo o valor da divida atual do cidadao
    select coalesce(fcr.vl_sld_dvd_fcr,0)
    into vl_divida_funcionario
    from sc_fcr.tbl_fcr fcr
      inner join sc_opr.tbl_crt crt on crt.cd_crt = fcr.cd_crt
    where crt.cd_crt = vp_cartao;
      
    vl_restante_rescisao = coalesce(rt_rescisao.vl_dsc_rsc,0) - coalesce(rt_rescisao.vl_pgt_rsc,0);
  
    -- Verificando valor a ser baixado da rescisao
    if vp_eh_baixa_rescisao then    
      if vl_restante_rescisao > vp_valor_baixa then
        vl_valor_baixa_rescisao = vp_valor_baixa;
      else
        vl_valor_baixa_rescisao = vl_restante_rescisao;
      end if;  
    else
      if vl_restante_rescisao > vl_divida_funcionario then
        vl_valor_baixa_rescisao = vl_restante_rescisao - vl_divida_funcionario;
      else
        vl_valor_baixa_rescisao := 0; 
      end if;      
      
    end if;  
      
    -- Verificando situacao da rescisao
    vl_pagamento_total_rescisao := coalesce(rt_rescisao.vl_pgt_rsc,0) + vl_valor_baixa_rescisao;
      
    if vl_pagamento_total_rescisao > 0 then
      if rt_rescisao.vl_dsc_rsc > vl_pagamento_total_rescisao then
        vl_situacao_rescisao := ST_RSC_PAGA_PARCIAL;
      else
        vl_situacao_rescisao := ST_RSC_PAGA;
      end if;
    else
      vl_situacao_rescisao := ST_RSC_CADASTRADA;  
    end if;
      
    update sc_rsc.tbl_rsc 
    set vl_pgt_rsc = (coalesce(vl_pgt_rsc,0) + coalesce(vl_valor_baixa_rescisao,0)),
        st_rsc = vl_situacao_rescisao
    where cd_rsc = rt_rescisao.cd_rsc;
    
  end if;
  
  return vl_valor_baixa_rescisao;
  
end;
$$;


ALTER FUNCTION sc_rsc.efetuar_baixa_cartao_rescisao(vp_cartao numeric, vp_valor_baixa numeric, vp_eh_baixa_rescisao boolean) OWNER TO scan;

--
-- TOC entry 1678 (class 1255 OID 564529)
-- Name: efetuar_rescisao(numeric, timestamp without time zone, numeric, character varying, numeric, double precision); Type: FUNCTION; Schema: sc_rsc; Owner: scan
--

CREATE FUNCTION efetuar_rescisao(vp_cartao numeric, vp_data_rescisao timestamp without time zone, vp_usuario numeric, vp_observacao character varying, vp_origem numeric, vp_valor double precision DEFAULT 0) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  TP_RSC_DESCONTO_TOTAL sc_rsc.tbl_rsc.tp_rsc%type := 1; 
  TP_RSC_DESCONTO_PARCIAL sc_rsc.tbl_rsc.tp_rsc%type := 2;
  TP_RSC_SEM_DIVIDA sc_rsc.tbl_rsc.tp_rsc%type := 3;
  TP_RSC_SEM_DESCONTO sc_rsc.tbl_rsc.tp_rsc%type := 4;
  
  ST_RSC_CADASTRADA sc_rsc.tbl_rsc.st_rsc%type := 1;
  ST_RSC_CANCELADA sc_rsc.tbl_rsc.st_rsc%type := 2;
  
  vl_saldo_devedor sc_fcr.tbl_fcr.vl_sld_dvd_fcr%type;
  vl_parcelas_a_vencer sc_fcr.tbl_fcr.vl_sld_dvd_fcr%type;
  
  vl_divida_funcionario sc_rsc.tbl_rsc.vl_dvd_fnc_rsc%type;
  vl_tipo_rescisao sc_rsc.tbl_rsc.tp_rsc%type;
  vl_rescisao sc_rsc.tbl_rsc.vl_dsc_rsc%type;
  vl_qtd_update numeric;

  vl_cd_fnc numeric;
  vl_cd_cun numeric;
  
  vl_qtd_rescisao numeric;
  
BEGIN

  -- verificando a existencia de rescisao para o cartao
  
  select count(*)
  into vl_qtd_rescisao
  from sc_rsc.tbl_rsc rsc
  where rsc.cd_crt = vp_cartao
    and rsc.st_rsc <> ST_RSC_CANCELADA; 

    -- Inativando o cartao
    update sc_opr.tbl_crt set fg_atv_crt = 'N' where cd_crt = vp_cartao and fg_atv_crt = 'S';
    get diagnostics vl_qtd_update := row_count;

    if vl_qtd_update > 0 then
    
      insert into sc_opr.tbl_ocr(cd_ocr,
                                 cd_toc,
                                 cd_crt,
                                 cd_pls,
                                 nm_his_ocr,
                                 fg_atm_ocr,
                                 cd_inc_usr,
                                 dt_inc_usr ) 
                      values    (nextval('sc_opr.sq_ocr'),
                                 16,-- Inativação de Cartao - via rescisao
                                 vp_cartao,
                                 null,
                                 vp_observacao,
                                 'N',
                                 vp_usuario,
                                 now());     
    end if;                             
  
    
  if coalesce(vl_qtd_rescisao,0) = 0 then
    
                                             
    select crt.cd_fnc, fnc.cd_cun
      into vl_cd_fnc, vl_cd_cun
    from sc_opr.tbl_crt crt
      inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    where crt.cd_crt = vp_cartao;

    -- Marcando o funcionário para demitido      
    update sc_cad.tbl_fnc  set
      st_fnc = 2,
      cd_alt_usr = vp_usuario,
      dt_alt_usr = now() -- Demitido
    where cd_fnc = vl_cd_fnc;

    -- tirar o cartao padrao
    /* -- comentado por Renato em 08/10/2013 em reuniao na Aptare com o Vitor e o JV
    update sc_cad.tbl_cun  set
      cd_crt = null -- Demitido
    where cd_cun = vl_cd_cun;
    */
    
    -- gerar parcelas que a vencer
    perform sc_fcr.gerar_parcelas(vp_cartao, null);

    -- gerar servicos a vencer
    perform sc_srv.cobrar_servico_saque_arredondado(vp_cartao, null);
                    
    -- Obtendo o valor da dívida do funcionario
    select fcr.vl_sld_dvd_fcr
    into vl_saldo_devedor
    from sc_fcr.tbl_fcr fcr
      inner join sc_opr.tbl_crt crt on crt.cd_fcr = fcr.cd_fcr
    where crt.cd_crt = vp_cartao;
    
    select sum(case when prc.fg_dcr_prc='D' then prc.vl_prc else prc.vl_prc*-1 end)
    into vl_parcelas_a_vencer
    from sc_fcr.tbl_prc prc
    where prc.st_prc = 1
      and prc.cd_crt = vp_cartao;
    
    vl_divida_funcionario := coalesce(vl_saldo_devedor,0) + coalesce(vl_parcelas_a_vencer,0);
    
    -- Verificando o tipo de rescisao
    if vl_divida_funcionario = 0 then
      vl_tipo_rescisao := TP_RSC_SEM_DIVIDA;
      vl_rescisao := 0;
    else
      if vp_valor <= 0 then
         vl_tipo_rescisao := TP_RSC_SEM_DESCONTO;
      else
         if vl_divida_funcionario > vp_valor then
           vl_tipo_rescisao := TP_RSC_DESCONTO_PARCIAL;
         else
           vl_tipo_rescisao := TP_RSC_DESCONTO_TOTAL;
           vl_rescisao := vl_divida_funcionario;
         end if; 
      end if;
    end if;
    
    vl_rescisao := coalesce(vl_rescisao,vp_valor);
                    
    -- Cadastrando a rescisao
    insert into sc_rsc.tbl_rsc(cd_rsc,  
                               cd_crt,
                               dt_rsc,
                               st_rsc,
                               tp_rsc,
                               cd_inc_usr,
                               dt_inc_usr,
                               vl_dsc_rsc,
                               org_rsc,
                               obs_rsc,
                               vl_dvd_fnc_rsc)
               values(nextval('sc_rsc.sq_rsc'),
                      vp_cartao,
                      vp_data_rescisao,
                      1,--Cadastrada,
                      vl_tipo_rescisao,
                      vp_usuario,
                      now(),
                      vl_rescisao,
                      vp_origem,
                      vp_observacao,
                      vl_divida_funcionario);
                      
   end if;                      
                                    
END;
$$;


ALTER FUNCTION sc_rsc.efetuar_rescisao(vp_cartao numeric, vp_data_rescisao timestamp without time zone, vp_usuario numeric, vp_observacao character varying, vp_origem numeric, vp_valor double precision) OWNER TO scan;

--
-- TOC entry 1458 (class 1255 OID 564532)
-- Name: efetuar_rescisao_antiga(numeric, timestamp without time zone, numeric, character varying, double precision); Type: FUNCTION; Schema: sc_rsc; Owner: scan
--

CREATE FUNCTION efetuar_rescisao_antiga(vp_cartao numeric, vp_data_rescisao timestamp without time zone, vp_usuario numeric, vp_observacao character varying, vp_valor double precision DEFAULT 0) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  TP_RSC_DESCONTO_TOTAL sc_rsc.tbl_rsc.tp_rsc%type := 1; 
  TP_RSC_DESCONTO_PARCIAL sc_rsc.tbl_rsc.tp_rsc%type := 2;
  TP_RSC_SEM_DIVIDA sc_rsc.tbl_rsc.tp_rsc%type := 3;
  TP_RSC_SEM_DESCONTO sc_rsc.tbl_rsc.tp_rsc%type := 4;
  
  ST_RSC_CADASTRADA sc_rsc.tbl_rsc.st_rsc%type := 1;
  ST_RSC_CANCELADA sc_rsc.tbl_rsc.st_rsc%type := 2;
  
  vl_saldo_devedor sc_fcr.tbl_fcr.vl_sld_dvd_fcr%type;
  vl_parcelas_a_vencer sc_fcr.tbl_fcr.vl_sld_dvd_fcr%type;
  
  vl_divida_funcionario sc_rsc.tbl_rsc.vl_dvd_fnc_rsc%type;
  vl_tipo_rescisao sc_rsc.tbl_rsc.tp_rsc%type;
  vl_rescisao sc_rsc.tbl_rsc.vl_dsc_rsc%type;
  vl_qtd_update numeric;

  vl_cd_fnc numeric;
  vl_cd_cun numeric;
  
  vl_qtd_rescisao numeric;
  
BEGIN

  -- verificando a existencia de rescisao para o cartao
  
  select count(*)
  into vl_qtd_rescisao
  from sc_rsc.tbl_rsc rsc
  where rsc.cd_crt = vp_cartao
    and rsc.st_rsc <> ST_RSC_CANCELADA; 
    
  if coalesce(vl_qtd_rescisao,0) = 0 then

    -- Inativando o cartao
    update sc_opr.tbl_crt set fg_atv_crt = 'N' where cd_crt = vp_cartao and fg_atv_crt = 'S';
    
    get diagnostics vl_qtd_update := row_count;
    
    if vl_qtd_update > 0 then
      insert into sc_opr.tbl_ocr(cd_ocr,
                                 cd_toc,
                                 cd_crt,
                                 cd_pls,
                                 nm_his_ocr,
                                 fg_atm_ocr,
                                 cd_inc_usr,
                                 dt_inc_usr ) 
                      values    (nextval('sc_opr.sq_ocr'),
                                 16,-- Inativação de Cartao
                                 vp_cartao,
                                 null,
                                 vp_observacao,
                                 'N',
                                 vp_usuario,
                                 now());     
    end if;                             
                                         
    select crt.cd_fnc, fnc.cd_cun
      into vl_cd_fnc, vl_cd_cun
    from sc_opr.tbl_crt crt
      inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    where crt.cd_crt = vp_cartao;

    -- Marcando o funcionário para demitido      
    update sc_cad.tbl_fnc  set
      st_fnc = 2 -- Demitido
    where cd_fnc = vl_cd_fnc;

    -- tirar o cartao padrao
    /* -- comentado por Renato em 08/10/2013 em reuniao na Aptare com o Vitor e o JV
    update sc_cad.tbl_cun  set
      cd_crt = null -- Demitido
    where cd_cun = vl_cd_cun;
    */
    
    -- gerar parcelas que a vencer
    perform sc_fcr.gerar_parcelas(vp_cartao, null);

    -- gerar servicos a vencer
    perform sc_srv.cobrar_servico_saque_arredondado(vp_cartao, null);
                    
    -- Obtendo o valor da dívida do funcionario
    select fcr.vl_sld_dvd_fcr
    into vl_saldo_devedor
    from sc_fcr.tbl_fcr fcr
      inner join sc_opr.tbl_crt crt on crt.cd_fcr = fcr.cd_fcr
    where crt.cd_crt = vp_cartao;
    
    select sum(case when prc.fg_dcr_prc='D' then prc.vl_prc else prc.vl_prc*-1 end)
    into vl_parcelas_a_vencer
    from sc_fcr.tbl_prc prc
    where prc.st_prc = 1
      and prc.cd_crt = vp_cartao;
    
    vl_divida_funcionario := coalesce(vl_saldo_devedor,0) + coalesce(vl_parcelas_a_vencer,0);
    
    -- Verificando o tipo de rescisao
    if vl_divida_funcionario = 0 then
      vl_tipo_rescisao := TP_RSC_SEM_DIVIDA;
      vl_rescisao := 0;
    else
      if vp_valor <= 0 then
         vl_tipo_rescisao := TP_RSC_SEM_DESCONTO;
      else
         if vl_divida_funcionario > vp_valor then
           vl_tipo_rescisao := TP_RSC_DESCONTO_PARCIAL;
         else
           vl_tipo_rescisao := TP_RSC_DESCONTO_TOTAL;
           vl_rescisao := vl_divida_funcionario;
         end if; 
      end if;
    end if;
    
    vl_rescisao := coalesce(vl_rescisao,vp_valor);
                    
    -- Cadastrando a rescisao
    insert into sc_rsc.tbl_rsc(cd_rsc,  
                               cd_crt,
                               dt_rsc,
                               st_rsc,
                               tp_rsc,
                               cd_inc_usr,
                               dt_inc_usr,
                               vl_dsc_rsc,
                               obs_rsc,
                               vl_dvd_fnc_rsc)
               values(nextval('sc_rsc.sq_rsc'),
                      vp_cartao,
                      vp_data_rescisao,
                      1,--Cadastrada,
                      vl_tipo_rescisao,
                      vp_usuario,
                      now(),
                      vl_rescisao,
                      vp_observacao,
                      vl_divida_funcionario);
                      
   end if;                      
                                    
END;
$$;


ALTER FUNCTION sc_rsc.efetuar_rescisao_antiga(vp_cartao numeric, vp_data_rescisao timestamp without time zone, vp_usuario numeric, vp_observacao character varying, vp_valor double precision) OWNER TO scan;

--
-- TOC entry 1436 (class 1255 OID 564535)
-- Name: efetuar_rescisao_cartao_padrao(numeric); Type: FUNCTION; Schema: sc_rsc; Owner: scan
--

CREATE FUNCTION efetuar_rescisao_cartao_padrao(vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record ;
  vl_cadastro_unico sc_cad.tbl_cun.cd_cun%type;
  vl_grupo_empresarial sc_cad.tbl_gem.cd_gem%type;
  vl_historico varchar;
  
BEGIN

  
   select cun.cd_cun, 
          emp.cd_gem 
   into vl_cadastro_unico,
        vl_grupo_empresarial
   from sc_opr.tbl_crt crt
     inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
     inner join sc_cad.tbl_emp emp on fnc.cd_emp = emp.cd_emp
     inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
   where crt.cd_crt = vp_cartao;
   
   
   for rg in select crt.cd_crt,
                    crt_padrao.cd_crt as cartao_padrao
             from sc_opr.tbl_crt crt
               inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
               inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
               inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
               inner join sc_opr.tbl_crt crt_padrao on crt_padrao.cd_crt = cun.cd_crt
               inner join sc_cad.tbl_fnc fnc_padrao on fnc_padrao.cd_fnc = crt_padrao.cd_fnc
               inner join sc_cad.tbl_emp emp_padrao on emp_padrao.cd_emp = fnc_padrao.cd_emp
             where crt.cd_crt <> vp_cartao
               and cun.cd_cun = vl_cadastro_unico
               and emp_padrao.cd_gem = vl_grupo_empresarial 
               and emp.cd_gem = vl_grupo_empresarial 
               and crt.fg_atv_crt = 'S' 
               loop
               
         vl_historico := 'INATIVAÇÃO DEVIDO A RESCISAO DE CARTAO DO MESMO GRUPO EMPRESARIAL DO CARTAO PADRAO. CARTAO PADRAO: ' || rg.cartao_padrao;      
               
         update sc_opr.tbl_crt set fg_atv_crt = 'N' where cd_crt = rg.cd_crt;

         -- inserir rescisao na tabela de rescisao tambem para o cartao padrao
         
         insert into sc_opr.tbl_ocr(cd_ocr,cd_toc,cd_crt,cd_pls,nm_his_ocr,fg_atm_ocr,cd_inc_usr,dt_inc_usr)
         values(nextval('sc_opr.sq_ocr'),16,rg.cd_crt,NULL,vl_historico,'S',1,now());

         -- garantindo a cobranca e consolidacao das dividas de todos os cartoes referentes ao cartao padrao
         perform sc_rsc.efetuar_rescisao(rg.cd_crt,now()::timestamp,1,'Rescisão via arquivo de depósito.',2, 0);
         perform sc_srv.cobrar_tarifa_servico(now()::date, null, rg.cd_crt); 
         perform sc_fcr.efetuar_baixa_cartao(rg.cd_crt,null,1,now()::timestamp,1,null,true);
             
   end loop;                 
               
  
END;
$$;


ALTER FUNCTION sc_rsc.efetuar_rescisao_cartao_padrao(vp_cartao numeric) OWNER TO scan;

SET search_path = sc_scan_cbe, pg_catalog;

--
-- TOC entry 1616 (class 1255 OID 942598)
-- Name: atualiza_dividas(); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION atualiza_dividas() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  vl_principal numeric;
  vl_encargos numeric;
begin
      for rg in select d.cd_dvd,f.cd_fcr,c.cd_crt,c.dt_ini_atr_crt
            from sc_cbe.tbl_dvd d
              inner join sc_opr.tbl_crt c on c.cd_crt = d.nsu_org_dvd
              inner join sc_fcr.tbl_fcr f on f.cd_fcr = c.cd_fcr
            where st_dvd = 1
              and tp_org_dvd = 1 loop

	select sc_fcr.get_valor_principal_devedor(rg.cd_fcr) into vl_principal;
		
	vl_encargos := 0;
	
	select sum(prc.vl_prc - coalesce(vl_pgt_prc,0))
	into vl_encargos
	from sc_fcr.tbl_prc prc
	   inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
	where opr.cd_top = 23
	  and prc.cd_fcr_atu_prc = rg.cd_fcr;

	if(vl_encargos is null or vl_encargos = 0) then

		select sc_scan_cbe.calcular_encargos_divida_antiga(rg.cd_crt,vl_principal,rg.dt_ini_atr_crt) into vl_encargos;  
		  
	end if;  
	
	if vl_principal = 0  then
	   update sc_cbe.tbl_dvd set st_dvd=5 where cd_dvd = rg.cd_dvd;       
	else
	   update sc_cbe.tbl_dvd set vlr_prn_dvd = vl_principal,vlr_enc_dvd = vl_encargos where cd_dvd = rg.cd_dvd;       
	end if; 

  end loop;            
end$$;


ALTER FUNCTION sc_scan_cbe.atualiza_dividas() OWNER TO scan;

--
-- TOC entry 1513 (class 1255 OID 852643)
-- Name: atualizar_fatura(); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION atualizar_fatura() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  rg2 record;
  
  ct_st_divida_a_renegociar numeric := 1;
  ct_st_divida_renegociada numeric  := 2;
  ct_st_divida_liquidada   numeric  := 3;
  ct_st_divida_cancelada numeric    := 5;  
  ct_st_divida_confirmada numeric    := 6;  

  ct_st_fatura_em_aberto numeric    := 1;
  ct_st_fatura_em_cobranca numeric  := 6;


  
begin


   for rg in select crt.cd_fcr
             from sc_opr.tbl_crt crt 
               inner join sc_cbe.tbl_dvd dvd on dvd.tp_org_dvd = 1 and dvd.nsu_org_dvd = crt.cd_crt
               inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
             where fcr.st_fcr = ct_st_fatura_em_aberto
               and dvd.st_dvd in ( ct_st_divida_liquidada, ct_st_divida_renegociada, ct_st_divida_confirmada )
               and dvd.cd_dvd =  ( select max(cd_dvd) 
                                   from sc_cbe.tbl_dvd 
                                   where tp_org_dvd = 1 
                                     and nsu_org_dvd = crt.cd_crt )
               and not exists (select 1 from sc_scan_cbe.tbl_dlq where cd_dvd = dvd.cd_dvd) loop

         update sc_fcr.tbl_fcr 
            set st_fcr = ct_st_fatura_em_cobranca 
         where cd_fcr = rg.cd_fcr; 
                                     
   end loop;                                  

   for rg2 in select crt.cd_fcr
             from sc_opr.tbl_crt crt 
               inner join sc_cbe.tbl_dvd dvd on dvd.tp_org_dvd = 1 and dvd.nsu_org_dvd = crt.cd_crt
               inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
             where fcr.st_fcr = ct_st_fatura_em_cobranca
               and dvd.st_dvd not in ( ct_st_divida_liquidada, ct_st_divida_renegociada, ct_st_divida_confirmada )
               and dvd.cd_dvd =  ( select max(cd_dvd) 
                                   from sc_cbe.tbl_dvd 
                                   where tp_org_dvd = 1 
                                     and nsu_org_dvd = crt.cd_crt )   loop

         update sc_fcr.tbl_fcr 
         set st_fcr = ct_st_fatura_em_aberto 
         where cd_fcr = rg2.cd_fcr; 
                             
   end loop;                                     
 
end$$;


ALTER FUNCTION sc_scan_cbe.atualizar_fatura() OWNER TO scan;

--
-- TOC entry 1651 (class 1255 OID 938083)
-- Name: calcular_encargos_divida_antiga(numeric, numeric, date); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION calcular_encargos_divida_antiga(vp_cartao numeric, vp_valor_principal numeric, vp_data_divida date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$declare

  vl_qtd_dias_hoje numeric;
  vl_multa numeric;
  vl_jrs_primeiro_periodo numeric;
  vl_jrs_segundo_periodo numeric;

  vl_taxa_primeiro_periodo numeric := 13.5;
  vl_taxa_segundo_periodo numeric := 2.1;
  
begin

 vl_multa := vp_valor_principal * 0.02;

 if current_date < vp_data_divida + 15 then
   vl_jrs_primeiro_periodo = vl_taxa_primeiro_periodo/100/30*vp_valor_principal*(current_date - vp_data_divida);
 else
   vl_jrs_primeiro_periodo = vl_taxa_primeiro_periodo/100/30*vp_valor_principal*15;
 end if;

 vl_qtd_dias_hoje := current_date - (vp_data_divida + 15);
 vl_jrs_segundo_periodo := vl_taxa_segundo_periodo/100/30*vl_qtd_dias_hoje*vp_valor_principal;
 
 if vl_qtd_dias_hoje < 0 then
    vl_qtd_dias_hoje := 0;
 end if;

 return vl_multa + vl_jrs_primeiro_periodo + vl_jrs_segundo_periodo;

end$$;


ALTER FUNCTION sc_scan_cbe.calcular_encargos_divida_antiga(vp_cartao numeric, vp_valor_principal numeric, vp_data_divida date) OWNER TO scan;

--
-- TOC entry 1512 (class 1255 OID 852404)
-- Name: cancelar_divida(); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION cancelar_divida() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_st_divida_a_renegociar numeric := 1;
  ct_st_divida_renegociada numeric  := 2;
  ct_st_divida_cancelada numeric  := 5;

  rg record;

begin

   for rg in select *
             from sc_cbe.tbl_dvd dvd
               inner join sc_opr.tbl_crt crt on crt.cd_crt = dvd.nsu_org_dvd
               inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
             where st_dvd = ct_st_divida_a_renegociar 
               and dvd.tp_org_dvd = 1 
               and fcr.vl_sld_dvd_fcr = 0 loop


         update sc_cbe.tbl_dvd set st_dvd = ct_st_divida_cancelada where cd_dvd = rg.cd_dvd;
         
   end loop;          
end$$;


ALTER FUNCTION sc_scan_cbe.cancelar_divida() OWNER TO scan;

--
-- TOC entry 1688 (class 1255 OID 860942)
-- Name: cobrar_parcela_divida_cartao(numeric); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION cobrar_parcela_divida_cartao(vp_cartao numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  st_parc_cadastrada numeric := 1;
  st_parc_paga numeric := 2;

  st_fcr_aberta numeric := 1;
  st_fcr_cobranca numeric := 6;

  ct_st_divida_a_renegociar numeric := 1;
  ct_st_divida_renegociada numeric  := 2;
  ct_st_divida_liquidada   numeric  := 3;
  ct_st_divida_cancelada numeric    := 5;  
  ct_st_divida_confirmada numeric    := 6;  

  ct_st_acordo_cadastrado numeric := 1;
  ct_st_acordo_confirmado numeric := 2;

  ct_tp_baixa_parcela_boleto numeric := 1;
  ct_tp_baixa_parcela_debito_conta numeric := 2;
  ct_tp_baixa_parcela_empresa_cobranca numeric := 2;

  qtd_dias_desconto numeric := 5;
  qtd_dias_carencia_desconto numeric := 3;

rg record;


BEGIN

  for rg in select crt.cd_Crt,prd.cd_prd
	    from sc_opr.tbl_crt crt
	        inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
		inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt and cnt_crt.prp_cnt_crt = 1
		inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
		inner join sc_cbe.tbl_dvd dvd on dvd.tp_org_dvd = 1 and dvd.nsu_org_dvd = crt.cd_crt
		inner join sc_cbe.tbl_acr acr on acr.cd_dvd = dvd.cd_dvd
		inner join sc_cbe.tbl_prd prd on prd.cd_acr = acr.cd_acr
	    where cnt.vl_sld_cnt > 0
                AND fcr.st_fcr in (st_fcr_aberta, st_fcr_cobranca)
		and prd.st_prd = st_parc_cadastrada
	        and dvd.st_dvd in(ct_st_divida_renegociada,ct_st_divida_confirmada)
	        and acr.st_acr in(ct_st_acordo_cadastrado, ct_st_acordo_confirmado)
                and (prd.dt_vnc_prd <= current_date + qtd_dias_carencia_desconto::integer
                    or
                    (dt_vnc_prd <= current_date + qtd_dias_desconto::integer and coalesce(prd.fg_dbt_aut_prd,'N') = 'S'))
 	        and (crt.cd_crt = vp_cartao or vp_cartao is null)
   loop


	 perform sc_scan_cbe.efetuar_baixa_parcela_cartao(rg.cd_prd, rg.cd_crt, null, now()::timestamp, 1::numeric);

   end loop;

END;
$$;


ALTER FUNCTION sc_scan_cbe.cobrar_parcela_divida_cartao(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1703 (class 1255 OID 1001528)
-- Name: cobrar_parcela_divida_outro_cartao(numeric); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION cobrar_parcela_divida_outro_cartao(vp_cartao numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  st_parc_cadastrada numeric := 1;
  st_parc_paga numeric := 2;

  st_fcr_aberta numeric := 1;
  st_fcr_cobranca numeric := 6;

  ct_st_divida_a_renegociar numeric := 1;
  ct_st_divida_renegociada numeric  := 2;
  ct_st_divida_liquidada   numeric  := 3;
  ct_st_divida_cancelada numeric    := 5;  
  ct_st_divida_confirmada numeric    := 6;  

  ct_st_acordo_cadastrado numeric := 1;
  ct_st_acordo_confirmado numeric := 2;

  ct_tp_baixa_parcela_debito_conta numeric := 1;
  ct_tp_baixa_parcela_empresa_cobranca numeric := 2;

  qtd_dias_desconto numeric := 5;
  qtd_dias_carencia_desconto numeric := 3;

  vl_saldo_restante numeric(13,2); 
  vl_a_transferir numeric(13,2);
  vl_conta_debito numeric;
  vl_conta_credito numeric;

rg record;


BEGIN

  vl_saldo_restante = sc_cnt.get_saldo_cartao(vp_cartao,'S','S');

  if (vl_saldo_restante > 0 ) then

    for rg in select crt.cd_crt as cartao_devedor, sum(prd.vlr_prd - coalesce(prd.vlr_pgt_prd,0)) as saldo_devedor
	    from sc_opr.tbl_crt crt
	        inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	        inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
		inner join sc_cbe.tbl_dvd dvd on dvd.tp_org_dvd = 1 and dvd.nsu_org_dvd = crt.cd_crt
		inner join sc_cbe.tbl_acr acr on acr.cd_dvd = dvd.cd_dvd
		inner join sc_cbe.tbl_prd prd on prd.cd_acr = acr.cd_acr
	    where   fcr.st_fcr in (st_fcr_aberta, st_fcr_cobranca)
		and prd.st_prd = st_parc_cadastrada
	        and dvd.st_dvd in(ct_st_divida_renegociada,ct_st_divida_confirmada)
	        and acr.st_acr in(ct_st_acordo_cadastrado, ct_st_acordo_confirmado)
	        and prd.vlr_prd - coalesce(prd.vlr_pgt_prd,0) > 0
                and (prd.dt_vnc_prd <= current_date + qtd_dias_carencia_desconto::integer
                    or
                    (dt_vnc_prd <= current_date + qtd_dias_desconto::integer and coalesce(prd.fg_dbt_aut_prd,'N') = 'S'))
 	        and exists(select 1 
                             from sc_opr.tbl_crt crt2 
                                inner join sc_cad.tbl_fnc fnc2 on fnc2.cd_fnc = crt2.cd_fnc
                             where fnc2.cd_cun = fnc.cd_cun
                               and crt2.cd_crt <> crt.cd_crt
                               and crt2.cd_crt = vp_cartao)
            group by crt.cd_crt                     
     loop

        if vl_saldo_restante > 0 then 

           vl_a_transferir = 0;	
               
           if(vl_saldo_restante >= rg.saldo_devedor) then
              vl_a_transferir = rg.saldo_devedor;
           else
              vl_a_transferir = vl_saldo_restante;   
           end if;

           -- obtendo a conta de debito
           select cnt_crt.cd_cnt
             into vl_conta_debito
           from sc_opr.tbl_cnt_crt cnt_crt
           where cnt_crt.cd_crt = vp_cartao
             and cnt_crt.fg_pdr_cnt_crt = 'S';
                   
           -- obtendo a conta de credito
           select cnt_crt.cd_cnt
             into vl_conta_credito
           from sc_opr.tbl_cnt_crt cnt_crt
           where cnt_crt.cd_crt = rg.cartao_devedor
            and cnt_crt.fg_pdr_cnt_crt = 'S';
                   
	   perform sc_cnt.lancar_debito_credito(vl_conta_debito,vl_conta_credito,175,null,'TRANSF. PARA QUITAR DIVIDA DE OUTRO CARTAO'::varchar,vl_a_transferir,now()::timestamp,1,5,1000);

           perform sc_scan_cbe.cobrar_parcela_divida_cartao(rg.cartao_devedor);

           vl_saldo_restante := vl_saldo_restante - vl_a_transferir;

       end if;       

     end loop;

  end if;

END;
$$;


ALTER FUNCTION sc_scan_cbe.cobrar_parcela_divida_outro_cartao(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1567 (class 1255 OID 883067)
-- Name: efetuar_baixa_divida_liquidada(numeric); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION efetuar_baixa_divida_liquidada(vp_cartao numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $_$declare

  ct_st_divida_liquidada numeric := 3;
  ct_st_repasse_liquidado numeric := 4;
  ct_tipo_baixa_parcela_repasse numeric := 3;
 
  ct_st_fatura_aberta numeric := 1;
  ct_st_fatura_renegociada numeric := 4;
  ct_st_fatura_em_cobranca numeric := 6;



  ct_tp_pagamento_estorno numeric := 4;

  ct_tp_ocorrencia_liquidacao_divida numeric := 19;

  vl_historico varchar := 'LIQUIDACAO DE DIVIDA';
  vl_historico_comp varchar := '';
 
  rg record;

begin

   for rg in select fcr.*, dvd.cd_dvd
             from sc_cbe.tbl_dvd dvd
               inner join sc_opr.tbl_crt crt on crt.cd_crt = dvd.nsu_org_dvd and dvd.tp_org_dvd = 1
               inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
             where dvd.st_dvd = ct_st_divida_liquidada
               and fcr.st_fcr = ct_st_fatura_em_cobranca
               and crt.cd_crt = coalesce(vp_cartao,crt.cd_crt)
               and not exists (select 1 from sc_scan_cbe.tbl_dlq where cd_dvd = dvd.cd_dvd)
               and NOT exists (select 1 from sc_cbe.tbl_bpr bpr 
                               inner join sc_cbe.tbl_prd prd on prd.cd_prd = bpr.cd_prd
                               inner join sc_cbe.tbl_acr acr on acr.cd_acr = prd.cd_acr
                               where acr.cd_dvd = dvd.cd_dvd
                                 and bpr.tp_bpr = ct_tipo_baixa_parcela_repasse
                                 AND bpr.cd_rce is null)
               AND NOT EXISTS (select 1 from sc_cbe.tbl_rce rce
                               inner join sc_cbe.tbl_bpr bpr on bpr.cd_rce = rce.cd_rce
                               inner join sc_cbe.tbl_prd prd on prd.cd_prd = bpr.cd_prd
                               inner join sc_cbe.tbl_acr acr on acr.cd_acr = prd.cd_acr
                               where acr.cd_dvd = dvd.cd_dvd
                                 AND rce.st_rce <> ct_st_repasse_liquidado)
          loop

         vl_historico_comp := ' SEM BAIXA DE FATURA'; 

         -- se o saldo devedor da fatura for maior que zero efetuar a baixa por ESTORNO
         if rg.vl_sld_dvd_fcr > 0 then

           update sc_fcr.tbl_fcr set st_fcr = ct_st_fatura_aberta where cd_fcr = rg.cd_fcr;
           perform sc_fcr.contabilizar_baixar_cartao(rg.cd_crt, rg.vl_sld_dvd_fcr, ct_tp_pagamento_estorno, now()::timestamp, 1, null);

           vl_historico_comp := ' COM BAIXA DE FATURA POR ESTORNO NO VALOR DE R$ ' || sc_pbl.valor_formato_ptbr(rg.vl_sld_dvd_fcr);

         end if;

         -- marcando a fatura que estava em cobranca para renegociada
         update sc_fcr.tbl_fcr set st_fcr = ct_st_fatura_renegociada where cd_fcr = rg.cd_fcr;

         -- gravando a ocorrencia
	  insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		     values (nextval('sc_opr.sq_ocr'), ct_tp_ocorrencia_liquidacao_divida, rg.cd_crt, null, 
				 vl_historico || vl_historico_comp, 'N', 1, now());

         -- inserindo a divida na tabela de dividas liquidadas
         insert into sc_scan_cbe.tbl_dlq values (rg.cd_dvd, current_date, now(), 1);
         
   end loop;          
end$_$;


ALTER FUNCTION sc_scan_cbe.efetuar_baixa_divida_liquidada(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1699 (class 1255 OID 853330)
-- Name: efetuar_baixa_parcela_cartao(numeric, numeric, numeric, timestamp without time zone, numeric); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION efetuar_baixa_parcela_cartao(vp_cod_parcela numeric, vp_cartao numeric, vp_valor_baixa numeric, vp_data_baixa timestamp without time zone, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  st_parc_cadastrada numeric := 1;
  st_parc_paga numeric := 2;

  ct_st_divida_a_renegociar numeric := 1;
  ct_st_divida_renegociada numeric  := 2;
  ct_st_divida_liquidada   numeric  := 3;
  ct_st_divida_cancelada numeric    := 5;  
  ct_st_divida_confirmada numeric   := 6;  

  ct_st_fatura_em_aberto numeric := 1;
  ct_st_fatura_em_cobranca numeric := 6;

  ct_st_acordo_cadastrado numeric := 1;
  ct_st_acordo_confirmado numeric := 2;

  ct_tp_baixa_parcela_boleto numeric := 1;
  ct_tp_baixa_parcela_debito_conta numeric := 2;  
  ct_tp_baixa_parcela_empresa_cobranca numeric := 2;

  ct_conta_receita_recuperada numeric := 157229;
  ct_tipo_lancamento_receita_cobranca_tercerizada numeric := 1440;
  ct_sistema_baixa_parcela_divida numeric := 26;

  qtd_dias_desconto numeric := 5;
  qtd_dias_carencia_desconto numeric := 3;
  vl_restante numeric := 0;
  vl_pagamento numeric := 0;
  vl_saldo numeric := 0;

  vl_valor_baixa_fatura numeric := 0;
  vl_valor_baixa_receita_cobranca numeric := 0;
  vl_saldo_devedor numeric := 0;
  vl_conta_cartao numeric;

  rg record;

begin


   select sc_cnt.get_saldo_cartao(vp_cartao, 'S', 'S') into vl_saldo;

   if vl_saldo < coalesce(vp_valor_baixa,vl_saldo) then
      raise exception 'VALOR DISPONIVEL MENOR QUE O VALOR DA BAIXA';
   end if;

   vl_restante := coalesce(vp_valor_baixa,vl_saldo);

   select cd_cnt
     into vl_conta_cartao
     from sc_opr.tbl_cnt_crt
   where cd_crt = vp_cartao;
 
   
   for rg in select prd.vlr_prd - coalesce(vlr_pgt_prd,0) as valor_a_pagar,
                    emc.crd_cd_cnt as conta_empresa_cobranca,
                    emc.cd_emc,
                    fcr.cd_fcr,
                    prd.cd_prd,
                    fcr.st_fcr,
                    acr.st_acr,
                    acr.cd_acr,
                    prd.fg_ent_prd
	     from sc_cbe.tbl_prd prd
	       inner join sc_cbe.tbl_acr acr on acr.cd_acr = prd.cd_acr
	       inner join sc_cbe.tbl_dvd dvd on dvd.cd_dvd = acr.cd_dvd
	       inner join sc_opr.tbl_crt crt on crt.cd_crt = dvd.nsu_org_dvd
	       inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
	       inner join sc_cbe.tbl_emc emc on emc.cd_emc = dvd.cd_emc
	       inner join sc_opr.tbl_cnt_crt cnt on cnt.cd_crt = crt.cd_crt
	     where prd.st_prd = st_parc_cadastrada
	       and dvd.st_dvd in( ct_st_divida_renegociada,ct_st_divida_confirmada )
	       and dvd.tp_org_dvd = 1 
	       and dvd.nsu_org_dvd = vp_cartao
	       and acr.st_acr in(ct_st_acordo_cadastrado, ct_st_acordo_confirmado)
	       and (prd.dt_vnc_prd <= current_date + qtd_dias_carencia_desconto::integer
                    or
                    (dt_vnc_prd <= current_date + qtd_dias_desconto::integer and coalesce(prd.fg_dbt_aut_prd,'N') = 'S'))
	       and prd.cd_prd = coalesce(vp_cod_parcela,prd.cd_prd) loop
	       
	  if vl_restante >= rg.valor_a_pagar then
              vl_pagamento := rg.valor_a_pagar;
	  else 
	      vl_pagamento := vl_restante;
	  end if;

          perform sc_cbe.efetuar_baixa_parcela(rg.cd_prd,vl_pagamento,ct_tp_baixa_parcela_debito_conta,vp_data_baixa::date,vp_usuario);        
 
          if rg.st_fcr = ct_st_fatura_em_cobranca then

               vl_valor_baixa_fatura := 0;
               vl_valor_baixa_receita_cobranca := 0;

               select coalesce(vl_sld_dvd_fcr,0)
                into vl_saldo_devedor
               from sc_fcr.tbl_fcr
               where cd_fcr = rg.cd_fcr; 

               if vl_saldo_devedor > 0 then

                 vl_valor_baixa_fatura := vl_pagamento;
                 
                 if vl_valor_baixa_fatura > vl_saldo_devedor then

                    vl_valor_baixa_receita_cobranca := vl_valor_baixa_fatura - vl_saldo_devedor;
                    vl_valor_baixa_fatura := vl_saldo_devedor;

                 end if;

	         update sc_fcr.tbl_fcr set st_fcr = ct_st_fatura_em_aberto where cd_fcr = rg.cd_fcr;
	         perform sc_fcr.efetuar_baixa_cartao(vp_cartao,vl_valor_baixa_fatura,1,now()::timestamp,1,null,false);
	         update sc_fcr.tbl_fcr set st_fcr = ct_st_fatura_em_cobranca where cd_fcr = rg.cd_fcr;

               else

                 vl_valor_baixa_receita_cobranca := vl_pagamento;

               end if;

               if vl_valor_baixa_receita_cobranca > 0 then

                   perform sc_cnt.lancar_debito_credito(vl_conta_cartao, ct_conta_receita_recuperada, ct_tipo_lancamento_receita_cobranca_tercerizada, 
                   null, 'BAIXA PARCELA COBRANCA TERCERIZADA NSU ' || rg.cd_prd, vl_valor_baixa_receita_cobranca, now()::timestamp, 1, ct_sistema_baixa_parcela_divida, rg.cd_prd);
                  
               end if;
	     
	  end if;

	  /*
	  if rg.st_fcr = ct_st_fatura_em_cobranca then
	  
	     update sc_fcr.tbl_fcr set st_fcr = ct_st_fatura_em_aberto where cd_fcr = rg.cd_fcr;
	     perform sc_fcr.efetuar_baixa_cartao(vp_cartao,vl_pagamento,1,now()::timestamp,1,null,false);
	     update sc_fcr.tbl_fcr set st_fcr = ct_st_fatura_em_cobranca where cd_fcr = rg.cd_fcr;
	     
	  end if;
	  */

	  vl_restante := vl_restante - (vl_valor_baixa_fatura + vl_valor_baixa_receita_cobranca);

	  if vl_restante <= 0 then
	     return;
	  end if;
	       
   end loop;	       
end$$;


ALTER FUNCTION sc_scan_cbe.efetuar_baixa_parcela_cartao(vp_cod_parcela numeric, vp_cartao numeric, vp_valor_baixa numeric, vp_data_baixa timestamp without time zone, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1829 (class 1255 OID 1668907)
-- Name: enviar_cobranca(numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION enviar_cobranca(vp_empresa_cobranca numeric, vp_empresa_funcionario numeric, vp_cartao numeric, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  CT_ST_A_RENEGOCIAR constant numeric := 1;
  CT_ST_RENEGOCIADA constant numeric := 2;
  
  CT_ORIGEM_CARTAO constant numeric := 1;
  CT_A_INCLUIR constant numeric := 1;
  
  CT_ST_EM_COBRANCA constant numeric := 6;

  CT_TP_OCR_INCLUSAO_COBRANCA constant numeric:= 37;

  vl_principal numeric := 0;
  vl_ccb numeric := 0;
  vl_compra numeric := 0;
  vl_encargos numeric := 0;
  
  vl_rg record;
  vl_rg_emc record;
begin
   if vp_usuario is null then
     raise exception 'o campo código do usuário não pode ser nulo';
   end if;
   
   --inicio loop das empresas de cobranca
   for vl_rg_emc in select *
                 from sc_cbe.tbl_emc 
                 where cd_emc = coalesce(vp_empresa_cobranca, cd_emc) loop
				 
       --inicio loop dos cartões que devem ser cobrados
	   for vl_rg in select crt.cd_crt, cun.cd_cun,fcr.vl_sld_dvd_fcr,fcr.cd_fcr,
                               (case when crt.fg_ind_crt = 'S' then crt.dt_ini_atr_crt else fcr.dt_vnc_fcr end) as dt_divida
		         from sc_opr.tbl_crt crt
		              INNER JOIN sc_cci.tbl_cci cci on cci.cd_crt = crt.cd_crt
		              inner join sc_Cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
		              inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
		              inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
		         where cci.fg_pas_cbr_cci = 'S' 
		           and crt.cd_crt = coalesce(vp_cartao, crt.cd_crt)
		           AND not exists(select 1
				                  from sc_cbe.tbl_dvd dvd
				                  where dvd.tp_org_dvd = CT_ORIGEM_CARTAO
					                and dvd.nsu_org_dvd = crt.cd_crt
									and dvd.fg_atv_dvd = 'S'
					                and dvd.st_dvd in (CT_ST_A_RENEGOCIAR, CT_ST_RENEGOCIADA))
			       and (vp_cartao is not null OR sc_fcr.calcula_dias_atraso_cartao(current_date, crt.cd_crt) between vl_rg_emc.nr_dia_ini_atr_emc and vl_rg_emc.nr_dia_fim_atr_emc)
			       and fnc.cd_emp = coalesce(vp_empresa_funcionario, fnc.cd_emp) 
			       and fcr.st_fcr <> CT_ST_EM_COBRANCA loop
			  
		vl_ccb := 0;
		select coalesce(sc_fcr.get_valor_principal_ccb(vl_rg.cd_fcr), 0) into vl_ccb;
		
		vl_compra := 0;
		select coalesce(sc_fcr.get_valor_principal_compra(vl_rg.cd_fcr), 0) into vl_compra;
		
		vl_principal := vl_ccb + vl_compra;
		
		vl_encargos := vl_rg.vl_sld_dvd_fcr - vl_principal;
                if vl_encargos < 0 then
                  vl_encargos := 0.0;
                  vl_principal := vl_rg.vl_sld_dvd_fcr;
                end if;

		if vl_principal >= vl_rg_emc.vlr_min_emc then
			insert into sc_cbe.tbl_dvd(cd_dvd, cd_cun, cd_emc, st_dvd, tp_org_dvd, nsu_org_dvd, vlr_prn_dvd, vlr_enc_dvd, 
			                           dt_dvd, cd_inc_usr, dt_inc_usr, fg_atv_dvd, vl_ccb_dvd, vl_cmp_dvd, st_arq_dvd) 
			values (nextval('sc_cbe.sq_dvd'), vl_rg.cd_cun, vl_rg_emc.cd_emc, CT_ST_A_RENEGOCIAR, CT_ORIGEM_CARTAO, vl_rg.cd_crt, vl_principal, coalesce(vl_encargos,0),
			        vl_rg.dt_divida, vp_usuario, now(), 'S', vl_ccb, vl_compra, CT_A_INCLUIR);
					
			insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, 
			                           nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		    values(nextval('sc_opr.sq_ocr'), CT_TP_OCR_INCLUSAO_COBRANCA, vl_rg.cd_crt, null, 
				   'INCLUSAO NA EMPRESA DE COBRANCA '|| vl_rg_emc.nm_emc || ' DIVIDA DE: ' || to_char(vl_rg.dt_divida, 'dd/mm/yyyy') || ' VALOR DE CCB: ' || vl_ccb ||
				   ' VALOR DE COMPRA: ' || vl_compra || ' VALOR DE ENCARGOS: ' || coalesce(vl_encargos,0) || ' VALOR TOTAL DA DÍVIDA: ' || vl_rg.vl_sld_dvd_fcr, 'N', 1, now());	
        end if;					  

	   end loop;
    end loop;
end$$;


ALTER FUNCTION sc_scan_cbe.enviar_cobranca(vp_empresa_cobranca numeric, vp_empresa_funcionario numeric, vp_cartao numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1827 (class 1255 OID 844352)
-- Name: enviar_cobranca_old(numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION enviar_cobranca_old(vp_empresa_cobranca numeric, vp_empresa_funcionario numeric, vp_cartao numeric, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  ct_st_divida_a_renegociar numeric := 1;
  ct_st_divida_renegociada numeric  := 2;

  ct_tp_ocorrencia_alteracao_dados_cobranca numeric := 21;

  vl_principal numeric := 0;
  vl_encargos numeric := 0;
  rg record;
  rg_emc record;
  vl_cod_divida numeric;
  vl_cod_empresa_atual numeric;
  vl_empresa_atual varchar;
  vl_empresa_nova varchar;

begin

   if vp_empresa_cobranca is not null and vp_cartao is not null then

      select cd_dvd, cd_emc
       into vl_cod_divida, vl_cod_empresa_atual
      from sc_cbe.tbl_dvd 
      where nsu_org_dvd = vp_cartao
        and fg_atv_dvd = 'S'
        and cd_emc <> vp_empresa_cobranca;

      if vl_cod_divida is not null then

         -- retornando a empresa atual
         select nm_emc into vl_empresa_atual from sc_cbe.tbl_emc where cd_emc = vl_cod_empresa_atual;

         -- retornando a nova empresa
         select nm_emc into vl_empresa_nova from sc_cbe.tbl_emc where cd_emc = vp_empresa_cobranca;

         -- alterando a empresa de cobranca
	 update sc_cbe.tbl_dvd set cd_emc = vp_empresa_cobranca, cd_act = null where cd_dvd = vl_cod_divida;
	 
	  -- gravando a ocorrencia
	  insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		     values (nextval('sc_opr.sq_ocr'), ct_tp_ocorrencia_alteracao_dados_cobranca, vp_cartao, null, 
				 'ALTERADO DA EMPRESA DE COBRANCA DE '|| vl_empresa_atual || ' PARA ' || vl_empresa_nova, 'N', 1, now());

          return;	 
	 
      end if;

   end if;

   for rg_emc in select *
                 from sc_cbe.tbl_emc 
                 where cd_emc = coalesce(vp_empresa_cobranca,cd_emc) loop

	   for rg in select crt.cd_crt, cun.cd_cun,fcr.vl_sld_dvd_fcr,crt.dt_ini_atr_crt,fcr.cd_fcr
		     from sc_opr.tbl_crt crt
		       INNER JOIN sc_cci.tbl_cci cci on cci.cd_crt = crt.cd_crt
		       inner join sc_Cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
		       inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
		       inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
		     where cci.fg_pas_cbr_cci = 'S' 
		          and crt.cd_crt = coalesce(vp_cartao,crt.cd_crt)
		          AND not exists(select 1
				      from sc_cbe.tbl_dvd dvd
				      where dvd.tp_org_dvd = 1
					and dvd.nsu_org_dvd = crt.cd_crt
					and dvd.st_dvd in(ct_st_divida_a_renegociar,ct_st_divida_renegociada))
			  and (vp_cartao is not null OR sc_fcr.calcula_dias_atraso_cartao(current_date,crt.cd_crt) between rg_emc.nr_dia_ini_atr_emc and rg_emc.nr_dia_fim_atr_emc)
			  and fnc.cd_emp = coalesce(vp_empresa_funcionario, fnc.cd_emp) 
			  and crt.cd_crt = coalesce(vp_cartao, crt.cd_crt) 
			  and fcr.st_fcr <> 6 --EM COBRANCA
			      loop
			  
		vl_principal := 0;
		
		select sc_fcr.get_valor_principal_devedor(rg.cd_fcr) into vl_principal;
		
		vl_encargos := 0;
		
		select sum(prc.vl_prc - coalesce(vl_pgt_prc,0))
		into vl_encargos
		from sc_fcr.tbl_prc prc
		   inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
		where opr.cd_top = 23
		  and prc.cd_fcr_atu_prc = rg.cd_fcr;

		if(vl_encargos is null or vl_encargos = 0) then

			/*select sum(prc.vl_prc - coalesce(vl_pgt_prc,0))
			into vl_encargos
			from sc_fcr.tbl_prc prc
			   inner join sc_opr.tbl_opr opr on opr.cd_opr = prc.cd_opr
			where opr.cd_top in (6,7)
			  and prc.cd_fcr_atu_prc = rg.cd_fcr;*/

			select sc_scan_cbe.calcular_encargos_divida_antiga(rg.cd_crt,vl_principal,rg.dt_ini_atr_crt) into vl_encargos;  
			  
		end if;  

		if vl_principal >= rg_emc.vlr_min_emc then

			insert into sc_cbe.tbl_dvd(cd_dvd,cd_cun,cd_emc,st_dvd,tp_org_dvd,nsu_org_dvd,vlr_prn_dvd,vlr_enc_dvd,dt_dvd,cd_inc_usr,dt_inc_usr,fg_atv_dvd) values          
					  (nextval('sc_cbe.sq_dvd'),rg.cd_cun,rg_emc.cd_emc,ct_st_divida_a_renegociar,1,rg.cd_crt,vl_principal,coalesce(vl_encargos,0),rg.dt_ini_atr_crt,vp_usuario,now(),'S');
                end if;					  

	   end loop;                            
	   
    end loop;	   
	   

end$$;


ALTER FUNCTION sc_scan_cbe.enviar_cobranca_old(vp_empresa_cobranca numeric, vp_empresa_funcionario numeric, vp_cartao numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1738 (class 1255 OID 1014260)
-- Name: enviar_email_baixa_debito_em_conta(); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION enviar_email_baixa_debito_em_conta() RETURNS void
    LANGUAGE plpgsql
    AS $$declare 

rg record;

count numeric := 1;

vl_emails varchar := 'risco@somacontadigital.com.br';

vl_cabecalho text;
vl_capturados text := '';
vl_mensagem text := '';
vl_separador varchar := '';

vl_soma_capturados numeric := 0;

vl_empresa_anterior numeric;

begin


  vl_cabecalho := '<!DOCTYPE html>' || chr(10);
  vl_cabecalho := vl_cabecalho || '<html>' || chr(10);
  vl_cabecalho := vl_cabecalho || '<head>' || chr(10);
  --vl_cabecalho := vl_cabecalho || '<meta http-equiv="Content-Type" content="text/html; charset=utf-8">' || chr(10);
  vl_cabecalho := vl_cabecalho || '<style type="text/css">' || chr(10);
  vl_cabecalho := vl_cabecalho || '.tabela {' || chr(10);
  vl_cabecalho := vl_cabecalho || '	width: 100%;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	font-family: Arial;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	font-size: 10pt;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	border-collapse: collapse;' || chr(10);
  vl_cabecalho := vl_cabecalho || '}' || chr(10);
  vl_cabecalho := vl_cabecalho || '.tabela th {' || chr(10);
  vl_cabecalho := vl_cabecalho || '	padding: 2px;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	text-align: center;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	border: 1px solid #f2aa5c;' || chr(10);
  vl_cabecalho := vl_cabecalho || '}' || chr(10);
  vl_cabecalho := vl_cabecalho || '.tabela td {' || chr(10);
  vl_cabecalho := vl_cabecalho || '	padding: 2px;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	border: 1px solid #f2aa5c;' || chr(10);
  vl_cabecalho := vl_cabecalho || '}' || chr(10);
  vl_cabecalho := vl_cabecalho || '.tabela thead tr {' || chr(10);
  vl_cabecalho := vl_cabecalho || '	background: #f7be80;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	color: white;' || chr(10);
  vl_cabecalho := vl_cabecalho || '}' || chr(10);
  vl_cabecalho := vl_cabecalho || '.tabela tfoot tr {' || chr(10);
  vl_cabecalho := vl_cabecalho || '	background: #f69730;' || chr(10);
  vl_cabecalho := vl_cabecalho || '	color: #FFF;' || chr(10);
  vl_cabecalho := vl_cabecalho || '}' || chr(10);
  vl_cabecalho := vl_cabecalho || '.impar {' || chr(10);
  vl_cabecalho := vl_cabecalho || '	background:#CCC;' || chr(10);
  vl_cabecalho := vl_cabecalho || '}' || chr(10);
  vl_cabecalho := vl_cabecalho || '</style>' || chr(10);
  vl_cabecalho := vl_cabecalho || '</head>' || chr(10);
  vl_cabecalho := vl_cabecalho || '<body>' || chr(10);

  
  for rg in select emc.cd_emc, emc.nm_emc, cun.nm_cun, cun.nr_cpf_cnpj_cun, crt.cd_crt, pfc.*
	  from sc_fcr.tbl_pfc pfc
	  inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = pfc.cd_fcr
	  inner join sc_opr.tbl_crt crt on crt.cd_crt = fcr.cd_crt
	  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
	  inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	  inner join sc_cbe.tbl_dvd dvd on dvd.nsu_org_dvd = crt.cd_crt
	  inner join sc_cbe.tbl_emc emc on emc.cd_emc = dvd.cd_emc
	where pfc.st_pfc = 1
	  and pfc.dt_rcb_pfc >= current_date - 1
	  and pfc.dt_rcb_pfc < current_date
	order by dvd.cd_emc
  loop       

     if vl_empresa_anterior is null then
        vl_empresa_anterior := rg.cd_emc;
     end if;

     if vl_empresa_anterior <> rg.cd_emc then

        vl_mensagem = vl_mensagem || '<br><br>' || vl_cabecalho;

        if vl_capturados <> '' then
          vl_mensagem := vl_mensagem || vl_capturados || '</tbody>' || chr(10);
          vl_mensagem := vl_mensagem || '<tfoot>'|| chr(10);
	  vl_mensagem := vl_mensagem || '<th colspan="4" />'|| chr(10);
          vl_mensagem := vl_mensagem || '<th style="text-align:right">'|| sc_pbl.valor_formato_ptbr(vl_soma_capturados) ||'</th>'|| chr(10);
          vl_mensagem := vl_mensagem || '</tfoot>'|| chr(10);
          vl_mensagem := vl_mensagem || '</table>'|| chr(10);
          vl_separador := '<br><br>'|| chr(10);
        end if;

        --vl_mensagem := vl_mensagem || '</body>'|| chr(10) ||'</html>';

        --vl_mensagem := convert_to(vl_mensagem,'UTF8');
        
        begin
 
          --perform sc_pbl.enviar_email_saqpag(vl_emails, 'Soma Conta Digital - Cartões com renegociação que sofreram captura', vl_mensagem, null);  

        exception when others then

        end;

        vl_capturados := '';

        vl_soma_capturados := 0;
        
        vl_empresa_anterior := rg.cd_emc;
     
     end if;
     

     if vl_capturados = '' then
	 
     count := 0;

     vl_capturados = '<table class="tabela">' || chr(10);
     vl_capturados := vl_capturados || '<thead>' || chr(10);
     vl_capturados := vl_capturados || '<tr>' || chr(10);
     vl_capturados := vl_capturados || '<th colspan="5" style="color:green;">' || rg.nm_emc || chr(10);
     vl_capturados := vl_capturados || '</tr>' || chr(10);	
     vl_capturados := vl_capturados || '<tr>' || chr(10);
     vl_capturados := vl_capturados || '<th>CPF</th>' || chr(10);
     vl_capturados := vl_capturados || '<th>Nome</th>' || chr(10);
     vl_capturados := vl_capturados || '<th>Cartão</th>' || chr(10);
     vl_capturados := vl_capturados || '<th>Data do Pagamento</th>' || chr(10);
     vl_capturados := vl_capturados || '<th>Valor do Pagamento</th>' || chr(10);
     vl_capturados := vl_capturados || '</tr>' || chr(10);
     vl_capturados := vl_capturados || '</thead>' || chr(10);
     vl_capturados := vl_capturados || '<tbody>' || chr(10);

     end if;

     vl_capturados := vl_capturados || '<tr class="' || case when mod(count,2) = 0 then '' else 'impar' end || '">' || chr(10);
     vl_capturados := vl_capturados || '<td>'|| rg.nr_cpf_cnpj_cun ||'</td>' || chr(10);
     vl_capturados := vl_capturados || '<td>'|| rg.nm_cun ||'</td>' || chr(10);
     vl_capturados := vl_capturados || '<td>'|| rg.cd_crt ||'</td>' || chr(10);
     vl_capturados := vl_capturados || '<td align="center">'|| to_char(rg.dt_pgt_pfc,'dd/MM/yyyy') ||'</td>' || chr(10);
     vl_capturados := vl_capturados || '<td align="right">'|| sc_pbl.valor_formato_ptbr(rg.vl_pfc) ||'</td>' || chr(10);
     vl_capturados := vl_capturados || '</tr>';

     vl_soma_capturados := vl_soma_capturados + rg.vl_pfc;
     

  end loop;


  if vl_capturados <> '' then

        vl_mensagem = vl_mensagem || '<br><br>' || vl_cabecalho;

        vl_mensagem := vl_mensagem || vl_capturados || '</tbody>' || chr(10);
        vl_mensagem := vl_mensagem || '<tfoot>'|| chr(10);
	vl_mensagem := vl_mensagem || '<th colspan="4" />'|| chr(10);
        vl_mensagem := vl_mensagem || '<th style="text-align:right">'|| sc_pbl.valor_formato_ptbr(vl_soma_capturados) ||'</th>'|| chr(10);
        vl_mensagem := vl_mensagem || '</tfoot>'|| chr(10);
        vl_mensagem := vl_mensagem || '</table>'|| chr(10);
        vl_separador := '<br><br>'|| chr(10);
        
        vl_mensagem := vl_mensagem || '</body>'|| chr(10) ||'</html>';

        
        begin
 
          perform sc_pbl.enviar_email_saqpag(vl_emails, 'Soma Conta Digital - Cartões com renegociação que sofreram captura', vl_mensagem, null);  

        exception when others then

        end;
         
   end if;
     
  exception when others then
    raise 'ERRO NO ENVIO DE EMAIL CARTOES COM RENEGOCIACAO QUE SOFRERAM CAPTURAS %', sqlerrm;
end;$$;


ALTER FUNCTION sc_scan_cbe.enviar_email_baixa_debito_em_conta() OWNER TO scan;

--
-- TOC entry 7876 (class 0 OID 0)
-- Dependencies: 1738
-- Name: FUNCTION enviar_email_baixa_debito_em_conta(); Type: COMMENT; Schema: sc_scan_cbe; Owner: scan
--

COMMENT ON FUNCTION enviar_email_baixa_debito_em_conta() IS 'funcao que envia email com as baixas realizadas via debito em conta do dia anterior';


--
-- TOC entry 1818 (class 1255 OID 1668908)
-- Name: excluir_pagos_cobranca(); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION excluir_pagos_cobranca() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  CT_ST_A_RENEGOCIAR constant numeric := 1;
  
  CT_ORIGEM_CARTAO constant numeric := 1;
  CT_MOTIVO_PAGAMENTO constant numeric := 1;
  CT_A_EXCLUIR constant numeric := 3;
  
  CT_TP_OCR_EXCLUSAO_COBRANCA constant numeric:= 38;

  vl_rg record;
begin
   --inicio loop das empresas de cobranca
   for vl_rg in select dvd.cd_dvd as codigo_divida, emc.nm_emc as empresa_cobranca, crt.cd_crt as cartao, dvd.dt_dvd as data_divida,
                       dvd.vlr_prn_dvd as valor_principal, dvd.vlr_enc_dvd as valor_encargos, dvd.vlr_prn_dvd + dvd.vlr_enc_dvd as valor_total_divida
                from sc_cbe.tbl_dvd dvd 
                     inner join sc_opr.tbl_crt crt on dvd.nsu_org_dvd::numeric = crt.cd_crt and dvd.tp_org_dvd = 1
                     inner join sc_fcr.tbl_fcr fcr on crt.cd_fcr = fcr.cd_fcr
                     inner join sc_cbe.tbl_emc emc on dvd.cd_emc = emc.cd_emc
                where dvd.st_dvd = CT_ST_A_RENEGOCIAR
                  and dvd.fg_atv_dvd = 'S'
                  and dvd.dt_dvd < crt.dt_ini_atr_crt loop
				  
		update sc_cbe.tbl_dvd
		   set fg_atv_dvd = 'N',
		       st_arq_dvd = CT_A_EXCLUIR,
			   mtv_exc_dvd = CT_MOTIVO_PAGAMENTO
	    where cd_dvd = vl_rg.codigo_divida;
		
		insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, 
			                       nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		values(nextval('sc_opr.sq_ocr'), CT_TP_OCR_EXCLUSAO_COBRANCA, vl_rg.cartao, null, 
		       'EXCLUSAO NA EMPRESA DE COBRANCA '|| vl_rg.empresa_cobranca || ' DIVIDA DE: ' || to_char(vl_rg.data_divida, 'dd/mm/yyyy') || ' VALOR PRINCIPAL: ' || vl_rg.valor_principal ||
			   ' VALOR DE ENCARGOS: ' || vl_rg.valor_encargos || ' VALOR TOTAL DA DÍVIDA: ' || vl_rg.valor_total_divida, 'N', 1, now());
	end loop;
end;$$;


ALTER FUNCTION sc_scan_cbe.excluir_pagos_cobranca() OWNER TO scan;

--
-- TOC entry 1820 (class 1255 OID 1668909)
-- Name: excluir_todos_cobranca(); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION excluir_todos_cobranca() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  CT_ST_A_RENEGOCIAR constant numeric := 1;
  
  CT_ORIGEM_CARTAO constant numeric := 1;
  CT_MOTIVO_LIMPEZA_BASE constant numeric := 2;
  CT_A_EXCLUIR constant numeric := 3;
  
  CT_TP_OCR_EXCLUSAO_COBRANCA constant numeric:= 38;

  vl_rg record;
begin
   --inicio loop das empresas de cobranca
   for vl_rg in select dvd.cd_dvd as codigo_divida, emc.nm_emc as empresa_cobranca, crt.cd_crt as cartao, dvd.dt_dvd as data_divida,
                       dvd.vlr_prn_dvd as valor_principal, dvd.vlr_enc_dvd as valor_encargos, dvd.vlr_prn_dvd + dvd.vlr_enc_dvd as valor_total_divida
                from sc_cbe.tbl_dvd dvd 
                     inner join sc_opr.tbl_crt crt on dvd.nsu_org_dvd::numeric = crt.cd_crt and dvd.tp_org_dvd = 1
                     inner join sc_cbe.tbl_emc emc on dvd.cd_emc = emc.cd_emc
                where dvd.st_dvd = CT_ST_A_RENEGOCIAR
                  and dvd.fg_atv_dvd = 'S' loop
				  
		update sc_cbe.tbl_dvd
		   set fg_atv_dvd = 'N',
		       st_arq_dvd = CT_A_EXCLUIR,
			   mtv_exc_dvd = CT_MOTIVO_LIMPEZA_BASE
	    where cd_dvd = vl_rg.codigo_divida;
		
		insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, 
			                       nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		values(nextval('sc_opr.sq_ocr'), CT_TP_OCR_EXCLUSAO_COBRANCA, vl_rg.cartao, null, 
		       'EXCLUSAO NA EMPRESA DE COBRANCA '|| vl_rg.empresa_cobranca || ' DIVIDA DE: ' || to_char(vl_rg.data_divida, 'dd/mm/yyyy') || ' VALOR PRINCIPAL: ' || vl_rg.valor_principal ||
			   ' VALOR DE ENCARGOS: ' || vl_rg.valor_encargos || ' VALOR TOTAL DA DÍVIDA: ' || vl_rg.valor_total_divida, 'N', 1, now());
	end loop;
end;$$;


ALTER FUNCTION sc_scan_cbe.excluir_todos_cobranca() OWNER TO scan;

--
-- TOC entry 1684 (class 1255 OID 983653)
-- Name: processar_repasse(numeric, numeric); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION processar_repasse(vp_codigo numeric, vp_usuario numeric DEFAULT (1)::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  rg_bpr record;

  vl_lancamento_contrapartida numeric;  
  vl_principal numeric;
  vl_encargos numeric;

  ct_st_fatura_em_aberto numeric := 1;
  ct_st_fatura_em_cobranca numeric := 6;

  ct_repasse_processado numeric := 2;
  ct_repasse_liquidado numeric := 4;

  ct_conta_banco numeric := 469;
  ct_conta_transitoria_cobranca_tercerizada numeric := 182921;
  ct_conta_fornecedores_diversos numeric :=  19083;
  ct_conta_receita_recuperada numeric := 157229;
  ct_tipo_lancamento_receb_repasse numeric := 1435;
  ct_tipo_lancamento_despesa_comissao numeric := 1437;
  ct_tipo_lancamento_receita_cobranca_tercerizada numeric := 1440;
  ct_sistema_repasse_cob_externa numeric := 32;
  ct_tipo_despesa_comissao_cobranca numeric := 124;
  ct_fornecedor_comissao_cobranca numeric := 420; 
  

  vl_saldo_devedor numeric := 0;
  vl_valor_baixa_fatura numeric := 0;
  vl_valor_baixa_receita_cobranca numeric := 0;
  
begin
  for rg in select rce.*, emc.dbt_cd_cnt
            from sc_cbe.tbl_rce rce
              inner join sc_cbe.tbl_emc emc on emc.cd_emc = rce.cd_emc
            where rce.st_rce = ct_repasse_processado -- PROCESSADO
              AND rce.cd_rce = coalesce(vp_codigo,rce.cd_rce)
  loop

        -- efetuar lancamento na conta transitoria
        select nextval('sc_cnt.sq_lcn') into vl_lancamento_contrapartida;

        
        perform sc_cnt.lancar_movimento(vl_lancamento_contrapartida, null, ct_tipo_lancamento_receb_repasse, 
                                        ct_conta_transitoria_cobranca_tercerizada, 'D', rg.vl_bpr_rce, now()::timestamp, vp_usuario, null,
                                        'REPASSE DE COBRANCA EXTERNA NSU ' || rg.cd_rce, ct_sistema_repasse_cob_externa, rg.cd_rce);

        -- efetuar as baixas nos cartoes
        for rg_bpr in select bpr.vl_bpr, cnt.cd_cnt, dvd.nsu_org_dvd, crt.cd_fcr, fcr.st_fcr
            from sc_cbe.tbl_bpr bpr
              inner join sc_cbe.tbl_prd prd on prd.cd_prd = bpr.cd_prd
              inner join sc_cbe.tbl_acr acr on acr.cd_acr = prd.cd_acr
	      inner join sc_cbe.tbl_dvd dvd on dvd.cd_dvd = acr.cd_dvd
	      inner join sc_opr.tbl_crt crt on crt.cd_crt = dvd.nsu_org_dvd
	      inner join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr
	      --inner join sc_cbe.tbl_emc emc on emc.cd_emc = dvd.cd_emc
	      inner join sc_opr.tbl_cnt_crt cnt on cnt.cd_crt = crt.cd_crt
            where cd_rce = rg.cd_rce 
	loop

             -- efetuar lancamento na conta do cartao
             perform sc_cnt.lancar_movimento(null, vl_lancamento_contrapartida, ct_tipo_lancamento_receb_repasse, 
                                             rg_bpr.cd_cnt, 'C', rg_bpr.vl_bpr, now()::timestamp, vp_usuario, null,
                                            'REPASSE DE COBRANCA EXTERNA NSU ' || rg.cd_rce, ct_sistema_repasse_cob_externa, rg.cd_rce);
	     

             if rg_bpr.st_fcr = ct_st_fatura_em_cobranca then

               vl_valor_baixa_fatura := 0;
               vl_valor_baixa_receita_cobranca := 0;

               select coalesce(vl_sld_dvd_fcr,0)
                into vl_saldo_devedor
               from sc_fcr.tbl_fcr
               where cd_fcr = rg_bpr.cd_fcr; 

               if vl_saldo_devedor > 0 then

                 vl_valor_baixa_fatura := rg_bpr.vl_bpr;
                 
                 if vl_valor_baixa_fatura > vl_saldo_devedor then

                    vl_valor_baixa_receita_cobranca := vl_valor_baixa_fatura - vl_saldo_devedor;
                    vl_valor_baixa_fatura := vl_saldo_devedor;

                 end if;
	  
	         update sc_fcr.tbl_fcr set st_fcr = ct_st_fatura_em_aberto where cd_fcr = rg_bpr.cd_fcr;
	         perform sc_fcr.efetuar_baixa_cartao(rg_bpr.nsu_org_dvd,vl_valor_baixa_fatura,1,rg.dt_cmp_bnc_rce,vp_usuario,null,false);
	         update sc_fcr.tbl_fcr set st_fcr = ct_st_fatura_em_cobranca where cd_fcr = rg_bpr.cd_fcr;

               else

                 vl_valor_baixa_receita_cobranca := rg_bpr.vl_bpr;

               end if;

               if vl_valor_baixa_receita_cobranca > 0 then

                   -- caso o valor da baixa for maior que o debito contabilizar como receita
                   perform sc_cnt.lancar_debito_credito(rg_bpr.cd_cnt, ct_conta_receita_recuperada, ct_tipo_lancamento_receita_cobranca_tercerizada, 
                   null, 'REPASSE DE COBRANCA EXTERNA NSU ' || rg.cd_rce, vl_valor_baixa_receita_cobranca, now()::timestamp, vp_usuario, ct_sistema_repasse_cob_externa, rg.cd_rce);
                  
               end if;
	     
	     end if;

	END LOOP;

        -- efetuar o lancamento de comissao
        perform sc_cnt.lancar_debito_credito(ct_conta_fornecedores_diversos, ct_conta_transitoria_cobranca_tercerizada, ct_tipo_lancamento_despesa_comissao, null, 
                                             'DESPESA COMISSAO REPASSE COBRANCA NSU ' || rg.cd_rce, rg.vl_cms_rce, now()::timestamp, vp_usuario, ct_sistema_repasse_cob_externa, rg.cd_rce);

        -- efetuar o lancamento no banco
        --(NAO SE FAZ NECESSARIO O LANCAMENTO NO BANCO POIS JA EH REALIZADO NO FINANCEIRO)
        --perform sc_cnt.lancar_debito_credito(ct_conta_banco, ct_conta_transitoria_cobranca_tercerizada, ct_tipo_lancamento_receb_repasse, null, 
        --                                     'REPASSE DE COBRANCA EXTERNA NSU ' || rg.cd_rce, rg.vl_bpr_rce - rg.vl_cms_rce, rg.dt_cmp_bnc_rce, vp_usuario, ct_sistema_repasse_cob_externa, rg.cd_rce);                                     

        -- inserindo contas a pagar para a comissao
        insert into sc_cap.tbl_dsp(cd_dsp,cd_cdc,cd_frn,cd_tdp,st_dsp,vl_dsp,dt_ref_dsp,dt_pgt_dsp,tp_pgt_dsp,ds_dsp,cd_inc_usr,dt_inc_usr,nr_prc_dsp,tp_dbt_dsp,ord_prc_dsp,vl_prc_dsp)
                            values(nextval('sc_cap.sq_dsp'),1,ct_fornecedor_comissao_cobranca,ct_tipo_despesa_comissao_cobranca,3,rg.vl_cms_rce,rg.dt_rce,rg.dt_cmp_bnc_rce,2,'REF COMISSAO REPASSE COBRANCA',vp_usuario,now(),1,1,1,rg.vl_cms_rce);

        -- atualizando o repasse como liquidado
        update sc_cbe.tbl_rce set st_rce = ct_repasse_liquidado where cd_rce = rg.cd_rce;
        
  end loop;            
end$$;


ALTER FUNCTION sc_scan_cbe.processar_repasse(vp_codigo numeric, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 1254 (class 1255 OID 1001951)
-- Name: quebrar_acordo(numeric); Type: FUNCTION; Schema: sc_scan_cbe; Owner: scan
--

CREATE FUNCTION quebrar_acordo(vp_empresa numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  st_divida_a_renegociar numeric := 1;
  st_divida_acordo_descumprido numeric := 4;
 
  st_acordo_cadastrado numeric := 1;
  st_acordo_confirmado numeric := 2;
  st_acordo_descumprido numeric := 4;
  st_acordo_cancelado numeric := 5;
  
  st_parcela_cadastrada numeric := 1;
  st_parcela_cancelada numeric := 3;

  ct_dias_atraso_parcela_acordo_nao_confirmado numeric := 5;
  ct_dias_atraso_parcela_acordo_confirmado numeric := 33;
  ct_qtd_parcelas_em_atraso numeric := 2;
  ct_tp_ocorrencia_quebra_acordo numeric := 20;

  CT_SITUACAO_DIVIDA_RENEGOCIADA numeric := 2;
  vl_quantidade numeric := 0;
  vl_saldo_devedor numeric(13,2) := 0;

  TP_OPERACAO_JUROS sc_opr.tbl_top.cd_top%type := 7;
  vl_cod_operacao numeric;
  vl_plastico numeric;
  vl_cod_fatura_atual numeric;
  vl_dt_vnc_fatura date;
  vl_saldo_devedor_fatura numeric(13,2) := 0;
  vl_parcela_juros numeric(13,2) := 0;

  rg record;
  rg_emc record;
  rg_acr record;
  
begin



for rg_emc in select cd_emc
                 from sc_cbe.tbl_emc 
                 where cd_emc = coalesce(vp_empresa,cd_emc) loop

   -- cancelando acordos nao confirmados

   for rg in 
     select acr.cd_acr, acr.cd_dvd, dvd.nsu_org_dvd
     from sc_cbe.tbl_acr acr
       inner join sc_cbe.tbl_prd prd on prd.cd_acr = acr.cd_acr
       inner join sc_cbe.tbl_dvd dvd on dvd.cd_acr = acr.cd_acr
     where dvd.cd_emc = rg_emc.cd_emc
       and acr.st_acr = st_acordo_cadastrado
       and prd.st_prd = st_parcela_cadastrada
       and prd.dt_vnc_prd + ct_dias_atraso_parcela_acordo_nao_confirmado * interval '1 day'  < current_date
     group by acr.cd_acr, acr.cd_dvd, dvd.nsu_org_dvd
   loop    

      -- cancelando as parcelas do acordo
      update sc_cbe.tbl_prd set st_prd = st_parcela_cancelada where cd_acr = rg.cd_acr;

      -- cancelando o acordo
      update sc_cbe.tbl_acr set st_acr = st_acordo_cancelado where cd_acr = rg.cd_acr;

      -- retornando a divida para a renegociar
      update sc_cbe.tbl_dvd set st_dvd = st_divida_a_renegociar where cd_dvd = rg.cd_dvd;


      -- gravando a ocorrencia
	  insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		     values (nextval('sc_opr.sq_ocr'), ct_tp_ocorrencia_quebra_acordo, rg.nsu_org_dvd, null, 
				 'CANCELAMENTO DE ACORDO NAO CONFIRMADO NSU '|| rg.cd_acr, 'N', 1, now());
   
   end loop;


   -- cancelando acordos ja confirmados (descumpridos)
   for rg in 
     select acr.cd_acr, acr.cd_dvd, dvd.nsu_org_dvd
     from sc_cbe.tbl_acr acr
       inner join sc_cbe.tbl_prd prd on prd.cd_acr = acr.cd_acr
       inner join sc_cbe.tbl_dvd dvd on dvd.cd_acr = acr.cd_acr
     where dvd.cd_emc = rg_emc.cd_emc
       and acr.st_acr = st_acordo_confirmado
       and prd.st_prd = st_parcela_cadastrada
       and prd.dt_vnc_prd + ct_dias_atraso_parcela_acordo_confirmado * interval '1 day'  < current_date
       and prd.nr_prd = (select min(nr_prd) from sc_cbe.tbl_prd where cd_acr = acr.cd_acr and st_prd = st_parcela_cadastrada)
       --and acr.cd_acr = 431
     group by acr.cd_acr, acr.cd_dvd, dvd.nsu_org_dvd
   loop    

      -- gerando uma nova dívida com o valor de saldo devedor
      select sum(vlr_prd - coalesce(vlr_pgt_prd,0))
        into vl_saldo_devedor
        from sc_cbe.tbl_prd
      where cd_acr = rg.cd_acr
        and st_prd = st_parcela_cadastrada;  
      
      insert into sc_cbe.tbl_dvd
      select nextval('sc_cbe.sq_dvd') as cd_dvd,cd_cun,cd_emc,null as cd_acr, st_divida_a_renegociar as st_dvd,tp_org_dvd,nsu_org_dvd,vl_saldo_devedor as vlr_prn_dvd, 0 as vlr_enc_dvd,now() as dt_dvd, 1 as cd_inc_usr, now() as dt_inc_usr, null as cd_alt_usr, null as dt_alt_usr,'S' as fg_atv_dvd, null as cd_act
      from sc_cbe.tbl_dvd
      where cd_dvd = rg.cd_dvd;

      -- gravando a ocorrencia
	  insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		     values (nextval('sc_opr.sq_ocr'), ct_tp_ocorrencia_quebra_acordo, rg.nsu_org_dvd, null, 
				 'DESCUMPRIMENTO DE ACORDO NSU '|| rg.cd_acr, 'N', 1, now());

       -- cancelando as parcelas do acordo que estao em aberto
      update sc_cbe.tbl_prd set st_prd = st_parcela_cancelada where cd_acr = rg.cd_acr and st_prd = st_parcela_cadastrada;

      -- marcando o acordo como descumprido
      update sc_cbe.tbl_acr set st_acr = st_acordo_descumprido where cd_acr = rg.cd_acr;

      -- marcando a divida referenciada ao acordo descumprido 
      -- como divida de acordo descumprido
      update sc_cbe.tbl_dvd set st_dvd = st_divida_acordo_descumprido where cd_dvd = rg.cd_dvd;
      

      -- verificando saldo devedor da fatura
      select crt.cd_fcr, fcr.dt_vnc_fcr, coalesce(fcr.vl_sld_dvd_fcr,0)
       into vl_cod_fatura_atual, vl_dt_vnc_fatura, vl_saldo_devedor_fatura
      from sc_opr.tbl_crt crt
      inner join sc_fcr.tbl_fcr fcr on crt.cd_fcr = fcr.cd_fcr
      where crt.cd_crt = rg.nsu_org_dvd;

      -- caso o saldo devedor da fatura for menor que o saldo devedor da nova divida
      -- gerar uma parcela de juros para cobrir a divida
      if vl_saldo_devedor_fatura <  vl_saldo_devedor then

        vl_parcela_juros := vl_saldo_devedor - vl_saldo_devedor_fatura;

        select nextval('sc_opr.sq_opr') into vl_cod_operacao;

        -- Obtendo o numero do plastico para gravar a operacao
        select cd_pls
        into vl_plastico
        from sc_opr.tbl_pls pls
        where pls.cd_crt = rg.nsu_org_dvd 
          and pls.dt_inc_usr = (select max(dt_inc_usr)
                                from sc_opr.tbl_pls
                                where cd_crt = pls.cd_crt);

        -- gravando operacao de Juros
        insert into sc_opr.tbl_opr(cd_opr,cd_top,cd_pls,cd_atm,dt_opr,vl_opr,vl_jrs_opr,vl_trf_opr,
                       nr_nsu_org_opr,nr_prc_opr,vl_prc_opr,vl_iof_opr,st_opr,dt_prc_opr)
             values(vl_cod_operacao,TP_OPERACAO_JUROS,vl_plastico,null,now(),vl_parcela_juros,0,0,vl_cod_fatura_atual,1,vl_parcela_juros,0,2,null);
    		     
    		     
        -- gravando parcela referente a operacao de juros
        insert into sc_fcr.tbl_prc(cd_prc,
                                   cd_crt,
                                   cd_fcr,
                                   vl_prc,
                                   fg_dcr_prc,
                                   st_prc,
                                   cd_opr,
                                   ds_prc,
                                   dt_vnc_prc,
                                   dt_grc_prc,
                                   cd_fcr_atu_prc)
              values(nextval('sc_fcr.sq_prc'),
                     rg.nsu_org_dvd,
                     vl_cod_fatura_atual,
                     vl_parcela_juros,
                     'D',
                     2,
                     vl_cod_operacao,
                     'JUROS - QUEBRA DE ACORDO',
                     vl_dt_vnc_fatura,
                     now(),
                     vl_cod_fatura_atual);

         -- atualizando o saldo devedor da fatura            
         update sc_fcr.tbl_fcr set vl_fcr = vl_fcr + vl_parcela_juros, vl_sld_dvd_fcr = vl_sld_dvd_fcr + vl_parcela_juros where cd_fcr = vl_cod_fatura_atual;
                  
      end if;
 

   end loop;
 
  end loop;
 
end$$;


ALTER FUNCTION sc_scan_cbe.quebrar_acordo(vp_empresa numeric) OWNER TO scan;

SET search_path = sc_sds, pg_catalog;

--
-- TOC entry 1459 (class 1255 OID 564536)
-- Name: fecha_saldo_subconta(numeric, date); Type: FUNCTION; Schema: sc_sds; Owner: postgres
--

CREATE FUNCTION fecha_saldo_subconta(vp_codigo_subconta numeric, vp_data_referencia date, OUT vr_saldo_incial numeric, OUT vr_debito numeric, OUT vr_credito numeric, OUT vr_saldo_final numeric) RETURNS record
    LANGUAGE plpgsql
    AS $$declare
  vl_saldo_inicial numeric;
  vl_total_debito numeric;
  vl_total_credito numeric;
  vl_saldo_final numeric;

  vl_saldo_inicial_aux numeric;
  vl_debito_aux numeric;
  vl_credito_aux numeric;
  vl_saldo_final_aux numeric;

  vl_existe numeric;

  vl_natureza character(1);

  rg record;
begin
  --excluindo lancamento atual
  delete from sc_cnt.tbl_sds where cd_scn = vp_codigo_subconta and dt_sds = vp_data_referencia and dt_inc_usr < now();
  
  --verificando se existe sub-conta com o código passado como parâmetro
  select count(*)
  into vl_existe
  from sc_cnt.tbl_scn
  where cd_scn = vp_codigo_subconta;

  --se nao existe a sub-conta lancar excecao
  if vl_existe = 0 then
    raise exception 'Não existe sub-conta com o código: %', vp_codigo_subconta;
  end if;

  select fg_ntr_scn
    into vl_natureza
  from sc_cnt.tbl_scn
  where cd_scn = vp_codigo_subconta;

  vl_saldo_inicial := 0;
  vl_total_debito := 0;
  vl_total_credito := 0;
  vl_saldo_final := 0;



  for rg in select *
            from sc_cnt.tbl_scn
            where pai_scn = vp_codigo_subconta loop

	vl_saldo_inicial_aux := 0;
	vl_debito_aux := 0;
	vl_credito_aux := 0;
	vl_saldo_final_aux := 0;
            
            
	select  a.vr_saldo_incial ,a.vr_debito, a.vr_credito, a.vr_saldo_final 
	into vl_saldo_inicial_aux,vl_debito_aux,vl_credito_aux,vl_saldo_final_aux
	from sc_sds.fecha_saldo_subconta(rg.cd_scn, vp_data_referencia) as a;

	if (vl_natureza is null) or (vl_natureza = rg.fg_ntr_scn) or (vl_natureza = '-' and rg.fg_ntr_scn = 'C') then
	  vl_saldo_inicial := coalesce(vl_saldo_inicial,0) + coalesce(vl_saldo_inicial_aux,0);
	  vl_saldo_final := coalesce(vl_saldo_final,0) + coalesce(vl_saldo_final_aux,0); 
	else
	  vl_saldo_inicial := coalesce(vl_saldo_inicial,0) - coalesce(vl_saldo_inicial_aux,0);
	  vl_saldo_final := coalesce(vl_saldo_final,0) - coalesce(vl_saldo_final_aux,0); 
	end if;
		
	vl_total_debito := vl_total_debito + coalesce(vl_debito_aux,0);
	vl_total_credito := vl_total_credito + coalesce(vl_credito_aux,0);
            
  end loop;

   select sum(case when (scn.fg_ntr_scn is null or scn.fg_ntr_scn = cnt.fg_ntr_cnt or cnt.fg_ntr_cnt = 'C' and scn.fg_ntr_scn = '-') then sdc.vl_ini_sdc else sdc.vl_ini_sdc * -1 end), 
       sum(sdc.vl_dbt_sdc),sum(sdc.vl_crd_sdc), 
       sum(case when (scn.fg_ntr_scn = cnt.fg_ntr_cnt or cnt.fg_ntr_cnt = 'C' and scn.fg_ntr_scn = '-') then sdc.vl_fin_sdc else sdc.vl_fin_sdc * -1 end) 
   into vl_saldo_inicial_aux,vl_debito_aux,vl_credito_aux,vl_saldo_final_aux
   from sc_cnt.tbl_sdc sdc 
      inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = sdc.cd_cnt
      inner join sc_cnt.tbl_scn scn on scn.cd_scn = cnt.cd_scn
   where cnt.cd_scn = vp_codigo_subconta
     and sdc.dt_sdc = vp_data_referencia;  

   vl_saldo_inicial := vl_saldo_inicial + coalesce(vl_saldo_inicial_aux,0);
   vl_total_debito := vl_total_debito + coalesce(vl_debito_aux,0);
   vl_total_credito := vl_total_credito + coalesce(vl_credito_aux,0);
   vl_saldo_final := vl_saldo_final + coalesce(vl_saldo_final_aux,0);

  --verificando se deve ser armazenado o registro de saldo diario de subconta
  if (vl_saldo_inicial <> 0) or (vl_total_debito <> 0) or (vl_total_credito <> 0) or (vl_saldo_final <> 0) then
    insert into sc_cnt.tbl_sds(cd_sds, cd_scn, dt_sds, vl_ini_sds, vl_dbt_sds, vl_crd_sds, vl_fin_sds, dt_inc_usr)
    values(nextval('sc_cnt.sq_sds'), vp_codigo_subconta, vp_data_referencia, vl_saldo_inicial, coalesce(vl_total_debito,0), coalesce(vl_total_credito,0), vl_saldo_final, now());
  end if;

  vr_saldo_incial := vl_saldo_inicial;
  vr_debito := vl_total_debito;
  vr_credito := vl_total_credito;
  vr_saldo_final := vl_saldo_final;
  
end;$$;


ALTER FUNCTION sc_sds.fecha_saldo_subconta(vp_codigo_subconta numeric, vp_data_referencia date, OUT vr_saldo_incial numeric, OUT vr_debito numeric, OUT vr_credito numeric, OUT vr_saldo_final numeric) OWNER TO postgres;

--
-- TOC entry 1460 (class 1255 OID 564537)
-- Name: fecha_saldo_subcontas(date); Type: FUNCTION; Schema: sc_sds; Owner: scan
--

CREATE FUNCTION fecha_saldo_subcontas(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;
begin
  --executando para todas as contas que tiveram lancamento na data informada
  for vl_rg in select cd_scn
               from sc_cnt.tbl_scn
               where pai_scn is null loop
  
    perform sc_sds.fecha_saldo_subconta(vl_rg.cd_scn, vp_data_referencia);

  end loop;

  -- atualizando todas as subcontas que tem saldo final do dia anterior maior do que zero e não tiveram lancamento no dia
  -- deletando os registros caso seja um reprocessamento; 
  delete from sc_cnt.tbl_sds
    where dt_sds = vp_data_referencia
      and cd_scn in (select cd_scn
		      from sc_cnt.tbl_sds sds
                      where sds.dt_sds = vp_data_referencia - 1
                        and sds.vl_fin_sds <> 0
                        and not exists (select 1
                                         from sc_cnt.tbl_sds sds2
                                         where sds.cd_scn = sds2.cd_scn
                                         and sds2.dt_sds = vp_data_referencia));

  -- inserindo novos registros
  insert 
     into sc_cnt.tbl_sds(cd_sds, cd_scn, dt_sds, vl_ini_sds, vl_dbt_sds, vl_crd_sds, vl_fin_sds, dt_inc_usr) 
  select nextval('sc_cnt.sq_sds') as cd_sds,
         cd_scn, 
         vp_data_referencia as dt_sds, 
         sds.vl_fin_sds as vl_ini_sds, 
         0 as vl_dbt_sds, 
         0 as vl_crd_sds, 
         sds.vl_fin_sds as vl_fin_sds,
         now() as dt_inc_usr
    from sc_cnt.tbl_sds sds
    where sds.dt_sds = vp_data_referencia - 1
      and sds.vl_fin_sds <> 0
      and not exists (select 1
                        from sc_cnt.tbl_sds sds2
                       where sds.cd_scn = sds2.cd_scn
                         and sds2.dt_sds = vp_data_referencia);
  

end;$$;


ALTER FUNCTION sc_sds.fecha_saldo_subcontas(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7877 (class 0 OID 0)
-- Dependencies: 1460
-- Name: FUNCTION fecha_saldo_subcontas(vp_data_referencia date); Type: COMMENT; Schema: sc_sds; Owner: scan
--

COMMENT ON FUNCTION fecha_saldo_subcontas(vp_data_referencia date) IS 'calcula o valor do saldo inicial, total de debitos, total de créditos e saldo final para todas as subcontas em uma determinada data';


--
-- TOC entry 1461 (class 1255 OID 564538)
-- Name: fecha_saldo_subcontas_periodo(date, date); Type: FUNCTION; Schema: sc_sds; Owner: postgres
--

CREATE FUNCTION fecha_saldo_subcontas_periodo(vp_data_referencia_inicial date, vp_data_referencia_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_data_atual date;
begin
  vl_data_atual := vp_data_referencia_inicial;
  while vl_data_atual <= vp_data_referencia_final loop
    perform sc_sds.fecha_saldo_subcontas(vl_data_atual);
    vl_data_atual := vl_data_atual + 1;
  end loop;
end;$$;


ALTER FUNCTION sc_sds.fecha_saldo_subcontas_periodo(vp_data_referencia_inicial date, vp_data_referencia_final date) OWNER TO postgres;

SET search_path = sc_sgr, pg_catalog;

--
-- TOC entry 1365 (class 1255 OID 874366)
-- Name: excluir_usuario_cartao(numeric, numeric); Type: FUNCTION; Schema: sc_sgr; Owner: postgres
--

CREATE FUNCTION excluir_usuario_cartao(vp_cartao numeric, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

 vl_cod_ucr numeric;

begin
   
   select cd_ucr into vl_cod_ucr from sc_sgr.tbl_ucr where cd_crt = vp_cartao;

   if not vl_cod_ucr is null then
     -- gravando historico de exclusao
     insert into sc_sgr.tbl_ucr_old(select u.cd_ucr,u.cd_crt,u.lgn_ucr,u.snh_ucr,u.st_ucr,u.tp_rgs_ucr,u.dt_inc_ucr,u.nr_err_snh_ucr,now(),vp_usuario,u.id_push_msg from sc_sgr.tbl_ucr u where cd_ucr = vl_cod_ucr);
     insert into sc_sgr.tbl_ucc_old(select u.* from sc_sgr.tbl_ucc u where cd_ucr = vl_cod_ucr);

     -- excluindo registros
     delete from sc_cad.tbl_luc where cd_ucr = vl_cod_ucr;
     delete from sc_sgr.tbl_cfv where cd_ucr = vl_cod_ucr;
     delete from sc_sgr.tbl_ucc where cd_ucr = vl_cod_ucr;
     delete from sc_sgr.tbl_ucr where cd_ucr = vl_cod_ucr;
   else

     raise exception 'Usuário do Internet Life não encontrado!';
     
   end if;
end$$;


ALTER FUNCTION sc_sgr.excluir_usuario_cartao(vp_cartao numeric, vp_usuario numeric) OWNER TO postgres;

--
-- TOC entry 1548 (class 1255 OID 874363)
-- Name: excluir_usuario_cartao_OLD(numeric); Type: FUNCTION; Schema: sc_sgr; Owner: scan
--

CREATE FUNCTION "excluir_usuario_cartao_OLD"(vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin
end$$;


ALTER FUNCTION sc_sgr."excluir_usuario_cartao_OLD"(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 1580 (class 1255 OID 889069)
-- Name: importar_usuariocartao_cartao(); Type: FUNCTION; Schema: sc_sgr; Owner: scan
--

CREATE FUNCTION importar_usuariocartao_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   rg record;
begin
     for rg in select cd_ucr, cd_crt
		from sc_sgr.tbl_ucr ucr
		where not exists (select 1 from  sc_sgr.tbl_ucc ucc where ucc.cd_ucr = ucr.cd_ucr)
     loop
     	
          insert into sc_sgr.tbl_ucc values(nextval('sc_sgr.sq_ucc'), rg.cd_ucr, rg.cd_crt, null, now());
        
     end loop;
end;$$;


ALTER FUNCTION sc_sgr.importar_usuariocartao_cartao() OWNER TO scan;

SET search_path = sc_spc, pg_catalog;

--
-- TOC entry 1462 (class 1255 OID 564539)
-- Name: gerar_arquivo_remessa_spc(); Type: FUNCTION; Schema: sc_spc; Owner: scan
--

CREATE FUNCTION gerar_arquivo_remessa_spc() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg record;
  ct_situacao_cadastrado numeric := 1;
begin

   for rg in select * 
            from sc_spc.tbl_hdr hdr
            where st_hdr = ct_situacao_cadastrado
   loop
     perform sc_spc.gerar_arquivo_remessa_spc(rg.cd_hdr);
   end loop;

end;
$$;


ALTER FUNCTION sc_spc.gerar_arquivo_remessa_spc() OWNER TO scan;

--
-- TOC entry 1466 (class 1255 OID 564540)
-- Name: gerar_arquivo_remessa_spc(numeric); Type: FUNCTION; Schema: sc_spc; Owner: scan
--

CREATE FUNCTION gerar_arquivo_remessa_spc(vp_header numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg record;
  rg_det record;

  ct_a_direita constant numeric := 1;
  ct_a_esquerda constant numeric := 2;
  ct_centralizado constant numeric := 3;
  ct_tipo_arquivo_spc constant numeric := 7;
  ct_cod_socio_spc constant numeric := 7088;
  ct_cod_entidade_spc constant numeric := 5501;
  ct_situacao_cadastrado numeric := 1;
  ct_situacao_gerado numeric := 2;
  ct_situacao_enviado numeric := 2;

  vl_diretorio varchar;
  vl_local_arquivo varchar;
  
  vl_codigo_arquivo numeric;
  vl_nome_arquivo varchar;
  vl_linha varchar;
  vl_sequencial numeric := 1;
  vl_remessa numeric;

begin

   -- RECUPERANDO CODIGO DO ARQUIVO A SER GERADO
  select nextval('sc_dwn.sq_dwa') into vl_codigo_arquivo;

  -- RECUPERANDO DIRETORIO DO ARQUIVO A SER GERADO 
  select tda.dir_tda
    into vl_diretorio
  from sc_dwn.tbl_tda tda
  where tda.cd_tda = ct_tipo_arquivo_spc;

  -- VERIFCANDO O NUMERO DA REMESSA
  select count(*) + 1
    into vl_remessa 
  from sc_dwn.tbl_dwa 
  where cd_tda = ct_tipo_arquivo_spc
    and st_dwa in (1, 2); -- situacao cadastrado e baixado

  -- RECUPERANDO NOME DO ARQUIVO A SER GERADO
  vl_nome_arquivo := 'saqpg_' || sc_arq.preencher(8, ct_cod_entidade_spc, '0', ct_a_esquerda) || '_' || sc_arq.preencher(10, vl_remessa, '0', ct_a_esquerda) || '.txt'; --(EM PRODUÇÃO)
  --vl_nome_arquivo := sc_arq.preencher(5, ct_cod_socio_spc, '0', ct_a_esquerda) || '_' || sc_arq.preencher(8, ct_cod_entidade_spc, '0', ct_a_esquerda) || '_' || to_char(now(), 'yyyyMMdd') || '_' || to_char(now(), 'hh24mi') || '.txt'; -- (EM HOMOLOGAÇÃO)
  vl_local_arquivo := vl_diretorio || '//' || vl_nome_arquivo;

  -- INSERIR REGISTRO NA TBL_DWA, REFERENTE AO ARQUIVO GERADO
  insert into sc_dwn.tbl_dwa values (vl_codigo_arquivo, vl_nome_arquivo, now(), now(), ct_tipo_arquivo_spc, 1); 

  -- VERIFICANDO SE EXISTE ARQUIVO A SER ENVIADO
  for rg in select * 
            from sc_spc.tbl_hdr hdr
            where cd_hdr = vp_header
   loop
      -- CRIANDO HEADER DO ARQUIVO - INICIO

      -- identificador da linha
      vl_linha := '00';

      -- tipo de arquivo
      vl_linha := vl_linha || 'REMESSA';

      -- data do movimento
      vl_linha := vl_linha || to_char(now(), 'ddMMyyyy'); 

      -- codigo da remessa
      vl_linha := vl_linha || sc_arq.preencher(8, vl_remessa, '0', ct_a_esquerda); 

      -- codigo da entidade
      vl_linha := vl_linha || sc_arq.preencher(5, ct_cod_entidade_spc, '0', ct_a_esquerda); 

      -- codigo do associado
      vl_linha := vl_linha || sc_arq.preencher(8, ct_cod_socio_spc, '0', ct_a_esquerda);

      -- data do movimento do arquivo
      vl_linha := vl_linha || to_char(now(), 'yyyyMMdd'); 

      -- preencher com espaços em branco
      vl_linha := vl_linha || sc_arq.preencher(271, ' ', ' ', ct_a_esquerda);

      -- unidade de negocio
      vl_linha := vl_linha || sc_arq.preencher(5, rg.ds_uni_neg_hdr, ' ', ct_a_direita);

      -- numero da versao
      vl_linha := vl_linha || sc_arq.preencher(2, rg.nr_vrs_hdr, '0', ct_a_esquerda);

      -- codigo do erro (preencher com espaços em branco)
      vl_linha := vl_linha || sc_arq.preencher(10, ' ', ' ', ct_a_esquerda);

      -- numero sequencial da linha
      vl_linha := vl_linha || sc_arq.preencher(6, vl_sequencial, '0', ct_a_esquerda);
      
      perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);

      -- CRIANDO HEADER DO ARQUIVO - FIM 

      -- CRIANDO DETALHE DO ARQUIVO - INICIO
      for rg_det in select * 
		    from sc_spc.tbl_det 
		    where cd_hdr = rg.cd_hdr 
		      and st_det = ct_situacao_cadastrado 
		    order by cd_det
      loop

	 -- ### LINHA DO CONSUMIDOR
	 -- identificador da linha
	 vl_linha := '01';

	 -- cep da loja 
	vl_linha := vl_linha || sc_arq.preencher(8, rg_det.nr_cep_prc_cnc_det, '0', ct_a_esquerda);

	-- razao social / nome do cliente
	vl_linha := vl_linha || sc_arq.preencher(45, rg_det.nm_cli_det, ' ', ct_a_direita);

	-- tipo de pessoa
	vl_linha := vl_linha || sc_arq.preencher(1, rg_det.tp_pss_det, '0', ct_a_esquerda);

	-- cpf / cnpj
	vl_linha := vl_linha || sc_arq.preencher(15, rg_det.nr_cpf_cnpj_det, '0', ct_a_esquerda);

	-- rg
	vl_linha := vl_linha || sc_arq.preencher(20, rg_det.nr_rg_det, ' ', ct_a_direita);

	-- data de nascimento
	vl_linha := vl_linha || to_char(rg_det.dt_nsc_det, 'ddMMyyyy');

	-- nome da mae
	vl_linha := vl_linha || sc_arq.preencher(45, rg_det.nm_mae_det, ' ', ct_a_direita);

	-- endereco
	vl_linha := vl_linha || sc_arq.preencher(50, rg_det.ds_end_det, ' ', ct_a_direita);

	-- numero 
	vl_linha := vl_linha || sc_arq.preencher(5, rg_det.nr_end_det, '0', ct_a_esquerda);

	-- complemento
	vl_linha := vl_linha || sc_arq.preencher(30, rg_det.ds_cmp_det, ' ', ct_a_direita);

	-- bairro
	vl_linha := vl_linha || sc_arq.preencher(25, rg_det.ds_brr_det, ' ', ct_a_direita);

	-- CEP
	vl_linha := vl_linha || sc_arq.preencher(8, rg_det.nr_cep_det, '0', ct_a_esquerda);

	-- Cidade
	vl_linha := vl_linha || sc_arq.preencher(30, rg_det.ds_lcl_det, ' ', ct_a_direita);

	-- uf
	vl_linha := vl_linha || sc_arq.preencher(2, rg_det.uf_det, ' ', ct_a_direita);
	
	-- ddd
	vl_linha := vl_linha || sc_arq.preencher(2, rg_det.nr_ddd_det, '0', ct_a_esquerda);
	
	-- brancos
	vl_linha := vl_linha || sc_arq.preencher(18, ' ', ' ', ct_a_direita);

	-- telefone
	vl_linha := vl_linha || sc_arq.preencher(10, rg_det.nr_tel_det, ' ', ct_a_esquerda);

	-- codigo do retorno
	vl_linha := vl_linha || sc_arq.preencher(10, ' ', ' ', ct_a_direita);

	-- sequencial
	vl_sequencial := vl_sequencial + 1;
	vl_linha := vl_linha || sc_arq.preencher(6, vl_sequencial, '0', ct_a_esquerda);

	perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);

	-- ### LINHA DO SPC
	
	-- identificador da linha
	vl_linha := '02';

	-- tipo de pessoa
	vl_linha := vl_linha || sc_arq.preencher(1, rg_det.tp_pss_det, '0', ct_a_esquerda);

	-- cpf
	vl_linha := vl_linha || sc_arq.preencher(15, rg_det.nr_cpf_cnpj_det, '0', ct_a_esquerda);

	-- tipo de operacao (inclusao/exclusao)
	vl_linha := vl_linha || rg_det.tp_opr_det;

	-- tipo de cliente (fixo: C - Comprador)
	vl_linha := vl_linha || 'C';

	-- data de vencimento
	vl_linha := vl_linha || to_char(rg_det.dt_vnc_det, 'ddMMyyyy');

	-- data de registro da compra
	vl_linha := vl_linha || to_char(rg_det.dt_reg_det, 'ddMMyyyy');

	-- valor da divida
	vl_linha := vl_linha || sc_arq.formatar_moeda(13, rg_det.vl_dvd_det);

	-- numero do contrato
	vl_linha := vl_linha || sc_arq.preencher(30, rg_det.nr_ctr_det, ' ', ct_a_direita);

	-- codigo do associado
	vl_linha := vl_linha || sc_arq.preencher(8, ct_cod_socio_spc, '0', ct_a_esquerda);

	-- motivo da inclusao
	vl_linha := vl_linha || sc_arq.preencher(2, rg_det.cd_mtv_inc_det, '0', ct_a_esquerda);

	-- motivo da exclusao
	vl_linha := vl_linha || sc_arq.preencher(3, rg_det.cd_mtv_exc_det, '0', ct_a_esquerda);

	-- brancos
	vl_linha := vl_linha || sc_arq.preencher(232, ' ', ' ', ct_a_direita);

	-- codigo do retorno
	vl_linha := vl_linha || sc_arq.preencher(10, ' ', ' ', ct_a_direita);

	-- sequencial
	vl_sequencial := vl_sequencial + 1;
	vl_linha := vl_linha || sc_arq.preencher(6, vl_sequencial, '0', ct_a_esquerda);

	perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);

      end loop;
      -- CRIANDO DETALHE DO ARQUIVO - FIM
	
      -- CRIANDO TRAILLER DO ARQUIVO - INICIO
      
      -- identificador da linha
      vl_linha := '99';

      -- total de registros
      vl_sequencial := vl_sequencial + 1;
      vl_linha := vl_linha || sc_arq.preencher(6, vl_sequencial, '0', ct_a_esquerda);

      -- brancos
      vl_linha := vl_linha || sc_arq.preencher(316, ' ', ' ', ct_a_direita);

      -- codigo do retorno
      vl_linha := vl_linha || sc_arq.preencher(10, ' ', ' ', ct_a_direita);

      -- sequencial
      vl_linha := vl_linha || sc_arq.preencher(6, vl_sequencial, '0', ct_a_esquerda);

      perform sc_arq.gravarlinha(vl_local_arquivo, vl_linha);
      
      -- CRIANDO TRAILLER DO ARQUIVO - FIM

      -- atualizando o arquivo de negativacao do spc para enviado
      update sc_cci.tbl_ans 
         set st_ans = ct_situacao_enviado, 
             dt_env_ans = now()
      where cd_det in (select cd_det from sc_spc.tbl_det where cd_hdr = rg.cd_hdr);	
      
      -- atualizando os detalhes como gerados
      update sc_spc.tbl_det 
         set st_det = ct_situacao_gerado
      where cd_hdr = rg.cd_hdr;
      
      -- atualizando o header como gerado
      update sc_spc.tbl_hdr 
         set st_hdr = ct_situacao_gerado, 
             nr_rms_hdr = vl_remessa
      where cd_hdr = rg.cd_hdr;
   end loop;

end;
$$;


ALTER FUNCTION sc_spc.gerar_arquivo_remessa_spc(vp_header numeric) OWNER TO scan;

--
-- TOC entry 1310 (class 1255 OID 564543)
-- Name: gerar_remessa_spc(numeric, numeric, numeric); Type: FUNCTION; Schema: sc_spc; Owner: scan
--

CREATE FUNCTION gerar_remessa_spc(vp_tipo numeric, vp_cartao numeric, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  
  ct_sit_gerado numeric := 5;
  ct_sit_arquivo_pendente numeric := 1;
  ct_tipo_inclusao numeric := 1;

  vl_rg_edr sc_cad.vw_edr%rowtype;
  vl_cd_header numeric := 0;
  vl_nome_arquivo varchar;
  vl_diretorio varchar;
  vl_linha varchar;
  vl_logradouro varchar;
  vl_nr_logradouro numeric;
  vl_complemento varchar;
  vl_bairro varchar;
  vl_localidade varchar;
  vl_uf varchar;
  vl_cep numeric;
  vl_ddd_telefone numeric;
  vl_numero_telefone numeric;
  vl_cpf numeric;
  vl_numero_contrato varchar;
  vl_data_vencimento date;
  vl_data_registro date;
  vl_valor_divida numeric;
  vl_numero_logradouro varchar;
BEGIN
    
    for rg in select case when ans.tp_ans = 1 then 'INCLUSAO' else 'EXCLUSAO' end as tipo, ans.tp_ans, cun.cd_cun, cun.tp_pss_cun,
			cun.nm_cun as nome, cun.nr_cpf_cnpj_cun as cpf, COALESCE(cpf.nr_rg_cpf, 9090) as nr_rg, COALESCE(cpf.dt_nsc_cpf, '01-01-1990') as data_nascimento, 
			COALESCE(cpf.nm_mae_cpf, 'MARIA') as nome_mae,crt.cd_crt as cartao, crt.cd_fcr as fatura, crt.dt_ini_atr_crt as data_atraso,
			current_date - crt.dt_ini_atr_crt as dias_atraso,
			fcr.dt_vnc_fcr as data_vencimento, fcr.vl_sld_dvd_fcr as saldo_devedor, cd_ans
	      from sc_cci.tbl_ans ans
			inner join sc_opr.tbl_crt crt on crt.cd_crt = ans.cd_crt
			inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
			inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
			inner join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
			left join sc_fcr.tbl_fcr fcr on fcr.cd_fcr = crt.cd_fcr	
              where ans.st_ans = 1 -- cadastrado
                and ans.cd_crt = COALESCE(vp_cartao, ans.cd_crt)
                and ans.tp_ans = COALESCE(vp_tipo, ans.tp_ans)
                and fnc.cd_emp = COALESCE(vp_empresa, fnc.cd_emp)
	      order by tipo, saldo_devedor, nome
    loop
                
      if vl_cd_header = 0 then
         select nextval ('sc_spc.sq_hdr') into vl_cd_header;

         insert into sc_spc.tbl_hdr(cd_hdr, nr_seq_hdr, nr_vrs_hdr, st_hdr, ds_uni_neg_hdr, dt_mvm_hdr, dt_inc_usr)
		values (vl_cd_header, 1, 8, ct_sit_arquivo_pendente, 'SPC', current_date, now());

      end if;

      vl_cpf := null;
      vl_numero_contrato := null;
      vl_data_vencimento := null;
      vl_data_registro := null;
      vl_valor_divida := null;

      -- capturando endereco quando for seja inclusão, caso contrario, irá enviar o endereço da saqcard visto que na exclusão não é obrigatório
      if rg.tp_ans = ct_tipo_inclusao then

         select * 
          into vl_rg_edr 
         from sc_aeo.get_endereco(rg.cd_cun);
        
         if vl_rg_edr.logradouro is not null then
           vl_logradouro := vl_rg_edr.logradouro;
         else
           vl_logradouro := '';
         end if;
         
         if trim(vl_rg_edr.nr_edr) is not null then
           --vl_numero_logradouro := replace(replace(replace(replace(replace(trim(vl_rg_edr.nr_edr), 'S', ''), 'N', ''), '/', ''), '-', ''), 'A', ''); 
           begin
             vl_numero_logradouro := trim(sc_pbl.texto_to_numero(vl_rg_edr.nr_edr));
             vl_nr_logradouro := vl_numero_logradouro::numeric;
             
             if vl_nr_logradouro >= 100000 then
                vl_nr_logradouro := vl_nr_logradouro % 100000;
             end if;
           exception when others then
              vl_nr_logradouro := 0;
           end;
         else
           vl_nr_logradouro := 0;
         end if;

         if vl_rg_edr.cpl_edr is not null then
	   vl_complemento := vl_rg_edr.cpl_edr;
	 else
	   vl_complemento := '';
	 end if;

	 if vl_rg_edr.bairro is not null then
	   vl_bairro := vl_rg_edr.bairro;
	 else
	   vl_bairro := '';
	 end if;

	 if vl_rg_edr.localidade is not null then
	   vl_localidade := vl_rg_edr.localidade;
	 else
	   vl_localidade := '';
	 end if;

	 if vl_rg_edr.uf is not null then
	   vl_uf := vl_rg_edr.uf;
	 else
	   vl_uf := '';
	 end if;

	 if vl_rg_edr.cep_edr is not null then
	   vl_cep := vl_rg_edr.cep_edr;
	 else
	   vl_cep := 0;
	 end if;

	 -- campos de checagem devem ser iguais tanto na inclusao como na exclusao (cpf, contrato, data de vencimento, data de registro e valor da divida)
	 vl_cpf := rg.cpf;
	 vl_numero_contrato := rg.cpf;
	 vl_data_vencimento := rg.data_atraso + interval '1 month';
	 vl_data_registro := rg.data_atraso;
	 vl_valor_divida := rg.saldo_devedor;
	 
      else  
         -- informando o endereço da SAQCARD quando o tipo de registro for EXCLUSÃO pois não é obrigatório
         vl_logradouro := 'AVENIDA ENGENHEIRO SANTANA JUNIOR';
	 vl_nr_logradouro := 3000;
	 vl_complemento := '';
	 vl_bairro := 'COCO';
	 vl_localidade := 'FORTALEZA';
	 vl_uf := 'CE';
	 vl_cep := 60192200;

	 -- capturando os valores enviados nos campos de checagem para excluir (cpf, contrato, data de vencimento, data de registro e valor da divida)
	 select nr_cpf_cnpj_det, nr_ctr_det, dt_vnc_det, dt_reg_det, vl_dvd_det
	   into vl_cpf, vl_numero_contrato, vl_data_vencimento, vl_data_registro, vl_valor_divida
	 from sc_spc.tbl_det
	 where nr_cpf_cnpj_det = rg.cpf
	   and tp_opr_det = 'I'
	 order by cd_hdr desc;

	 if vl_numero_contrato is null then
	    vl_cpf := rg.cpf;
	    vl_numero_contrato := rg.cpf;
	    vl_data_vencimento := current_date;
	    vl_data_registro := current_date;
	    vl_valor_divida := rg.saldo_devedor;
	 end if;
      end if;
	  
      -- capturando telefone (ESTA FIXO O NUMERO DA SAQCARD)
      vl_ddd_telefone := 85;
      vl_numero_telefone := 32156666;
      
      insert into sc_spc.tbl_det(cd_det, cd_hdr, st_det, nr_cep_prc_cnc_det, tp_opr_det, nr_ctr_det, 
				tp_pss_det, nr_cpf_cnpj_det, nm_cli_det, dt_vnc_det, dt_reg_det, 
				vl_dvd_det, cd_mtv_inc_det, cd_mtv_exc_det, nr_rg_det, dt_nsc_det, nm_mae_det, 
				ds_end_det, nr_end_det, ds_cmp_det, ds_brr_det, ds_lcl_det, uf_det, nr_cep_det,
				nr_ddd_det, nr_tel_det, dt_mvm_det, dt_inc_usr)
	    values (nextval ('sc_spc.sq_det'), vl_cd_header, ct_sit_arquivo_pendente, 60192200, case when rg.tp_ans = 1 then 'I' else 'E' end, vl_numero_contrato, 
			    case when rg.tp_pss_cun = 'F' then 2 else 1 end, vl_cpf, substring(rg.nome, 1, 45), vl_data_vencimento, vl_data_registro, 
			    vl_valor_divida, case when rg.tp_ans = 1 then 65 else null end, case when rg.tp_ans = 2 then 1 else null end, rg.nr_rg, rg.data_nascimento, substring(rg.nome_mae, 1, 45),
			    substring(vl_logradouro, 1, 50), vl_nr_logradouro, substring(vl_complemento, 1, 30), substring(vl_bairro, 1, 25), substring(vl_localidade, 1, 30), vl_uf, vl_cep, 
			    vl_ddd_telefone, vl_numero_telefone, current_date, now()); 
		 
      update sc_cci.tbl_ans
         set st_ans = ct_sit_gerado,
             cd_det = currval('sc_spc.sq_det')
      where cd_ans = rg.cd_ans;
            
    end loop;             
END;  
$$;


ALTER FUNCTION sc_spc.gerar_remessa_spc(vp_tipo numeric, vp_cartao numeric, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1463 (class 1255 OID 564546)
-- Name: processar_arquivo_retorno_spc(); Type: FUNCTION; Schema: sc_spc; Owner: scan
--

CREATE FUNCTION processar_arquivo_retorno_spc() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  rg record;
  rg_det record;

  ct_situacao_recebido numeric := 1;
  ct_situacao_processado numeric := 2;
  ct_situacao_processado_com_erro numeric := 4;
  ct_sit_prc_sucesso numeric := 0;
  ct_situacao_enviado numeric := 2;

  vl_situacao numeric;
  vl_situacao_processamento numeric;
  vl_cd_header numeric := 0;
  vl_retorno_spc numeric;
  vl_retorno_consumidor numeric;
begin

   for rg in select * 
             from sc_spc.tbl_hrs hrs
             where st_hrs = ct_situacao_recebido
   loop

     select cd_hdr
       into vl_cd_header
     from sc_spc.tbl_hdr
     where nr_rms_hdr = rg.nr_rms_hrs
      and st_hdr = ct_situacao_enviado;

     if vl_cd_header is not null or vl_cd_header != 0 then
     
       for rg_det in select *
		     from sc_spc.tbl_det det
		     where det.cd_hdr = vl_cd_header
		     order by nr_ctr_det
       loop
         -- capturando o retorno do SPC
         select ss.cd_ret_drss
           into vl_retorno_spc
         from sc_spc.tbl_drss ss 
	 where ss.cd_hrs = rg.cd_hrs
	   and ss.nr_ctr_drss = rg_det.nr_ctr_det;
	     
         -- capturando o retorno do consumidor
         select cs.cd_ret_drcs
           into vl_retorno_consumidor
          from sc_spc.tbl_drcs cs
	 where cs.cd_hrs = rg.cd_hrs
	   and cs.nr_cpf_cnpj_drcs = rg_det.nr_cpf_cnpj_det;

         if vl_retorno_spc = ct_sit_prc_sucesso then
            vl_situacao_processamento := 1; -- sucesso
         else
            vl_situacao_processamento := 2; -- erro

            -- voltando a situacao de pendente para poder reenviar, caso seja inclusao
            if rg_det.tp_opr_det = 'I' then

               update sc_cci.tbl_ans 
                  set st_ans = 1 -- pendente
               where cd_det = rg_det.cd_det;
            end if;
	 end if;

	 update sc_spc.tbl_det
	    set cd_ret_cns_det = vl_retorno_consumidor, 
	        cd_ret_spc_det = vl_retorno_spc, 
                st_prc_det = vl_situacao_processamento  
	 where cd_det = rg_det.cd_det;
       end loop;

       vl_situacao := ct_situacao_processado;
     else
       vl_situacao := ct_situacao_processado_com_erro;
     end if;

     update sc_spc.tbl_hrs
        set st_hrs = vl_situacao, 
             dt_prc_hrs = now()
     where cd_hrs = rg.cd_hrs;
     
   end loop;
end;
$$;


ALTER FUNCTION sc_spc.processar_arquivo_retorno_spc() OWNER TO scan;

--
-- TOC entry 1464 (class 1255 OID 564547)
-- Name: processar_negativacao_spc(); Type: FUNCTION; Schema: sc_spc; Owner: scan
--

CREATE FUNCTION processar_negativacao_spc() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  
begin

   -- gerando remessa de EXCLUSÃO
   PERFORM sc_spc.gerar_remessa_spc(2, null, null);

   -- gerando remessa de INCLUSÃO
   PERFORM sc_spc.gerar_remessa_spc(1, null, null);

   -- gerando os arquivos para envio ao SPC
   PERFORM sc_spc.gerar_arquivo_remessa_spc();

end;
$$;


ALTER FUNCTION sc_spc.processar_negativacao_spc() OWNER TO scan;

--
-- TOC entry 7878 (class 0 OID 0)
-- Dependencies: 1464
-- Name: FUNCTION processar_negativacao_spc(); Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON FUNCTION processar_negativacao_spc() IS 'Rotina que gera as remessas de inclusão e exclusão para enviar ao SPC';


SET search_path = sc_srs, pg_catalog;

--
-- TOC entry 1586 (class 1255 OID 900994)
-- Name: atualizar_titulos_soma(); Type: FUNCTION; Schema: sc_srs; Owner: scan
--

CREATE FUNCTION atualizar_titulos_soma() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  rg_prg record;
  rg_lqd record;
  rg_cnc record;
  ct_tp_ocorrencia_adicionar_ttl numeric := 1;
  ct_tp_ocorrencia_remocao_ttl numeric := 2;
  ct_tp_ocorrencia_prorrogacao_ttl numeric := 3;
  ct_tp_ocorrencia_liquidacao_ttl numeric := 4;
  st_ttl_cadastrado numeric := 1;
  st_ttl_cancelado numeric := 2;
  st_ttl_pago numeric := 3;
  vl_data_pagamento date;
  
begin

    -- ADICIONAR TITULOS
    for rg in select *
              from sc_fep.tbl_fep fep
              where fep.st_fep = 1 
              and not exists(select 1 
                             from sc_srs.tbl_tlt 
                             where tp_org_tlt = 1 
                               and nsu_org_tlt = fep.cd_fep) loop

        insert into sc_srs.tbl_ttl(cd_ttl,st_ttl,vl_ttl,cd_inc_usr,dt_inc_usr,nr_cnpj_ttl,tp_org_ttl,nsu_org_ttl,dt_vnc_ttl)
          values(nextval('sc_fep.sq_tlt'),1,rg.vl_fep,1,now(),vl_cnpj,1,rg.cd_fep, rg.dt_vnc_fep);

        insert into sc_srs.tbl_ott(cd_ott,cd_ttl,dt_ott,ds_ott,tp_ott)
          values(nextval('sc_fep.sq_tlt'),currval('sc_fep.sq_tlt'),now(),'INCLUSAO DE TITULOS',1,ct_tp_ocorrencia_adicionar_ttl);
              
    end loop;

    -- PRORROGAR TITULOS
    for rg_prg in select ttl.cd_ttl,fep.cd_fep,vl_fep,dt_vnc_fep
              from sc_srs.tbl_ttl ttl
                inner join sc_fep.tbl_fep fep on fep.cd_fep = ttl.nsu_org_ttl and ttl.tp_org_ttl = 1
              where st_tlt = st_ttl_cadastrado
                and ttl.dt_vnc_ttl < fep.dt_vnc_fep
                and fep.st_fep = 1 loop

         update sc_srs.tbl_ttl 
         set dt_vnc_ttl = rg_prg.dt_vnc_fep ,
             vl_ttl = rg_prg.vl_fep
         where tp_org_ttl = 1 
           and nsu_org_ttl = rg_prg.cd_fep;       

         insert into sc_srs.tbl_ott(cd_ott,cd_ttl,dt_ott,ds_ott,tp_ott)
          values(nextval('sc_fep.sq_tlt'),rg_prg.cd_ttl,now(),'PRORROGACAO DE TITULO',1,ct_tp_ocorrencia_prorrogacao_ttl);
          
    end loop;

    -- LIQUIDAR TITULOS
    for rg_lqd in select ttl.cd_ttl,fep.cd_fep,vl_fep,dt_vnc_fep
                  from sc_srs.tbl_ttl ttl
                    inner join sc_fep.tbl_fep fep on fep.cd_fep = ttl.nsu_org_ttl and ttl.tp_org_ttl = 1
                  where st_tlt = st_ttl_cadastrado
                    and fep.st_fep = 2 loop

         select max(pfe.dt_pfe)
         into vl_data_pagamento
         from sc_fep.tbl_pfe
         where cd_fep = rg_lqd.cd_fep;  

         update sc_srs.tbl_ttl 
         set st_ttl = st_ttl_pago,
             dt_pgt_ttl = vl_data_pagamento
         where tp_org_ttl = 1 
           and nsu_org_ttl = rg_lqd.cd_fep;  

         insert into sc_srs.tbl_ott(cd_ott,cd_ttl,dt_ott,ds_ott,tp_ott)
          values(nextval('sc_fep.sq_tlt'),rg_lqd.cd_ttl,now(),'LIQUIDACAO DE TITULO',1,ct_tp_ocorrencia_liquidacao_ttl);
          
    end loop;   

    -- CANCELAR TITULOS
    for rg_cnc in select ttl.cd_ttl,fep.cd_fep,vl_fep,dt_vnc_fep
                  from sc_srs.tbl_ttl ttl
                    inner join sc_fep.tbl_fep fep on fep.cd_fep = ttl.nsu_org_ttl and ttl.tp_org_ttl = 1
                  where st_tlt = st_ttl_cadastrado
                    and fep.st_fep = 3 loop

         update sc_srs.tbl_ttl 
         set st_ttl = st_ttl_cancelado
         where tp_org_ttl = 1 
           and nsu_org_ttl = rg_cnc.cd_fep;       

         insert into sc_srs.tbl_ott(cd_ott,cd_ttl,dt_ott,ds_ott,tp_ott)
          values(nextval('sc_fep.sq_tlt'),rg_cnc.cd_ttl,now(),'CANCELAMENTO DE TITULO',1,ct_tp_ocorrencia_remocao_ttl);
          
    end loop;                        

end$$;


ALTER FUNCTION sc_srs.atualizar_titulos_soma() OWNER TO scan;

--
-- TOC entry 1590 (class 1255 OID 899524)
-- Name: gerar_info_serasa(); Type: FUNCTION; Schema: sc_srs; Owner: postgres
--

CREATE FUNCTION gerar_info_serasa() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   vl_linha varchar;
   vl_nome_arquivo varchar;
   vl_local_arquivo varchar;
begin	

       vl_nome_arquivo := 'TESTE.TXT';
       
      --definindo onde o arquivo sera gravado
      vl_local_arquivo := vl_diretorio || E'\\' || vl_nome_arquivo;

      --gravando a linha de header
      vl_linha := '00';
      vl_linha := vl_linha || 'RELATO COMP NEGOCIOS';
      vl_linha := vl_linha || 'RELATO COMP NEGOCIOS'; -- CNPJ
      vl_linha := vl_linha || '20161101'; -- DATA PERIODO INICIAL
      vl_linha := vl_linha || '20161130'; -- DATA PERIODO FINAL
      vl_linha := vl_linha || 'S'; -- PERIODICIDADE
      vl_linha := vl_linha || sc_arq.repetir(' ',15);
      vl_linha := vl_linha || sc_arq.repetir(' ',3);
      vl_linha := vl_linha || sc_arq.repetir(' ',29);
      vl_linha := vl_linha || 'V.';
      vl_linha := vl_linha || '01';
      vl_linha := vl_linha || sc_arq.repetir(' ',26);
      
      
      
      perform sc_arq.gravarlinha(vl_local_arquivo, linha);


 
end$$;


ALTER FUNCTION sc_srs.gerar_info_serasa() OWNER TO postgres;

SET search_path = sc_srv, pg_catalog;

--
-- TOC entry 1465 (class 1255 OID 564548)
-- Name: arquivo_affinity_mapfre(); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION arquivo_affinity_mapfre() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_completar_direita numeric := 1;
  ct_completar_esquerda numeric := 2;
  ct_cd_srv_affinity numeric := 2;
  ct_cd_sga_mapfre numeric := 1;
  ct_st_srv_ativo numeric := 1;
  ct_st_srv_cancelado numeric := 2;
  
  vl_qnt_registro numeric;
  vl_qnt_registro_cancelados numeric;
  vl_cd_has numeric;
  vl_nome_arquivo varchar(50);
  vl_linha varchar(2000);
  vl_sequencia numeric;
  vl_diretorio varchar(200) := 'c:/java/';

  rg_sgr record;
  vl_rg_sga record;
  vl_rg_edr record;
  vl_rg_tlf record;

begin

  -- #### registro de adesão para geracao do arquivo
  select count(*)
    into vl_qnt_registro
  from sc_srv.tbl_sgr sgr
    inner join sc_srv.tbl_scr srv on srv.cd_scr = sgr.cd_scr
  where sgr.cd_has is null
    and srv.st_scr = ct_st_srv_ativo
    and srv.cd_srv = ct_cd_srv_affinity
    and sgr.cd_sga = ct_cd_sga_mapfre;

  if vl_qnt_registro > 0 then

    -- registro da seguradora
    select *
      into vl_rg_sga
    from sc_srv.tbl_sga; 
					
    -- inserindo o header do arquivo
    select nextval('sc_srv.sq_has') into vl_cd_has;
    insert into sc_srv.tbl_has (cd_has, dt_grc_has) values (vl_cd_has, now());

    -- nome do arquivo
    vl_nome_arquivo := vl_diretorio || 'AFF' || vl_cd_has || to_char(current_date, 'YYYYMMDD') || '.txt';

    -- escrevendo o header
    vl_linha := '01'; -- header
    vl_linha := vl_linha || to_char(current_date, 'YYYYMMDD'); -- data de envio
    vl_linha := vl_linha || sc_arq.preencher(6, vl_cd_has, '0', ct_completar_esquerda); -- numero da remessa
    vl_linha := vl_linha || sc_arq.preencher(6, vl_cd_has, '0', ct_completar_esquerda); -- código da seguradora
    vl_linha := vl_linha || sc_arq.preencher(24, '', ' ', ct_completar_direita); -- filler
    vl_linha := vl_linha || sc_arq.preencher(10, vl_rg_sga.cd_emp_sga, '0', ct_completar_esquerda); -- código da empresa na seguradora
    vl_linha := vl_linha || sc_arq.preencher(1946, '', ' ', ct_completar_direita); -- filler

    perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);
 
    vl_sequencia := 1;
    -- registro de seguros
    for rg_sgr in select *
                  from sc_srv.tbl_sgr sgr
                    inner join sc_srv.tbl_scr srv on srv.cd_scr = sgr.cd_scr
                    inner join sc_opr.tbl_crt crt on crt.cd_crt = srv.cd_crt
                    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
                    inner join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
                    inner join sc_srv.tbl_sga sga on sga.cd_sga = sgr.cd_sga
                  where sgr.cd_has is null
                    and srv.st_scr = ct_st_srv_ativo
                    and srv.cd_srv = ct_cd_srv_affinity 
                    and sgr.cd_sga = ct_cd_sga_mapfre loop

      vl_linha := '03'; -- detalhe adesão
      vl_linha := vl_linha || sc_arq.preencher(4, '','0', ct_completar_esquerda); -- Código Estipulante
      vl_linha := vl_linha || 'E'; -- Envio/Retorno
      vl_linha := vl_linha || sc_arq.preencher(6, vl_sequencia + 1, '0', ct_completar_esquerda); -- Seqüência Registro
      vl_linha := vl_linha || sc_arq.preencher(5, '', ' ', ct_completar_direita); -- Filler
      vl_linha := vl_linha || sc_arq.preencher(10, rg_sgr.cd_fnc, '0', ct_completar_esquerda); -- Cód. Cliente na Corret./Prest.
      vl_linha := vl_linha || sc_arq.preencher(20, rg_sgr.cd_fnc, '0', ct_completar_esquerda); -- Cód. Identificador do cliente
      vl_linha := vl_linha || sc_arq.preencher(14, rg_sgr.nr_cpf_cnpj_cun, '0', ct_completar_esquerda); -- CPF
      vl_linha := vl_linha || sc_arq.preencher(14, rg_sgr.nr_rg_cpf, '0', ct_completar_esquerda); -- RG  
      vl_linha := vl_linha || sc_arq.preencher(10, substr(rg_sgr.nm_org_ems_rg_cpf, '0', length(rg_sgr.nm_org_ems_rg_cpf) - 1), ' ', ct_completar_esquerda); -- Órgão Emissor
      vl_linha := vl_linha || sc_arq.preencher(2, substr(rg_sgr.nm_org_ems_rg_cpf, length(rg_sgr.nm_org_ems_rg_cpf) - 1), ' ', ct_completar_esquerda); -- UF emissão RG
      vl_linha := vl_linha || coalesce(to_char(rg_sgr.dt_ems_rg_cpf,'YYYYMMDD'),'00000000'); -- Data de Emissão RG
      vl_linha := vl_linha || sc_arq.preencher(50, rg_sgr.nm_cun, ' ', ct_completar_direita); -- Nome
      vl_linha := vl_linha || coalesce(to_char(rg_sgr.dt_nsc_cpf,'YYYYMMDD'),'00000000'); -- DT Nascimento
      vl_linha := vl_linha || rg_sgr.sexo_cpf; -- Sexo
      vl_linha := vl_linha || case rg_sgr.cd_est_civil_cpf when 1 then 'S' when 2 then 'C' when 3 then 'V' else 'P' end; -- Estado Civil

      -- ta seperado por questao de performace
      begin
        select *
          into vl_rg_edr
        from sc_cad.vw_edr edr
        where edr.cd_cun = rg_sgr.cd_cun
        order by edr.cd_edr desc;
      exception when others then
        vl_rg_edr := null;
      end;

      vl_linha := vl_linha || sc_arq.preencher(70, vl_rg_edr.logradouro, ' ', ct_completar_direita); -- Endereço 
      --vl_linha := vl_linha || sc_arq.preencher(10, vl_rg_edr.nr_edr, ' ', ct_completar_direita); -- Número  
      vl_linha := vl_linha || sc_arq.preencher(70, vl_rg_edr.cpl_edr, ' ', ct_completar_direita); -- Complemento
      vl_linha := vl_linha || sc_arq.preencher(25, vl_rg_edr.bairro, ' ', ct_completar_direita); -- Bairro         
      vl_linha := vl_linha || sc_arq.preencher(35, vl_rg_edr.localidade, ' ', ct_completar_direita); -- Cidade         
      vl_linha := vl_linha || sc_arq.preencher(8, vl_rg_edr.cep_edr, '0', ct_completar_esquerda); -- CEP 
      vl_linha := vl_linha || sc_arq.preencher(2, vl_rg_edr.uf, ' ', ct_completar_direita); -- UF 

      begin
        select *
          into vl_rg_tlf
        from sc_cad.tbl_tlf tlf
        where tlf.nsu_org_tlf = rg_sgr.cd_cun
          and tlf.tp_org_tlf = 1 -- pessoa fisica
        order by tlf.cd_tlf desc;
      exception when others then
        vl_rg_tlf := null;
      end;

      vl_linha := vl_linha || sc_arq.preencher(4, vl_rg_tlf.nr_ddd_tlf, '0', ct_completar_esquerda); -- DDD 
      vl_linha := vl_linha || sc_arq.preencher(8, vl_rg_tlf.nr_tlf, '0', ct_completar_esquerda); -- Telefone 
      vl_linha := vl_linha || sc_arq.preencher(6, '', ' ', ct_completar_direita); -- Ramal 
      vl_linha := vl_linha || sc_arq.preencher(16, '', ' ', ct_completar_direita); -- Filler
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Numero do seguro
      vl_linha := vl_linha || sc_arq.preencher(4, rg_sgr.cd_prd, ' ', ct_completar_esquerda); -- Código do produto
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Código do plano
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Código Faixa Etária
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Código Vigência
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Código Nivel
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Código campanha
      vl_linha := vl_linha || sc_arq.formatar_moeda(rg_sgr.vl_sgr, 13, 2, ''); -- Valor do seguro    
      vl_linha := vl_linha || sc_arq.preencher(2, '', ' ', ct_completar_esquerda); -- Dia de cobrança   
      vl_linha := vl_linha || coalesce(to_char(rg_sgr.dt_inc_usr, 'YYYYMMDD'),'00000000'); -- Data Adesão  
      vl_linha := vl_linha || sc_arq.formatar_moeda(rg_sgr.vl_sgr, 4, 2, ''); -- Valor da prestação
      vl_linha := vl_linha || sc_arq.preencher(2, rg_sgr.qt_prs_sgr, '0', ct_completar_esquerda); -- Quantidade de prestações
      vl_linha := vl_linha || sc_arq.preencher(10, '', ' ', ct_completar_esquerda); -- Código do Vendedor
      vl_linha := vl_linha || sc_arq.preencher(10, '', ' ', ct_completar_esquerda); -- Filial
      vl_linha := vl_linha || sc_arq.preencher(8, '', ' ', ct_completar_esquerda); -- 1ª prestação/inicio garantia    
      vl_linha := vl_linha || sc_arq.preencher(5, '', ' ', ct_completar_esquerda); -- Filler
      vl_linha := vl_linha || sc_arq.preencher(20, '', ' ', ct_completar_esquerda); -- Número da conta
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Sequência arrecadação
      vl_linha := vl_linha || 'A'; -- Tipo
      vl_linha := vl_linha || sc_arq.formatar_moeda(rg_sgr.vl_sgr, 13, 2, ''); -- Valor do Arrecadado
      vl_linha := vl_linha || coalesce(to_char(rg_sgr.dt_inc_usr, 'YYYYMMDD'),'00000000'); -- Data de Vencimento
      vl_linha := vl_linha || coalesce(to_char(rg_sgr.dt_inc_usr, 'YYYYMMDD'),'00000000'); -- Data de Arrecadação
      vl_linha := vl_linha || coalesce(to_char(rg_sgr.dt_inc_usr, 'YYYYMMDD'),'00000000'); -- Data do Processamento
      vl_linha := vl_linha || sc_arq.preencher(15, '', ' ', ct_completar_esquerda); -- Número da FCA
      vl_linha := vl_linha || sc_arq.preencher(8, '', '0', ct_completar_esquerda); -- Data alteração cadastral
      vl_linha := vl_linha || sc_arq.preencher(10, '', '0', ct_completar_esquerda); -- Valor segurado    
      vl_linha := vl_linha || sc_arq.preencher(9, '', ' ', ct_completar_esquerda); -- Filler   
      vl_linha := vl_linha || sc_arq.preencher(6, '', '0', ct_completar_esquerda);-- Remessa envio
      vl_linha := vl_linha || sc_arq.preencher(6, '', '0', ct_completar_esquerda);-- Seqüência Envio     
      vl_linha := vl_linha || sc_arq.preencher(1, '', ' ', ct_completar_esquerda);-- Aceitação        
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda);-- Motivo Rejeição
      vl_linha := vl_linha || sc_arq.preencher(255, '', ' ', ct_completar_esquerda);-- Descrição Rejeição
      vl_linha := vl_linha || sc_arq.preencher(16, '', ' ', ct_completar_esquerda);-- Cartão Benefício
      vl_linha := vl_linha || sc_arq.preencher(10, '', ' ', ct_completar_esquerda);-- Número de sorteio
      vl_linha := vl_linha || sc_arq.preencher(1102, '', ' ', ct_completar_esquerda);-- Dados Variaveis

      perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);
      vl_sequencia := vl_sequencia + 1;

      -- atualizando o codigo do header no detalhe
      update sc_srv.tbl_sgr set cd_has = vl_cd_has where cd_sgr = rg_sgr.cd_sgr;
    end loop;

  end if;

  -- trailler
  if vl_qnt_registro > 0 then
    vl_linha := '16'; -- codigo trailler
    vl_linha := vl_linha || sc_arq.preencher(9, vl_qnt_registro, '0', ct_completar_direita); -- Total de registros enviados
    vl_linha := vl_linha || sc_arq.preencher(1989, '', ' ', ct_completar_esquerda); -- Filler

    perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);
  end if;
end;$$;


ALTER FUNCTION sc_srv.arquivo_affinity_mapfre() OWNER TO scan;

--
-- TOC entry 1467 (class 1255 OID 564551)
-- Name: arquivo_capitalizacao_new(); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION arquivo_capitalizacao_new() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  
  ct_completar_direita numeric := 1;
  ct_completar_esquerda numeric := 2;
  ct_cd_srv_capitalizacao numeric := 3;
  ct_cd_sga_mapfre numeric := 1;
  ct_st_srv_ativo numeric := 1;
  ct_st_srv_cancelado numeric := 2;

  vl_qnt_registro numeric;
  vl_cd_has numeric;
  vl_nome_arquivo varchar(50);
  vl_linha varchar(2000);
  vl_sequencia numeric;
  vl_diretorio varchar(200) := 'c:/java/';
  vl_sequencial_remessa numeric(10,0);
  vl_numero_remessa varchar(10);

  vl_rg_sgr record;
  vl_rg_sga record;

  rg_sgr record;

begin

  -- #### registro de adesão para geracao do arquivo
  select count(*)
    into vl_qnt_registro
  from sc_srv.tbl_sgr sgr
    inner join sc_srv.tbl_scr srv on srv.cd_scr = sgr.cd_scr
  where srv.st_scr = ct_st_srv_ativo
    and srv.cd_srv = ct_cd_srv_capitalizacao
    and sgr.cd_sga = ct_cd_sga_mapfre;

  if vl_qnt_registro > 0 then

    select count(distinct(cap.cd_new_has))
      into vl_sequencial_remessa
    from sc_srv.tbl_sgr sgr
      inner join sc_srv.tbl_scr srv on srv.cd_scr = sgr.cd_scr
      inner join sc_srv.tbl_has has on has.cd_has = sgr.cd_has
      inner join sc_srv.tbl_cap cap on cap.cd_sgr = sgr.cd_sgr
    where srv.st_scr = ct_st_srv_ativo
      and srv.cd_srv = ct_cd_srv_capitalizacao
      and sgr.cd_sga = ct_cd_sga_mapfre
      and to_char(has.dt_grc_has, 'yyyy') = to_char(current_date, 'yyyy');

    vl_sequencial_remessa := coalesce(vl_sequencial_remessa, 0) + 1;
    vl_numero_remessa := to_char(current_date, 'YYYY') || sc_arq.preencher(6, vl_sequencial_remessa, '0', ct_completar_esquerda);
  
    -- registro da seguradora
    select *
      into vl_rg_sga
    from sc_srv.tbl_sga
    where cd_sga = ct_cd_sga_mapfre;

    -- registro do servico de capitalizacao
    select *
      into vl_rg_sgr
    from sc_srv.tbl_srv
    where cd_srv = ct_cd_srv_capitalizacao;
					 
    -- inserindo o header do arquivo
    select nextval('sc_srv.sq_has') into vl_cd_has;
    insert into sc_srv.tbl_has (cd_has, dt_grc_has, nr_sqn_rms_has) values (vl_cd_has, now(), vl_numero_remessa);

    -- nome do arquivo
    vl_nome_arquivo := vl_diretorio || 'MCAP_NEW_' || sc_arq.preencher(4, vl_rg_sgr.cd_prd, '0', ct_completar_esquerda) || '_' || vl_cd_has || to_char(current_date, 'DDMMYY') || '.txt';

    -- escrevendo o header
    vl_linha := 'H'; -- header
    vl_linha := vl_linha || sc_arq.preencher(4, vl_rg_sga.cd_emp_sga, '0', ct_completar_esquerda); -- Código do CLIENTE (Definido MAPFRE)
    vl_linha := vl_linha || sc_arq.preencher(4, vl_rg_sgr.cd_prd, '0', ct_completar_esquerda); -- Código do Plano (Definido MAPFRE)
    vl_linha := vl_linha || to_char(current_date, 'YYYYMMDD'); -- Data da Geração do Arquivo
    vl_linha := vl_linha || vl_numero_remessa; -- Número da Remessa

    perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);

    -- escrevendo o detalhe
    vl_linha := 'D'; -- detalhe
    vl_linha := vl_linha || sc_arq.preencher(5, vl_sequencial_remessa, '0', ct_completar_esquerda); -- Lote de envio do cliente
    vl_linha := vl_linha || sc_arq.preencher(7, vl_qnt_registro, '0', ct_completar_esquerda); -- Quantidade de números de sorte desejada
    vl_linha := vl_linha || sc_arq.preencher(25, '', '0', ct_completar_esquerda); -- Reservado para uso cliente

    perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);

    -- alterar o detalhe pro arquivo
    for rg_sgr in select *
                  from sc_srv.tbl_sgr sgr
                    inner join sc_srv.tbl_scr srv on srv.cd_scr = sgr.cd_scr
                  where srv.st_scr = ct_st_srv_ativo
                    and srv.cd_srv = ct_cd_srv_capitalizacao
                    and sgr.cd_sga = ct_cd_sga_mapfre loop

      -- atualizando o header
      update sc_srv.tbl_sgr set cd_has = vl_cd_has where cd_sgr = rg_sgr.cd_sgr;

      -- inserindo na tabela de capitalizacao
      insert into sc_srv.tbl_cap (cd_cap, cd_sgr, cd_new_has, dt_inc_usr)
        values (nextval('sc_srv.sq_cap'), rg_sgr.cd_sgr, vl_cd_has, now());

    end loop;
   
    -- escrevendo trailler
    vl_linha := 'T'; -- detalhe

    perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);

  end if;

end;$$;


ALTER FUNCTION sc_srv.arquivo_capitalizacao_new() OWNER TO scan;

--
-- TOC entry 1468 (class 1255 OID 564552)
-- Name: arquivo_capitalizacao_pag(); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION arquivo_capitalizacao_pag() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_completar_direita numeric := 1;
  ct_completar_esquerda numeric := 2;
  ct_st_srv_ativo numeric := 1;
  ct_cd_srv_capitalizacao numeric := 3;
  ct_cd_sga_mapfre numeric := 1;

  vl_qnt_registro numeric;
  vl_cd_has numeric;
  vl_nome_arquivo varchar(50);
  vl_linha varchar(2000);
  vl_qnt_ttl numeric := 0;
  vl_vl_ttl numeric(13,2) := 0;
  vl_diretorio varchar(200) := 'c:/java/';

  rg_nr_rms record;
  vl_rg_sga record;
  vl_rg_sgr record;

  rg_sgr record;

begin

  for rg_nr_rms in select distinct has.nr_sqn_rms_has as numero
                   from sc_srv.tbl_sgr sgr
                     inner join sc_srv.tbl_scr srv on srv.cd_scr = sgr.cd_scr
                     inner join sc_srv.tbl_has has on has.cd_has = sgr.cd_has
                     inner join sc_srv.tbl_cap cap on cap.cd_sgr = sgr.cd_sgr and cap.cd_new_has = has.cd_has
                   where cap.cd_new_has is not null
                     and cap.cd_pag_has is null
                     and cap.nr_srt_cap is not null
                     and srv.st_scr = ct_st_srv_ativo
                     and srv.cd_srv = ct_cd_srv_capitalizacao
                     and sgr.cd_sga = ct_cd_sga_mapfre loop
  
    -- registro da seguradora
    select *
      into vl_rg_sga
    from sc_srv.tbl_sga
    where cd_sga = ct_cd_sga_mapfre;

    -- registro do servico de capitalizacao
    select *
      into vl_rg_sgr
    from sc_srv.tbl_srv
    where cd_srv = ct_cd_srv_capitalizacao;

    -- inserindo o header do arquivo
    select nextval('sc_srv.sq_has') into vl_cd_has;
    insert into sc_srv.tbl_has (cd_has, dt_grc_has, nr_sqn_rms_has) values (vl_cd_has, now(), rg_nr_rms.numero);

    -- nome do arquivo
    vl_nome_arquivo := vl_diretorio || 'MCAP_PAG_' || sc_arq.preencher(4, vl_rg_sgr.cd_prd, '0', ct_completar_esquerda) || '_' || vl_cd_has || to_char(current_date, 'DDMMYY') || '.txt';

    -- escrevendo o header
    vl_linha := 'H'; -- header
    vl_linha := vl_linha || sc_arq.preencher(4, vl_rg_sga.cd_emp_sga, '0', ct_completar_esquerda); -- Código do CLIENTE (Definido MAPFRE)
    vl_linha := vl_linha || sc_arq.preencher(4, vl_rg_sgr.cd_prd, '0', ct_completar_esquerda); -- Código do Plano (Definido MAPFRE)
    vl_linha := vl_linha || '0000'; -- codigo do estipulante
    vl_linha := vl_linha || to_char(current_date, 'YYYYMMDD'); -- Data da Geração do Arquivo
    vl_linha := vl_linha || rg_nr_rms.numero; -- Número da Remessa

    perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);

    -- escrevendo o detalhe
    for rg_sgr in select *
                  from sc_srv.tbl_sgr sgr
                    inner join sc_srv.tbl_has has on has.cd_has = sgr.cd_has
                    inner join sc_srv.tbl_scr scr on scr.cd_scr = sgr.cd_scr
                    inner join sc_opr.tbl_crt crt on crt.cd_crt = scr.cd_crt
                    inner join sc_srv.tbl_cap cap on cap.cd_sgr = sgr.cd_sgr and cap.cd_new_has = has.cd_has
                  where has.nr_sqn_rms_has = rg_nr_rms.numero 
                    and cap.cd_pag_has is null loop

      vl_qnt_ttl := vl_qnt_ttl + 1;
      vl_vl_ttl := vl_vl_ttl + rg_sgr.vl_prs_sgr;
      
      vl_linha := 'D'; -- detalhe
      vl_linha := vl_linha || to_char(current_date, 'YYYYMM'); --Ano e Mês de Vigência
      vl_linha := vl_linha || substr(rg_nr_rms.numero, length(rg_nr_rms.numero) - 2, length(rg_nr_rms.numero)); --Número da Série de Distibuição
      vl_linha := vl_linha || sc_arq.preencher(8, rg_sgr.nr_srt_cap, '0', ct_completar_esquerda); --Número de Sorte
      vl_linha := vl_linha || sc_arq.formatar_moeda(rg_sgr.vl_prs_sgr, 9, 2, ''); --Valor do Título
      vl_linha := vl_linha || to_char((to_date('01'||to_char(current_date,'mmyyyy'), 'ddmmyyyy') + interval '1 month') - interval '1 day', 'yyyymmdd'); --Data de Vigência do Sorteio (ultimo dia do mes)
      vl_linha := vl_linha || sc_arq.preencher(25, rg_sgr.cd_fnc, '0', ct_completar_esquerda); --Identificação do cliente / cessionário
      vl_linha := vl_linha || sc_arq.preencher(9, vl_qnt_ttl, '0', ct_completar_esquerda); --Número seqüencial dos registros

      perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);

      update sc_srv.tbl_cap set cd_pag_has = vl_cd_has where cd_cap = rg_sgr.cd_cap;
    end loop;

    -- trailler
    vl_linha := 'T'; -- trailler
    vl_linha := vl_linha || sc_arq.preencher(9, vl_qnt_ttl, '0', ct_completar_esquerda);
    vl_linha := vl_linha || sc_arq.formatar_moeda(vl_vl_ttl, 9, 2, '');

    perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);
    
  end loop;

end;$$;


ALTER FUNCTION sc_srv.arquivo_capitalizacao_pag() OWNER TO scan;

--
-- TOC entry 1469 (class 1255 OID 564553)
-- Name: arquivo_mapfre_cancelado(); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION arquivo_mapfre_cancelado() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_completar_direita numeric := 1;
  ct_completar_esquerda numeric := 2;
  ct_cd_srv_perda_roubo numeric := 1;
  ct_cd_sga_mapfre numeric := 1;
  ct_st_srv_ativo numeric := 1;
  ct_st_srv_cancelado numeric := 2;
  
  vl_qnt_registro_cancelados numeric;
  vl_cd_has numeric;
  vl_nome_arquivo varchar(50);
  vl_linha varchar(2000);
  vl_sequencia numeric;
  vl_diretorio varchar(200) := 'c:/java/';

  rg_sgr record;
  vl_rg_sga record;
  vl_rg_edr record;
  vl_rg_tlf record;

begin

  -- #### registro de cancelados para geracao do arquivo
  select count(*)
    into vl_qnt_registro_cancelados
  from sc_srv.tbl_sgr sgr
    inner join sc_srv.tbl_scr srv on srv.cd_scr = sgr.cd_scr
  where sgr.cd_has is not null
    and sgr.cd_cnc_has is null
    and srv.st_scr = ct_st_srv_cancelado
    --and srv.cd_srv = ct_cd_srv_perda_roubo
    and sgr.cd_sga = ct_cd_sga_mapfre;

  if vl_qnt_registro_cancelados > 0 then

   select *
     into vl_rg_sga
   from sc_srv.tbl_sga; 

   -- inserindo o header do arquivo
   select nextval('sc_srv.sq_has') into vl_cd_has;
   insert into sc_srv.tbl_has (cd_has, dt_grc_has) values (vl_cd_has, now());

   -- nome do arquivo 
   vl_nome_arquivo := vl_diretorio || 'CNC' || vl_cd_has || to_char(current_date, 'YYYYMMDD') || '.txt';

   -- escrevendo o header
   vl_linha := '01'; -- header
   vl_linha := vl_linha || to_char(current_date, 'YYYYMMDD'); -- data de envio
   vl_linha := vl_linha || sc_arq.preencher(6, vl_cd_has, '0', ct_completar_esquerda); -- numero da remessa
   vl_linha := vl_linha || sc_arq.preencher(6, vl_cd_has, '0', ct_completar_esquerda); -- código da seguradora
   vl_linha := vl_linha || sc_arq.preencher(4, ct_cd_sga_mapfre, '0', ct_completar_esquerda); -- código da seguradora
   vl_linha := vl_linha || sc_arq.preencher(24, '', ' ', ct_completar_direita); -- filler
   vl_linha := vl_linha || sc_arq.preencher(10, vl_rg_sga.cd_emp_sga, '0', ct_completar_esquerda); -- código da empresa na seguradora
   vl_linha := vl_linha || sc_arq.preencher(1946, '', ' ', ct_completar_direita); -- filler

   perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);

   vl_sequencia := 1;

   -- registro de seguros
   for rg_sgr in select *
                  from sc_srv.tbl_sgr sgr
                    inner join sc_srv.tbl_scr srv on srv.cd_scr = sgr.cd_scr
                    inner join sc_opr.tbl_crt crt on crt.cd_crt = srv.cd_crt
                    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
                    inner join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
                    inner join sc_srv.tbl_sga sga on sga.cd_sga = sgr.cd_sga
                  where sgr.cd_has is not null
                    and sgr.cd_cnc_has is null
                    and srv.st_scr = ct_st_srv_cancelado
                    --and srv.cd_srv = ct_cd_srv_perda_roubo 
                    and sgr.cd_sga = ct_cd_sga_mapfre loop

      vl_linha := '04'; -- detalhe cancelamento
      vl_linha := vl_linha || sc_arq.preencher(4, '', '0', ct_completar_esquerda); --Código Estipulante
      vl_linha := vl_linha || 'E'; --Envio/Retorno
      vl_linha := vl_linha || sc_arq.preencher(6, vl_sequencia, '0', ct_completar_esquerda); --Seqüência Registro
      vl_linha := vl_linha || sc_arq.preencher(5, '', ' ', ct_completar_direita); --Filler
      vl_linha := vl_linha || sc_arq.preencher(10, rg_sgr.cd_fnc, '0', ct_completar_esquerda); --Cód. Cliente na Corret./Prest.
      vl_linha := vl_linha || sc_arq.preencher(20, '', ' ', ct_completar_direita); --Cód. Identificador do Cliente.
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_direita); --Numero do seguro
      vl_linha := vl_linha || sc_arq.preencher(4, rg_sgr.cd_prd, ' ', ct_completar_esquerda); --Código do produto
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_direita); --Documento cancelamento
      vl_linha := vl_linha || coalesce(to_char(rg_sgr.dt_cnc_sgr,'YYYYMMDD'),'00000000'); --Data de cancelamento
      vl_linha := vl_linha || sc_arq.preencher(2, rg_sgr.tp_cnc_sgr, '0', ct_completar_esquerda); --Tipo de cancelamento
      vl_linha := vl_linha || sc_arq.preencher(255, rg_sgr.ds_mtv_cnc_sgr, ' ', ct_completar_direita); --Motivo do cancelamento
      vl_linha := vl_linha || sc_arq.preencher(275, '', ' ', ct_completar_direita); --Filler
      vl_linha := vl_linha || sc_arq.preencher(6, '', '0', ct_completar_esquerda); --Rodada Envio
      vl_linha := vl_linha || sc_arq.preencher(6, '', '0', ct_completar_esquerda); --Seqüência Envio
      vl_linha := vl_linha || sc_arq.preencher(1, '', ' ', ct_completar_direita); --Aceitação
      vl_linha := vl_linha ||  sc_arq.preencher(4, '', ' ', ct_completar_direita); --Motivo Rejeição
      vl_linha := vl_linha ||  sc_arq.preencher(255, '', ' ', ct_completar_direita); --Descrição Rejeição
      vl_linha := vl_linha ||  sc_arq.preencher(1128, '', ' ', ct_completar_direita); --Filler

      perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);
      vl_sequencia := vl_sequencia + 1;

      -- atualizando o codigo do header no detalhe
      update sc_srv.tbl_sgr set cd_cnc_has = vl_cd_has where cd_sgr = rg_sgr.cd_sgr;
    end loop;

  end if; 

  -- trailler
  if vl_qnt_registro_cancelados > 0 then
    vl_linha := '16'; -- codigo trailler
    vl_linha := vl_linha || sc_arq.preencher(9, vl_qnt_registro_cancelados, '0', ct_completar_direita); -- Total de registros enviados
    vl_linha := vl_linha || sc_arq.preencher(1989, '', ' ', ct_completar_esquerda); -- Filler

    perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);
  end if;
end;$$;


ALTER FUNCTION sc_srv.arquivo_mapfre_cancelado() OWNER TO scan;

--
-- TOC entry 1470 (class 1255 OID 564554)
-- Name: arquivo_perda_roubo_mapfre(); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION arquivo_perda_roubo_mapfre() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_completar_direita numeric := 1;
  ct_completar_esquerda numeric := 2;
  ct_cd_srv_perda_roubo numeric := 1;
  ct_cd_sga_mapfre numeric := 1;
  ct_st_srv_ativo numeric := 1;
  ct_st_srv_cancelado numeric := 2;
  
  vl_qnt_registro numeric;
  vl_qnt_registro_cancelados numeric;
  vl_cd_has numeric;
  vl_nome_arquivo varchar(50);
  vl_linha varchar(2000);
  vl_sequencia numeric;
  vl_diretorio varchar(200) := 'c:/java/';

  rg_sgr record;
  vl_rg_sga record;
  vl_rg_edr record;
  vl_rg_tlf record;

begin

  -- #### registro de adesão para geracao do arquivo
  select count(*)
    into vl_qnt_registro
  from sc_srv.tbl_sgr sgr
    inner join sc_srv.tbl_scr srv on srv.cd_scr = sgr.cd_scr
  where sgr.cd_has is null
    and srv.st_scr = ct_st_srv_ativo
    and srv.cd_srv = ct_cd_srv_perda_roubo
    and sgr.cd_sga = ct_cd_sga_mapfre;

  if vl_qnt_registro > 0 then

    -- registro da seguradora
    select *
      into vl_rg_sga
    from sc_srv.tbl_sga; 
					
    -- inserindo o header do arquivo
    select nextval('sc_srv.sq_has') into vl_cd_has;
    insert into sc_srv.tbl_has (cd_has, dt_grc_has) values (vl_cd_has, now());

    -- nome do arquivo
    vl_nome_arquivo := vl_diretorio || 'APR' || vl_cd_has || to_char(current_date, 'YYYYMMDD') || '.txt';

    -- escrevendo o header
    vl_linha := '01'; -- header
    vl_linha := vl_linha || to_char(current_date, 'YYYYMMDD'); -- data de envio
    vl_linha := vl_linha || sc_arq.preencher(6, vl_cd_has, '0', ct_completar_esquerda); -- numero da remessa
    vl_linha := vl_linha || sc_arq.preencher(6, vl_cd_has, '0', ct_completar_esquerda); -- código da seguradora
    vl_linha := vl_linha || sc_arq.preencher(4, ct_cd_sga_mapfre, '0', ct_completar_esquerda); -- código da seguradora
    vl_linha := vl_linha || sc_arq.preencher(24, '', ' ', ct_completar_direita); -- filler
    vl_linha := vl_linha || sc_arq.preencher(10, vl_rg_sga.cd_emp_sga, '0', ct_completar_esquerda); -- código da empresa na seguradora
    vl_linha := vl_linha || sc_arq.preencher(1946, '', ' ', ct_completar_direita); -- filler

    perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);
 
    vl_sequencia := 1;
    -- registro de seguros
    for rg_sgr in select *
                  from sc_srv.tbl_sgr sgr
                    inner join sc_srv.tbl_scr srv on srv.cd_scr = sgr.cd_scr
                    inner join sc_opr.tbl_crt crt on crt.cd_crt = srv.cd_crt
                    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
                    inner join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
                    inner join sc_srv.tbl_sga sga on sga.cd_sga = sgr.cd_sga
                  where sgr.cd_has is null
                    and srv.st_scr = ct_st_srv_ativo
                    and srv.cd_srv = ct_cd_srv_perda_roubo 
                    and sgr.cd_sga = ct_cd_sga_mapfre loop

      vl_linha := '02'; -- detalhe adesão
      vl_linha := vl_linha || sc_arq.preencher(4, '','0', ct_completar_esquerda); -- Código Estipulante
      vl_linha := vl_linha || 'E'; -- Envio/Retorno
      vl_linha := vl_linha || sc_arq.preencher(6, vl_sequencia, '0', ct_completar_esquerda); -- Seqüência Registro
      vl_linha := vl_linha || sc_arq.preencher(5, '', ' ', ct_completar_direita); -- Filler
      vl_linha := vl_linha || sc_arq.preencher(10, rg_sgr.cd_fnc, '0', ct_completar_esquerda); -- Cód. Cliente na Corret./Prest.
      vl_linha := vl_linha || sc_arq.preencher(20, '', '0', ct_completar_esquerda); -- Cód. Identificador do cliente
      vl_linha := vl_linha || sc_arq.preencher(14, rg_sgr.nr_cpf_cnpj_cun, '0', ct_completar_esquerda); -- CPF
      vl_linha := vl_linha || sc_arq.preencher(14, rg_sgr.nr_rg_cpf, '0', ct_completar_esquerda); -- RG  
      vl_linha := vl_linha || sc_arq.preencher(10, substr(rg_sgr.nm_org_ems_rg_cpf, '0', length(rg_sgr.nm_org_ems_rg_cpf) - 1), ' ', ct_completar_esquerda); -- Órgão Emissor
      vl_linha := vl_linha || sc_arq.preencher(2, substr(rg_sgr.nm_org_ems_rg_cpf, length(rg_sgr.nm_org_ems_rg_cpf) - 1), ' ', ct_completar_esquerda); -- UF emissão RG
      vl_linha := vl_linha || coalesce(to_char(rg_sgr.dt_ems_rg_cpf,'YYYYMMDD'),'00000000'); -- Data de Emissão RG
      vl_linha := vl_linha || sc_arq.preencher(50, rg_sgr.nm_cun, ' ', ct_completar_direita); -- Nome
      vl_linha := vl_linha || coalesce(to_char(rg_sgr.dt_nsc_cpf,'YYYYMMDD'),'00000000'); -- DT Nascimento
      vl_linha := vl_linha || rg_sgr.sexo_cpf; -- Sexo
      vl_linha := vl_linha || case rg_sgr.cd_est_civil_cpf when 1 then 'S' when 2 then 'C' when 3 then 'V' else 'P' end; -- Estado Civil

      -- ta seperado por questao de performace
      begin
        select *
          into vl_rg_edr
        from sc_cad.vw_edr edr
        where edr.cd_cun = rg_sgr.cd_cun
        order by edr.cd_edr desc;
      exception when others then
        vl_rg_edr := null;
      end;

      vl_linha := vl_linha || sc_arq.preencher(70, vl_rg_edr.logradouro, ' ', ct_completar_direita); -- Endereço 
      vl_linha := vl_linha || sc_arq.preencher(10, vl_rg_edr.nr_edr, ' ', ct_completar_direita); -- Número  
      vl_linha := vl_linha || sc_arq.preencher(70, vl_rg_edr.cpl_edr, ' ', ct_completar_direita); -- Complemento
      vl_linha := vl_linha || sc_arq.preencher(25, vl_rg_edr.bairro, ' ', ct_completar_direita); -- Bairro         
      vl_linha := vl_linha || sc_arq.preencher(35, vl_rg_edr.localidade, ' ', ct_completar_direita); -- Cidade         
      vl_linha := vl_linha || sc_arq.preencher(8, vl_rg_edr.cep_edr, '0', ct_completar_esquerda); -- CEP 
      vl_linha := vl_linha || sc_arq.preencher(2, vl_rg_edr.uf, ' ', ct_completar_direita); -- UF 

      begin
        select *
          into vl_rg_tlf
        from sc_cad.tbl_tlf tlf
        where tlf.nsu_org_tlf = rg_sgr.cd_cun
          and tlf.tp_org_tlf = 1 -- pessoa fisica
        order by tlf.cd_tlf desc;
      exception when others then
        vl_rg_tlf := null;
      end;

      vl_linha := vl_linha || sc_arq.preencher(4, vl_rg_tlf.nr_ddd_tlf, '0', ct_completar_esquerda); -- DDD 
      vl_linha := vl_linha || sc_arq.preencher(8, vl_rg_tlf.nr_tlf, '0', ct_completar_esquerda); -- Telefone 
      vl_linha := vl_linha || sc_arq.preencher(6, '', ' ', ct_completar_direita); -- Ramal 
      vl_linha := vl_linha || sc_arq.preencher(6, '', ' ', ct_completar_direita); -- Filler
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Numero do seguro
      vl_linha := vl_linha || sc_arq.preencher(4, rg_sgr.cd_prd, ' ', ct_completar_esquerda); -- Código do produto
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Código do plano
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Código Faixa Etária
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Código Vigência
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Código Nivel
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Código campanha
      vl_linha := vl_linha || sc_arq.formatar_moeda(rg_sgr.vl_sgr, 13, 2, ''); -- Valor do seguro    
      vl_linha := vl_linha || sc_arq.preencher(2, '', ' ', ct_completar_esquerda); -- Dia de cobrança   
      vl_linha := vl_linha || coalesce(to_char(rg_sgr.dt_inc_usr, 'YYYYMMDD'),'00000000'); -- Data Adesão  
      vl_linha := vl_linha || sc_arq.formatar_moeda(rg_sgr.vl_sgr, 4, 2, ''); -- Valor da prestação
      vl_linha := vl_linha || sc_arq.preencher(2, rg_sgr.qt_prs_sgr, '0', ct_completar_esquerda); -- Quantidade de prestações
      vl_linha := vl_linha || sc_arq.preencher(10, '', ' ', ct_completar_esquerda); -- Código do Vendedor
      vl_linha := vl_linha || sc_arq.preencher(10, '', ' ', ct_completar_esquerda); -- Filial
      vl_linha := vl_linha || sc_arq.preencher(8, '', ' ', ct_completar_esquerda); -- 1ª prestação/inicio garantia
      vl_linha := vl_linha || sc_arq.preencher(10, '', '0', ct_completar_direita); -- Valor segurado    
      vl_linha := vl_linha || sc_arq.preencher(34, '', ' ', ct_completar_esquerda); -- Filler  
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Canal de Vendas
      vl_linha := vl_linha || sc_arq.preencher(63, '', ' ', ct_completar_esquerda); -- Filler  
      vl_linha := vl_linha || sc_arq.preencher(6, '', '0', ct_completar_direita); -- Remessa envio
      vl_linha := vl_linha || sc_arq.preencher(6, '', '0', ct_completar_direita); -- Seqüência Envio     
      vl_linha := vl_linha || sc_arq.preencher(1, '', ' ', ct_completar_esquerda); -- Aceitação        
      vl_linha := vl_linha || sc_arq.preencher(4, '', ' ', ct_completar_esquerda); -- Motivo Rejeição
      vl_linha := vl_linha || sc_arq.preencher(255, '', ' ', ct_completar_esquerda); -- Descrição Rejeição
      vl_linha := vl_linha || sc_arq.preencher(16, '', ' ', ct_completar_esquerda); -- Cartão Benefício
      vl_linha := vl_linha || sc_arq.preencher(10, '', '0', ct_completar_direita); -- Número de sorteio
      vl_linha := vl_linha || sc_arq.preencher(1102, '', ' ', ct_completar_esquerda); -- Dados Variaveis

      perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);
      vl_sequencia := vl_sequencia + 1;

      -- atualizando o codigo do header no detalhe
      update sc_srv.tbl_sgr set cd_has = vl_cd_has where cd_sgr = rg_sgr.cd_sgr;
    end loop;

  end if;

  -- trailler
  if vl_qnt_registro > 0 then
    vl_linha := '16'; -- codigo trailler
    vl_linha := vl_linha || sc_arq.preencher(9, vl_qnt_registro, '0', ct_completar_direita); -- Total de registros enviados
    vl_linha := vl_linha || sc_arq.preencher(1989, '', ' ', ct_completar_esquerda); -- Filler

    perform sc_arq.gravarlinha(vl_nome_arquivo, vl_linha);
  end if;
end;$$;


ALTER FUNCTION sc_srv.arquivo_perda_roubo_mapfre() OWNER TO scan;

--
-- TOC entry 1552 (class 1255 OID 876284)
-- Name: cancelar_servico(numeric, numeric, character varying, numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cancelar_servico(vp_servico numeric, vp_cartao numeric, vp_motivo character varying, vp_usuario numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  CT_SITUACAO_SERVICO_ATIVO constant numeric := 1;
  CT_SITUACAO_SERVICO_CANCELADO constant numeric := 2;

  CT_SITUACAO_TARIFA_CADASTRADO constant numeric := 1;
  CT_SITUACAO_TARIFA_CANCELADO constant numeric := 3;

  rg record;
  rg_tsc record;
  
begin

  -- caso o cartao nao seja informado nao faz nada
  if vp_cartao is null then
     return;
  end if;

  -- iterando sobre o(s) servico(s) cadastrados no cartao
  for rg in select cd_scr, cd_srv
            from sc_srv.tbl_scr
              where cd_crt = vp_cartao 
                and cd_srv = coalesce(vp_servico,cd_srv) 
                and st_scr = CT_SITUACAO_SERVICO_ATIVO loop

        -- cancelando as tarifas cadastradas
        update sc_srv.tbl_tsc 
          set st_tsc = CT_SITUACAO_TARIFA_CANCELADO,
              cd_alt_usr = 1,
              dt_alt_usr = now()
        where cd_crt = vp_cartao
          and cd_srv = rg.cd_srv;  

        -- inativando o servico de cartao
        update sc_srv.tbl_scr 
          set st_scr = CT_SITUACAO_SERVICO_CANCELADO,
              cd_alt_usr = 1,
              dt_alt_usr = now()
        where cd_crt = vp_cartao
          and cd_srv = rg.cd_srv;     

  end loop;              
end;$$;


ALTER FUNCTION sc_srv.cancelar_servico(vp_servico numeric, vp_cartao numeric, vp_motivo character varying, vp_usuario numeric) OWNER TO scan;

--
-- TOC entry 7879 (class 0 OID 0)
-- Dependencies: 1552
-- Name: FUNCTION cancelar_servico(vp_servico numeric, vp_cartao numeric, vp_motivo character varying, vp_usuario numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cancelar_servico(vp_servico numeric, vp_cartao numeric, vp_motivo character varying, vp_usuario numeric) IS 'rotina que inativa a cobranca de um servico de cartao';


--
-- TOC entry 1471 (class 1255 OID 564557)
-- Name: carga_inicial_seguro(); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION carga_inicial_seguro() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_srv_seguro numeric := 1;
ct_sga_mapfre numeric := 1;

ct_st_srv_cadastrado numeric := 1;
ct_tp_adp_empresa numeric := 2;

vl_cd_src numeric;

rg_crt record;

begin
  for rg_crt in select *
                from sc_opr.tbl_crt crt
                  inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                where fnc.cd_emp = 2255 
                  and crt.fg_atv_crt = 'S' loop

    select nextval('sc_srv.sq_src') into vl_cd_src;

    -- inserindo o servico
    insert into sc_srv.tbl_src (cd_src, cd_srv, cd_crt, st_src, cd_inc_usr, dt_inc_usr, tp_ads_src)
      values (vl_cd_src, ct_srv_seguro, rg_crt.cd_crt, ct_st_srv_cadastrado, 1, now(), ct_tp_adp_empresa);

    -- inserindo o seguro
    insert into sc_srv.tbl_sgr (cd_sgr, cd_sga, cd_src, vl_sgr, vl_prs_sgr, qt_prs_sgr, dt_vnc_sgr, vl_fin_sgr)
      values (nextval('sc_srv.sq_sgr'), ct_sga_mapfre, vl_cd_src, 1.2, 1.2, 1, current_date + 20, 1.2);

  end loop;
end;$$;


ALTER FUNCTION sc_srv.carga_inicial_seguro() OWNER TO scan;

--
-- TOC entry 7880 (class 0 OID 0)
-- Dependencies: 1471
-- Name: FUNCTION carga_inicial_seguro(); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION carga_inicial_seguro() IS 'carga inicial seguro';


--
-- TOC entry 1443 (class 1255 OID 564558)
-- Name: cobrar_servico(date); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_servico(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_st_scr_ativo numeric := 1;
ct_tp_ads_scr_individual numeric := 1;
ct_cd_srv_seguro_perda_roubo numeric := 1;
ct_cd_srv_seguro_affinity numeric := 2;

rg_scr record;

begin

  for rg_scr in select distinct scr.cd_srv
                from sc_srv.tbl_scr scr
                where scr.st_scr = ct_st_scr_ativo
                  and scr.tp_ads_scr = ct_tp_ads_scr_individual loop
                  
    if rg_scr.cd_srv = ct_cd_srv_seguro_perda_roubo then  
      perform sc_srv.cobrar_servico_seguro_perda_roubo(vp_data);

    elsif rg_scr.cd_srv = ct_cd_srv_seguro_affinity then 
      perform sc_srv.cobrar_servico_seguro_affinity(vp_data);

    end if;
    
  end loop;
end;$$;


ALTER FUNCTION sc_srv.cobrar_servico(vp_data date) OWNER TO scan;

--
-- TOC entry 7881 (class 0 OID 0)
-- Dependencies: 1443
-- Name: FUNCTION cobrar_servico(vp_data date); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_servico(vp_data date) IS 'cobrar todos os tipos de servico dos cartoes';


--
-- TOC entry 1607 (class 1255 OID 564559)
-- Name: cobrar_servico_1_via_cartao(numeric, date); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_servico_1_via_cartao(vp_cartao numeric, vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_cd_srv_1_via_cartao numeric := 7;
ct_st_scr_ativo numeric := 1;
ct_st_scr_inativo numeric := 2;
ct_tp_ads_scr_individual numeric := 1;
ct_st_tsc_cadastrado numeric := 1;
ct_pce_tarifa_1_via_cartao numeric := 8;

ct_cd_top_1_via_cartao numeric := 10;
ct_st_opr_confirmada numeric := 2;
vl_data_vencimento date;
vl_contrato numeric;
vl_valor_tarifa numeric;

rg record;

begin
   
  if vp_data is null then
    vl_data_vencimento := current_date;
  else
    vl_data_vencimento := vp_data;
  end if;

  for rg in select * 
            from sc_srv.tbl_scr 
            where cd_srv = ct_cd_srv_1_via_cartao
              and st_scr = ct_st_scr_ativo
              and tp_ads_scr = ct_tp_ads_scr_individual
  loop

    vl_contrato := 0;
    
    -- capturando o contrato da empresa do cartao a ser cobrado
    select ctr.cd_ctr 
      into vl_contrato
    from sc_cad.tbl_fnc fnc
       inner join sc_opr.tbl_crt crt on crt.cd_fnc = fnc.cd_fnc
       inner join sc_cad.tbl_ctr ctr on ctr.cd_emp = fnc.cd_emp
    where crt.cd_crt = rg.cd_crt
      and ctr.fg_atv_ctr = 'S';

    if vl_contrato != 0 then
            -- capturando o valor da tarifa no contrato da empresa
            select replace(replace(sc_cad.get_parametro_contrato_cartao(ct_pce_tarifa_1_via_cartao, rg.cd_crt), '.', ''),',','.')::numeric(13,2)
            into vl_valor_tarifa;
            
	    /*select replace(vl_pce_ctr,',','.')::numeric
	      into vl_valor_tarifa
	    from sc_cad.tbl_pce_ctr
	    where cd_ctr = vl_contrato
	      and cd_pce = ct_pce_tarifa_1_via_cartao;*/
	    
	    -- gerando a tarifa
	    insert into sc_srv.tbl_tsc (cd_tsc, cd_srv, cd_crt, vl_tsc, st_tsc, dt_vnc_tsc, cd_inc_usr, dt_inc_usr, cd_opr)
		      values (nextval('sc_srv.sq_tsc'), ct_cd_srv_1_via_cartao, rg.cd_crt, vl_valor_tarifa, ct_st_tsc_cadastrado, vl_data_vencimento, 1, now(), null);
		       
	    -- inativando o servico para não cobrar em duplicidade
	    update sc_srv.tbl_scr set st_scr = ct_st_scr_inativo where cd_scr = rg.cd_scr;
    end if;
    
  end loop;

end;$$;


ALTER FUNCTION sc_srv.cobrar_servico_1_via_cartao(vp_cartao numeric, vp_data date) OWNER TO scan;

--
-- TOC entry 7882 (class 0 OID 0)
-- Dependencies: 1607
-- Name: FUNCTION cobrar_servico_1_via_cartao(vp_cartao numeric, vp_data date); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_servico_1_via_cartao(vp_cartao numeric, vp_data date) IS 'cobrar tarifa servico 1 via de cartao';


--
-- TOC entry 1474 (class 1255 OID 564560)
-- Name: cobrar_servico_conta_inativa(date); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_servico_conta_inativa(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  CT_PRM_VL_TRF_SERVICO_CONTA_INATIVA constant varchar := 'VALOR_TARIFA_SERVICO_CONTA_INATIVA';
  CT_SERVICO_CONTA_INATIVA constant numeric := 4;
  CT_SITUACAO_OPERACAO_CONFIRMADA constant numeric := 2;
  CT_TIPO_OPERACAO_SERVICO_CONTA_INATIVA constant numeric := 18;

  vl_rg record;

  vl_tarifa numeric;
  vl_saldo_cartao numeric;
  vl_valor_a_cobrar numeric;
  vl_plastico numeric;
  vl_codigo_tarifa_servico_conta_inativa numeric;
    
begin

  -- capturando o valor da tarifa
  select vl_prm::numeric
    into vl_tarifa
  from sc_cad.tbl_prm
  where nm_prm = CT_PRM_VL_TRF_SERVICO_CONTA_INATIVA;

  -- capturando os cartoes que devem ser cobrados o servico de conta inativa
  for vl_rg in  select distinct scr.cd_crt as cartao, scr.cd_srv as servico
		from sc_srv.tbl_scr scr
		  inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = scr.cd_crt and cc.fg_pdr_cnt_crt = 'S'
		where scr.st_scr = 1 -- ATIVO
		   and scr.cd_srv = CT_SERVICO_CONTA_INATIVA
		   and sc_cnt.saldo_conta(cc.cd_cnt, 'S', 'N') > 0
                   and not exists
				(
				select 1
				from sc_srv.tbl_tsc tsc
				where tsc.cd_crt = scr.cd_crt
				  and tsc.st_tsc in (1,2) -- cadastrada ou cobrado
				  and tsc.dt_vnc_tsc >= vp_data_referencia - interval '1 month'
				)
				/*(
				select 1
				from sc_opr.tbl_opr opr
					inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
					inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
				where crt.cd_crt = scr.cd_crt
				  and opr.cd_top in (CT_TIPO_OPERACAO_SERVICO_CONTA_INATIVA)
				  and opr.st_opr in (CT_SITUACAO_OPERACAO_CONFIRMADA)
				  and dt_opr >= vp_data_referencia - interval '1 month'
				  --and dt_opr < vp_data_referencia
				)*/		
   loop

        -- capturar o saldo da conta padrao
	vl_saldo_cartao := sc_cnt.get_saldo_cartao(vl_rg.cartao, 'S', 'S');

	if vl_saldo_cartao > 0 then
	   -- obtem o valor a ser cobrado, pois o saldo da conta pode ser menor que a tarifa a ser cobrada
	   if vl_saldo_cartao < vl_tarifa then
	      vl_valor_a_cobrar := vl_saldo_cartao;
	   else
	      vl_valor_a_cobrar := vl_tarifa;
	   end if;
	
	   -- gravar na tabela de tarifa de servico de cartao para ser cobrado
	   select nextval('sc_srv.sq_tsc') into vl_codigo_tarifa_servico_conta_inativa;

	   insert into sc_srv.tbl_tsc(cd_tsc, cd_srv, cd_crt, vl_tsc, st_tsc, dt_vnc_tsc, cd_inc_usr, dt_inc_usr)
	  	  values (vl_codigo_tarifa_servico_conta_inativa, CT_SERVICO_CONTA_INATIVA, vl_rg.cartao, vl_valor_a_cobrar, 1, now()::date, 1, now());
	end if;	
   end loop;
end;$$;


ALTER FUNCTION sc_srv.cobrar_servico_conta_inativa(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7883 (class 0 OID 0)
-- Dependencies: 1474
-- Name: FUNCTION cobrar_servico_conta_inativa(vp_data_referencia date); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_servico_conta_inativa(vp_data_referencia date) IS 'rotina que cobra a tarifa de serviço de conta inativa dos cartões que foram identificado que possuem conta inativa';


--
-- TOC entry 1792 (class 1255 OID 564561)
-- Name: cobrar_servico_saque_arredondado(numeric, date); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_servico_saque_arredondado(vp_cartao numeric, vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_cd_srv_saque_arredondado numeric := 6;
ct_st_scr_ativo numeric := 1;
ct_st_tsc_cadastrado numeric := 1;

ct_cd_top_saque_arredondado numeric := 19;
ct_st_opr_confirmada numeric := 2;
vl_data_vencimento date;

begin
   
  if vp_data is null then
    vl_data_vencimento := current_date;
  else
    vl_data_vencimento := vp_data;
  end if;
  
  insert into sc_srv.tbl_tsc (cd_tsc, cd_srv, cd_crt, vl_tsc, st_tsc, dt_vnc_tsc, cd_inc_usr, dt_inc_usr, cd_opr)
    select nextval('sc_srv.sq_tsc') as cd_tsc, ct_cd_srv_saque_arredondado as cd_srv, pls.cd_crt as cd_crt, opr.vl_opr as vl_tsc, ct_st_tsc_cadastrado as st_tsc, vl_data_vencimento as dt_vnc_tsc, 1 as cd_inc_usr, clock_timestamp() as dt_inc_usr, opr.cd_opr
     from sc_opr.tbl_opr opr
       inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls 
    where opr.cd_top = ct_cd_top_saque_arredondado
      and (
            (opr.dt_opr >= vp_data - interval '1 day' 
            and opr.dt_opr < vp_data) 
            or vp_data is null
          )
      and opr.st_opr = ct_st_opr_confirmada
      and (pls.cd_crt = vp_cartao or vp_cartao is null)
      and not exists (select 1 from sc_srv.tbl_tsc where cd_opr = opr.cd_opr); 

end;$$;


ALTER FUNCTION sc_srv.cobrar_servico_saque_arredondado(vp_cartao numeric, vp_data date) OWNER TO scan;

--
-- TOC entry 7884 (class 0 OID 0)
-- Dependencies: 1792
-- Name: FUNCTION cobrar_servico_saque_arredondado(vp_cartao numeric, vp_data date); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_servico_saque_arredondado(vp_cartao numeric, vp_data date) IS 'cobrar tarifa servico saque arredondado';


--
-- TOC entry 1472 (class 1255 OID 564562)
-- Name: cobrar_servico_seguro_affinity(date); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_servico_seguro_affinity(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_cd_srv_seguro_affinity numeric := 2;
ct_tp_ads_scr_individual numeric := 1;
ct_st_scr_ativo numeric := 1;
ct_st_tsc_cadastrado numeric := 1;

rg_sgr record;
vl_nova_data_vencimento date;
vl_existe_tarifa numeric := 0;
vl_data_vencimento date;
vl_data_validade date;

begin
  
  vl_data_vencimento := vp_data + interval '5 days';

  for rg_sgr in select *
                from sc_srv.tbl_sgr sgr
                  inner join sc_srv.tbl_scr scr on scr.cd_scr = sgr.cd_scr
                  inner join sc_opr.tbl_crt crt on crt.cd_crt = scr.cd_crt
                where crt.dt_prx_apr_crt = vp_data
                  and scr.tp_ads_scr = ct_tp_ads_scr_individual
                  and scr.st_scr = ct_st_scr_ativo 
                  and scr.cd_srv = ct_cd_srv_seguro_affinity
                  and sgr.dt_vnc_sgr + interval '1 month' * qt_prs_sgr >= vp_data + interval '5 days' loop

    select count(*)
      into vl_existe_tarifa
    from sc_srv.tbl_tsc tsc
    where tsc.cd_crt = rg_sgr.cd_crt
      and tsc.cd_srv = ct_cd_srv_seguro_affinity
      and to_char(tsc.dt_vnc_tsc,'mm/yyyy') = to_char(vl_data_vencimento,'mm/yyyy');

    if vl_existe_tarifa = 0 then
      insert into sc_srv.tbl_tsc (cd_tsc, cd_srv, cd_crt, vl_tsc, st_tsc, dt_vnc_tsc, cd_inc_usr, dt_inc_usr)
        values (nextval('sc_srv.sq_tsc'), ct_cd_srv_seguro_affinity, rg_sgr.cd_crt, rg_sgr.vl_prs_sgr, ct_st_tsc_cadastrado, vl_data_vencimento, 1, now());
    end if; 

  end loop;

end;$$;


ALTER FUNCTION sc_srv.cobrar_servico_seguro_affinity(vp_data date) OWNER TO scan;

--
-- TOC entry 1473 (class 1255 OID 564563)
-- Name: cobrar_servico_seguro_perda_roubo(date); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_servico_seguro_perda_roubo(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_cd_srv_seguro_perda_roubo numeric := 1;
ct_tp_ads_scr_individual numeric := 1;
ct_st_scr_ativo numeric := 1;
ct_st_tsc_cadastrado numeric := 1;

rg_sgr record;
vl_nova_data_vencimento date;
vl_existe_tarifa numeric := 0;
vl_data_vencimento date;
vl_data_validade date;

begin

  vl_data_vencimento := vp_data + interval '5 days';

  for rg_sgr in select *
                from sc_srv.tbl_sgr sgr
                  inner join sc_srv.tbl_scr scr on scr.cd_scr = sgr.cd_scr
                  inner join sc_opr.tbl_crt crt on crt.cd_crt = scr.cd_crt
                where crt.dt_prx_apr_crt = vp_data
                  and scr.tp_ads_scr = ct_tp_ads_scr_individual
                  and scr.st_scr = ct_st_scr_ativo 
                  and scr.cd_srv = ct_cd_srv_seguro_perda_roubo
                  and sgr.dt_vnc_sgr + interval '1 month' * qt_prs_sgr >= vp_data + interval '5 days' loop

    select count(*)
      into vl_existe_tarifa
    from sc_srv.tbl_tsc tsc
    where tsc.cd_crt = rg_sgr.cd_crt
      and tsc.cd_srv = ct_cd_srv_seguro_perda_roubo
      and to_char(tsc.dt_vnc_tsc,'mm/yyyy') = to_char(vl_data_vencimento,'mm/yyyy');

    if vl_existe_tarifa = 0 then
      insert into sc_srv.tbl_tsc (cd_tsc, cd_srv, cd_crt, vl_tsc, st_tsc, dt_vnc_tsc, cd_inc_usr, dt_inc_usr)
        values (nextval('sc_srv.sq_tsc'), ct_cd_srv_seguro_perda_roubo, rg_sgr.cd_crt, rg_sgr.vl_prs_sgr, ct_st_tsc_cadastrado, vl_data_vencimento, 1, now());
    end if; 

  end loop;

end;$$;


ALTER FUNCTION sc_srv.cobrar_servico_seguro_perda_roubo(vp_data date) OWNER TO scan;

--
-- TOC entry 7885 (class 0 OID 0)
-- Dependencies: 1473
-- Name: FUNCTION cobrar_servico_seguro_perda_roubo(vp_data date); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_servico_seguro_perda_roubo(vp_data date) IS 'cobrar tarifa servico seguro';


--
-- TOC entry 1553 (class 1255 OID 564564)
-- Name: cobrar_servico_tmc_OLD(date); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION "cobrar_servico_tmc_OLD"(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  rg_crt record;
  
  ct_pce_tmc numeric := 15;
  ct_top_tmc numeric := 13;
  ct_srv_tmc numeric := 12;
  
  vl_plastico numeric;
  vl_cod_tarifa numeric;
  vl_cod_operacao numeric;
  vl_valor_tmc numeric;
begin 
   for rg in  select distinct hfe.cd_ctr as contrato
		  from sc_adp.tbl_rdp rdp
			inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
			inner join sc_cad.tbl_emp emp on emp.cd_emp = hfe.cd_emp
			inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
		  where rdp.st_rdp = 5
			and emp.cd_gem in (1, 133) -- cameron, kioma
			and emp.cd_emp not in (999) -- saqcard
			and crt.fg_atv_crt = 'S'
			and hfe.dt_dps_hfe > vp_data_referencia - interval '3 month'
			and not exists (select 1 
					from sc_opr.tbl_opr opr
					  inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
					where pls.cd_crt = crt.cd_crt
					  and opr.dt_opr > vp_data_referencia - interval '1 month'
					  and opr.dt_opr <= vp_data_referencia
					  and opr.cd_top = ct_top_tmc)
		  order by contrato	   
   loop
   
     -- pegando o valor da tmc do contrato para cobrar a tarifa dos cartoes
	 begin
       select replace(replace(pce_ctr.vl_pce_ctr, '.', ''), ',', '.')
          into strict vl_valor_tmc
       from sc_cad.tbl_pce_ctr pce_ctr 
       where cd_ctr = rg.contrato
          and cd_pce = ct_pce_tmc;
     exception when others then
        vl_valor_tmc := 0;
     end;
	 
     if vl_valor_tmc > 0 then 
       
	   for rg_crt in  select distinct crt.cd_crt as cartao
			  from sc_adp.tbl_rdp rdp
				inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
				inner join sc_cad.tbl_emp emp on emp.cd_emp = hfe.cd_emp
				inner join sc_opr.tbl_crt crt on crt.cd_crt = rdp.cd_crt
			  where rdp.st_rdp = 5
				and emp.cd_gem in (1, 133) -- cameron, kioma
				and emp.cd_emp not in (999) -- saqcard
				and crt.fg_atv_crt = 'S'
				and hfe.cd_ctr = rg.contrato
				and hfe.dt_dps_hfe > vp_data_referencia - interval '3 month'
				and not exists (select 1 
						from sc_opr.tbl_opr opr
						  inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
						where pls.cd_crt = crt.cd_crt
						  and opr.dt_opr > vp_data_referencia - interval '1 month'
						  and opr.dt_opr <= vp_data_referencia
						  and opr.cd_top = ct_top_tmc)
			  order by cartao	   
       loop

		  select cd_pls 
			into vl_plastico
		  from sc_opr.tbl_pls
		  where cd_crt = rg_crt.cartao
		  order by dt_inc_usr desc;

		  select nextval('sc_opr.sq_opr') into vl_cod_operacao;
		  select nextval('sc_srv.sq_tsc') into vl_cod_tarifa;

		 -- gravando a operação
		 INSERT INTO sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, vl_trf_opr, 
							 nr_prc_opr, vl_prc_opr, vl_iof_opr, nr_nsu_org_opr, st_opr, dt_prc_opr)
		  VALUES (vl_cod_operacao, ct_top_tmc, vl_plastico, null, vp_data_referencia, vl_valor_tmc, 0, vl_valor_tmc, 
				1, vl_valor_tmc, 0, vl_cod_tarifa, 2, vp_data_referencia);

		 -- gravando a tarifa de servico
		 insert into sc_srv.tbl_tsc (cd_tsc, cd_srv, cd_crt, vl_tsc, st_tsc, dt_vnc_tsc, cd_inc_usr, dt_inc_usr, cd_opr)
			 values (vl_cod_tarifa, ct_srv_tmc, rg_crt.cartao, vl_valor_tmc, 1, vp_data_referencia, 1, now(), vl_cod_operacao);

	   end loop;
	 end if;
   end loop;

end;$$;


ALTER FUNCTION sc_srv."cobrar_servico_tmc_OLD"(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7886 (class 0 OID 0)
-- Dependencies: 1553
-- Name: FUNCTION "cobrar_servico_tmc_OLD"(vp_data_referencia date); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION "cobrar_servico_tmc_OLD"(vp_data_referencia date) IS 'cobrar tarifa TMC do cartao';


--
-- TOC entry 1559 (class 1255 OID 877297)
-- Name: cobrar_servico_tmc_deposito(numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_servico_tmc_deposito(vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
  rg_crt record;
  
  ct_pce_tmc numeric := 15;
  ct_top_tmc numeric := 13;
  ct_srv_tmc numeric := 12;

  ct_sit_servico_ativo numeric := 1;
  ct_sit_tarifa_ativo numeric := 1;
  ct_sit_tarifa_cobrado numeric := 2;

  ct_tipo_pgto_funcionario numeric := 2;
  
  vl_plastico numeric;
  vl_cod_tarifa numeric;
  vl_cod_operacao numeric;

  vl_tipo_cobranca_tmc numeric := 0;
  vl_valor_tmc numeric(13,2) := 0;

  vl_existe numeric;
  
  vl_dt_pri_dps date;

  --vl_tmc_minutrade numeric;
begin
   
   -- verifica se eh o primeiro deposito
   select dt_pri_dps_crt
     into vl_dt_pri_dps
   from sc_opr.tbl_crt 
   where cd_crt = vp_cartao;

   if vl_dt_pri_dps is not null then
     return;
   end if;

   -- retornando se a cobranca eh do funcionario
   vl_tipo_cobranca_tmc := sc_cad.get_parametro_contrato_cartao(ct_pce_tmc, vp_cartao, 3)::numeric;
   -- retornando a tarifa
   vl_valor_tmc := replace(replace(sc_cad.get_parametro_contrato_cartao(ct_pce_tmc, vp_cartao, 1),'.',''),',','.')::numeric(13,2);

   if vl_valor_tmc > 0 and vl_tipo_cobranca_tmc = ct_tipo_pgto_funcionario then

     -- insere o servico de TMC caso o cartao nao possua
     select count(*)
       into vl_existe
       from sc_srv.tbl_scr
     where cd_crt = vp_cartao
       and cd_srv = ct_srv_tmc
       and st_scr = ct_sit_servico_ativo;

     if vl_existe = 0 then

       -- inserindo o servico de TMC
       INSERT INTO sc_srv.tbl_scr(cd_scr, cd_srv, cd_crt, st_scr, tp_ads_scr, cd_inc_usr, dt_inc_usr)
			VALUES (nextval('sc_srv.sq_scr'), ct_srv_tmc, vp_cartao, 1, 1, 1, now());

     end if;   

     insert into sc_srv.tbl_tsc (cd_tsc, cd_srv, cd_crt, vl_tsc, st_tsc, dt_vnc_tsc, cd_inc_usr, dt_inc_usr)
		values (nextval('sc_srv.sq_tsc'), ct_srv_tmc, vp_cartao, vl_valor_tmc, 1, current_date, 1, now());

     -- inserindo a tarifa de servico de TMC caso nao exista
     /*select count(*)
       into vl_existe
       from sc_srv.tbl_tsc
     where cd_crt = vp_cartao
       and cd_srv = ct_srv_tmc
       and st_tsc in (ct_sit_tarifa_ativo, ct_sit_tarifa_cobrado)
       --and to_char(dt_vnc_tsc,'mmyyyy') = to_char(current_date,'mmyyyy');  
       and (current_date - dt_vnc_tsc) <= 23;
     

     if vl_existe = 0 then

       -- testando se existe operacao somente para o mes de julho de 2016
       /*if to_char(current_date,'mmyyyy') = '072016' then

          select count(*)
              into vl_existe 
                   from sc_opr.tbl_opr opr
                     inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
                   where cd_top = 13
                     and st_opr = 2
                     and cd_crt = vp_cartao
                     and dt_opr >= to_date('01/' || to_char(current_date,'mm/yyyy'),'dd/mm/yyyy')
                     and dt_opr < current_date + 1;
	
       end if;
       */

       --if vl_existe = 0 then

          -- MINUTRADE
/*          select coalesce(sc_mnt.get_valor_tmc_minutrade(vp_cartao),0) into vl_tmc_minutrade;       

          if vl_tmc_minutrade > 0 then
             vl_valor_tmc := vl_tmc_minutrade;
          end if;
          -- FIM MINUTRADE
*/
      --    insert into sc_srv.tbl_tsc (cd_tsc, cd_srv, cd_crt, vl_tsc, st_tsc, dt_vnc_tsc, cd_inc_usr, dt_inc_usr)
      --   values (nextval('sc_srv.sq_tsc'), ct_srv_tmc, vp_cartao, vl_valor_tmc, 1, current_date, 1, now());

      -- end if;
       */	
   
     --end if;
     
  end if;  

end;$$;


ALTER FUNCTION sc_srv.cobrar_servico_tmc_deposito(vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7887 (class 0 OID 0)
-- Dependencies: 1559
-- Name: FUNCTION cobrar_servico_tmc_deposito(vp_cartao numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_servico_tmc_deposito(vp_cartao numeric) IS 'cobrar tarifa TMC do cartao no momento do deposito';


--
-- TOC entry 1632 (class 1255 OID 931502)
-- Name: cobrar_servico_tsm(); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_servico_tsm() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin
   perform sc_srv.cobrar_servico_tsm(null);
end;$$;


ALTER FUNCTION sc_srv.cobrar_servico_tsm() OWNER TO scan;

--
-- TOC entry 7888 (class 0 OID 0)
-- Dependencies: 1632
-- Name: FUNCTION cobrar_servico_tsm(); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_servico_tsm() IS 'cobrar tarifa TSM dos cartoes ativos mensalmente que ja sofreram o primeiro deposito';


--
-- TOC entry 1702 (class 1255 OID 1666826)
-- Name: cobrar_servico_tsm(date); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_servico_tsm(vp_data_ref date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  rg record;
    
  ct_pce_tmc numeric := 15;
  ct_top_tmc numeric := 13;
  ct_srv_tmc numeric := 12;

  ct_sit_servico_ativo numeric := 1;
  ct_sit_tarifa_ativo numeric := 1;
  ct_sit_tarifa_cobrado numeric := 2;

  ct_tipo_pgto_funcionario numeric := 2;
  
  vl_plastico numeric;
  vl_cod_tarifa numeric;
  vl_cod_operacao numeric;

  vl_tipo_cobranca_tmc numeric := 0;
  vl_valor_tmc numeric(13,2) := 0;

  vl_existe numeric;

  vl_data_ref date;
  
  --vl_tmc_minutrade numeric;
begin

   vl_data_ref := coalesce(vp_data_ref, current_date);
   
   if to_char(vl_data_ref,'dd') <> '01' then
     return;
   end if;

   for rg in select crt.cd_crt, replace(replace(sc_cad.get_parametro_contrato_cartao(ct_pce_tmc, crt.cd_crt, 1),'.',''),',','.')::numeric(13,2) as vl_valor_tsm
                 from sc_opr.tbl_crt crt
                 where crt.fg_atv_crt = 'S'
                   and crt.dt_pri_dps_crt is not null
                   and crt.cd_prd = 1
                   AND sc_cad.get_parametro_contrato_cartao(ct_pce_tmc, crt.cd_crt, 3)::numeric = 2
                   and not exists (select 1 from sc_srv.tbl_tsc 
                                   where cd_crt = crt.cd_crt 
                                     and cd_srv = ct_srv_tmc
                                     AND st_tsc in (ct_sit_tarifa_ativo, ct_sit_tarifa_cobrado)
                                     AND to_char(dt_vnc_tsc,'mm/yyyy') = to_char(vl_data_ref,'mm/yyyy')) loop


	if rg.vl_valor_tsm > 0 then

	     -- insere o servico de TMC caso o cartao nao possua
	     select count(*)
	       into vl_existe
	       from sc_srv.tbl_scr
	     where cd_crt = rg.cd_crt
	       and cd_srv = ct_srv_tmc
	       and st_scr = ct_sit_servico_ativo;

	     if vl_existe = 0 then

	       -- inserindo o servico de TMC
	       INSERT INTO sc_srv.tbl_scr(cd_scr, cd_srv, cd_crt, st_scr, tp_ads_scr, cd_inc_usr, dt_inc_usr)
				VALUES (nextval('sc_srv.sq_scr'), ct_srv_tmc, rg.cd_crt, 1, 1, 1, now());

	     end if;   

             insert into sc_srv.tbl_tsc (cd_tsc, cd_srv, cd_crt, vl_tsc, st_tsc, dt_vnc_tsc, cd_inc_usr, dt_inc_usr)
		values (nextval('sc_srv.sq_tsc'), ct_srv_tmc, rg.cd_crt, rg.vl_valor_tsm, 1, vl_data_ref, 1, now());

	   end if;  
   end loop;                                  
   

end;$$;


ALTER FUNCTION sc_srv.cobrar_servico_tsm(vp_data_ref date) OWNER TO scan;

--
-- TOC entry 7889 (class 0 OID 0)
-- Dependencies: 1702
-- Name: FUNCTION cobrar_servico_tsm(vp_data_ref date); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_servico_tsm(vp_data_ref date) IS 'cobrar tarifa TSM dos cartoes ativos mensalmente que ja sofreram o primeiro deposito';


--
-- TOC entry 1574 (class 1255 OID 564565)
-- Name: cobrar_tarifa_servico(date, numeric, numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_servico(vp_data_referencia date, vp_servico numeric DEFAULT NULL::numeric, vp_cartao numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin
  perform sc_srv.cobrar_tarifa_servico(vp_data_referencia, vp_servico, vp_cartao, null);
end;$$;


ALTER FUNCTION sc_srv.cobrar_tarifa_servico(vp_data_referencia date, vp_servico numeric, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7890 (class 0 OID 0)
-- Dependencies: 1574
-- Name: FUNCTION cobrar_tarifa_servico(vp_data_referencia date, vp_servico numeric, vp_cartao numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_tarifa_servico(vp_data_referencia date, vp_servico numeric, vp_cartao numeric) IS 'cobrar(debitar) todas as tarifas de serviços de cartao cadastradas';


--
-- TOC entry 1714 (class 1255 OID 1666828)
-- Name: cobrar_tarifa_servico(date, numeric, numeric, numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_servico(vp_data_referencia date, vp_servico numeric, vp_cartao numeric, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_st_cadastrado numeric := 1;

ct_cd_srv_seguro_perda_roubo numeric := 1;
ct_cd_srv_servico_conta_inativa numeric := 4;
ct_cd_srv_servico_saque_arredondado numeric := 6;
ct_cd_srv_servico_1_via_cartao numeric := 7;
ct_cd_srv_servico_desconto_no_vencimento numeric := 10;
ct_cd_srv_servico_tad numeric := 11;
ct_cd_srv_servico_tmc numeric := 12;
ct_cd_srv_servico_tarifa_contestacao_indevida numeric := 13;

vl_rg record;

begin
  
  for vl_rg in  select distinct tsc.cd_srv as servico
                from sc_srv.tbl_tsc tsc
			inner join sc_srv.tbl_srv srv on srv.cd_srv = tsc.cd_srv
			inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
			inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
			inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and cc.fg_pdr_cnt_crt = 'S'
			left join  sc_opr.tbl_opr opr on opr.cd_opr = tsc.cd_opr
                where tsc.st_tsc = ct_st_cadastrado
                  and tsc.dt_vnc_tsc <= vp_data_referencia
                  and tsc.cd_srv = COALESCE(vp_servico, tsc.cd_srv)
                  and tsc.cd_crt = COALESCE(vp_cartao, tsc.cd_crt)
                  and fnc.cd_emp = COALESCE(vp_empresa, fnc.cd_emp)
                order by servico
  loop
                  
     if vl_rg.servico = ct_cd_srv_servico_conta_inativa then  

        perform sc_srv.cobrar_tarifa_servico_conta_inativa(vp_data_referencia, vp_cartao);

     elsif vl_rg.servico = ct_cd_srv_servico_tmc then 

        perform sc_srv.cobrar_tarifa_servico_tmc_deposito(vp_data_referencia, vp_cartao);
         
     elsif vl_rg.servico = ct_cd_srv_servico_saque_arredondado then 

        perform sc_srv.cobrar_tarifa_servico_saque_arredondado(vp_data_referencia, vp_cartao);

     elsif vl_rg.servico = ct_cd_srv_servico_1_via_cartao then 

        perform sc_srv.cobrar_tarifa_servico_1_via_cartao(vp_data_referencia, vp_cartao);

     elsif vl_rg.servico = ct_cd_srv_servico_desconto_no_vencimento then 

        perform sc_srv.cobrar_tarifa_servico_desconto_no_vencimento(vp_data_referencia, vp_cartao);

     elsif vl_rg.servico = ct_cd_srv_servico_tad then 

        perform sc_srv.cobrar_tarifa_servico_tad(vp_data_referencia, vp_cartao);

     elsif vl_rg.servico = ct_cd_srv_servico_tarifa_contestacao_indevida then 

        perform sc_srv.cobrar_tarifa_servico_contestacao_indevida(vp_data_referencia, vp_cartao);                          

     end if;
   
  end loop;
  
end;$$;


ALTER FUNCTION sc_srv.cobrar_tarifa_servico(vp_data_referencia date, vp_servico numeric, vp_cartao numeric, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 7891 (class 0 OID 0)
-- Dependencies: 1714
-- Name: FUNCTION cobrar_tarifa_servico(vp_data_referencia date, vp_servico numeric, vp_cartao numeric, vp_empresa numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_tarifa_servico(vp_data_referencia date, vp_servico numeric, vp_cartao numeric, vp_empresa numeric) IS 'cobrar(debitar) todas as tarifas de serviços de cartao cadastradas';


--
-- TOC entry 1476 (class 1255 OID 564566)
-- Name: cobrar_tarifa_servico_1_via_cartao(date, numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_servico_1_via_cartao(vp_data_referencia date, vp_cartao numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

CT_SITUACAO_OPERACAO_CONFIRMADA constant numeric := 2;
CT_TIPO_OPERACAO_SERVICO_CONTA_INATIVA constant numeric := 18;
CT_TIPO_OPERACAO_PRIMEIRA_VIA_CARTA0 constant numeric := 10;
ct_st_cadastrado numeric := 1;
ct_st_cobrado numeric := 2;

ct_cd_conta_saque_arredondado numeric := 13;
ct_lanc_tarifa_saque_arredondado numeric := 179;

ct_cd_srv_seguro_perda_roubo numeric := 1;
ct_cd_srv_servico_conta_inativa numeric := 4;
ct_cd_srv_servico_saque_arredondado numeric := 6;
ct_cd_srv_servico_1_via_cartao numeric := 7;

vl_valor_credito numeric := 0;
vl_valor_credito_1_via numeric := 0;
vl_nr_lanc_credito numeric := 0;
vl_nr_lanc_debito numeric := 0;
vl_tipo_lancamento numeric := 0;
vl_tipo_lancamento_1_via numeric := 0;
vl_conta_credito numeric := 0;
vl_conta_credito_1_via numeric := 0;
vl_plastico numeric;
vl_conta_debito numeric := 0;
vl_saldo_conta numeric := 0;

vl_rg record;

begin
  select nextval('sc_cnt.sq_lcn') into vl_nr_lanc_credito;

  for vl_rg in  select tsc.cd_tsc as codigo_tarifa_servico, tsc.cd_srv as servico, crt.cd_crt as cartao, cc.cd_cnt as conta_debito, 
		       tsc.vl_tsc as valor, tsc.dt_vnc_tsc as data_vencimento, srv.cd_cnt as conta_credito, srv.cd_tlc as tipo_lancamento,
		       opr.vl_trf_opr as valor_receita_tarifa
                from sc_srv.tbl_tsc tsc
			inner join sc_srv.tbl_srv srv on srv.cd_srv = tsc.cd_srv
			inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
			inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and cc.fg_pdr_cnt_crt = 'S'
			left join  sc_opr.tbl_opr opr on opr.cd_opr = tsc.cd_opr
                where tsc.st_tsc = ct_st_cadastrado
                  and tsc.dt_vnc_tsc <= vp_data_referencia
                  and tsc.cd_srv = ct_cd_srv_servico_1_via_cartao
                  and tsc.cd_crt = COALESCE(vp_cartao, tsc.cd_crt)
                  and sc_cnt.saldo_conta(cc.cd_cnt, 'S', 'N') >= tsc.vl_tsc
                order by servico, cartao 
  loop

        vl_saldo_conta := 0;

        select sc_cnt.saldo_conta(vl_rg.conta_debito, 'S', 'S') into vl_saldo_conta;

        if vl_saldo_conta >= vl_rg.valor then
          
		-- gravar operacao já confirmada para registrar a cobrança
		select cd_pls 
		  into vl_plastico
		from sc_opr.tbl_pls
		where cd_crt = vl_rg.cartao
		order by dt_inc_usr desc;
	      
		insert into sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, 
				vl_trf_opr, nr_nsu_org_opr, nr_prc_opr, vl_prc_opr, vl_iof_opr, st_opr,dt_prc_opr)
		   values(nextval('sc_opr.sq_opr'), CT_TIPO_OPERACAO_PRIMEIRA_VIA_CARTA0, vl_plastico, null, now(), vl_rg.valor, 0, 
				0, vl_rg.codigo_tarifa_servico, 1, vl_rg.valor, 0, CT_SITUACAO_OPERACAO_CONFIRMADA, null);
				
		vl_saldo_conta := 0;
		vl_nr_lanc_debito := null;

		-- realizando o lançamento de debito na conta do funcionario
		--> CONTA DE DEBITO => conta do funcionario
		--> CONTA DE CREDITO => receita
		--> TIPO DE LANCAMENTO => esta definido na tabela de servico de cartao (181 - TARIFA PRIMEIRA VIA DE CARTAO)
		perform sc_cnt.lancar_movimento(vl_nr_lanc_debito, vl_nr_lanc_credito, vl_rg.tipo_lancamento, vl_rg.conta_debito, 'D',
						vl_rg.valor, now()::timestamp, 1::numeric, null, 'COBRANÇA DA TARIFA PRIMEIRA VIA DO CARTAO', 
						15, vl_rg.codigo_tarifa_servico);

		-- marcando que a tarifa de servico já foi COBRADA
		update sc_srv.tbl_tsc set st_tsc = ct_st_cobrado, cd_opr = currval('sc_opr.sq_opr'),dt_pgto_tsc = current_date where cd_tsc = vl_rg.codigo_tarifa_servico;                    
			
		vl_valor_credito := vl_valor_credito + vl_rg.valor;				
		vl_tipo_lancamento := vl_rg.tipo_lancamento;
		vl_conta_credito := vl_rg.conta_credito;                           
			
	end if;

  end loop;

  if vl_valor_credito > 0 then
     
     -- realizando o lancamento: (nr_lanc, nr_lanc_contraPartida, tipo de lancamento, conta, fg_debito_credito, valor, data ref, usr inc, historico, complemento, sistema, nsu)
     perform sc_cnt.lancar_movimento(vl_nr_lanc_credito, null, vl_tipo_lancamento, vl_conta_credito,'C',
                                       vl_valor_credito, now()::timestamp, 1::numeric, null, 'COBRANÇA DA TARIFA PRIMEIRA VIA DO CARTAO', 
                                       15, 0);
  end if;

end;$$;


ALTER FUNCTION sc_srv.cobrar_tarifa_servico_1_via_cartao(vp_data_referencia date, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7892 (class 0 OID 0)
-- Dependencies: 1476
-- Name: FUNCTION cobrar_tarifa_servico_1_via_cartao(vp_data_referencia date, vp_cartao numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_tarifa_servico_1_via_cartao(vp_data_referencia date, vp_cartao numeric) IS 'cobrar(debitar) todas as tarifas de serviços de cartao PRIMEIRA VIA DE CARTAO cadastradas';


--
-- TOC entry 1799 (class 1255 OID 564569)
-- Name: cobrar_tarifa_servico_conta_inativa(date, numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_servico_conta_inativa(vp_data_referencia date, vp_cartao numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

CT_SITUACAO_OPERACAO_CONFIRMADA constant numeric := 2;
CT_TIPO_OPERACAO_SERVICO_CONTA_INATIVA constant numeric := 18;
CT_TIPO_OPERACAO_PRIMEIRA_VIA_CARTA0 constant numeric := 10;
ct_st_cadastrado numeric := 1;
ct_st_cobrado numeric := 2;

ct_cd_conta_saque_arredondado numeric := 13;
ct_lanc_tarifa_saque_arredondado numeric := 179;

ct_cd_srv_seguro_perda_roubo numeric := 1;
ct_cd_srv_servico_conta_inativa numeric := 4;
ct_cd_srv_servico_saque_arredondado numeric := 6;
ct_cd_srv_servico_1_via_cartao numeric := 7;

vl_valor_credito numeric := 0;
vl_valor_credito_1_via numeric := 0;
vl_nr_lanc_credito numeric := 0;
vl_nr_lanc_debito numeric := 0;
vl_tipo_lancamento numeric := 0;
vl_tipo_lancamento_1_via numeric := 0;
vl_conta_credito numeric := 0;
vl_conta_credito_1_via numeric := 0;
vl_plastico numeric;
vl_conta_debito numeric := 0;
vl_saldo_conta numeric := 0;

vl_rg record;

begin

  for vl_rg in  select tsc.cd_tsc as codigo_tarifa_servico, tsc.cd_srv as servico, crt.cd_crt as cartao, cc.cd_cnt as conta_debito, 
		       tsc.vl_tsc as valor, tsc.dt_vnc_tsc as data_vencimento, srv.cd_cnt as conta_credito, srv.cd_tlc as tipo_lancamento,
		       opr.vl_trf_opr as valor_receita_tarifa
                from sc_srv.tbl_tsc tsc
			inner join sc_srv.tbl_srv srv on srv.cd_srv = tsc.cd_srv
			inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
			inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and cc.fg_pdr_cnt_crt = 'S'
			left join  sc_opr.tbl_opr opr on opr.cd_opr = tsc.cd_opr
                where tsc.st_tsc = ct_st_cadastrado
                  and tsc.dt_vnc_tsc <= vp_data_referencia
                  and crt.cd_prd = 1
                  and tsc.cd_srv = ct_cd_srv_servico_conta_inativa
                  and tsc.cd_crt = COALESCE(vp_cartao, tsc.cd_crt)
                  and sc_cnt.saldo_conta(cc.cd_cnt, 'S', 'N') >= tsc.vl_tsc
                order by servico, cartao 
  loop

        if vl_nr_lanc_credito = 0 then
           select nextval('sc_cnt.sq_lcn') into vl_nr_lanc_credito;        
        end if;   

        vl_saldo_conta := 0;

        select sc_cnt.saldo_conta(vl_rg.conta_debito, 'S', 'S') into vl_saldo_conta;

        if vl_saldo_conta >= vl_rg.valor then
  
          -- gravar operacao já confirmada para registrar a cobrança
          select cd_pls 
            into vl_plastico
          from sc_opr.tbl_pls
          where cd_crt = vl_rg.cartao
          order by dt_inc_usr desc;
      
          insert into sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, 
			vl_trf_opr, nr_nsu_org_opr, nr_prc_opr, vl_prc_opr, vl_iof_opr, st_opr,dt_prc_opr)
           values(nextval('sc_opr.sq_opr'), CT_TIPO_OPERACAO_SERVICO_CONTA_INATIVA, vl_plastico, null, now(), vl_rg.valor, 0, 
			vl_rg.valor, vl_rg.codigo_tarifa_servico, 1, vl_rg.valor, 0, CT_SITUACAO_OPERACAO_CONFIRMADA, null);


	  -- realizando o lancamento
	  vl_nr_lanc_debito := null;
		
          perform sc_cnt.lancar_movimento(vl_nr_lanc_debito, vl_nr_lanc_credito, vl_rg.tipo_lancamento, vl_rg.conta_debito, 'D',
                                       vl_rg.valor, now()::timestamp, 1::numeric, null, 'COBRANÇA DA TARIFA DE SERVIÇO DE CONTA INATIVA', 
                                       15, vl_rg.codigo_tarifa_servico);


       	  vl_valor_credito := vl_valor_credito + vl_rg.valor;				
       	  vl_tipo_lancamento := vl_rg.tipo_lancamento;
       	  vl_conta_credito := vl_rg.conta_credito;

       	  -- marcando que a tarifa de servico já foi COBRADA
          update sc_srv.tbl_tsc set st_tsc = ct_st_cobrado, cd_opr = currval('sc_opr.sq_opr'), dt_pgto_tsc = current_date where cd_tsc = vl_rg.codigo_tarifa_servico;

        end if;

  end loop;

  if vl_valor_credito > 0 then
     
     -- realizando o lancamento: (nr_lanc, nr_lanc_contraPartida, tipo de lancamento, conta, fg_debito_credito, valor, data ref, usr inc, historico, complemento, sistema, nsu)
     perform sc_cnt.lancar_movimento(vl_nr_lanc_credito, null, vl_tipo_lancamento, vl_conta_credito,'C',
                                       vl_valor_credito, now()::timestamp, 1::numeric, null, 'COBRANÇA DA TARIFA DE SERVIÇO DE CONTA INATIVA', 
                                       15, 0);
  end if;

end;$$;


ALTER FUNCTION sc_srv.cobrar_tarifa_servico_conta_inativa(vp_data_referencia date, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7893 (class 0 OID 0)
-- Dependencies: 1799
-- Name: FUNCTION cobrar_tarifa_servico_conta_inativa(vp_data_referencia date, vp_cartao numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_tarifa_servico_conta_inativa(vp_data_referencia date, vp_cartao numeric) IS 'cobrar(debitar) todas as tarifas de serviços de cartao de CONTA INATIVA cadastradas';


--
-- TOC entry 1800 (class 1255 OID 564572)
-- Name: cobrar_tarifa_servico_contestacao_indevida(date, numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_servico_contestacao_indevida(vp_data_referencia date, vp_cartao numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

CT_SITUACAO_OPERACAO_CONFIRMADA constant numeric := 2;
CT_TIPO_OPERACAO_TARIFA_CONTESTACAO_INDEVIDA constant numeric := 21;

ct_st_cadastrado numeric := 1;
ct_st_cobrado numeric := 2;

ct_cd_srv_servico_tarifa_contestacao_indevida numeric := 13;

vl_valor_credito numeric := 0;

vl_tipo_lancamento numeric := 0;
vl_conta_credito numeric := 0;
vl_plastico numeric;
vl_conta_debito numeric := 0;
vl_saldo_conta numeric := 0;

vl_rg record;

begin
  
  for vl_rg in  select tsc.cd_tsc as codigo_tarifa_servico, tsc.cd_srv as servico, crt.cd_crt as cartao, cc.cd_cnt as conta_debito, 
		       tsc.vl_tsc as valor, tsc.dt_vnc_tsc as data_vencimento, srv.cd_cnt as conta_credito, srv.cd_tlc as tipo_lancamento,
		       opr.vl_trf_opr as valor_receita_tarifa
                from sc_srv.tbl_tsc tsc
			inner join sc_srv.tbl_srv srv on srv.cd_srv = tsc.cd_srv
			inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
			inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and cc.fg_pdr_cnt_crt = 'S'
			left join  sc_opr.tbl_opr opr on opr.cd_opr = tsc.cd_opr
                where tsc.st_tsc = ct_st_cadastrado
                  and tsc.dt_vnc_tsc <= vp_data_referencia
                  and tsc.cd_srv = ct_cd_srv_servico_tarifa_contestacao_indevida
                  and tsc.cd_crt = COALESCE(vp_cartao, tsc.cd_crt)
                  and sc_cnt.saldo_conta(cc.cd_cnt, 'S', 'N') >= tsc.vl_tsc
                order by servico, cartao 
  loop

        vl_saldo_conta := 0; 
 
        select sc_cnt.saldo_conta(vl_rg.conta_debito, 'S', 'S') into vl_saldo_conta;

        if vl_saldo_conta >= vl_rg.valor then
                  
          -- gravar operacao já confirmada para registrar a cobrança
          select cd_pls 
            into vl_plastico
          from sc_opr.tbl_pls
          where cd_crt = vl_rg.cartao
          order by dt_inc_usr desc;
      
           insert into sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, 
			vl_trf_opr, nr_nsu_org_opr, nr_prc_opr, vl_prc_opr, vl_iof_opr, st_opr,dt_prc_opr)
           values(nextval('sc_opr.sq_opr'), CT_TIPO_OPERACAO_TARIFA_CONTESTACAO_INDEVIDA, vl_plastico, null, now(), vl_rg.valor, 0, 
			vl_rg.valor, vl_rg.codigo_tarifa_servico, 1, vl_rg.valor, 0, CT_SITUACAO_OPERACAO_CONFIRMADA, null);


	  -- realizando o lancamento contabil
	  perform sc_cnt.lancar_debito_credito(vl_rg.conta_debito, vl_rg.conta_credito, vl_rg.tipo_lancamento, null, 'REFERENTE CONTESTACAO INDEVIDA. OPERACAO NSU ' || currval('sc_opr.sq_opr'), vl_rg.valor, clock_timestamp()::timestamp, 1, 15, vl_rg.codigo_tarifa_servico);

       	  -- marcando que a tarifa de servico já foi COBRADA
          update sc_srv.tbl_tsc set st_tsc = ct_st_cobrado, cd_opr = currval('sc_opr.sq_opr'), dt_pgto_tsc = current_date where cd_tsc = vl_rg.codigo_tarifa_servico;

        end if; 

  end loop;

end;$$;


ALTER FUNCTION sc_srv.cobrar_tarifa_servico_contestacao_indevida(vp_data_referencia date, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7894 (class 0 OID 0)
-- Dependencies: 1800
-- Name: FUNCTION cobrar_tarifa_servico_contestacao_indevida(vp_data_referencia date, vp_cartao numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_tarifa_servico_contestacao_indevida(vp_data_referencia date, vp_cartao numeric) IS 'cobrar(debitar) todas as tarifas de serviços de cartao de CONTESTACAO INDEVIDA cadastradas';


--
-- TOC entry 1482 (class 1255 OID 564573)
-- Name: cobrar_tarifa_servico_desconto_no_vencimento(date, numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_servico_desconto_no_vencimento(vp_data_referencia date, vp_cartao numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_st_cadastrado numeric := 1;
ct_st_cobrado numeric := 2;

ct_cd_srv_desconto_no_vencimento numeric := 10;

vl_conta_credito numeric := 0;
vl_saldo_conta numeric := 0;

vl_rg record;

begin
  
  for vl_rg in  select tsc.cd_tsc as codigo_tarifa_servico, tsc.cd_srv as servico, tsc.his_lcn_tsc as complemento_historico, tsc.cd_cnt as conta_credito_servico,
                       crt.cd_crt as cartao, cc.cd_cnt as conta_debito, tsc.vl_tsc as valor, tsc.dt_vnc_tsc as data_vencimento, srv.cd_cnt as conta_credito, srv.cd_tlc as tipo_lancamento
                from sc_srv.tbl_tsc tsc
			inner join sc_srv.tbl_srv srv on srv.cd_srv = tsc.cd_srv
			inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
			inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and cc.fg_pdr_cnt_crt = 'S'
                where tsc.st_tsc = ct_st_cadastrado
                  and tsc.dt_vnc_tsc <= vp_data_referencia
                  and tsc.cd_srv = ct_cd_srv_desconto_no_vencimento
                  and tsc.cd_crt = COALESCE(vp_cartao, tsc.cd_crt)
                  and sc_cnt.saldo_conta(cc.cd_cnt, 'S', 'N') >= tsc.vl_tsc
                order by servico, cartao 
  loop

        vl_saldo_conta := 0;

        select sc_cnt.saldo_conta(vl_rg.conta_debito, 'S', 'S') into vl_saldo_conta;

        if vl_saldo_conta >= vl_rg.valor then
          
		vl_saldo_conta := 0;
                vl_conta_credito := vl_rg.conta_credito;
                

		if not vl_rg.conta_credito_servico is null then
		  vl_conta_credito := vl_rg.conta_credito_servico;
		end if;
				
                perform sc_cnt.lancar_debito_credito(vl_rg.conta_debito, vl_conta_credito, vl_rg.tipo_lancamento, null, vl_rg.complemento_historico,
                                                     vl_rg.valor, clock_timestamp()::timestamp, 1, 15, vl_rg.codigo_tarifa_servico); 
		
		-- marcando a tarifa como COBRADA
		update sc_srv.tbl_tsc set st_tsc = ct_st_cobrado, dt_pgto_tsc = current_date where cd_tsc = vl_rg.codigo_tarifa_servico;                    
	
	end if;

  end loop;
end;$$;


ALTER FUNCTION sc_srv.cobrar_tarifa_servico_desconto_no_vencimento(vp_data_referencia date, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7895 (class 0 OID 0)
-- Dependencies: 1482
-- Name: FUNCTION cobrar_tarifa_servico_desconto_no_vencimento(vp_data_referencia date, vp_cartao numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_tarifa_servico_desconto_no_vencimento(vp_data_referencia date, vp_cartao numeric) IS 'cobrar(debitar) todas as tarifas de serviços de cartao DESCONTO NO VENCIMENTO cadastradas';


--
-- TOC entry 1798 (class 1255 OID 564574)
-- Name: cobrar_tarifa_servico_saque_arredondado(date, numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_servico_saque_arredondado(vp_data_referencia date, vp_cartao numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

CT_SITUACAO_OPERACAO_CONFIRMADA constant numeric := 2;
CT_TIPO_OPERACAO_SERVICO_CONTA_INATIVA constant numeric := 18;
CT_TIPO_OPERACAO_PRIMEIRA_VIA_CARTA0 constant numeric := 10;
ct_st_cadastrado numeric := 1;
ct_st_cobrado numeric := 2;

ct_cd_conta_saque_arredondado numeric := 187272;
ct_lanc_tarifa_saque_arredondado numeric := 179;

ct_cd_srv_seguro_perda_roubo numeric := 1;
ct_cd_srv_servico_conta_inativa numeric := 4;
ct_cd_srv_servico_saque_arredondado numeric := 6;
ct_cd_srv_servico_1_via_cartao numeric := 7;

vl_valor_credito numeric := 0;
vl_valor_credito_1_via numeric := 0;
vl_nr_lanc_credito numeric := 0;
vl_nr_lanc_debito numeric := 0;
vl_tipo_lancamento numeric := 0;
vl_tipo_lancamento_1_via numeric := 0;
vl_conta_credito numeric := 0;
vl_conta_credito_1_via numeric := 0;
vl_plastico numeric;
vl_conta_debito numeric := 0;
vl_saldo_conta numeric := 0;

vl_rg record;

begin
  select nextval('sc_cnt.sq_lcn') into vl_nr_lanc_credito;

  for vl_rg in  select tsc.cd_tsc as codigo_tarifa_servico, tsc.cd_srv as servico, crt.cd_crt as cartao, cc.cd_cnt as conta_debito, 
		       tsc.vl_tsc as valor, tsc.dt_vnc_tsc as data_vencimento, srv.cd_cnt as conta_credito, srv.cd_tlc as tipo_lancamento,
		       opr.vl_trf_opr as valor_receita_tarifa
                from sc_srv.tbl_tsc tsc
			inner join sc_srv.tbl_srv srv on srv.cd_srv = tsc.cd_srv
			inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
			inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and cc.fg_pdr_cnt_crt = 'S'
			left join  sc_opr.tbl_opr opr on opr.cd_opr = tsc.cd_opr
                where tsc.st_tsc = ct_st_cadastrado
                  and tsc.dt_vnc_tsc <= vp_data_referencia
                  and tsc.cd_srv = ct_cd_srv_servico_saque_arredondado
                  and tsc.cd_crt = COALESCE(vp_cartao, tsc.cd_crt)
                  and sc_cnt.saldo_conta(cc.cd_cnt, 'S', 'N') >= tsc.vl_tsc
                order by servico, cartao 
  loop

        vl_saldo_conta := 0;

        select sc_cnt.saldo_conta(vl_rg.conta_debito, 'S', 'S') into vl_saldo_conta;

        if vl_saldo_conta >= vl_rg.valor then
          
           -- obtendo o numero de lancamento 
	   select nextval('sc_cnt.sq_lcn') into vl_nr_lanc_debito;


           -- descontando o valor do servico na conta do cartao
           perform sc_cnt.lancar_movimento(vl_nr_lanc_debito, null, vl_rg.tipo_lancamento, vl_rg.conta_debito, 'D',
                                       vl_rg.valor, now()::timestamp, 1::numeric, null, 'BAIXA CREDITO SAQUE ARREDONDADO', 
                                       15, vl_rg.codigo_tarifa_servico);

           -- efetuando a baixa do credito disponibilizado
           perform sc_cnt.lancar_movimento(null, vl_nr_lanc_debito, vl_rg.tipo_lancamento, ct_cd_conta_saque_arredondado, 'C',
                                       vl_rg.valor, now()::timestamp, 1::numeric, null, 'BAIXA CREDITO SAQUE ARREDONDADO', 
                                       15, vl_rg.codigo_tarifa_servico);

        
           -- creditando a receita com o valor da tarifa 
          /* perform sc_cnt.lancar_movimento(null, vl_nr_lanc_debito, ct_lanc_tarifa_saque_arredondado, vl_rg.conta_credito, 'C',
                                       vl_rg.valor_receita_tarifa, now()::timestamp, 1::numeric, null, 'COBRANCA TARIFA SAQUE ARREDONDADO', 
                                       15, vl_rg.codigo_tarifa_servico);*/


           -- setando servico como cobrado
           update sc_srv.tbl_tsc set st_tsc = ct_st_cobrado, dt_pgto_tsc = current_date where cd_tsc = vl_rg.codigo_tarifa_servico;                               
		
	end if;

  end loop;

end;$$;


ALTER FUNCTION sc_srv.cobrar_tarifa_servico_saque_arredondado(vp_data_referencia date, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7896 (class 0 OID 0)
-- Dependencies: 1798
-- Name: FUNCTION cobrar_tarifa_servico_saque_arredondado(vp_data_referencia date, vp_cartao numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_tarifa_servico_saque_arredondado(vp_data_referencia date, vp_cartao numeric) IS 'cobrar(debitar) todas as tarifas de serviços de cartao SAQUE ARREDONDADO cadastradas';


--
-- TOC entry 1795 (class 1255 OID 564575)
-- Name: cobrar_tarifa_servico_tad(date, numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_servico_tad(vp_data_referencia date, vp_cartao numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_st_cadastrado numeric := 1;
ct_st_cobrado numeric := 2;
ct_cd_srv_servico_tad numeric := 11;


vl_valor_credito numeric := 0;
vl_nr_lanc_credito numeric := 0;
vl_tipo_lancamento numeric := 0;
vl_conta_credito numeric := 0;
vl_saldo_conta numeric := 0;

vl_rg record;

begin

  for vl_rg in  select tsc.cd_tsc as codigo_tarifa_servico, tsc.cd_srv as servico, crt.cd_crt as cartao, cc.cd_cnt as conta_debito, 
		       tsc.vl_tsc as valor, tsc.dt_vnc_tsc as data_vencimento, srv.cd_cnt as conta_credito, srv.cd_tlc as tipo_lancamento,
		       opr.vl_trf_opr as valor_receita_tarifa
                from sc_srv.tbl_tsc tsc
			inner join sc_srv.tbl_srv srv on srv.cd_srv = tsc.cd_srv
			inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
			inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and cc.fg_pdr_cnt_crt = 'S'
			left join  sc_opr.tbl_opr opr on opr.cd_opr = tsc.cd_opr
                where tsc.st_tsc = ct_st_cadastrado
                  and tsc.dt_vnc_tsc <= vp_data_referencia
                  and tsc.cd_srv = ct_cd_srv_servico_tad
                  and tsc.cd_crt = COALESCE(vp_cartao, tsc.cd_crt)
                  and sc_cnt.saldo_conta(cc.cd_cnt, 'S', 'N') >= tsc.vl_tsc
                order by servico, cartao 
  loop
                  
        if vl_nr_lanc_credito = 0 then
          select nextval('sc_cnt.sq_lcn') into vl_nr_lanc_credito;
        end if;

        vl_saldo_conta := 0;

        select sc_cnt.saldo_conta(vl_rg.conta_debito, 'S', 'S') into vl_saldo_conta;

        if vl_saldo_conta >= vl_rg.valor then 
 		
          perform sc_cnt.lancar_movimento(null, vl_nr_lanc_credito, vl_rg.tipo_lancamento, vl_rg.conta_debito, 'D',
                                       vl_rg.valor, now()::timestamp, 1::numeric, null, 'COBRANÇA DA TARIFA DE SERVIÇO DE TAD', 
                                       15, vl_rg.codigo_tarifa_servico);


       	  vl_valor_credito := vl_valor_credito + vl_rg.valor;				
       	  vl_tipo_lancamento := vl_rg.tipo_lancamento;
       	  vl_conta_credito := vl_rg.conta_credito;

       	  -- marcando que a tarifa de servico já foi COBRADA
          update sc_srv.tbl_tsc set st_tsc = ct_st_cobrado, dt_pgto_tsc = current_date where cd_tsc = vl_rg.codigo_tarifa_servico;

        end if;

  end loop;

  if vl_valor_credito > 0 then
     
     -- realizando o lancamento: (nr_lanc, nr_lanc_contraPartida, tipo de lancamento, conta, fg_debito_credito, valor, data ref, usr inc, historico, complemento, sistema, nsu)
     perform sc_cnt.lancar_movimento(vl_nr_lanc_credito, null, vl_tipo_lancamento, vl_conta_credito,'C',
                                       vl_valor_credito, now()::timestamp, 1::numeric, null, 'COBRANÇA DA TARIFA DE SERVIÇO DE TAD', 
                                       15, 0);
  end if;

end;$$;


ALTER FUNCTION sc_srv.cobrar_tarifa_servico_tad(vp_data_referencia date, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7897 (class 0 OID 0)
-- Dependencies: 1795
-- Name: FUNCTION cobrar_tarifa_servico_tad(vp_data_referencia date, vp_cartao numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_tarifa_servico_tad(vp_data_referencia date, vp_cartao numeric) IS 'cobrar(debitar) todas as tarifas de serviços de cartao de TAD cadastradas';


--
-- TOC entry 1554 (class 1255 OID 564576)
-- Name: cobrar_tarifa_servico_tmc_OLD(date, numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION "cobrar_tarifa_servico_tmc_OLD"(vp_data_referencia date, vp_cartao numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_st_cadastrado numeric := 1;
ct_st_cobrado numeric := 2;
ct_cd_srv_servico_tmc numeric := 12;


vl_valor_credito numeric := 0;
vl_nr_lanc_credito numeric := 0;
vl_tipo_lancamento numeric := 0;
vl_conta_credito numeric := 0;
vl_saldo_conta numeric := 0;

vl_rg record;

begin
  select nextval('sc_cnt.sq_lcn') into vl_nr_lanc_credito;

  for vl_rg in  select tsc.cd_tsc as codigo_tarifa_servico, tsc.cd_srv as servico, crt.cd_crt as cartao, cc.cd_cnt as conta_debito, 
		       tsc.vl_tsc as valor, tsc.dt_vnc_tsc as data_vencimento, srv.cd_cnt as conta_credito, srv.cd_tlc as tipo_lancamento,
		       opr.vl_trf_opr as valor_receita_tarifa
                from sc_srv.tbl_tsc tsc
			inner join sc_srv.tbl_srv srv on srv.cd_srv = tsc.cd_srv
			inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
			inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and cc.fg_pdr_cnt_crt = 'S'
			left join  sc_opr.tbl_opr opr on opr.cd_opr = tsc.cd_opr
                where tsc.st_tsc = ct_st_cadastrado
                  and tsc.dt_vnc_tsc <= vp_data_referencia
                  and tsc.cd_srv = ct_cd_srv_servico_tmc
                  and tsc.cd_crt = COALESCE(vp_cartao, tsc.cd_crt)
                order by servico, cartao 
  loop
                  

    vl_saldo_conta := 0;

    select sc_cnt.saldo_conta(vl_rg.conta_debito, 'S', 'S') into vl_saldo_conta;

    if vl_saldo_conta >= vl_rg.valor then 
		
        perform sc_cnt.lancar_movimento(null, vl_nr_lanc_credito, vl_rg.tipo_lancamento, vl_rg.conta_debito, 'D',
                                       vl_rg.valor, now()::timestamp, 1::numeric, null, 'COBRANÇA DA TARIFA DE SERVIÇO DE TMC', 
                                       15, vl_rg.codigo_tarifa_servico);


       	vl_valor_credito := vl_valor_credito + 	vl_rg.valor;				
       	vl_tipo_lancamento := vl_rg.tipo_lancamento;
       	vl_conta_credito := vl_rg.conta_credito;

       	-- marcando que a tarifa de servico já foi COBRADA
        update sc_srv.tbl_tsc set st_tsc = ct_st_cobrado, dt_pgto_tsc = current_date where cd_tsc = vl_rg.codigo_tarifa_servico;

     end if;   

  end loop;

  if vl_valor_credito > 0 then
     
     -- realizando o lancamento: (nr_lanc, nr_lanc_contraPartida, tipo de lancamento, conta, fg_debito_credito, valor, data ref, usr inc, historico, complemento, sistema, nsu)
     perform sc_cnt.lancar_movimento(vl_nr_lanc_credito, null, vl_tipo_lancamento, vl_conta_credito,'C',
                                       vl_valor_credito, now()::timestamp, 1::numeric, null, 'COBRANÇA DA TARIFA DE SERVIÇO DE TMC', 
                                       15, 0);
  end if;

end;$$;


ALTER FUNCTION sc_srv."cobrar_tarifa_servico_tmc_OLD"(vp_data_referencia date, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7898 (class 0 OID 0)
-- Dependencies: 1554
-- Name: FUNCTION "cobrar_tarifa_servico_tmc_OLD"(vp_data_referencia date, vp_cartao numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION "cobrar_tarifa_servico_tmc_OLD"(vp_data_referencia date, vp_cartao numeric) IS 'cobrar(debitar) todas as tarifas de serviços de cartao de TMC cadastradas';


--
-- TOC entry 1867 (class 1255 OID 877298)
-- Name: cobrar_tarifa_servico_tmc_deposito(date, numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_servico_tmc_deposito(vp_data_referencia date, vp_cartao numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_st_cadastrado numeric := 1;
ct_st_cobrado numeric := 2;
ct_cd_srv_servico_tmc numeric := 12;
ct_top_tmc numeric := 13;

vl_valor_credito numeric := 0;
vl_nr_lanc_credito numeric := 0;
vl_tipo_lancamento numeric := 0;
vl_conta_credito numeric := 0;
vl_saldo_conta numeric := 0;
vl_cod_operacao numeric;

vl_rg record;

begin
  select nextval('sc_cnt.sq_lcn') into vl_nr_lanc_credito;

  for vl_rg in select tsc.cd_tsc as codigo_tarifa_servico, tsc.cd_srv as servico, crt.cd_crt as cartao, cc.cd_cnt as conta_debito, 
		      tsc.vl_tsc as valor, tsc.dt_vnc_tsc as data_vencimento, srv.cd_cnt as conta_credito, srv.cd_tlc as tipo_lancamento,
		      pls.cd_pls as plastico
               from sc_srv.tbl_tsc tsc
                  inner join sc_srv.tbl_srv srv on srv.cd_srv = tsc.cd_srv
                  inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
                  inner join sc_opr.tbl_pls pls on pls.cd_crt = crt.cd_crt and pls.dt_inc_usr = (select max(dt_inc_usr) from sc_opr.tbl_pls where cd_crt = crt.cd_crt)
		  inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and cc.fg_pdr_cnt_crt = 'S'
               where tsc.cd_crt = coalesce(vp_cartao,tsc.cd_crt)
                  and tsc.dt_vnc_tsc <= vp_data_referencia
                  and crt.cd_prd = 1
                  and tsc.cd_srv = ct_cd_srv_servico_tmc
                  and tsc.st_tsc = ct_st_cadastrado
                  and sc_cnt.saldo_conta(cc.cd_cnt, 'S', 'N') >= tsc.vl_tsc
               order by tsc.dt_vnc_tsc loop
                 
    vl_saldo_conta := 0;

    select sc_cnt.saldo_conta(vl_rg.conta_debito, 'S', 'S') into vl_saldo_conta;

    if vl_saldo_conta >= vl_rg.valor then 
		
        -- efetuando a cobranca na conta do cartao
        perform sc_cnt.lancar_debito_credito(vl_rg.conta_debito, vl_rg.conta_credito, 
                vl_rg.tipo_lancamento, null, 'REFERENTE A ' || to_char(vl_rg.data_vencimento, 'mm/yyyy'), vl_rg.valor, now()::timestamp, 1, 15, vl_rg.codigo_tarifa_servico);
       
        
       	-- gravando a operação
        select nextval('sc_opr.sq_opr') into vl_cod_operacao; 
       	
	insert into sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, vl_trf_opr, 
				 nr_prc_opr, vl_prc_opr, vl_iof_opr, nr_nsu_org_opr, st_opr, dt_prc_opr)
	values (vl_cod_operacao, ct_top_tmc, vl_rg.plastico, null, vp_data_referencia, vl_rg.valor, 0, vl_rg.valor, 
				1, vl_rg.valor, 0, vl_rg.codigo_tarifa_servico, 2, null);

       	
       	-- marcando que a tarifa de servico já foi COBRADA
        update sc_srv.tbl_tsc set st_tsc = ct_st_cobrado, dt_pgto_tsc = current_date, cd_opr = vl_cod_operacao where cd_tsc = vl_rg.codigo_tarifa_servico;

     end if;   

  end loop;

end;$$;


ALTER FUNCTION sc_srv.cobrar_tarifa_servico_tmc_deposito(vp_data_referencia date, vp_cartao numeric) OWNER TO scan;

--
-- TOC entry 7899 (class 0 OID 0)
-- Dependencies: 1867
-- Name: FUNCTION cobrar_tarifa_servico_tmc_deposito(vp_data_referencia date, vp_cartao numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_tarifa_servico_tmc_deposito(vp_data_referencia date, vp_cartao numeric) IS 'cobrar(debitar) todas as tarifas de serviços de cartao de TMC cadastradas';


--
-- TOC entry 1870 (class 1255 OID 1657043)
-- Name: cobrar_tarifa_servico_tmc_por_vencimento(date, date); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_servico_tmc_por_vencimento(vp_data_vencimento_inicial date, vp_data_vencimento_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin
  perform sc_srv.cobrar_tarifa_servico_tmc_por_vencimento(vp_data_vencimento_inicial, vp_data_vencimento_final, null);
end;$$;


ALTER FUNCTION sc_srv.cobrar_tarifa_servico_tmc_por_vencimento(vp_data_vencimento_inicial date, vp_data_vencimento_final date) OWNER TO scan;

--
-- TOC entry 7900 (class 0 OID 0)
-- Dependencies: 1870
-- Name: FUNCTION cobrar_tarifa_servico_tmc_por_vencimento(vp_data_vencimento_inicial date, vp_data_vencimento_final date); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_tarifa_servico_tmc_por_vencimento(vp_data_vencimento_inicial date, vp_data_vencimento_final date) IS 'cobrar(debitar) todas as tarifas de serviços de cartao de TMC cadastradas (não leva em consideração se o cliente possui saldo em conta)';


--
-- TOC entry 1812 (class 1255 OID 1667113)
-- Name: cobrar_tarifa_servico_tmc_por_vencimento(date, date, numeric); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION cobrar_tarifa_servico_tmc_por_vencimento(vp_data_vencimento_inicial date, vp_data_vencimento_final date, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ct_st_cadastrado numeric := 1;
  ct_st_cobrado numeric := 2;
  ct_cd_srv_servico_tmc numeric := 12;
  ct_top_tmc numeric := 13;

  vl_cod_operacao numeric;

  vl_rg record;

begin

  for vl_rg in select tsc.cd_tsc as codigo_tarifa_servico, tsc.cd_srv as servico, crt.cd_crt as cartao, cc.cd_cnt as conta_debito, 
		      tsc.vl_tsc as valor, tsc.dt_vnc_tsc as data_vencimento, srv.cd_cnt as conta_credito, srv.cd_tlc as tipo_lancamento,
		      pls.cd_pls as plastico
               from sc_srv.tbl_tsc tsc
                  inner join sc_srv.tbl_srv srv on srv.cd_srv = tsc.cd_srv
                  inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
                  inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
                  inner join sc_cad.tbl_cun cun on fnc.cd_cun = cun.cd_cun
                  inner join sc_opr.tbl_pls pls on pls.cd_crt = crt.cd_crt and pls.dt_inc_usr = (select max(dt_inc_usr) from sc_opr.tbl_pls where cd_crt = crt.cd_crt)
		  inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and cc.fg_pdr_cnt_crt = 'S'
               where tsc.dt_vnc_tsc >= vp_data_vencimento_inicial
                 and tsc.dt_vnc_tsc <= vp_data_vencimento_final
                  and crt.cd_prd = 1
                  --and cun.nr_cpf_cnpj_cun = 91931118353
                  and tsc.cd_srv = ct_cd_srv_servico_tmc
                  and tsc.st_tsc = ct_st_cadastrado
                  and crt.dt_ult_dps_crt >= vp_data_vencimento_inicial
                  and fnc.cd_emp = coalesce(vp_empresa, fnc.cd_emp)
               order by tsc.dt_vnc_tsc loop

	raise notice 'debitando tarifa TMC do cartão: %', vl_rg.cartao;
		
        -- efetuando a cobranca na conta do cartao
        perform sc_cnt.lancar_debito_credito(vl_rg.conta_debito, vl_rg.conta_credito, 
                vl_rg.tipo_lancamento, null, 'REFERENTE A ' || to_char(vl_rg.data_vencimento, 'mm/yyyy'), vl_rg.valor, now()::timestamp, 1, 15, vl_rg.codigo_tarifa_servico);
       
        
       	-- gravando a operação
        select nextval('sc_opr.sq_opr') into vl_cod_operacao; 
       	
	insert into sc_opr.tbl_opr(cd_opr, cd_top, cd_pls, cd_atm, dt_opr, vl_opr, vl_jrs_opr, vl_trf_opr, 
				 nr_prc_opr, vl_prc_opr, vl_iof_opr, nr_nsu_org_opr, st_opr, dt_prc_opr)
	values (vl_cod_operacao, ct_top_tmc, vl_rg.plastico, null, vp_data_vencimento_inicial, vl_rg.valor, 0, vl_rg.valor, 
				1, vl_rg.valor, 0, vl_rg.codigo_tarifa_servico, 2, null);

       	
       	-- marcando que a tarifa de servico já foi COBRADA
        update sc_srv.tbl_tsc set st_tsc = ct_st_cobrado, dt_pgto_tsc = current_date, cd_opr = vl_cod_operacao where cd_tsc = vl_rg.codigo_tarifa_servico;

  end loop;

end;$$;


ALTER FUNCTION sc_srv.cobrar_tarifa_servico_tmc_por_vencimento(vp_data_vencimento_inicial date, vp_data_vencimento_final date, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 7901 (class 0 OID 0)
-- Dependencies: 1812
-- Name: FUNCTION cobrar_tarifa_servico_tmc_por_vencimento(vp_data_vencimento_inicial date, vp_data_vencimento_final date, vp_empresa numeric); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION cobrar_tarifa_servico_tmc_por_vencimento(vp_data_vencimento_inicial date, vp_data_vencimento_final date, vp_empresa numeric) IS 'cobrar(debitar) todas as tarifas de serviços de cartao de TMC cadastradas (não leva em consideração se o cliente possui saldo em conta), pode ser informado o código da empresa, se for para efetuar o desconto apenas de uma empresa específica';


--
-- TOC entry 1617 (class 1255 OID 926240)
-- Name: estornar_tarifa_servico_conta_inativa(numeric, character varying); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION estornar_tarifa_servico_conta_inativa(vp_tarifa numeric, vp_motivo character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

ct_st_cobrado numeric := 2;
ct_st_cancelado numeric := 3;

ct_st_opr_cancelado numeric := 3;

vl_rg record;

begin
  
  for vl_rg in  select cc.cd_cnt as conta_debito, 
		       tsc.vl_tsc as valor, srv.cd_cnt as conta_credito, tlc.cd_est_tlc as tipo_lancamento,
		       opr.cd_opr as cod_operacao
                from sc_srv.tbl_tsc tsc
			inner join sc_srv.tbl_srv srv on srv.cd_srv = tsc.cd_srv
			inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
			inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt and cc.fg_pdr_cnt_crt = 'S'
			INNER join  sc_opr.tbl_opr opr on opr.cd_opr = tsc.cd_opr
			INNER JOIN sc_cnt.tbl_tlc tlc on tlc.cd_tlc = srv.cd_tlc
                where tsc.cd_tsc = vp_tarifa
                  AND tsc.st_tsc = ct_st_cobrado
  loop
                  
        -- cancelando a operacao
        update sc_opr.tbl_opr set st_opr = ct_st_opr_cancelado where cd_opr = vl_rg.cod_operacao;
      
	-- realizando o lancamento de estorno
        if vp_motivo is null then
          vp_motivo := 'NSU ' || vp_tarifa;
        else
          vp_motivo := vp_motivo || '. NSU ' || vp_tarifa;  
        end if;
	
        perform sc_cnt.lancar_debito_credito(vl_rg.conta_credito , vl_rg.conta_debito, vl_rg.tipo_lancamento, null, vp_motivo, vl_rg.valor, now()::timestamp, 1, 15, vp_tarifa);

       	-- marcando que a tarifa de servico como CANCELADA
        update sc_srv.tbl_tsc set st_tsc = ct_st_cancelado where cd_tsc = vp_tarifa;

  end loop;

end;$$;


ALTER FUNCTION sc_srv.estornar_tarifa_servico_conta_inativa(vp_tarifa numeric, vp_motivo character varying) OWNER TO scan;

--
-- TOC entry 7902 (class 0 OID 0)
-- Dependencies: 1617
-- Name: FUNCTION estornar_tarifa_servico_conta_inativa(vp_tarifa numeric, vp_motivo character varying); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION estornar_tarifa_servico_conta_inativa(vp_tarifa numeric, vp_motivo character varying) IS 'estornar uma tarifas de serviços de cartao de CONTA INATIVA já cobrada';


--
-- TOC entry 1563 (class 1255 OID 881076)
-- Name: estornar_tarifa_servico_tmc_deposito(numeric, numeric, character varying); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION estornar_tarifa_servico_tmc_deposito(vp_codigo_tarifa numeric, vp_usuario numeric, vp_motivo character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

begin

  if vp_motivo is null then
    vp_motivo := 'ESTORNO COBRANÇA DA TARIFA DE SERVIÇO DE TSM';
  else
    vp_motivo := 'ESTORNO COBRANÇA DA TARIFA DE SERVIÇO DE TSM ' || vp_motivo;  
  end if;

  select tsc.*, cc.cd_cnt as conta_cartao
    into rg
  from sc_srv.tbl_tsc tsc
    inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
    inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = crt.cd_crt
    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp  
  where tsc.cd_tsc = vp_codigo_tarifa
    and tsc.st_tsc = 2;

  -- estornando a cobranca
  perform sc_cnt.lancar_debito_credito(19442, rg.conta_cartao, 
     1019, null, vp_motivo, rg.vl_tsc, now()::timestamp, vp_usuario, 15, rg.cd_tsc);
        
  -- cancelando a operacao
  update sc_opr.tbl_opr set st_opr = 3 where cd_opr = rg.cd_opr;

  -- cancelando a tarifa
  update sc_srv.tbl_tsc set st_tsc = 3, cd_alt_usr = vp_usuario, dt_alt_usr = now() where cd_tsc = rg.cd_tsc;

end;$$;


ALTER FUNCTION sc_srv.estornar_tarifa_servico_tmc_deposito(vp_codigo_tarifa numeric, vp_usuario numeric, vp_motivo character varying) OWNER TO scan;

--
-- TOC entry 7903 (class 0 OID 0)
-- Dependencies: 1563
-- Name: FUNCTION estornar_tarifa_servico_tmc_deposito(vp_codigo_tarifa numeric, vp_usuario numeric, vp_motivo character varying); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION estornar_tarifa_servico_tmc_deposito(vp_codigo_tarifa numeric, vp_usuario numeric, vp_motivo character varying) IS 'estornar a cobranca de uma tarifa de serviços de cartao de TMC';


--
-- TOC entry 1511 (class 1255 OID 1667111)
-- Name: estornar_tarifa_servico_tmc_deposito(numeric, character varying, numeric, character varying); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION estornar_tarifa_servico_tmc_deposito(vp_empresa numeric, vp_mes_ref character varying, vp_usuario numeric, vp_motivo character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  vl_rg record;

  CT_SITUACAO_COBRADA constant integer := 2;
  CT_SERVICO_TMC constant integer := 12;
begin

  for vl_rg in select tsc.cd_tsc
               from sc_srv.tbl_tsc tsc
                    inner join sc_opr.tbl_crt crt on tsc.cd_crt = crt.cd_crt
	            inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
               where fnc.cd_emp = vp_empresa
                 and crt.fg_atv_crt = 'S'
                 and tsc.dt_vnc_tsc >= to_date('01/' || vp_mes_ref, 'dd/mm/yyyy')
                 and tsc.dt_vnc_tsc < to_date('01/' || vp_mes_ref, 'dd/mm/yyyy') + interval '1 month'
                 and tsc.st_tsc = CT_SITUACAO_COBRADA
                 and tsc.cd_srv = CT_SERVICO_TMC loop
    perform sc_srv.estornar_tarifa_servico_tmc_deposito(vl_rg.cd_tsc, vp_usuario, vp_motivo);
  end loop;
  
end;$$;


ALTER FUNCTION sc_srv.estornar_tarifa_servico_tmc_deposito(vp_empresa numeric, vp_mes_ref character varying, vp_usuario numeric, vp_motivo character varying) OWNER TO scan;

--
-- TOC entry 7904 (class 0 OID 0)
-- Dependencies: 1511
-- Name: FUNCTION estornar_tarifa_servico_tmc_deposito(vp_empresa numeric, vp_mes_ref character varying, vp_usuario numeric, vp_motivo character varying); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION estornar_tarifa_servico_tmc_deposito(vp_empresa numeric, vp_mes_ref character varying, vp_usuario numeric, vp_motivo character varying) IS 'estornar a cobranca de uma tarifa de serviços de cartao de TMC de uma determinada empresa em um determinado mês';


--
-- TOC entry 1780 (class 1255 OID 1667754)
-- Name: estornar_tarifa_servico_tmc_empresa(numeric, date, date, character varying); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION estornar_tarifa_servico_tmc_empresa(vp_codigo_empresa numeric, vp_data_inicial date, vp_data_final date, vp_motivo character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_rg record;
  ST_COBRADO constant integer := 2;
begin
  for vl_rg in select tsc.cd_tsc
               from sc_srv.tbl_tsc tsc
                    inner join sc_opr.tbl_crt crt on tsc.cd_crt = crt.cd_crt
                    inner join sc_cad.tbl_fnc fnc on crt.cd_fnc = fnc.cd_fnc
               where fnc.cd_emp = vp_codigo_empresa
                 and tsc.dt_pgto_tsc >= vp_data_inicial
                 and tsc.dt_pgto_tsc < vp_data_final + interval '1 day'
                 and tsc.st_tsc = ST_COBRADO
               order by cd_tsc loop
    perform sc_srv.estornar_tarifa_servico_tmc_deposito(vl_rg.cd_tsc, 1, vp_motivo);
  end loop;
end;$$;


ALTER FUNCTION sc_srv.estornar_tarifa_servico_tmc_empresa(vp_codigo_empresa numeric, vp_data_inicial date, vp_data_final date, vp_motivo character varying) OWNER TO scan;

--
-- TOC entry 7905 (class 0 OID 0)
-- Dependencies: 1780
-- Name: FUNCTION estornar_tarifa_servico_tmc_empresa(vp_codigo_empresa numeric, vp_data_inicial date, vp_data_final date, vp_motivo character varying); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION estornar_tarifa_servico_tmc_empresa(vp_codigo_empresa numeric, vp_data_inicial date, vp_data_final date, vp_motivo character varying) IS 'rotina que estornar as tarifas de TMC cobradas de uma determinada empresa, em um determinado período de pagamento';


--
-- TOC entry 1484 (class 1255 OID 1651388)
-- Name: gerar_arquivo_representacao_comercial(date); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION gerar_arquivo_representacao_comercial(vp_data_referencia date DEFAULT NULL::date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  data_referencia date;
  dt_ref_inicial timestamp;
  dt_ref_final timestamp;

  vl_data varchar;
begin
  data_referencia := coalesce(vp_data_referencia,current_date);

  if data_referencia::date > current_date then
    raise exception 'DATA DE REFERENCIA INVALIDA PARA ESSA OPERACAO';
  end if; 

  vl_data := to_char(data_referencia - interval '1 month','dd/mm/yyyy') || ' 00:00:00';
  dt_ref_inicial := vl_data::timestamp;

  vl_data := to_char(data_referencia,'dd/mm/yyyy') || ' 23:59:59';
  dt_ref_final := vl_data::timestamp - interval '1 day';

  perform sc_srv.gerar_arquivo_representacao_comercial(dt_ref_inicial, dt_ref_final, null);
end;$$;


ALTER FUNCTION sc_srv.gerar_arquivo_representacao_comercial(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7906 (class 0 OID 0)
-- Dependencies: 1484
-- Name: FUNCTION gerar_arquivo_representacao_comercial(vp_data_referencia date); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION gerar_arquivo_representacao_comercial(vp_data_referencia date) IS 'gera e envia o arquivo da representacao comercial';


--
-- TOC entry 1790 (class 1255 OID 1667130)
-- Name: gerar_arquivo_representacao_comercial(date, date); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION gerar_arquivo_representacao_comercial(vp_data_ref_inicial date, vp_data_ref_final date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
begin
    perform sc_srv.gerar_arquivo_representacao_comercial(vp_data_ref_inicial, vp_data_ref_final, null);
end;$$;


ALTER FUNCTION sc_srv.gerar_arquivo_representacao_comercial(vp_data_ref_inicial date, vp_data_ref_final date) OWNER TO scan;

--
-- TOC entry 7907 (class 0 OID 0)
-- Dependencies: 1790
-- Name: FUNCTION gerar_arquivo_representacao_comercial(vp_data_ref_inicial date, vp_data_ref_final date); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION gerar_arquivo_representacao_comercial(vp_data_ref_inicial date, vp_data_ref_final date) IS 'gera e envia o arquivo da representacao comercial de um determinado período';


--
-- TOC entry 1816 (class 1255 OID 1667149)
-- Name: gerar_arquivo_representacao_comercial(date, date, integer); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION gerar_arquivo_representacao_comercial(vp_data_ref_inicial date, vp_data_ref_final date, vp_grupo_empresarial integer) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  vl_data_ref_final timestamp without time zone;
begin
    vl_data_ref_final := vp_data_ref_final + interval '1 day' - interval '1 second';
    perform sc_srv.gerar_arquivo_representacao_comercial(vp_data_ref_inicial::timestamp, vl_data_ref_final, vp_grupo_empresarial);
end;$$;


ALTER FUNCTION sc_srv.gerar_arquivo_representacao_comercial(vp_data_ref_inicial date, vp_data_ref_final date, vp_grupo_empresarial integer) OWNER TO scan;

--
-- TOC entry 7908 (class 0 OID 0)
-- Dependencies: 1816
-- Name: FUNCTION gerar_arquivo_representacao_comercial(vp_data_ref_inicial date, vp_data_ref_final date, vp_grupo_empresarial integer); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION gerar_arquivo_representacao_comercial(vp_data_ref_inicial date, vp_data_ref_final date, vp_grupo_empresarial integer) IS 'gera e envia o arquivo da representacao comercial de um determinado período e grupo empresarial';


--
-- TOC entry 1650 (class 1255 OID 1667425)
-- Name: gerar_arquivo_representacao_comercial(timestamp without time zone, timestamp without time zone, integer); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION gerar_arquivo_representacao_comercial(vp_data_ref_inicial timestamp without time zone, vp_data_ref_final timestamp without time zone, vp_grupo_empresarial integer) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

mes_referencia varchar;

vl_data varchar;
vl_nome_arquivo varchar;
vl_linha varchar;
vl_existe_dados boolean;
vl_data_inicial_deposito date;
vl_data_final_deposito date;
vl_texto_email varchar := E'Enviado diretamente pelo sistema. Favor não responder.\nEnviado em: ' || to_char(current_timestamp,'dd/mm/yyyy hh24:mi:ss');

rg_gem record; 
rg record;

begin
    mes_referencia := to_char(vp_data_ref_inicial, 'dd_mm_yy') || '_A_' || to_char(vp_data_ref_final, 'dd_mm_yy') || '_' || to_char(now(), 'yymmddus');

    vl_data_inicial_deposito := to_date('01/' || to_char(vp_data_ref_inicial - interval '1 month', 'mm/yyyy'), 'dd/mm/yyyy');
    --vl_data_final_deposito := vl_data_inicial_deposito + interval '1 month' - interval '1 day';
    vl_data_final_deposito := vp_data_ref_final;
    
    raise notice 'data inicial deposito: %, data final deposito: %',  vl_data_inicial_deposito, vl_data_final_deposito;
    
    if vp_data_ref_final > current_date then
      raise exception 'DATA DE REFERENCIA FINAL NAO PODE SER MAIOR QUE A DATA ATUAL';
    end if; 

    for rg_gem in select cd_gem, nm_gem, dia_crt_rep_com_gem
                  from sc_cad.tbl_gem 
                  where dia_crt_rep_com_gem is not null
                    and (cd_gem = vp_grupo_empresarial
                          or dia_crt_rep_com_gem = to_char(vp_data_ref_inicial,'dd')::numeric) loop 

    vl_existe_dados := false;
    
    --vl_nome_arquivo := E'c:\\arquivo_scan\\envio\\rep_comercial\\REPCOM_' || sc_pbl.sem_acento(replace(trim(rg_gem.nm_gem),' ','_')) || '_' || replace(mes_referencia,'/','') || '.csv';
    vl_nome_arquivo := E'c:/arquivo_scan/envio/rep_comercial/REPCOM_' || sc_pbl.sem_acento(replace(trim(rg_gem.nm_gem),' ','_')) || '_' || replace(mes_referencia,'/','') || '.csv';

    raise notice 'nome do arquivo: %', vl_nome_arquivo;
    
    perform sc_arq.excluirarquivo(vl_nome_arquivo);

    vl_linha := 'CODIGO;CARTAO;CPF;NOME;VALOR;DT. VENCTO;DT. PAGTO';
    perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

    raise notice 'grupo: %', rg_gem.cd_gem;
    raise notice 'data inicial: %', vp_data_ref_inicial;
    raise notice 'data final: %', vp_data_ref_final;
    
    for rg in select tsc.cd_tsc as codigo,
                     crt.cd_crt as cartao,
                     REPLACE(REPLACE(TO_CHAR(cun.nr_cpf_cnpj_cun, '000#000#000-00'), '#', '.'), ' ', '') as cpf, 
		     trim(cun.nm_cun) as nome, 
		     sc_pbl.valor_formato_ptbr(tsc.vl_tsc) as valor, 
		     to_char(tsc.dt_vnc_tsc, 'dd/mm/yyyy') as dt_vencimento,
		     to_char(tsc.dt_pgto_tsc, 'dd/mm/yyyy') as dt_pgto
	      from sc_srv.tbl_tsc tsc
		    inner join sc_opr.tbl_crt crt on crt.cd_crt = tsc.cd_crt
		    inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
		    inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
		    inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	      where tsc.cd_srv = 12
		and tsc.st_tsc = 2
		and emp.cd_gem  = rg_gem.cd_gem
		and tsc.dt_pgto_tsc between vp_data_ref_inicial and vp_data_ref_final
                and tsc.dt_grc_rps_tsc is null
		and tsc.vl_tsc > 6
		and exists (select 1 from sc_adp.tbl_rdp rdp
			      inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
			      where rdp.cd_crt = crt.cd_crt
				and hfe.cd_tdp = 1
				and rdp.st_rdp = 5
				and hfe.st_hfe = 5
				and hfe.dt_dps_hfe between vl_data_inicial_deposito and vl_data_final_deposito)
		    order by nome loop

        --gerando a linha do arquivo
        vl_linha := rg.codigo || ';';
        vl_linha := vl_linha || rg.cartao|| ';';
        vl_linha := vl_linha || rg.cpf || ';';
	vl_linha := vl_linha || rg.nome || ';';
	vl_linha := vl_linha || rg.valor || ';';
	vl_linha := vl_linha || rg.dt_vencimento || ';';
	vl_linha := vl_linha || rg.dt_pgto;

        --gravando a linha no arquivo
        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

        vl_existe_dados := true;

        --prenchendo o campo data de repasse
        update sc_srv.tbl_tsc set dt_grc_rps_tsc = now() where cd_tsc = rg.codigo;        
    end loop;
    
    
    if vl_existe_dados then
      perform sc_pbl.enviar_email('contato@somacontadigital.com.br', 'rafael@somacontadigital.com.br', 'tecnologia@somacontadigital.com.br', 'REPCOM ' || trim(rg_gem.nm_gem) || ' - ' || mes_referencia , vl_texto_email, vl_texto_email, null, vl_nome_arquivo);
    else
      perform sc_arq.excluirarquivo(vl_nome_arquivo);
    end if;  

  end loop;   
end;$$;


ALTER FUNCTION sc_srv.gerar_arquivo_representacao_comercial(vp_data_ref_inicial timestamp without time zone, vp_data_ref_final timestamp without time zone, vp_grupo_empresarial integer) OWNER TO scan;

--
-- TOC entry 7909 (class 0 OID 0)
-- Dependencies: 1650
-- Name: FUNCTION gerar_arquivo_representacao_comercial(vp_data_ref_inicial timestamp without time zone, vp_data_ref_final timestamp without time zone, vp_grupo_empresarial integer); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION gerar_arquivo_representacao_comercial(vp_data_ref_inicial timestamp without time zone, vp_data_ref_final timestamp without time zone, vp_grupo_empresarial integer) IS 'gera e envia o arquivo da representacao comercial de um determinado período e grupo empresarial';


--
-- TOC entry 1549 (class 1255 OID 564577)
-- Name: identificar_servico_1_via_cartao(); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION identificar_servico_1_via_cartao() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
    
begin

   -- inserindo os servicos dos cartoes que nao tiveram a cobranca da 1a via de cartao
   INSERT INTO sc_srv.tbl_scr(cd_scr, cd_srv, cd_crt, st_scr, tp_ads_scr, cd_inc_usr, dt_inc_usr)
          select nextval('sc_srv.sq_scr'), 7, x.cartao, 1, 1, 1, now()
	  from (
	        select distinct crt.cd_crt as cartao
		from sc_opr.tbl_pls pls
			inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
			inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
			inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
			inner join sc_cad.tbl_gem gem on gem.cd_gem = emp.cd_gem
			inner join sc_cad.tbl_ctr ctr on ctr.cd_emp = emp.cd_emp
			inner join sc_cad.tbl_fem fem on fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
			inner join sc_cad.tbl_pce_ctr pce on pce.cd_ctr = ctr.cd_ctr and pce.cd_pce = 8 and pce.tp_pgt_pce_ctr = 2
			inner join sc_ssp.tbl_ssp ssp on ssp.cd_pls = pls.cd_pls and ssp.fg_cbr_emi_ssp = 'S' and ssp.cd_fep is null
		where --fnc.cd_emp in (183) and
		  --and pls.fg_blq_pls = 'N'
		   crt.fg_atv_crt = 'S'
		  and fem.fg_emt_crt_fem = 'S' 
		  and not exists (select 1 from sc_opr.tbl_opr opr where opr.cd_pls = pls.cd_pls and opr.cd_top = 10)
		  and not exists (select 1 from sc_srv.tbl_scr src where crt.cd_crt = src.cd_crt and cd_srv = 7)
		  ) x;

    -- gerando a tarifa para poder realizar a cobranca quando o funcionario tiver saldo em conta
    perform sc_srv.cobrar_servico_1_via_cartao(null, null);

    -- efetivando a cobranca dos funcionarios com saldo em conta
    perform sc_srv.cobrar_tarifa_servico(now()::date, 7, null);
     
end;$$;


ALTER FUNCTION sc_srv.identificar_servico_1_via_cartao() OWNER TO scan;

--
-- TOC entry 7910 (class 0 OID 0)
-- Dependencies: 1549
-- Name: FUNCTION identificar_servico_1_via_cartao(); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION identificar_servico_1_via_cartao() IS 'rotina de cobranca de 1a via de cartao atraves das tarifas de servico';


--
-- TOC entry 1481 (class 1255 OID 564578)
-- Name: identificar_servico_contas_inativas(date); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION identificar_servico_contas_inativas(vp_data_referencia date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  CT_PRM_QTDE_DIAS_CONTA_INATIVA constant varchar := 'QTDE_DIAS_CONTA_INATIVA';
  CT_SERVICO_CONTA_INATIVA constant numeric := 4;
  CT_SITUACAO_DEPOSITADO constant numeric := 5;
  CT_TIPO_OCORRENCIA_INATIVACAO_CARTAO constant numeric := 6;

  vl_rg record;
  
  vl_numero_dias numeric;
  vl_data_referencia date;
  vl_historico text;
  vl_qtde_operacoes numeric;
  vl_qtde_empresa numeric;
    
begin

  -- capturando a quantidade de dias que uma conta deverá estar inativa após não realizar nenhuma operação nem receber depósito
  select vl_prm::numeric
  into vl_numero_dias
  from sc_cad.tbl_prm
  where nm_prm = CT_PRM_QTDE_DIAS_CONTA_INATIVA;

  vl_data_referencia := vp_data_referencia - interval '1 day' * vl_numero_dias;
  vl_historico := 'CARTAO ESTA SENDO INATIVADO POIS ESTA COM MAIS DE ' || vl_numero_dias || ' DIAS SEM TER DEPOSITO NEM REALIZAR OPERACAO DE SAQUE E/OU SAQUE EXTRA';
  
  -- trazendo os cartoes que não obtiveram deposito no periodo definido
  for vl_rg in  select ct.cd_crt as cartao, cnt.cd_cnt as conta, ct.fg_atv_crt as flag_ativo
		from sc_opr.tbl_crt ct
			inner join sc_opr.tbl_cnt_crt cc on cc.cd_crt = ct.cd_crt and fg_pdr_cnt_crt = 'S' 
			inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cc.cd_cnt
		where not exists
				(
				select 1
				from sc_adp.tbl_rdp rdp
					inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
				where rdp.cd_crt = ct.cd_crt
				  and hfe.st_hfe in (CT_SITUACAO_DEPOSITADO)
				  and hfe.dt_dps_hfe >= vl_data_referencia
				)
		     and not exists 
				(
			        select 1
			        from sc_srv.tbl_scr scr
			        where scr.cd_crt = ct.cd_crt
			          and scr.cd_srv = CT_SERVICO_CONTA_INATIVA
			          and st_scr = 1 -- ativo
			        )
		  and vl_sld_cnt > 0
		  and ct.dt_inc_usr < vl_data_referencia 
   loop

        -- verificando se o cartao que não houve deposito, também não houve operação de saque e/ou saque extra no periodo informado
	select count(*)
	  into vl_qtde_operacoes
	from sc_opr.tbl_opr opr
		inner join sc_opr.tbl_pls pls on pls.cd_pls = opr.cd_pls
		inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt		
	where crt.cd_crt = vl_rg.cartao
	  and opr.cd_top in (4,5) -- saque, saque extra
	  and dt_opr >= vl_data_referencia;

        -- verificando se é "permitido" cobrar a tarifa dos funcionarios dessa empresa
        vl_qtde_empresa := 1;

        -- INICIO codigo sem sentido verificar depois JV em 14/06/2018 -- acima o codigo para garantir o if debaixo
        /*select count(*)
          into vl_qtde_empresa
        from sc_opr.tbl_crt crt
		inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
        where crt.cd_crt = vl_rg.cartao;*/
        -- FIM codigo sem sentido verificar depois JV em 14/06/2018 -- acima o codigo para garantir o if debaixo
          --and fnc.cd_emp not in (141, 65); -- brascop e contato
        
	-- caso NÃO tenha operacao, o cartao irá ser incluído na tabela de servico de cartao para ser cobrado a tarifa de servico de conta inativa
	if vl_qtde_operacoes = 0 and vl_qtde_empresa > 0 then

	     INSERT INTO sc_srv.tbl_scr(cd_scr, cd_srv, cd_crt, st_scr, tp_ads_scr, cd_inc_usr, dt_inc_usr)
			VALUES (nextval('sc_srv.sq_scr'), CT_SERVICO_CONTA_INATIVA, vl_rg.cartao, 1, 1, 1, now());

   	     -- caso o cartão esteja como ATIVO, o mesmo será INATIVADO
	     if vl_rg.flag_ativo = 'S' then
	        update sc_opr.tbl_crt set fg_atv_crt = 'N' where cd_crt = vl_rg.cartao and fg_atv_crt = 'S';

	        insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, 
				         nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
		             values (nextval('sc_opr.sq_ocr'), CT_TIPO_OCORRENCIA_INATIVACAO_CARTAO, vl_rg.cartao, null, 
				         vl_historico, 'N', 1, now());
	     end if;
	end if;

   end loop;
end;$$;


ALTER FUNCTION sc_srv.identificar_servico_contas_inativas(vp_data_referencia date) OWNER TO scan;

--
-- TOC entry 7911 (class 0 OID 0)
-- Dependencies: 1481
-- Name: FUNCTION identificar_servico_contas_inativas(vp_data_referencia date); Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON FUNCTION identificar_servico_contas_inativas(vp_data_referencia date) IS 'rotina que identifica os cartões que estão com mais de XX Dias SEM Receber Arquivo de Depósito e XX dias sem realizar operação de Saque e/ou Saque Extra no qual irão ser cobradas a tarifa de serviço de conta inativa';


--
-- TOC entry 1479 (class 1255 OID 564581)
-- Name: importar_capitalizacao_tit(); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION importar_capitalizacao_tit() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_str_banco varchar := 'localhost:5432/scaDesenvolvimento';
  vl_usuario_banco varchar := 'sca';
  vl_senha_banco varchar := 'sca';
  vl_arquivo_ajl varchar := 'C:/arquivo/ajl/RETORNO_CAP_TIT.AJL';
  vl_arquivo_origem varchar := 'C:/logs/cap/recebido';
  vl_arquivo_destino varchar := 'C:/logs/cap/processado';
  vl_arquivo_extensao varchar := '.txt';

begin
  perform sc_pbl.importar(vl_str_banco, vl_usuario_banco, vl_senha_banco, vl_arquivo_ajl, vl_arquivo_origem, vl_arquivo_destino, vl_arquivo_extensao);
end;$$;


ALTER FUNCTION sc_srv.importar_capitalizacao_tit() OWNER TO scan;

--
-- TOC entry 1433 (class 1255 OID 564582)
-- Name: processar_arquivo_retorno_tit(); Type: FUNCTION; Schema: sc_srv; Owner: scan
--

CREATE FUNCTION processar_arquivo_retorno_tit() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_nr_srt integer[];
  vl_posicao numeric := 1;

  rg_hrc record;
  rg_drc record;
  rg_sgr record;

begin

  for rg_hrc in select *
                from sc_srv.tbl_hrc hrc
                where hrc.dt_prc_hrc is null loop

    -- pegar todos os numeros da sorte de um arquivo
    for rg_drc in select *
                  from sc_srv.tbl_drc drc
                  where drc.cd_hrc = rg_hrc.cd_hrc loop
  
      vl_nr_srt[vl_posicao] := rg_drc.nr_srt_drc;

      vl_posicao := vl_posicao + 1;
    end loop;

    -- atualizar os numeros da sorte do arquivo
    vl_posicao := 1;
    for rg_sgr in select *
                  from sc_srv.tbl_cap cap
                    inner join sc_srv.tbl_has has on has.cd_has = cap.cd_new_has
                  where has.nr_sqn_rms_has = rg_hrc.nr_rms_hrc
                    and cap.nr_srt_cap is null loop

      update sc_srv.tbl_cap set nr_srt_cap = vl_nr_srt[vl_posicao] where cd_cap = rg_sgr.cd_cap;

      vl_posicao := vl_posicao + 1;
    end loop;

    -- atualizando a data
    update sc_srv.tbl_hrc set dt_prc_hrc = now() where cd_hrc = rg_hrc.cd_hrc;

  end loop;

end;$$;


ALTER FUNCTION sc_srv.processar_arquivo_retorno_tit() OWNER TO scan;

SET search_path = sc_ssp, pg_catalog;

--
-- TOC entry 1395 (class 1255 OID 564583)
-- Name: enviar_arquivo_plastico(numeric); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION enviar_arquivo_plastico(vp_cod_arquivo numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  ST_HAEP_CADASTRADO sc_ssp.tbl_haep.st_haep%type := 1;
  ST_HAEP_ENVIADO sc_ssp.tbl_haep.st_haep%type := 2;
  ST_HAEP_CANCELADO sc_ssp.tbl_haep.st_haep%type := 3;
  
  COD_FTP_ARQ_PLASTICO sc_pbl.tbl_ftp.cd_ftp%type;
  
  vl_nm_diretorio varchar;
  vl_nm_arquivo varchar;
  rg record;
  
begin
        
      select haep.nm_dir_arq_haep,
             haep.nm_arq_haep,
             coalesce(ftp.cd_ftp, 2)
      into vl_nm_diretorio,
           vl_nm_arquivo,
           COD_FTP_ARQ_PLASTICO       
      from sc_ssp.tbl_haep haep
        left join sc_pbl.tbl_ftp ftp on ftp.nm_ftp = haep.nm_ftp_imp_haep
      where haep.cd_haep = vp_cod_arquivo;
     
      perform sc_pbl.enviar_arquivo_ftp(COD_FTP_ARQ_PLASTICO,vl_nm_diretorio,vl_nm_arquivo);
      
      update sc_ssp.tbl_haep set st_haep = ST_HAEP_ENVIADO, dt_env_haep = now() where cd_haep = vp_cod_arquivo;
       
exception 
     
   when others then
     raise exception 'PROBLEMA AO ENVIAR O ARQUIVO DE EMISSAO DE PLASTICO NR. %', sqlerrm;
     
end
$$;


ALTER FUNCTION sc_ssp.enviar_arquivo_plastico(vp_cod_arquivo numeric) OWNER TO scan;

--
-- TOC entry 1407 (class 1255 OID 564584)
-- Name: enviar_arquivos_plastico(); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION enviar_arquivos_plastico() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  ST_HAEP_CADASTRADO sc_ssp.tbl_haep.st_haep%type := 1;
  ST_HAEP_ENVIADO sc_ssp.tbl_haep.st_haep%type := 2;
  ST_HAEP_CANCELADO sc_ssp.tbl_haep.st_haep%type := 3;
  
  COD_FTP_ARQ_PLASTICO sc_pbl.tbl_ftp.cd_ftp%type := 1;
  
  rg record;
  
begin
   
   /* antigo job de envio de arquivos de emissao de plastico, comentado dia 30/05/2019 às 20:53
   for rg in select haep.nm_arq_haep,
                    haep.nm_dir_arq_haep,
                    haep.cd_haep
             from sc_ssp.tbl_haep haep
             where haep.st_haep = ST_HAEP_CADASTRADO loop
     begin
     
      perform sc_ssp.enviar_arquivo_plastico(rg.cd_haep);
       
     exception 
     
       when others then
         raise notice 'Arquivo: %, Erro: %', rg.cd_haep, SQLERRM;
       
     end; 
     
   end loop;*/

   --Nova job de envio de arquivo de emissão de plastico e senha
   perform sc_job.executar_java_job('enviaArquivosPlasticoSenha', null);
end
$$;


ALTER FUNCTION sc_ssp.enviar_arquivos_plastico() OWNER TO scan;

--
-- TOC entry 7912 (class 0 OID 0)
-- Dependencies: 1407
-- Name: FUNCTION enviar_arquivos_plastico(); Type: COMMENT; Schema: sc_ssp; Owner: scan
--

COMMENT ON FUNCTION enviar_arquivos_plastico() IS 'Rotina que envia via FTP os arquivos de emissao de plastico';


--
-- TOC entry 1600 (class 1255 OID 564585)
-- Name: gerar_arquivo_plastico(boolean); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION gerar_arquivo_plastico(vp_ger_imediata boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  CD_PARAMETRO_CONTRATO_MODELO sc_cad.tbl_pce.cd_pce%type := 9;
  SITUACAO_SSP_CADASTRADA sc_ssp.tbl_ssp.st_ssp%type := 1;
  SITUACAO_SSP_EM_GERACAO_IMEDIATA sc_ssp.tbl_ssp.st_ssp%type := 4;
  TP_SSP_PLASTICO sc_ssp.tbl_ssp.tp_ssp%type := 1;

  ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
  ALINHAMENTO_A_DIREITA numeric(2,0) := 1;

  PRM_DIRETORIO_ARQ_EMISSAO_PLS sc_cad.tbl_prm.nm_prm%type := 'DIR_ARQ_EMS_PLS';

  vl_diretorio varchar;

  vl_linha varchar;
  vl_nome_arquivo varchar;
  vl_nome_arquivo_aux varchar;

  vl_codigo_haep sc_ssp.tbl_haep.cd_haep%type;
  vl_codigo_caep sc_ssp.tbl_caep.cd_caep%type;
  vl_codigo_faep sc_ssp.tbl_faep.cd_faep%type;

  vl_cod_contrato_aux sc_cad.tbl_ctr.cd_ctr%type := 0;
  vl_cod_filial_aux sc_cad.tbl_fem.cd_fem%type := -1;

  vl_nr_linha numeric(5,0) := 1;

  vl_qtd_contrato_arquivo numeric(3,0) := 0;
  vl_qtd_filial_contrato numeric(3,0) := 0;
  vl_qtd_filial_arquivo numeric(3,0) := 0;
  vl_qtd_detalhe_filial numeric(5,0) := 0;
  vl_qtd_detalhe_contrato numeric(5,0) := 0;
  vl_qtd_detalhe_arquivo numeric(5,0) := 0;

  vl_prioridade_remessa varchar := 'S';

  vl_trilha_1 varchar;
  vl_trilha_2 varchar;

  rg record;
  rg_edr record;
  tem_endereco boolean;
  
  vl_cep sc_cad.vw_edr.cep_edr%type;
  vl_logradouro sc_cad.vw_edr.logradouro%type;
  vl_bairro sc_cad.vw_edr.bairro%type;
  vl_localidade sc_cad.vw_edr.localidade%type;
  vl_uf sc_cad.vw_edr.uf%type;
  vl_complemento sc_cad.vw_edr.cpl_edr%type;
  vl_numero sc_cad.vw_edr.nr_edr%type;
  
  vl_qnt_solicitacao numeric(5,0) := 0;

  vl_local_impressao_array text[];
  vl_local_impressao text;
  vl_tipo_entrega varchar;
  
begin

  -- locais de impressao
  select string_to_array(pce.lst_dad_pce, '@') 
    into vl_local_impressao_array
  from sc_cad.tbl_pce pce
  where pce.cd_pce = 16;

  for i in 1..array_length(vl_local_impressao_array,1) loop
    vl_local_impressao := vl_local_impressao_array[i];
    vl_qtd_detalhe_arquivo := 0;
 
  select count(*)
   into vl_qnt_solicitacao
  from sc_ssp.tbl_ssp ssp
    inner join sc_opr.tbl_pls pls on pls.cd_pls = ssp.cd_pls
    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
    inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
    inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 16
  where 
    ((vp_ger_imediata = true and ssp.st_ssp = SITUACAO_SSP_EM_GERACAO_IMEDIATA) or 
    (vp_ger_imediata = false and ssp.st_ssp = SITUACAO_SSP_CADASTRADA))
    and ssp.tp_ssp = TP_SSP_PLASTICO
    and (ssp.dt_prv_grc_ssp <= now() or vp_ger_imediata = true)
    and pce_ctr.vl_pce_ctr = vl_local_impressao;

  if vl_qnt_solicitacao > 0 then
  -- Obtendo os parametros
  select prm.vl_prm
  into vl_diretorio
  from sc_cad.tbl_prm prm
  where prm.nm_prm = PRM_DIRETORIO_ARQ_EMISSAO_PLS;

  select nextval('sc_ssp.sq_haep') into vl_codigo_haep;

  vl_nome_arquivo := 'AEP' || to_char(now(),'DDMMYYYY') || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA) || '.DAT';

  vl_nome_arquivo_aux := vl_nome_arquivo;

  vl_nome_arquivo := vl_diretorio || '/' || vl_nome_arquivo;

  -- XXXXXXXXXXXXXXXX GRAVANDO HEADER XXXXXXXXXXXXXXXXXXXXXXXXXX

  vl_linha := '11'; -- Identificador do registro de header
  vl_linha := vl_linha || '001'; -- Versão do layout
  vl_linha := vl_linha || to_char(now(),'DDMMYYYYHH24MISS'); -- Data da geracao
  vl_linha := vl_linha || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA); -- Código da remessa
  vl_linha := vl_linha || vl_prioridade_remessa; -- Prioridade da remessa
  vl_linha := vl_linha || sc_arq.preencher(6,'0','0',ALINHAMENTO_A_ESQUERDA); -- Codigo do arquivo (retorno)
  vl_linha := vl_linha || '00'; -- Retorno do processamento
  vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

  insert into sc_ssp.tbl_haep(cd_haep,vrs_haep,dt_grc_haep,nm_arq_haep,pri_haep,nm_dir_arq_haep, nm_ftp_imp_haep)
  values(vl_codigo_haep,1,now(),vl_nome_arquivo_aux,vl_prioridade_remessa,vl_diretorio, vl_local_impressao);

  perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
  vl_nr_linha := vl_nr_linha + 1;
  vl_linha := '';
  -- XXXXXXXXXXXXXXXXXXX FIM HEADER XXXXXXXXXXXXXXXXXXXXXXXXXXXX

  for rg in select crt.cd_ctr,fnc.cd_emp,emp.nm_emp,mpl.cd_mpl,fem.nm_fem,cun_func.nm_cun nm_func,
                   cun_filial.nr_cpf_cnpj_cun,ssp.cd_ssp,fem.nm_fem nm_filial, pls.nm_pls,
                   pls.dt_vld_pls,pls.nr_scc_pls,pls.nm_snh_pls,pls.cd_pls,fem.cd_fem,cun_func.nr_cpf_cnpj_cun cpf_fnc,
                   fnc.nr_idt_fnc nr_matricula, mpl.fg_snh_mpl,ssp.msg_crt_ssp,edr_ctr.cd_edr,pce_ctr_etr.vl_pce_ctr tipo_entrega
            from sc_ssp.tbl_ssp ssp
                 inner join sc_opr.tbl_pls pls on ssp.cd_pls = pls.cd_pls
                 inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
                 inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
                 inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 16
                 left  join sc_cad.tbl_pce_ctr pce_ctr_etr on pce_ctr_etr.cd_ctr = ctr.cd_ctr and pce_ctr_etr.cd_pce = 3
                 inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                 inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                 inner join sc_cad.tbl_fem fem on fnc.cd_emp = fem.cd_emp and fnc.cd_fem = fem.cd_fem
                 inner join sc_cad.tbl_cun cun_filial on cun_filial.cd_cun = fem.cd_cun
                 inner join sc_cad.tbl_cun cun_func on cun_func.cd_cun = fnc.cd_cun
                 inner join sc_ssp.tbl_mpl mpl on mpl.cd_mpl = ctr.cd_mpl
                 inner join sc_cad.tbl_edr_ctr edr_ctr on edr_ctr.cd_ctr = ctr.cd_ctr and edr_ctr.tp_edr_ctr = 1 and edr_ctr.fg_atv_edr_ctr = 'S'
            where ((vp_ger_imediata = true and ssp.st_ssp = SITUACAO_SSP_EM_GERACAO_IMEDIATA) or (vp_ger_imediata = false and ssp.st_ssp = SITUACAO_SSP_CADASTRADA))
              and ssp.tp_ssp = TP_SSP_PLASTICO
              and (ssp.dt_prv_grc_ssp <= now() or vp_ger_imediata = true)
              and edr_ctr.tp_edr_ctr = 1
              and pce_ctr.vl_pce_ctr = vl_local_impressao
              --and cun_func.nr_cpf_cnpj_cun = 4955541380
            order by crt.cd_ctr, fnc.cd_fem, nm_func, fnc.nr_idt_fnc loop

    if( vl_cod_filial_aux <> rg.cd_fem or vl_cod_contrato_aux <> rg.cd_ctr ) then
      if( vl_qtd_filial_contrato > 0 ) then
        -- TRAILLER DE FILIAL
        vl_linha := '39';
        vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_nr_linha := vl_nr_linha + 1;
        vl_linha := '';

        vl_qtd_detalhe_filial := 0;
        vl_qtd_filial_contrato := 0;
      end if;
    end if;

    if( vl_cod_contrato_aux <> rg.cd_ctr ) then
      vl_cod_filial_aux := -1;
      
      if( vl_qtd_contrato_arquivo > 0 ) then
        -- TRAILLER DE CONTRATO
        vl_linha := '29';
        vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(2,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_nr_linha := vl_nr_linha + 1;
        vl_linha := '';

        vl_qtd_filial_contrato := 0;
        vl_qtd_filial_contrato := 0;
        vl_qtd_detalhe_contrato := 0;
      end if;

      vl_cod_contrato_aux := rg.cd_ctr;
      -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE CONTRATO XXXXXXXXXXXXXXXX

      vl_linha := '21';-- Identificador de registro
      vl_linha := vl_linha || sc_arq.preencher(8,rg.cd_ctr,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do contrato
      vl_linha := vl_linha || sc_arq.preencher(5,rg.cd_emp,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo da empresa
      vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_emp,' ',ALINHAMENTO_A_DIREITA); -- Nome da empresa
      vl_linha := vl_linha || sc_arq.preencher(2,rg.cd_mpl,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do modelo de plastico
      vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
      vl_nr_linha := vl_nr_linha + 1;
      vl_linha := '';

      select nextval('sc_ssp.sq_caep') into vl_codigo_caep;
      
      insert into sc_ssp.tbl_caep(cd_caep,cd_haep,cd_ctr,cd_emp,ds_emp,cd_mpl)
      values(vl_codigo_caep,vl_codigo_haep,rg.cd_ctr,rg.cd_emp,rg.nm_emp,rg.cd_mpl);

      -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE CONTRATO XXXXXXXXXXXXXXXXXXXXXX
      vl_qtd_contrato_arquivo := vl_qtd_contrato_arquivo + 1;
    end if;

    if( vl_cod_filial_aux <> rg.cd_fem ) then
       vl_cod_filial_aux := rg.cd_fem;
       
       -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE FILIAL XXXXXXXXXXXXXXXXXX
       vl_linha := '31'; -- Identificador de registro
       vl_linha := vl_linha || sc_arq.preencher(5,rg.cd_fem,'0',ALINHAMENTO_A_ESQUERDA);
       vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_filial,' ',ALINHAMENTO_A_DIREITA);
       vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_cpf_cnpj_cun,'0',ALINHAMENTO_A_ESQUERDA);

       tem_endereco := false;
       vl_cep := 0;
       vl_logradouro := ' ';
       vl_bairro := ' ';
       vl_localidade := ' ';
       vl_uf := ' ';
       vl_complemento := null;
       vl_numero := ' ';
       for rg_edr in select * 
                     from sc_cad.vw_edr edr 
                     where edr.cd_edr = rg.cd_edr loop
         tem_endereco := true;
         vl_linha := vl_linha || sc_arq.preencher(8,rg_edr.cep_edr,'0',ALINHAMENTO_A_ESQUERDA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.logradouro,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(5,rg_edr.nr_edr,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.cpl_edr,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.bairro,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.localidade,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(2,rg_edr.uf,' ',ALINHAMENTO_A_DIREITA);

         vl_cep := rg_edr.cep_edr;
	 vl_logradouro := rg_edr.logradouro;
	 vl_bairro := rg_edr.bairro;
	 vl_localidade := rg_edr.localidade;
	 vl_uf := rg_edr.uf;
	 vl_complemento := rg_edr.cpl_edr;
	 vl_numero := rg_edr.nr_edr;
       end loop;
       
       if not tem_endereco then
         vl_linha := vl_linha || sc_arq.preencher(8+60+5+60+60+60+2, ' ', ' ', ALINHAMENTO_A_DIREITA);
       end if;
       
       vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

       perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
       vl_nr_linha := vl_nr_linha + 1;
       vl_linha := '';

       vl_qtd_filial_arquivo := vl_qtd_filial_arquivo + 1;
       vl_qtd_filial_contrato := vl_qtd_filial_contrato + 1;

       select nextval('sc_ssp.sq_faep') into vl_codigo_faep;
       insert into sc_ssp.tbl_faep(cd_faep,cd_caep,cd_fem,ds_fem,cnpj_faep,cep_faep,log_faep,
                                   nr_end_faep,cpl_edr_faep,brr_edr_faep,loc_edr_faep,uf_edr_faep,cd_emp)
       values(vl_codigo_faep,vl_codigo_caep,rg.cd_fem,rg.nm_filial,rg.nr_cpf_cnpj_cun,
              vl_cep,vl_logradouro,vl_numero,vl_complemento,vl_bairro,vl_localidade,vl_uf,rg.cd_emp);

       -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE FILIAL XXXXXXXXXXXXXXXXXXXXXX
     end if;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INICIO LINHA DE DETALHE XXXXXXXXXXXXXXXXXX
     vl_trilha_1 := sc_ssp.gerar_trilha_1(rg.nm_pls);
     vl_trilha_2 := sc_ssp.gerar_trilha_2(rg.cd_pls,rg.dt_vld_pls,'S');

     vl_linha := '41'; -- Identificador de registro
     vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_func,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(40,rg.nm_pls,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || rg.cd_pls;
     vl_linha := vl_linha || to_char(rg.dt_vld_pls,'MM/YYYY');
     vl_linha := vl_linha || sc_arq.preencher(3,rg.nr_scc_pls,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(76,vl_trilha_1,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(37,vl_trilha_2,'0',ALINHAMENTO_A_DIREITA);

     if(rg.fg_snh_mpl = 'S') then
          vl_linha := vl_linha || sc_arq.preencher(4,((rg.nm_snh_pls::integer)::numeric),'0',ALINHAMENTO_A_ESQUERDA);
       update sc_opr.tbl_pls set nm_snh_pls = md5(rg.nm_snh_pls) where cd_pls = rg.cd_pls;
     else
       vl_linha := vl_linha || sc_arq.preencher(4,0,'0',ALINHAMENTO_A_ESQUERDA);
     end if;

     vl_linha := vl_linha || sc_arq.preencher(40,rg.msg_crt_ssp,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(11,rg.cpf_fnc,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_matricula,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || '00';
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     if (rg.tipo_entrega = 'EMPRESA') then
       vl_tipo_entrega = 'E';
     elsif(rg.tipo_entrega = 'FILIAL') then
       vl_tipo_entrega = 'F';
     elsif(rg.tipo_entrega = 'ADMINISTRADORA') then
       vl_tipo_entrega = 'A';
     else  
       vl_tipo_entrega = null;
     end if;

     if vp_ger_imediata then
       vl_tipo_entrega := 'U';
     end if;

     vl_linha := vl_linha || coalesce(vl_tipo_entrega,' ');
     


     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     insert into sc_ssp.tbl_daep(cd_daep,nm_func_daep,nm_pls_daep,cd_pls,dt_vld_daep,scc_daep,
                                 trl1_daep,trl2_daep,msg_crt_daep,cd_haep,cd_caep,cd_faep,cd_ssp,tp_etr_daep)
     VALUES(nextval('sc_ssp.sq_daep'),rg.nm_func,rg.nm_pls,rg.cd_pls,to_char(rg.dt_vld_pls,'MM/YYYY'),
            rg.nr_scc_pls, vl_trilha_1,vl_trilha_2,rg.msg_crt_ssp,
            vl_codigo_haep,vl_codigo_caep,vl_codigo_faep,rg.cd_ssp,vl_tipo_entrega);

     update sc_ssp.tbl_ssp set st_ssp = 2, dt_grc_ssp = now() where cd_ssp = rg.cd_ssp;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE DETALHE XXXXXXXXXXXXXXXXXX

     vl_qtd_detalhe_arquivo := vl_qtd_detalhe_arquivo + 1;
     vl_qtd_detalhe_filial := vl_qtd_detalhe_filial + 1;
     vl_qtd_detalhe_contrato := vl_qtd_detalhe_contrato + 1;
   end loop;

   if(vl_qtd_detalhe_arquivo > 0) then
     -- TRAILLER DE FILIAL
     vl_linha := '39';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE CONTRATO
     vl_linha := '29';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE ARQUIVO
     vl_linha := '19';
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_contrato_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

    -- atualizando quantidade de plasticos no header
    update sc_ssp.tbl_haep
       set qtd_pls_haep = vl_qtd_detalhe_arquivo
    where cd_haep = vl_codigo_haep;


   else
     perform sc_arq.excluirArquivo(vl_nome_arquivo);
   end if;
  end if;
  end loop;
exception
when others then
  perform sc_arq.excluirArquivo(vl_nome_arquivo); 
  RAISE EXCEPTION 'Problema na geração do arquivo de emissão de plastico. NUM:%, DETAILS:%, CPF:%', SQLSTATE, SQLERRM, rg.cpf_fnc || ' - ' || rg.nm_func;
end;
$$;


ALTER FUNCTION sc_ssp.gerar_arquivo_plastico(vp_ger_imediata boolean) OWNER TO scan;

--
-- TOC entry 1408 (class 1255 OID 564588)
-- Name: gerar_arquivo_plastico_albertino(); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION gerar_arquivo_plastico_albertino() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  CD_PARAMETRO_CONTRATO_MODELO sc_cad.tbl_pce.cd_pce%type := 9;
  SITUACAO_SSP_CADASTRADA sc_ssp.tbl_ssp.st_ssp%type := 1;
  SITUACAO_SSP_EM_GERACAO_IMEDIATA sc_ssp.tbl_ssp.st_ssp%type := 4;
  TP_SSP_PLASTICO sc_ssp.tbl_ssp.tp_ssp%type := 1;

  ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
  ALINHAMENTO_A_DIREITA numeric(2,0) := 1;

  PRM_DIRETORIO_ARQ_EMISSAO_PLS sc_cad.tbl_prm.nm_prm%type := 'DIR_ARQ_EMS_PLS';

  vl_diretorio varchar;

  vl_linha varchar;
  vl_nome_arquivo varchar;
  vl_nome_arquivo_aux varchar;

  vl_codigo_haep sc_ssp.tbl_haep.cd_haep%type;
  vl_codigo_caep sc_ssp.tbl_caep.cd_caep%type;
  vl_codigo_faep sc_ssp.tbl_faep.cd_faep%type;

  vl_cod_contrato_aux sc_cad.tbl_ctr.cd_ctr%type := 0;
  vl_cod_filial_aux sc_cad.tbl_fem.cd_fem%type := -1;

  vl_nr_linha numeric(5,0) := 1;

  vl_qtd_contrato_arquivo numeric(3,0) := 0;
  vl_qtd_filial_contrato numeric(3,0) := 0;
  vl_qtd_filial_arquivo numeric(3,0) := 0;
  vl_qtd_detalhe_filial numeric(5,0) := 0;
  vl_qtd_detalhe_contrato numeric(5,0) := 0;
  vl_qtd_detalhe_arquivo numeric(5,0) := 0;

  vl_prioridade_remessa varchar := 'S';

  vl_trilha_1 varchar;
  vl_trilha_2 varchar;

  rg record;
  rg_edr record;
  tem_endereco boolean;
  
  vl_cep sc_cad.vw_edr.cep_edr%type;
  vl_logradouro sc_cad.vw_edr.logradouro%type;
  vl_bairro sc_cad.vw_edr.bairro%type;
  vl_localidade sc_cad.vw_edr.localidade%type;
  vl_uf sc_cad.vw_edr.uf%type;
  vl_complemento sc_cad.vw_edr.cpl_edr%type;
  vl_numero sc_cad.vw_edr.nr_edr%type;
  
  vl_qnt_solicitacao numeric(5,0) := 0;

  vl_local_impressao_array text[];
  vl_local_impressao text;
  
begin

  -- locais de impressao
  select string_to_array(pce.lst_dad_pce, '@') 
    into vl_local_impressao_array
  from sc_cad.tbl_pce pce
  where pce.cd_pce = 16;

  for i in 1..array_length(vl_local_impressao_array,1) loop
    vl_local_impressao := vl_local_impressao_array[i];
    vl_qtd_detalhe_arquivo := 0;
 
  select count(*)
   into vl_qnt_solicitacao
  from sc_ssp.tbl_ssp ssp
    inner join sc_opr.tbl_pls pls on pls.cd_pls = ssp.cd_pls
    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
    inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
    inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 16
  where ssp.st_ssp = 9 
    and ssp.tp_ssp = TP_SSP_PLASTICO
    and ssp.dt_prv_grc_ssp <= now() + interval '1 day'
    and pce_ctr.vl_pce_ctr = vl_local_impressao;

  if vl_qnt_solicitacao > 0 then
  -- Obtendo os parametros
  select prm.vl_prm
  into vl_diretorio
  from sc_cad.tbl_prm prm
  where prm.nm_prm = PRM_DIRETORIO_ARQ_EMISSAO_PLS;

  select nextval('sc_ssp.sq_haep') into vl_codigo_haep;

  vl_nome_arquivo := 'AEP' || to_char(now(),'DDMMYYYY') || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA) || '.DAT';

  vl_nome_arquivo_aux := vl_nome_arquivo;

  vl_nome_arquivo := vl_diretorio || '/' || vl_nome_arquivo;

  -- XXXXXXXXXXXXXXXX GRAVANDO HEADER XXXXXXXXXXXXXXXXXXXXXXXXXX

  vl_linha := '11'; -- Identificador do registro de header
  vl_linha := vl_linha || '001'; -- Versão do layout
  vl_linha := vl_linha || to_char(now(),'DDMMYYYYHH24MISS'); -- Data da geracao
  vl_linha := vl_linha || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA); -- Código da remessa
  vl_linha := vl_linha || vl_prioridade_remessa; -- Prioridade da remessa
  vl_linha := vl_linha || sc_arq.preencher(6,'0','0',ALINHAMENTO_A_ESQUERDA); -- Codigo do arquivo (retorno)
  vl_linha := vl_linha || '00'; -- Retorno do processamento
  vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

  insert into sc_ssp.tbl_haep(cd_haep,vrs_haep,dt_grc_haep,nm_arq_haep,pri_haep,nm_dir_arq_haep, nm_ftp_imp_haep)
  values(vl_codigo_haep,1,now(),vl_nome_arquivo_aux,vl_prioridade_remessa,vl_diretorio, vl_local_impressao);

  perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
  vl_nr_linha := vl_nr_linha + 1;
  vl_linha := '';
  -- XXXXXXXXXXXXXXXXXXX FIM HEADER XXXXXXXXXXXXXXXXXXXXXXXXXXXX

  for rg in select crt.cd_ctr,fnc.cd_emp,emp.nm_emp,mpl.cd_mpl,fem.nm_fem,cun_func.nm_cun nm_func,
                   cun_filial.nr_cpf_cnpj_cun,ssp.cd_ssp,fem.nm_fem nm_filial, pls.nm_pls,
                   pls.dt_vld_pls,pls.nr_scc_pls,pls.nm_snh_pls,pls.cd_pls,fem.cd_fem,cun_func.nr_cpf_cnpj_cun cpf_fnc,
                   fnc.nr_idt_fnc nr_matricula, mpl.fg_snh_mpl,ssp.msg_crt_ssp,edr_ctr.cd_edr
            from sc_ssp.tbl_ssp ssp
                 inner join sc_opr.tbl_pls pls on ssp.cd_pls = pls.cd_pls
                 inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
                 inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
                 inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 16
                 inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                 inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                 inner join sc_cad.tbl_fem fem on fnc.cd_emp = fem.cd_emp and fnc.cd_fem = fem.cd_fem
                 inner join sc_cad.tbl_cun cun_filial on cun_filial.cd_cun = fem.cd_cun
                 inner join sc_cad.tbl_cun cun_func on cun_func.cd_cun = fnc.cd_cun
                 inner join sc_ssp.tbl_mpl mpl on mpl.cd_mpl = ctr.cd_mpl
                 inner join sc_cad.tbl_edr_ctr edr_ctr on edr_ctr.cd_ctr = ctr.cd_ctr and edr_ctr.tp_edr_ctr = 1 and edr_ctr.fg_atv_edr_ctr = 'S'
            where ssp.st_ssp = 9
              and ssp.tp_ssp = TP_SSP_PLASTICO
              and ssp.dt_prv_grc_ssp <= now() + interval '1 day'
              and edr_ctr.tp_edr_ctr = 1
              and pce_ctr.vl_pce_ctr = vl_local_impressao
            order by fnc.nr_idt_fnc::numeric loop

    if( vl_cod_filial_aux <> rg.cd_fem or vl_cod_contrato_aux <> rg.cd_ctr ) then
      if( vl_qtd_filial_contrato > 0 ) then
        -- TRAILLER DE FILIAL
        vl_linha := '39';
        vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_nr_linha := vl_nr_linha + 1;
        vl_linha := '';

        vl_qtd_detalhe_filial := 0;
        vl_qtd_filial_contrato := 0;
      end if;
    end if;

    if( vl_cod_contrato_aux <> rg.cd_ctr ) then
      vl_cod_filial_aux := -1;
      
      if( vl_qtd_contrato_arquivo > 0 ) then
        -- TRAILLER DE CONTRATO
        vl_linha := '29';
        vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(2,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_nr_linha := vl_nr_linha + 1;
        vl_linha := '';

        vl_qtd_filial_contrato := 0;
        vl_qtd_filial_contrato := 0;
        vl_qtd_detalhe_contrato := 0;
      end if;

      vl_cod_contrato_aux := rg.cd_ctr;
      -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE CONTRATO XXXXXXXXXXXXXXXX

      vl_linha := '21';-- Identificador de registro
      vl_linha := vl_linha || sc_arq.preencher(8,rg.cd_ctr,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do contrato
      vl_linha := vl_linha || sc_arq.preencher(5,rg.cd_emp,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo da empresa
      vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_emp,' ',ALINHAMENTO_A_DIREITA); -- Nome da empresa
      vl_linha := vl_linha || sc_arq.preencher(2,rg.cd_mpl,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do modelo de plastico
      vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
      vl_nr_linha := vl_nr_linha + 1;
      vl_linha := '';

      select nextval('sc_ssp.sq_caep') into vl_codigo_caep;
      
      insert into sc_ssp.tbl_caep(cd_caep,cd_haep,cd_ctr,cd_emp,ds_emp,cd_mpl)
      values(vl_codigo_caep,vl_codigo_haep,rg.cd_ctr,rg.cd_emp,rg.nm_emp,rg.cd_mpl);

      -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE CONTRATO XXXXXXXXXXXXXXXXXXXXXX
      vl_qtd_contrato_arquivo := vl_qtd_contrato_arquivo + 1;
    end if;

    if( vl_cod_filial_aux <> rg.cd_fem ) then
       vl_cod_filial_aux := rg.cd_fem;
       
       -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE FILIAL XXXXXXXXXXXXXXXXXX
       vl_linha := '31'; -- Identificador de registro
       vl_linha := vl_linha || sc_arq.preencher(5,rg.cd_fem,'0',ALINHAMENTO_A_ESQUERDA);
       vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_filial,' ',ALINHAMENTO_A_DIREITA);
       vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_cpf_cnpj_cun,'0',ALINHAMENTO_A_ESQUERDA);

       tem_endereco := false;
       vl_cep := 0;
       vl_logradouro := ' ';
       vl_bairro := ' ';
       vl_localidade := ' ';
       vl_uf := ' ';
       vl_complemento := null;
       vl_numero := ' ';
       for rg_edr in select * 
                     from sc_cad.vw_edr edr 
                     where edr.cd_edr = rg.cd_edr loop
         tem_endereco := true;
         vl_linha := vl_linha || sc_arq.preencher(8,rg_edr.cep_edr,'0',ALINHAMENTO_A_ESQUERDA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.logradouro,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(5,rg_edr.nr_edr,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.cpl_edr,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.bairro,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.localidade,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(2,rg_edr.uf,' ',ALINHAMENTO_A_DIREITA);

         vl_cep := rg_edr.cep_edr;
	 vl_logradouro := rg_edr.logradouro;
	 vl_bairro := rg_edr.bairro;
	 vl_localidade := rg_edr.localidade;
	 vl_uf := rg_edr.uf;
	 vl_complemento := rg_edr.cpl_edr;
	 vl_numero := rg_edr.nr_edr;
       end loop;
       
       if not tem_endereco then
         vl_linha := vl_linha || sc_arq.preencher(8+60+5+60+60+60+2, ' ', ' ', ALINHAMENTO_A_DIREITA);
       end if;
       
       vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

       perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
       vl_nr_linha := vl_nr_linha + 1;
       vl_linha := '';

       vl_qtd_filial_arquivo := vl_qtd_filial_arquivo + 1;
       vl_qtd_filial_contrato := vl_qtd_filial_contrato + 1;

       select nextval('sc_ssp.sq_faep') into vl_codigo_faep;
       insert into sc_ssp.tbl_faep(cd_faep,cd_caep,cd_fem,ds_fem,cnpj_faep,cep_faep,log_faep,
                                   nr_end_faep,cpl_edr_faep,brr_edr_faep,loc_edr_faep,uf_edr_faep,cd_emp)
       values(vl_codigo_faep,vl_codigo_caep,rg.cd_fem,rg.nm_filial,rg.nr_cpf_cnpj_cun,
              vl_cep,vl_logradouro,vl_numero,vl_complemento,vl_bairro,vl_localidade,vl_uf,rg.cd_emp);

       -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE FILIAL XXXXXXXXXXXXXXXXXXXXXX
     end if;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INICIO LINHA DE DETALHE XXXXXXXXXXXXXXXXXX
     vl_trilha_1 := sc_ssp.gerar_trilha_1(rg.nm_pls);
     vl_trilha_2 := sc_ssp.gerar_trilha_2(rg.cd_pls,rg.dt_vld_pls,'S');

     vl_linha := '41'; -- Identificador de registro
     vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_func,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(40,rg.nm_pls,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || rg.cd_pls;
     vl_linha := vl_linha || to_char(rg.dt_vld_pls,'MM/YYYY');
     vl_linha := vl_linha || sc_arq.preencher(3,rg.nr_scc_pls,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(76,vl_trilha_1,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(37,vl_trilha_2,'0',ALINHAMENTO_A_DIREITA);

     if(rg.fg_snh_mpl = 'S') then
          vl_linha := vl_linha || sc_arq.preencher(4,((rg.nm_snh_pls::integer)::numeric),'0',ALINHAMENTO_A_ESQUERDA);
       update sc_opr.tbl_pls set nm_snh_pls = md5(rg.nm_snh_pls) where cd_pls = rg.cd_pls;
     else
       vl_linha := vl_linha || sc_arq.preencher(4,0,'0',ALINHAMENTO_A_ESQUERDA);
     end if;

     vl_linha := vl_linha || sc_arq.preencher(40,rg.msg_crt_ssp,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(11,rg.cpf_fnc,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_matricula,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || '00';
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);


     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     insert into sc_ssp.tbl_daep(cd_daep,nm_func_daep,nm_pls_daep,cd_pls,dt_vld_daep,scc_daep,
                                 trl1_daep,trl2_daep,msg_crt_daep,cd_haep,cd_caep,cd_faep,cd_ssp)
     VALUES(nextval('sc_ssp.sq_daep'),rg.nm_func,rg.nm_pls,rg.cd_pls,to_char(rg.dt_vld_pls,'MM/YYYY'),
            rg.nr_scc_pls, vl_trilha_1,vl_trilha_2,rg.msg_crt_ssp,
            vl_codigo_haep,vl_codigo_caep,vl_codigo_faep,rg.cd_ssp);

     update sc_ssp.tbl_ssp set st_ssp = 2, dt_grc_ssp = now() where cd_ssp = rg.cd_ssp;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE DETALHE XXXXXXXXXXXXXXXXXX

     vl_qtd_detalhe_arquivo := vl_qtd_detalhe_arquivo + 1;
     vl_qtd_detalhe_filial := vl_qtd_detalhe_filial + 1;
     vl_qtd_detalhe_contrato := vl_qtd_detalhe_contrato + 1;
   end loop;

   if(vl_qtd_detalhe_arquivo > 0) then
     -- TRAILLER DE FILIAL
     vl_linha := '39';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE CONTRATO
     vl_linha := '29';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE ARQUIVO
     vl_linha := '19';
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_contrato_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

    -- atualizando quantidade de plasticos no header
    update sc_ssp.tbl_haep
       set qtd_pls_haep = vl_qtd_detalhe_arquivo
    where cd_haep = vl_codigo_haep;


   else
     perform sc_arq.excluirArquivo(vl_nome_arquivo);
   end if;
  end if;
  end loop;
exception
when others then
  perform sc_arq.excluirArquivo(vl_nome_arquivo); 
  RAISE EXCEPTION 'Problema na geração do arquivo de emissão de plastico. NUM:%, DETAILS:%, CPF:%', SQLSTATE, SQLERRM, vl_trilha_2;
end;
$$;


ALTER FUNCTION sc_ssp.gerar_arquivo_plastico_albertino() OWNER TO scan;

--
-- TOC entry 1410 (class 1255 OID 564591)
-- Name: gerar_arquivo_plastico_operador(); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION gerar_arquivo_plastico_operador() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  SITUACAO_SSP_CADASTRADA sc_ssp.tbl_ssp.st_ssp%type := 1;
  TP_SSP_PLASTICO sc_ssp.tbl_ssp.tp_ssp%type := 1;

  ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
  ALINHAMENTO_A_DIREITA numeric(2,0) := 1;

  PRM_DIRETORIO_ARQ_EMISSAO_PLS sc_cad.tbl_prm.nm_prm%type := 'DIR_ARQ_EMS_PLS';

  vl_diretorio varchar;

  vl_linha varchar;
  vl_nome_arquivo varchar;
  vl_nome_arquivo_aux varchar;

  vl_codigo_haep sc_ssp.tbl_haep.cd_haep%type;
  vl_codigo_caep sc_ssp.tbl_caep.cd_caep%type;
  vl_codigo_faep sc_ssp.tbl_faep.cd_faep%type;

  vl_cod_contrato_aux sc_cad.tbl_ctr.cd_ctr%type := 99999;
  vl_cod_filial_aux sc_cad.tbl_fem.cd_fem%type := 5;

  vl_nr_linha numeric(5,0) := 1;

  vl_qtd_contrato_arquivo numeric(3,0) := 0;
  vl_qtd_filial_contrato numeric(3,0) := 0;
  vl_qtd_filial_arquivo numeric(3,0) := 0;
  vl_qtd_detalhe_filial numeric(3,0) := 0;
  vl_qtd_detalhe_contrato numeric(3,0) := 0;
  vl_qtd_detalhe_arquivo numeric(5,0) := 0;

  vl_prioridade_remessa varchar := 'S';

  vl_trilha_1 varchar;
  vl_trilha_2 varchar;

  rg record;
begin

  -- Obtendo os parametros
  select prm.vl_prm
  into vl_diretorio
  from sc_cad.tbl_prm prm
  where prm.nm_prm = PRM_DIRETORIO_ARQ_EMISSAO_PLS;

  select nextval('sc_ssp.sq_haep') into vl_codigo_haep;

  vl_nome_arquivo := 'AEPO' || to_char(now(),'DDMMYYYY') || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA) || '.DAT';

  vl_nome_arquivo_aux := vl_nome_arquivo;

  vl_nome_arquivo := vl_diretorio || '/' || vl_nome_arquivo;

  -- XXXXXXXXXXXXXXXX GRAVANDO HEADER XXXXXXXXXXXXXXXXXXXXXXXXXX

  vl_linha := '11'; -- Identificador do registro de header
  vl_linha := vl_linha || '001'; -- Versão do layout
  vl_linha := vl_linha || to_char(now(),'DDMMYYYYHH24MISS'); -- Data da geracao
  vl_linha := vl_linha || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA); -- Código da remessa
  vl_linha := vl_linha || vl_prioridade_remessa; -- Prioridade da remessa
  vl_linha := vl_linha || sc_arq.preencher(6,'0','0',ALINHAMENTO_A_ESQUERDA); -- Codigo do arquivo (retorno)
  vl_linha := vl_linha || '00'; -- Retorno do processamento
  vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

  insert into sc_ssp.tbl_haep(cd_haep,vrs_haep,dt_grc_haep,nm_arq_haep,pri_haep,nm_dir_arq_haep)
  values(vl_codigo_haep,1,now(),vl_nome_arquivo_aux,vl_prioridade_remessa,vl_diretorio);

  perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
  vl_nr_linha := vl_nr_linha + 1;
  vl_linha := '';
  -- XXXXXXXXXXXXXXXXXXX FIM HEADER XXXXXXXXXXXXXXXXXXXXXXXXXXXX

  -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE CONTRATO XXXXXXXXXXXXXXXX
  vl_linha := '21';-- Identificador de registro
  vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do contrato
  vl_linha := vl_linha || sc_arq.preencher(5,999,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo da empresa
  vl_linha := vl_linha || sc_arq.preencher(50,'SOMA CONTA DIGITAL',' ',ALINHAMENTO_A_DIREITA); -- Nome da empresa
  vl_linha := vl_linha || sc_arq.preencher(2,1,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do modelo de plastico
  vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

  perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
  vl_nr_linha := vl_nr_linha + 1;
  vl_linha := '';

  select nextval('sc_ssp.sq_caep') into vl_codigo_caep;
      
  insert into sc_ssp.tbl_caep(cd_caep,cd_haep,cd_ctr,cd_emp,ds_emp,cd_mpl)
  values(vl_codigo_caep,vl_codigo_haep,vl_cod_contrato_aux,29,'SOMA CONTA DIGITAL',1);

  -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE CONTRATO XXXXXXXXXXXXXXXXXXXXXX
  vl_qtd_contrato_arquivo := vl_qtd_contrato_arquivo + 1;

  -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE FILIAL XXXXXXXXXXXXXXXXXX
  vl_linha := '31'; -- Identificador de registro
  vl_linha := vl_linha || sc_arq.preencher(5,99999,'0',ALINHAMENTO_A_ESQUERDA);
  vl_linha := vl_linha || sc_arq.preencher(50,'SOMA CONTA DIGITAL',' ',ALINHAMENTO_A_DIREITA);
  vl_linha := vl_linha || sc_arq.preencher(14,'21444981000136','0',ALINHAMENTO_A_ESQUERDA);
  vl_linha := vl_linha || sc_arq.preencher(8,'60192200','0',ALINHAMENTO_A_ESQUERDA);
  vl_linha := vl_linha || sc_arq.preencher(60,'AV ENG SANTANA JUNIOR',' ',ALINHAMENTO_A_DIREITA);
  vl_linha := vl_linha || sc_arq.preencher(5,'3000',' ',ALINHAMENTO_A_DIREITA);
  vl_linha := vl_linha || sc_arq.preencher(60,'SL 1705',' ',ALINHAMENTO_A_DIREITA);
  vl_linha := vl_linha || sc_arq.preencher(60,'COCO',' ',ALINHAMENTO_A_DIREITA);
  vl_linha := vl_linha || sc_arq.preencher(60,'FORTALEZA',' ',ALINHAMENTO_A_DIREITA);
  vl_linha := vl_linha || sc_arq.preencher(2,'CE',' ',ALINHAMENTO_A_DIREITA);
       
  vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha
  perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
  vl_nr_linha := vl_nr_linha + 1;
  vl_linha := '';

  vl_qtd_filial_arquivo := vl_qtd_filial_arquivo + 1;
  vl_qtd_filial_contrato := vl_qtd_filial_contrato + 1;

  select nextval('sc_ssp.sq_faep') into vl_codigo_faep;
  insert into sc_ssp.tbl_faep(cd_faep,cd_caep,cd_fem,ds_fem,cnpj_faep,cep_faep,log_faep,
                              nr_end_faep,cpl_edr_faep,brr_edr_faep,loc_edr_faep,uf_edr_faep,cd_emp)
  values(vl_codigo_faep,vl_codigo_caep,1,'SOMA CONTA DIGITAL',21444981000136,
         '60192200','AV ENG SANTANA JUNIOR',3000,'SL 1705','COCO','FORTALEZA','CE',29);
  -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE FILIAL XXXXXXXXXXXXXXXXXXXXXX

  for rg in select vl_cod_contrato_aux as cd_ctr,29 as cd_emp, 'SOMA CONTA DIGITAL' as nm_emp,mpl.cd_mpl, 'SOMA' as nm_fem,pop.ds_pop as nm_func,
                   21444981000136 as nr_cpf_cnpj_cun,ssp.cd_ssp,'SOMA' as nm_filial, pop.nm_pop,
                   pop.dt_vld_pop,pop.nr_scc_pop,pop.nm_snh_pop,pop.cd_pop, 1 as cd_fem, 11111111111 as cpf_fnc,
                   pop.cd_pop nr_matricula, mpl.fg_snh_mpl,ssp.msg_crt_ssp
            from sc_ssp.tbl_ssp ssp
                 inner join sc_rds.tbl_pop pop on ssp.cd_pop = pop.cd_pop
                 inner join sc_ssp.tbl_mpl mpl on mpl.cd_mpl = pop.cd_mpl
            where ssp.st_ssp = SITUACAO_SSP_CADASTRADA
              and ssp.tp_ssp = TP_SSP_PLASTICO
              --and ssp.dt_prv_grc_ssp <= now()
            order by pop.nm_pop loop
     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INICIO LINHA DE DETALHE XXXXXXXXXXXXXXXXXX
     vl_trilha_1 := sc_ssp.gerar_trilha_1(rg.nm_pop);
     vl_trilha_2 := sc_ssp.gerar_trilha_2(rg.cd_pop,rg.dt_vld_pop,'S');

     vl_linha := '41'; -- Identificador de registro
     vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_func,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(40,rg.nm_pop,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || rg.cd_pop;
     vl_linha := vl_linha || to_char(rg.dt_vld_pop,'MM/YYYY');
     vl_linha := vl_linha || sc_arq.preencher(3,rg.nr_scc_pop,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(76,vl_trilha_1,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(37,vl_trilha_2,'0',ALINHAMENTO_A_DIREITA);

     if(rg.fg_snh_mpl = 'S') then
       vl_linha := vl_linha || sc_arq.preencher(4,rg.nm_snh_pop,'0',ALINHAMENTO_A_ESQUERDA);
       update sc_rds.tbl_pop set nm_snh_pop = md5(rg.nm_snh_pop) where cd_pop = rg.cd_pop;
     else
       vl_linha := vl_linha || sc_arq.preencher(4,0,'0',ALINHAMENTO_A_ESQUERDA);
     end if;

     vl_linha := vl_linha || sc_arq.preencher(40,rg.msg_crt_ssp,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(11,rg.cpf_fnc,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_matricula,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || '00';
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);


     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     insert into sc_ssp.tbl_daep(cd_daep,nm_func_daep,nm_pls_daep,cd_pop,dt_vld_daep,scc_daep,
                                 trl1_daep,trl2_daep,msg_crt_daep,cd_haep,cd_caep,cd_faep,cd_ssp)
     VALUES(nextval('sc_ssp.sq_daep'),rg.nm_func,rg.nm_pop,rg.cd_pop,to_char(rg.dt_vld_pop,'MM/YYYY'),
            rg.nr_scc_pop, vl_trilha_1,vl_trilha_2,rg.msg_crt_ssp,
            vl_codigo_haep,vl_codigo_caep,vl_codigo_faep,rg.cd_ssp);

     update sc_ssp.tbl_ssp set st_ssp = 2, dt_grc_ssp = now() where cd_ssp = rg.cd_ssp;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE DETALHE XXXXXXXXXXXXXXXXXX

     vl_qtd_detalhe_arquivo := vl_qtd_detalhe_arquivo + 1;
     vl_qtd_detalhe_filial := vl_qtd_detalhe_filial + 1;
     vl_qtd_detalhe_contrato := vl_qtd_detalhe_contrato + 1;

     -- MARCAR COMO DESBLOQUEADO
     update sc_rds.tbl_pop set fg_blq_pop = 'N' where cd_pop = rg.cd_pop;

   end loop;

   if(vl_qtd_detalhe_arquivo > 0) then
     -- TRAILLER DE FILIAL
     vl_linha := '39';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE CONTRATO
     vl_linha := '29';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE ARQUIVO
     vl_linha := '19';
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_contrato_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

      -- atualizando quantidade de plasticos no header
    update sc_ssp.tbl_haep
       set qtd_pls_haep = vl_qtd_detalhe_arquivo
    where cd_haep = vl_codigo_haep;

   else
     perform sc_arq.excluirArquivo(vl_nome_arquivo);
   end if;
/*exception
when others then
perform sc_arq.excluirArquivo(vl_nome_arquivo); */
end;
$$;


ALTER FUNCTION sc_ssp.gerar_arquivo_plastico_operador() OWNER TO scan;

--
-- TOC entry 1538 (class 1255 OID 862595)
-- Name: gerar_arquivo_plastico_servnac(boolean); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION gerar_arquivo_plastico_servnac(vp_ger_imediata boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  CD_PARAMETRO_CONTRATO_MODELO sc_cad.tbl_pce.cd_pce%type := 9;
  SITUACAO_SSP_CADASTRADA sc_ssp.tbl_ssp.st_ssp%type := 1;
  SITUACAO_SSP_CANCELADA sc_ssp.tbl_ssp.st_ssp%type := 3;
  SITUACAO_SSP_EM_GERACAO_IMEDIATA sc_ssp.tbl_ssp.st_ssp%type := 4;
  TP_SSP_PLASTICO sc_ssp.tbl_ssp.tp_ssp%type := 1;

  ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
  ALINHAMENTO_A_DIREITA numeric(2,0) := 1;

  PRM_DIRETORIO_ARQ_EMISSAO_PLS sc_cad.tbl_prm.nm_prm%type := 'DIR_ARQ_EMS_PLS';

  vl_diretorio varchar;

  vl_linha varchar;
  vl_nome_arquivo varchar;
  vl_nome_arquivo_aux varchar;

  vl_codigo_haep sc_ssp.tbl_haep.cd_haep%type;
  vl_codigo_caep sc_ssp.tbl_caep.cd_caep%type;
  vl_codigo_faep sc_ssp.tbl_faep.cd_faep%type;

  vl_cod_contrato_aux sc_cad.tbl_ctr.cd_ctr%type := 0;
  vl_cod_filial_aux sc_cad.tbl_fem.cd_fem%type := -1;

  vl_nr_linha numeric(5,0) := 1;

  vl_qtd_contrato_arquivo numeric(3,0) := 0;
  vl_qtd_filial_contrato numeric(3,0) := 0;
  vl_qtd_filial_arquivo numeric(3,0) := 0;
  vl_qtd_detalhe_filial numeric(5,0) := 0;
  vl_qtd_detalhe_contrato numeric(5,0) := 0;
  vl_qtd_detalhe_arquivo numeric(5,0) := 0;

  vl_prioridade_remessa varchar := 'S';

  vl_trilha_1 varchar;
  vl_trilha_2 varchar;

  rg record;
  rg_edr record;
  tem_endereco boolean;
  
  vl_cep sc_cad.vw_edr.cep_edr%type;
  vl_logradouro sc_cad.vw_edr.logradouro%type;
  vl_bairro sc_cad.vw_edr.bairro%type;
  vl_localidade sc_cad.vw_edr.localidade%type;
  vl_uf sc_cad.vw_edr.uf%type;
  vl_complemento sc_cad.vw_edr.cpl_edr%type;
  vl_numero sc_cad.vw_edr.nr_edr%type;
  
  vl_qnt_solicitacao numeric(5,0) := 0;

  vl_local_impressao_array text[];
  vl_local_impressao text;
  rg_x record;
  vl_senha varchar;
  
begin

  FOR RG_X IN SELECT DISTINCT CD_LTC,DS_LTC,cd_emp FROM SC__BUXO.TBL_SVN2 order by cd_emp,ds_ltc LOOP
  vl_cod_filial_aux := -1;
  vl_cod_contrato_aux := 0;
  vl_qtd_contrato_arquivo := 0;
  vl_qtd_filial_contrato := 0;
  vl_qtd_filial_arquivo := 0;
  vl_qtd_detalhe_filial := 0;
  vl_qtd_detalhe_contrato := 0;
  vl_qtd_detalhe_arquivo := 0;
  vl_nr_linha := 1;
  
  begin
  -- locais de impressao
  select string_to_array(pce.lst_dad_pce, '@') 
    into vl_local_impressao_array
  from sc_cad.tbl_pce pce
  where pce.cd_pce = 16;

  for i in 1..array_length(vl_local_impressao_array,1) loop
    vl_local_impressao := vl_local_impressao_array[i];
    vl_qtd_detalhe_arquivo := 0;
 
  select count(*)
   into vl_qnt_solicitacao
  from sc_ssp.tbl_ssp ssp
    inner join sc_opr.tbl_pls pls on pls.cd_pls = ssp.cd_pls
    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
    inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
    inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 16
    INNER JOIN SC_CAD.TBL_FNC FNC ON FNC.CD_FNC = CRT.CD_FNC
    INNER JOIN SC__BUXO.TBL_SVN2 S ON S.CD_EMP = FNC.CD_EMP AND S.NR_MTR_SVN::numeric = FNC.NR_IDT_FNC::numeric AND S.CD_LTC = RG_X.CD_LTC and s.ds_ltc = rg_x.ds_ltc
  where ssp.st_ssp = SITUACAO_SSP_CANCELADA
    and ssp.tp_ssp = TP_SSP_PLASTICO
    and ssp.dt_inc_usr >= current_date
    and pce_ctr.vl_pce_ctr = vl_local_impressao;

  if vl_qnt_solicitacao > 0 then
  -- Obtendo os parametros
  select prm.vl_prm
  into vl_diretorio
  from sc_cad.tbl_prm prm
  where prm.nm_prm = PRM_DIRETORIO_ARQ_EMISSAO_PLS;

  select nextval('sc_ssp.sq_haep') into vl_codigo_haep;

  vl_nome_arquivo := 'AEP_VIPER_'|| rg_x.ds_ltc || '_' || to_char(now(),'DDMMYYYY') || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA) || '.DAT';

  vl_nome_arquivo_aux := vl_nome_arquivo;

  vl_nome_arquivo := vl_diretorio || '/' || vl_nome_arquivo;

  -- XXXXXXXXXXXXXXXX GRAVANDO HEADER XXXXXXXXXXXXXXXXXXXXXXXXXX

  vl_linha := '11'; -- Identificador do registro de header
  vl_linha := vl_linha || '001'; -- Versão do layout
  vl_linha := vl_linha || to_char(now(),'DDMMYYYYHH24MISS'); -- Data da geracao
  vl_linha := vl_linha || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA); -- Código da remessa
  vl_linha := vl_linha || vl_prioridade_remessa; -- Prioridade da remessa
  vl_linha := vl_linha || sc_arq.preencher(6,'0','0',ALINHAMENTO_A_ESQUERDA); -- Codigo do arquivo (retorno)
  vl_linha := vl_linha || '00'; -- Retorno do processamento
  vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

  insert into sc_ssp.tbl_haep(cd_haep,vrs_haep,dt_grc_haep,nm_arq_haep,pri_haep,nm_dir_arq_haep, nm_ftp_imp_haep)
  values(vl_codigo_haep,1,now(),vl_nome_arquivo_aux,vl_prioridade_remessa,vl_diretorio, vl_local_impressao);

  perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
  vl_nr_linha := vl_nr_linha + 1;
  vl_linha := '';
  -- XXXXXXXXXXXXXXXXXXX FIM HEADER XXXXXXXXXXXXXXXXXXXXXXXXXXXX

  for rg in select crt.cd_ctr,fnc.cd_emp,emp.nm_emp,mpl.cd_mpl,fem.nm_fem,cun_func.nm_cun nm_func,
                   cun_filial.nr_cpf_cnpj_cun,ssp.cd_ssp,fem.nm_fem nm_filial, pls.nm_pls,
                   pls.dt_vld_pls,pls.nr_scc_pls,pls.nm_snh_pls,pls.cd_pls,fem.cd_fem,cun_func.nr_cpf_cnpj_cun cpf_fnc,
                   fnc.nr_idt_fnc nr_matricula, mpl.fg_snh_mpl,ssp.msg_crt_ssp,edr_ctr.cd_edr
            from sc_ssp.tbl_ssp ssp
                 inner join sc_opr.tbl_pls pls on ssp.cd_pls = pls.cd_pls
                 inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
                 inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
                 inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 16
                 inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                 inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                 INNER JOIN SC__BUXO.TBL_SVN2 S ON S.CD_EMP = EMP.CD_EMP AND FNC.NR_IDT_FNC::numeric = S.NR_MTR_SVN::numeric AND S.CD_LTC = RG_X.CD_LTC and s.ds_ltc = rg_x.ds_ltc
                 inner join sc_cad.tbl_fem fem on fnc.cd_emp = fem.cd_emp and fnc.cd_fem = fem.cd_fem
                 inner join sc_cad.tbl_cun cun_filial on cun_filial.cd_cun = fem.cd_cun
                 inner join sc_cad.tbl_cun cun_func on cun_func.cd_cun = fnc.cd_cun
                 inner join sc_ssp.tbl_mpl mpl on mpl.cd_mpl = ctr.cd_mpl
                 inner join sc_cad.tbl_edr_ctr edr_ctr on edr_ctr.cd_ctr = ctr.cd_ctr and edr_ctr.tp_edr_ctr = 1 and edr_ctr.fg_atv_edr_ctr = 'S'
            where ssp.st_ssp = SITUACAO_SSP_CANCELADA
              and ssp.tp_ssp = TP_SSP_PLASTICO
              and edr_ctr.tp_edr_ctr = 1
              and ssp.dt_inc_usr >= current_date
              and pce_ctr.vl_pce_ctr = vl_local_impressao
            order by crt.cd_ctr, fnc.cd_fem, nm_func, fnc.nr_idt_fnc loop

    if( vl_cod_filial_aux <> rg.cd_fem or vl_cod_contrato_aux <> rg.cd_ctr ) then
      if( vl_qtd_filial_contrato > 0 ) then
        -- TRAILLER DE FILIAL
        vl_linha := '39';
        vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_nr_linha := vl_nr_linha + 1;
        vl_linha := '';

        vl_qtd_detalhe_filial := 0;
        vl_qtd_filial_contrato := 0;
      end if;
    end if;

    if( vl_cod_contrato_aux <> rg.cd_ctr ) then
      vl_cod_filial_aux := -1;
      
      if( vl_qtd_contrato_arquivo > 0 ) then
        -- TRAILLER DE CONTRATO
        vl_linha := '29';
        vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(2,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_nr_linha := vl_nr_linha + 1;
        vl_linha := '';

        vl_qtd_filial_contrato := 0;
        vl_qtd_filial_contrato := 0;
        vl_qtd_detalhe_contrato := 0;
      end if;

      vl_cod_contrato_aux := rg.cd_ctr;
      -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE CONTRATO XXXXXXXXXXXXXXXX

      vl_linha := '21';-- Identificador de registro
      vl_linha := vl_linha || sc_arq.preencher(8,rg.cd_ctr,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do contrato
      vl_linha := vl_linha || sc_arq.preencher(5,rg.cd_emp,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo da empresa
      vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_emp,' ',ALINHAMENTO_A_DIREITA); -- Nome da empresa
      vl_linha := vl_linha || sc_arq.preencher(2,rg.cd_mpl,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do modelo de plastico
      vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
      vl_nr_linha := vl_nr_linha + 1;
      vl_linha := '';

      select nextval('sc_ssp.sq_caep') into vl_codigo_caep;
      
      insert into sc_ssp.tbl_caep(cd_caep,cd_haep,cd_ctr,cd_emp,ds_emp,cd_mpl)
      values(vl_codigo_caep,vl_codigo_haep,rg.cd_ctr,rg.cd_emp,rg.nm_emp,rg.cd_mpl);

      -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE CONTRATO XXXXXXXXXXXXXXXXXXXXXX
      vl_qtd_contrato_arquivo := vl_qtd_contrato_arquivo + 1;
    end if;

    if( vl_cod_filial_aux <> rg.cd_fem ) then
       vl_cod_filial_aux := rg.cd_fem;
       
       -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE FILIAL XXXXXXXXXXXXXXXXXX
       vl_linha := '31'; -- Identificador de registro
       vl_linha := vl_linha || sc_arq.preencher(5,rg.cd_fem,'0',ALINHAMENTO_A_ESQUERDA);
       vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_filial,' ',ALINHAMENTO_A_DIREITA);
       vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_cpf_cnpj_cun,'0',ALINHAMENTO_A_ESQUERDA);

       tem_endereco := false;
       vl_cep := 0;
       vl_logradouro := ' ';
       vl_bairro := ' ';
       vl_localidade := ' ';
       vl_uf := ' ';
       vl_complemento := null;
       vl_numero := ' ';
       for rg_edr in select * 
                     from sc_cad.vw_edr edr 
                     where edr.cd_edr = rg.cd_edr loop
         tem_endereco := true;
         vl_linha := vl_linha || sc_arq.preencher(8,rg_edr.cep_edr,'0',ALINHAMENTO_A_ESQUERDA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.logradouro,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(5,rg_edr.nr_edr,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.cpl_edr,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.bairro,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.localidade,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(2,rg_edr.uf,' ',ALINHAMENTO_A_DIREITA);

         vl_cep := rg_edr.cep_edr;
	 vl_logradouro := rg_edr.logradouro;
	 vl_bairro := rg_edr.bairro;
	 vl_localidade := rg_edr.localidade;
	 vl_uf := rg_edr.uf;
	 vl_complemento := rg_edr.cpl_edr;
	 vl_numero := rg_edr.nr_edr;
       end loop;
       
       if not tem_endereco then
         vl_linha := vl_linha || sc_arq.preencher(8+60+5+60+60+60+2, ' ', ' ', ALINHAMENTO_A_DIREITA);
       end if;
       
       vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

       perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
       vl_nr_linha := vl_nr_linha + 1;
       vl_linha := '';

       vl_qtd_filial_arquivo := vl_qtd_filial_arquivo + 1;
       vl_qtd_filial_contrato := vl_qtd_filial_contrato + 1;

       select nextval('sc_ssp.sq_faep') into vl_codigo_faep;
       insert into sc_ssp.tbl_faep(cd_faep,cd_caep,cd_fem,ds_fem,cnpj_faep,cep_faep,log_faep,
                                   nr_end_faep,cpl_edr_faep,brr_edr_faep,loc_edr_faep,uf_edr_faep,cd_emp)
       values(vl_codigo_faep,vl_codigo_caep,rg.cd_fem,rg.nm_filial,rg.nr_cpf_cnpj_cun,
              vl_cep,vl_logradouro,vl_numero,vl_complemento,vl_bairro,vl_localidade,vl_uf,rg.cd_emp);

       -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE FILIAL XXXXXXXXXXXXXXXXXXXXXX
     end if;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INICIO LINHA DE DETALHE XXXXXXXXXXXXXXXXXX
     vl_trilha_1 := sc_ssp.gerar_trilha_1(rg.nm_pls);
     vl_trilha_2 := sc_ssp.gerar_trilha_2(rg.cd_pls,rg.dt_vld_pls,'S');

     vl_linha := '41'; -- Identificador de registro
     vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_func,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(40,rg.nm_pls,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || rg.cd_pls;
     vl_linha := vl_linha || to_char(rg.dt_vld_pls,'MM/YYYY');
     vl_linha := vl_linha || sc_arq.preencher(3,rg.nr_scc_pls,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(76,vl_trilha_1,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(37,vl_trilha_2,'0',ALINHAMENTO_A_DIREITA);

     if(rg.fg_snh_mpl = 'S') then
          vl_senha := sc_acc.gera_numero_aleatorio(4);
          vl_linha := vl_linha || sc_arq.preencher(4,((vl_senha::integer)::numeric),'0',ALINHAMENTO_A_ESQUERDA);
	  update sc_opr.tbl_pls set nm_snh_pls = md5(vl_senha) where cd_pls = rg.cd_pls;
     else
       vl_linha := vl_linha || sc_arq.preencher(4,0,'0',ALINHAMENTO_A_ESQUERDA);
     end if;

     vl_linha := vl_linha || sc_arq.preencher(40,rg.msg_crt_ssp,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(11,rg.cpf_fnc,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_matricula,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || '00';
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);


     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     insert into sc_ssp.tbl_daep(cd_daep,nm_func_daep,nm_pls_daep,cd_pls,dt_vld_daep,scc_daep,
                                 trl1_daep,trl2_daep,msg_crt_daep,cd_haep,cd_caep,cd_faep,cd_ssp)
     VALUES(nextval('sc_ssp.sq_daep'),rg.nm_func,rg.nm_pls,rg.cd_pls,to_char(rg.dt_vld_pls,'MM/YYYY'),
            rg.nr_scc_pls, vl_trilha_1,vl_trilha_2,rg.msg_crt_ssp,
            vl_codigo_haep,vl_codigo_caep,vl_codigo_faep,rg.cd_ssp);

     update sc_ssp.tbl_ssp set st_ssp = 2, dt_grc_ssp = now() where cd_ssp = rg.cd_ssp;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE DETALHE XXXXXXXXXXXXXXXXXX

     vl_qtd_detalhe_arquivo := vl_qtd_detalhe_arquivo + 1;
     vl_qtd_detalhe_filial := vl_qtd_detalhe_filial + 1;
     vl_qtd_detalhe_contrato := vl_qtd_detalhe_contrato + 1;
   end loop;

   if(vl_qtd_detalhe_arquivo > 0) then
     -- TRAILLER DE FILIAL
     vl_linha := '39';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE CONTRATO
     vl_linha := '29';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE ARQUIVO
     vl_linha := '19';
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_contrato_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

    -- atualizando quantidade de plasticos no header
    update sc_ssp.tbl_haep
       set qtd_pls_haep = vl_qtd_detalhe_arquivo
    where cd_haep = vl_codigo_haep;


   else
     perform sc_arq.excluirArquivo(vl_nome_arquivo);
   end if;
  end if;
  end loop;
  exception
when others then
   raise notice 'ERRO NA LOTACAO %',RG_X.CD_LTC;
end;
  END LOOP;
/*exception
when others then
  perform sc_arq.excluirArquivo(vl_nome_arquivo); 
  RAISE EXCEPTION 'Problema na geração do arquivo de emissão de plastico. NUM:%, DETAILS:%, CPF:%', SQLSTATE, SQLERRM, rg.cpf_fnc || ' - ' || rg.nm_func;*/
end;
$$;


ALTER FUNCTION sc_ssp.gerar_arquivo_plastico_servnac(vp_ger_imediata boolean) OWNER TO scan;

--
-- TOC entry 1691 (class 1255 OID 998435)
-- Name: gerar_arquivo_plastico_temp(boolean); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION gerar_arquivo_plastico_temp(vp_ger_imediata boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  CD_PARAMETRO_CONTRATO_MODELO sc_cad.tbl_pce.cd_pce%type := 9;
  SITUACAO_SSP_CADASTRADA sc_ssp.tbl_ssp.st_ssp%type := 1;
  SITUACAO_SSP_EM_GERACAO_IMEDIATA sc_ssp.tbl_ssp.st_ssp%type := 4;
  TP_SSP_PLASTICO sc_ssp.tbl_ssp.tp_ssp%type := 1;

  ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
  ALINHAMENTO_A_DIREITA numeric(2,0) := 1;

  PRM_DIRETORIO_ARQ_EMISSAO_PLS sc_cad.tbl_prm.nm_prm%type := 'DIR_ARQ_EMS_PLS';

  vl_diretorio varchar;

  vl_linha varchar;
  vl_nome_arquivo varchar;
  vl_nome_arquivo_aux varchar;

  vl_codigo_haep sc_ssp.tbl_haep.cd_haep%type;
  vl_codigo_caep sc_ssp.tbl_caep.cd_caep%type;
  vl_codigo_faep sc_ssp.tbl_faep.cd_faep%type;

  vl_cod_contrato_aux sc_cad.tbl_ctr.cd_ctr%type := 0;
  vl_cod_filial_aux sc_cad.tbl_fem.cd_fem%type := -1;

  vl_nr_linha numeric(5,0) := 1;

  vl_qtd_contrato_arquivo numeric(3,0) := 0;
  vl_qtd_filial_contrato numeric(3,0) := 0;
  vl_qtd_filial_arquivo numeric(3,0) := 0;
  vl_qtd_detalhe_filial numeric(5,0) := 0;
  vl_qtd_detalhe_contrato numeric(5,0) := 0;
  vl_qtd_detalhe_arquivo numeric(5,0) := 0;

  vl_prioridade_remessa varchar := 'S';

  vl_trilha_1 varchar;
  vl_trilha_2 varchar;

  rg record;
  rg_edr record;
  tem_endereco boolean;
  
  vl_cep sc_cad.vw_edr.cep_edr%type;
  vl_logradouro sc_cad.vw_edr.logradouro%type;
  vl_bairro sc_cad.vw_edr.bairro%type;
  vl_localidade sc_cad.vw_edr.localidade%type;
  vl_uf sc_cad.vw_edr.uf%type;
  vl_complemento sc_cad.vw_edr.cpl_edr%type;
  vl_numero sc_cad.vw_edr.nr_edr%type;
  
  vl_qnt_solicitacao numeric(5,0) := 0;

  vl_local_impressao_array text[];
  vl_local_impressao text;
  vl_tipo_entrega varchar;
  
begin

  -- locais de impressao
  select string_to_array(pce.lst_dad_pce, '@') 
    into vl_local_impressao_array
  from sc_cad.tbl_pce pce
  where pce.cd_pce = 16;

  for i in 1..array_length(vl_local_impressao_array,1) loop
    vl_local_impressao := vl_local_impressao_array[i];
    vl_qtd_detalhe_arquivo := 0;
 
  select count(*)
   into vl_qnt_solicitacao
  from sc_ssp.tbl_ssp ssp
    inner join sc_opr.tbl_pls pls on pls.cd_pls = ssp.cd_pls
    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
    inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
    inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 16
  where 
    ((vp_ger_imediata = true and ssp.st_ssp = SITUACAO_SSP_EM_GERACAO_IMEDIATA) or 
    (vp_ger_imediata = false and ssp.st_ssp = SITUACAO_SSP_CADASTRADA))
    and ssp.tp_ssp = TP_SSP_PLASTICO
    and (ssp.dt_prv_grc_ssp <= now() or vp_ger_imediata = true)
    and pce_ctr.vl_pce_ctr = vl_local_impressao
    and length(pls.nm_snh_pls) > 4;

  if vl_qnt_solicitacao > 0 then
  -- Obtendo os parametros
  select prm.vl_prm
  into vl_diretorio
  from sc_cad.tbl_prm prm
  where prm.nm_prm = PRM_DIRETORIO_ARQ_EMISSAO_PLS;

  select nextval('sc_ssp.sq_haep') into vl_codigo_haep;

  vl_nome_arquivo := 'AEP' || to_char(now(),'DDMMYYYY') || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA) || '_RE.DAT';

  vl_nome_arquivo_aux := vl_nome_arquivo;

  vl_nome_arquivo := vl_diretorio || '/' || vl_nome_arquivo;

  -- XXXXXXXXXXXXXXXX GRAVANDO HEADER XXXXXXXXXXXXXXXXXXXXXXXXXX

  vl_linha := '11'; -- Identificador do registro de header
  vl_linha := vl_linha || '001'; -- Versão do layout
  vl_linha := vl_linha || to_char(now(),'DDMMYYYYHH24MISS'); -- Data da geracao
  vl_linha := vl_linha || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA); -- Código da remessa
  vl_linha := vl_linha || vl_prioridade_remessa; -- Prioridade da remessa
  vl_linha := vl_linha || sc_arq.preencher(6,'0','0',ALINHAMENTO_A_ESQUERDA); -- Codigo do arquivo (retorno)
  vl_linha := vl_linha || '00'; -- Retorno do processamento
  vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

  insert into sc_ssp.tbl_haep(cd_haep,vrs_haep,dt_grc_haep,nm_arq_haep,pri_haep,nm_dir_arq_haep, nm_ftp_imp_haep)
  values(vl_codigo_haep,1,now(),vl_nome_arquivo_aux,vl_prioridade_remessa,vl_diretorio, vl_local_impressao);

  perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
  vl_nr_linha := vl_nr_linha + 1;
  vl_linha := '';
  -- XXXXXXXXXXXXXXXXXXX FIM HEADER XXXXXXXXXXXXXXXXXXXXXXXXXXXX

  for rg in select crt.cd_ctr,fnc.cd_emp,emp.nm_emp,mpl.cd_mpl,fem.nm_fem,cun_func.nm_cun nm_func,
                   cun_filial.nr_cpf_cnpj_cun,ssp.cd_ssp,fem.nm_fem nm_filial, pls.nm_pls,
                   pls.dt_vld_pls,pls.nr_scc_pls,pls.nm_snh_pls,pls.cd_pls,fem.cd_fem,cun_func.nr_cpf_cnpj_cun cpf_fnc,
                   fnc.nr_idt_fnc nr_matricula, mpl.fg_snh_mpl,ssp.msg_crt_ssp,edr_ctr.cd_edr,pce_ctr_etr.vl_pce_ctr tipo_entrega
            from sc_ssp.tbl_ssp ssp
                 inner join sc_opr.tbl_pls pls on ssp.cd_pls = pls.cd_pls
                 inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
                 inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
                 inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 16
                 left  join sc_cad.tbl_pce_ctr pce_ctr_etr on pce_ctr_etr.cd_ctr = ctr.cd_ctr and pce_ctr_etr.cd_pce = 3
                 inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                 inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                 inner join sc_cad.tbl_fem fem on fnc.cd_emp = fem.cd_emp and fnc.cd_fem = fem.cd_fem
                 inner join sc_cad.tbl_cun cun_filial on cun_filial.cd_cun = fem.cd_cun
                 inner join sc_cad.tbl_cun cun_func on cun_func.cd_cun = fnc.cd_cun
                 inner join sc_ssp.tbl_mpl mpl on mpl.cd_mpl = ctr.cd_mpl
                 inner join sc_cad.tbl_edr_ctr edr_ctr on edr_ctr.cd_ctr = ctr.cd_ctr and edr_ctr.tp_edr_ctr = 1 and edr_ctr.fg_atv_edr_ctr = 'S'
            where ((vp_ger_imediata = true and ssp.st_ssp = SITUACAO_SSP_EM_GERACAO_IMEDIATA) or (vp_ger_imediata = false and ssp.st_ssp = SITUACAO_SSP_CADASTRADA))
              and ssp.tp_ssp = TP_SSP_PLASTICO
              and (ssp.dt_prv_grc_ssp <= now() or vp_ger_imediata = true)
              and edr_ctr.tp_edr_ctr = 1
              and pce_ctr.vl_pce_ctr = vl_local_impressao
              and length(pls.nm_snh_pls) > 4
            order by crt.cd_ctr, fnc.cd_fem, nm_func, fnc.nr_idt_fnc loop

    if( vl_cod_filial_aux <> rg.cd_fem or vl_cod_contrato_aux <> rg.cd_ctr ) then
      if( vl_qtd_filial_contrato > 0 ) then
        -- TRAILLER DE FILIAL
        vl_linha := '39';
        vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_nr_linha := vl_nr_linha + 1;
        vl_linha := '';

        vl_qtd_detalhe_filial := 0;
        vl_qtd_filial_contrato := 0;
      end if;
    end if;

    if( vl_cod_contrato_aux <> rg.cd_ctr ) then
      vl_cod_filial_aux := -1;
      
      if( vl_qtd_contrato_arquivo > 0 ) then
        -- TRAILLER DE CONTRATO
        vl_linha := '29';
        vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(2,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_nr_linha := vl_nr_linha + 1;
        vl_linha := '';

        vl_qtd_filial_contrato := 0;
        vl_qtd_filial_contrato := 0;
        vl_qtd_detalhe_contrato := 0;
      end if;

      vl_cod_contrato_aux := rg.cd_ctr;
      -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE CONTRATO XXXXXXXXXXXXXXXX

      vl_linha := '21';-- Identificador de registro
      vl_linha := vl_linha || sc_arq.preencher(8,rg.cd_ctr,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do contrato
      vl_linha := vl_linha || sc_arq.preencher(5,rg.cd_emp,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo da empresa
      vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_emp,' ',ALINHAMENTO_A_DIREITA); -- Nome da empresa
      vl_linha := vl_linha || sc_arq.preencher(2,rg.cd_mpl,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do modelo de plastico
      vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
      vl_nr_linha := vl_nr_linha + 1;
      vl_linha := '';

      select nextval('sc_ssp.sq_caep') into vl_codigo_caep;
      
      insert into sc_ssp.tbl_caep(cd_caep,cd_haep,cd_ctr,cd_emp,ds_emp,cd_mpl)
      values(vl_codigo_caep,vl_codigo_haep,rg.cd_ctr,rg.cd_emp,rg.nm_emp,rg.cd_mpl);

      -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE CONTRATO XXXXXXXXXXXXXXXXXXXXXX
      vl_qtd_contrato_arquivo := vl_qtd_contrato_arquivo + 1;
    end if;

    if( vl_cod_filial_aux <> rg.cd_fem ) then
       vl_cod_filial_aux := rg.cd_fem;
       
       -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE FILIAL XXXXXXXXXXXXXXXXXX
       vl_linha := '31'; -- Identificador de registro
       vl_linha := vl_linha || sc_arq.preencher(5,rg.cd_fem,'0',ALINHAMENTO_A_ESQUERDA);
       vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_filial,' ',ALINHAMENTO_A_DIREITA);
       vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_cpf_cnpj_cun,'0',ALINHAMENTO_A_ESQUERDA);

       tem_endereco := false;
       vl_cep := 0;
       vl_logradouro := ' ';
       vl_bairro := ' ';
       vl_localidade := ' ';
       vl_uf := ' ';
       vl_complemento := null;
       vl_numero := ' ';
       for rg_edr in select * 
                     from sc_cad.vw_edr edr 
                     where edr.cd_edr = rg.cd_edr loop
         tem_endereco := true;
         vl_linha := vl_linha || sc_arq.preencher(8,rg_edr.cep_edr,'0',ALINHAMENTO_A_ESQUERDA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.logradouro,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(5,rg_edr.nr_edr,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.cpl_edr,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.bairro,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.localidade,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(2,rg_edr.uf,' ',ALINHAMENTO_A_DIREITA);

         vl_cep := rg_edr.cep_edr;
	 vl_logradouro := rg_edr.logradouro;
	 vl_bairro := rg_edr.bairro;
	 vl_localidade := rg_edr.localidade;
	 vl_uf := rg_edr.uf;
	 vl_complemento := rg_edr.cpl_edr;
	 vl_numero := rg_edr.nr_edr;
       end loop;
       
       if not tem_endereco then
         vl_linha := vl_linha || sc_arq.preencher(8+60+5+60+60+60+2, ' ', ' ', ALINHAMENTO_A_DIREITA);
       end if;
       
       vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

       perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
       vl_nr_linha := vl_nr_linha + 1;
       vl_linha := '';

       vl_qtd_filial_arquivo := vl_qtd_filial_arquivo + 1;
       vl_qtd_filial_contrato := vl_qtd_filial_contrato + 1;

       select nextval('sc_ssp.sq_faep') into vl_codigo_faep;
       insert into sc_ssp.tbl_faep(cd_faep,cd_caep,cd_fem,ds_fem,cnpj_faep,cep_faep,log_faep,
                                   nr_end_faep,cpl_edr_faep,brr_edr_faep,loc_edr_faep,uf_edr_faep,cd_emp)
       values(vl_codigo_faep,vl_codigo_caep,rg.cd_fem,rg.nm_filial,rg.nr_cpf_cnpj_cun,
              vl_cep,vl_logradouro,vl_numero,vl_complemento,vl_bairro,vl_localidade,vl_uf,rg.cd_emp);

       -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE FILIAL XXXXXXXXXXXXXXXXXXXXXX
     end if;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INICIO LINHA DE DETALHE XXXXXXXXXXXXXXXXXX
     vl_trilha_1 := sc_ssp.gerar_trilha_1(rg.nm_pls);
     vl_trilha_2 := sc_ssp.gerar_trilha_2(rg.cd_pls,rg.dt_vld_pls,'S');

     vl_linha := '41'; -- Identificador de registro
     vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_func,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(40,rg.nm_pls,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || rg.cd_pls;
     vl_linha := vl_linha || to_char(rg.dt_vld_pls,'MM/YYYY');
     vl_linha := vl_linha || sc_arq.preencher(3,rg.nr_scc_pls,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(76,vl_trilha_1,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(37,vl_trilha_2,'0',ALINHAMENTO_A_DIREITA);

     
       vl_linha := vl_linha || sc_arq.preencher(4,0,'0',ALINHAMENTO_A_ESQUERDA);
     
     vl_linha := vl_linha || sc_arq.preencher(40,rg.msg_crt_ssp,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(11,rg.cpf_fnc,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_matricula,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || '00';
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     if (rg.tipo_entrega = 'EMPRESA') then
       vl_tipo_entrega = 'E';
     elsif(rg.tipo_entrega = 'FILIAL') then
       vl_tipo_entrega = 'F';
     elsif(rg.tipo_entrega = 'ADMINISTRADORA') then
       vl_tipo_entrega = 'A';
     else  
       vl_tipo_entrega = null;
     end if;

     if vp_ger_imediata then
       vl_tipo_entrega := 'U';
     end if;

     vl_linha := vl_linha || coalesce(vl_tipo_entrega,' ');
     


     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     insert into sc_ssp.tbl_daep(cd_daep,nm_func_daep,nm_pls_daep,cd_pls,dt_vld_daep,scc_daep,
                                 trl1_daep,trl2_daep,msg_crt_daep,cd_haep,cd_caep,cd_faep,cd_ssp,tp_etr_daep)
     VALUES(nextval('sc_ssp.sq_daep'),rg.nm_func,rg.nm_pls,rg.cd_pls,to_char(rg.dt_vld_pls,'MM/YYYY'),
            rg.nr_scc_pls, vl_trilha_1,vl_trilha_2,rg.msg_crt_ssp,
            vl_codigo_haep,vl_codigo_caep,vl_codigo_faep,rg.cd_ssp,vl_tipo_entrega);

     update sc_ssp.tbl_ssp set st_ssp = 2, dt_grc_ssp = now() where cd_ssp = rg.cd_ssp;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE DETALHE XXXXXXXXXXXXXXXXXX

     vl_qtd_detalhe_arquivo := vl_qtd_detalhe_arquivo + 1;
     vl_qtd_detalhe_filial := vl_qtd_detalhe_filial + 1;
     vl_qtd_detalhe_contrato := vl_qtd_detalhe_contrato + 1;
   end loop;

   if(vl_qtd_detalhe_arquivo > 0) then
     -- TRAILLER DE FILIAL
     vl_linha := '39';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE CONTRATO
     vl_linha := '29';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE ARQUIVO
     vl_linha := '19';
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_contrato_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

    -- atualizando quantidade de plasticos no header
    update sc_ssp.tbl_haep
       set qtd_pls_haep = vl_qtd_detalhe_arquivo
    where cd_haep = vl_codigo_haep;


   else
     perform sc_arq.excluirArquivo(vl_nome_arquivo);
   end if;
  end if;
  end loop;
exception
when others then
  perform sc_arq.excluirArquivo(vl_nome_arquivo); 
  RAISE EXCEPTION 'Problema na geração do arquivo de emissão de plastico. NUM:%, DETAILS:%, CPF:%', SQLSTATE, SQLERRM, rg.cpf_fnc || ' - ' || rg.nm_func;
end;
$$;


ALTER FUNCTION sc_ssp.gerar_arquivo_plastico_temp(vp_ger_imediata boolean) OWNER TO scan;

--
-- TOC entry 1711 (class 1255 OID 1007070)
-- Name: gerar_arquivo_plastico_temp(boolean, numeric); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION gerar_arquivo_plastico_temp(vp_ger_imediata boolean, vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  CD_PARAMETRO_CONTRATO_MODELO sc_cad.tbl_pce.cd_pce%type := 9;
  SITUACAO_SSP_CADASTRADA sc_ssp.tbl_ssp.st_ssp%type := 1;
  SITUACAO_SSP_EM_GERACAO_IMEDIATA sc_ssp.tbl_ssp.st_ssp%type := 4;
  TP_SSP_PLASTICO sc_ssp.tbl_ssp.tp_ssp%type := 1;

  ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
  ALINHAMENTO_A_DIREITA numeric(2,0) := 1;

  PRM_DIRETORIO_ARQ_EMISSAO_PLS sc_cad.tbl_prm.nm_prm%type := 'DIR_ARQ_EMS_PLS';

  vl_diretorio varchar;

  vl_linha varchar;
  vl_nome_arquivo varchar;
  vl_nome_arquivo_aux varchar;

  vl_codigo_haep sc_ssp.tbl_haep.cd_haep%type;
  vl_codigo_caep sc_ssp.tbl_caep.cd_caep%type;
  vl_codigo_faep sc_ssp.tbl_faep.cd_faep%type;

  vl_cod_contrato_aux sc_cad.tbl_ctr.cd_ctr%type := 0;
  vl_cod_filial_aux sc_cad.tbl_fem.cd_fem%type := -1;

  vl_nr_linha numeric(5,0) := 1;

  vl_qtd_contrato_arquivo numeric(3,0) := 0;
  vl_qtd_filial_contrato numeric(3,0) := 0;
  vl_qtd_filial_arquivo numeric(3,0) := 0;
  vl_qtd_detalhe_filial numeric(5,0) := 0;
  vl_qtd_detalhe_contrato numeric(5,0) := 0;
  vl_qtd_detalhe_arquivo numeric(5,0) := 0;

  vl_prioridade_remessa varchar := 'S';

  vl_trilha_1 varchar;
  vl_trilha_2 varchar;

  rg record;
  rg_edr record;
  tem_endereco boolean;
  
  vl_cep sc_cad.vw_edr.cep_edr%type;
  vl_logradouro sc_cad.vw_edr.logradouro%type;
  vl_bairro sc_cad.vw_edr.bairro%type;
  vl_localidade sc_cad.vw_edr.localidade%type;
  vl_uf sc_cad.vw_edr.uf%type;
  vl_complemento sc_cad.vw_edr.cpl_edr%type;
  vl_numero sc_cad.vw_edr.nr_edr%type;
  
  vl_qnt_solicitacao numeric(5,0) := 0;

  vl_local_impressao_array text[];
  vl_local_impressao text;
  vl_tipo_entrega varchar;
  
begin

  -- locais de impressao
  select string_to_array(pce.lst_dad_pce, '@') 
    into vl_local_impressao_array
  from sc_cad.tbl_pce pce
  where pce.cd_pce = 16;

  for i in 1..array_length(vl_local_impressao_array,1) loop
    vl_local_impressao := vl_local_impressao_array[i];
    vl_qtd_detalhe_arquivo := 0;
 
  select count(*)
   into vl_qnt_solicitacao
  from sc_ssp.tbl_ssp ssp
    inner join sc_opr.tbl_pls pls on pls.cd_pls = ssp.cd_pls
    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
    inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
    inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 16
  where 
    ((vp_ger_imediata = true and ssp.st_ssp = SITUACAO_SSP_EM_GERACAO_IMEDIATA) or 
    (vp_ger_imediata = false and ssp.st_ssp = SITUACAO_SSP_CADASTRADA))
    and ssp.tp_ssp = TP_SSP_PLASTICO
    and (ssp.dt_prv_grc_ssp <= now() or vp_ger_imediata = true)
    and pce_ctr.vl_pce_ctr = vl_local_impressao
    and length(pls.nm_snh_pls) > 4;

  if vl_qnt_solicitacao > 0 then
  -- Obtendo os parametros
  select prm.vl_prm
  into vl_diretorio
  from sc_cad.tbl_prm prm
  where prm.nm_prm = PRM_DIRETORIO_ARQ_EMISSAO_PLS;

  select nextval('sc_ssp.sq_haep') into vl_codigo_haep;

  vl_nome_arquivo := 'AEP' || to_char(now(),'DDMMYYYY') || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA) || '_RE_'||vp_empresa||'.DAT';

  vl_nome_arquivo_aux := vl_nome_arquivo;

  vl_nome_arquivo := vl_diretorio || '/' || vl_nome_arquivo;

  -- XXXXXXXXXXXXXXXX GRAVANDO HEADER XXXXXXXXXXXXXXXXXXXXXXXXXX

  vl_linha := '11'; -- Identificador do registro de header
  vl_linha := vl_linha || '001'; -- Versão do layout
  vl_linha := vl_linha || to_char(now(),'DDMMYYYYHH24MISS'); -- Data da geracao
  vl_linha := vl_linha || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA); -- Código da remessa
  vl_linha := vl_linha || vl_prioridade_remessa; -- Prioridade da remessa
  vl_linha := vl_linha || sc_arq.preencher(6,'0','0',ALINHAMENTO_A_ESQUERDA); -- Codigo do arquivo (retorno)
  vl_linha := vl_linha || '00'; -- Retorno do processamento
  vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

  insert into sc_ssp.tbl_haep(cd_haep,vrs_haep,dt_grc_haep,nm_arq_haep,pri_haep,nm_dir_arq_haep, nm_ftp_imp_haep)
  values(vl_codigo_haep,1,now(),vl_nome_arquivo_aux,vl_prioridade_remessa,vl_diretorio, vl_local_impressao);

  perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
  vl_nr_linha := vl_nr_linha + 1;
  vl_linha := '';
  -- XXXXXXXXXXXXXXXXXXX FIM HEADER XXXXXXXXXXXXXXXXXXXXXXXXXXXX

  for rg in select crt.cd_ctr,fnc.cd_emp,emp.nm_emp,mpl.cd_mpl,fem.nm_fem,cun_func.nm_cun nm_func,
                   cun_filial.nr_cpf_cnpj_cun,ssp.cd_ssp,fem.nm_fem nm_filial, pls.nm_pls,
                   pls.dt_vld_pls,pls.nr_scc_pls,pls.nm_snh_pls,pls.cd_pls,fem.cd_fem,cun_func.nr_cpf_cnpj_cun cpf_fnc,
                   fnc.nr_idt_fnc nr_matricula, mpl.fg_snh_mpl,ssp.msg_crt_ssp,edr_ctr.cd_edr,pce_ctr_etr.vl_pce_ctr tipo_entrega
            from sc_ssp.tbl_ssp ssp
                 inner join sc_opr.tbl_pls pls on ssp.cd_pls = pls.cd_pls
                 inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
                 inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
                 inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 16
                 left  join sc_cad.tbl_pce_ctr pce_ctr_etr on pce_ctr_etr.cd_ctr = ctr.cd_ctr and pce_ctr_etr.cd_pce = 3
                 inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                 inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                 inner join sc_cad.tbl_fem fem on fnc.cd_emp = fem.cd_emp and fnc.cd_fem = fem.cd_fem
                 inner join sc_cad.tbl_cun cun_filial on cun_filial.cd_cun = fem.cd_cun
                 inner join sc_cad.tbl_cun cun_func on cun_func.cd_cun = fnc.cd_cun
                 inner join sc_ssp.tbl_mpl mpl on mpl.cd_mpl = ctr.cd_mpl
                 inner join sc_cad.tbl_edr_ctr edr_ctr on edr_ctr.cd_ctr = ctr.cd_ctr and edr_ctr.tp_edr_ctr = 1 and edr_ctr.fg_atv_edr_ctr = 'S'
            where ((vp_ger_imediata = true and ssp.st_ssp = SITUACAO_SSP_EM_GERACAO_IMEDIATA) or (vp_ger_imediata = false and ssp.st_ssp = SITUACAO_SSP_CADASTRADA))
              and ssp.tp_ssp = TP_SSP_PLASTICO
              and (ssp.dt_prv_grc_ssp <= now() or vp_ger_imediata = true)
              and edr_ctr.tp_edr_ctr = 1
              and pce_ctr.vl_pce_ctr = vl_local_impressao
              and length(pls.nm_snh_pls) > 4
            order by crt.cd_ctr, fnc.cd_fem, nm_func, fnc.nr_idt_fnc loop

    if( vl_cod_filial_aux <> rg.cd_fem or vl_cod_contrato_aux <> rg.cd_ctr ) then
      if( vl_qtd_filial_contrato > 0 ) then
        -- TRAILLER DE FILIAL
        vl_linha := '39';
        vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_nr_linha := vl_nr_linha + 1;
        vl_linha := '';

        vl_qtd_detalhe_filial := 0;
        vl_qtd_filial_contrato := 0;
      end if;
    end if;

    if( vl_cod_contrato_aux <> rg.cd_ctr ) then
      vl_cod_filial_aux := -1;
      
      if( vl_qtd_contrato_arquivo > 0 ) then
        -- TRAILLER DE CONTRATO
        vl_linha := '29';
        vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(2,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_nr_linha := vl_nr_linha + 1;
        vl_linha := '';

        vl_qtd_filial_contrato := 0;
        vl_qtd_filial_contrato := 0;
        vl_qtd_detalhe_contrato := 0;
      end if;

      vl_cod_contrato_aux := rg.cd_ctr;
      -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE CONTRATO XXXXXXXXXXXXXXXX

      vl_linha := '21';-- Identificador de registro
      vl_linha := vl_linha || sc_arq.preencher(8,rg.cd_ctr,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do contrato
      vl_linha := vl_linha || sc_arq.preencher(5,rg.cd_emp,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo da empresa
      vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_emp,' ',ALINHAMENTO_A_DIREITA); -- Nome da empresa
      vl_linha := vl_linha || sc_arq.preencher(2,rg.cd_mpl,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do modelo de plastico
      vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
      vl_nr_linha := vl_nr_linha + 1;
      vl_linha := '';

      select nextval('sc_ssp.sq_caep') into vl_codigo_caep;
      
      insert into sc_ssp.tbl_caep(cd_caep,cd_haep,cd_ctr,cd_emp,ds_emp,cd_mpl)
      values(vl_codigo_caep,vl_codigo_haep,rg.cd_ctr,rg.cd_emp,rg.nm_emp,rg.cd_mpl);

      -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE CONTRATO XXXXXXXXXXXXXXXXXXXXXX
      vl_qtd_contrato_arquivo := vl_qtd_contrato_arquivo + 1;
    end if;

    if( vl_cod_filial_aux <> rg.cd_fem ) then
       vl_cod_filial_aux := rg.cd_fem;
       
       -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE FILIAL XXXXXXXXXXXXXXXXXX
       vl_linha := '31'; -- Identificador de registro
       vl_linha := vl_linha || sc_arq.preencher(5,rg.cd_fem,'0',ALINHAMENTO_A_ESQUERDA);
       vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_filial,' ',ALINHAMENTO_A_DIREITA);
       vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_cpf_cnpj_cun,'0',ALINHAMENTO_A_ESQUERDA);

       tem_endereco := false;
       vl_cep := 0;
       vl_logradouro := ' ';
       vl_bairro := ' ';
       vl_localidade := ' ';
       vl_uf := ' ';
       vl_complemento := null;
       vl_numero := ' ';
       for rg_edr in select * 
                     from sc_cad.vw_edr edr 
                     where edr.cd_edr = rg.cd_edr loop
         tem_endereco := true;
         vl_linha := vl_linha || sc_arq.preencher(8,rg_edr.cep_edr,'0',ALINHAMENTO_A_ESQUERDA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.logradouro,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(5,rg_edr.nr_edr,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.cpl_edr,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.bairro,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.localidade,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(2,rg_edr.uf,' ',ALINHAMENTO_A_DIREITA);

         vl_cep := rg_edr.cep_edr;
	 vl_logradouro := rg_edr.logradouro;
	 vl_bairro := rg_edr.bairro;
	 vl_localidade := rg_edr.localidade;
	 vl_uf := rg_edr.uf;
	 vl_complemento := rg_edr.cpl_edr;
	 vl_numero := rg_edr.nr_edr;
       end loop;
       
       if not tem_endereco then
         vl_linha := vl_linha || sc_arq.preencher(8+60+5+60+60+60+2, ' ', ' ', ALINHAMENTO_A_DIREITA);
       end if;
       
       vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

       perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
       vl_nr_linha := vl_nr_linha + 1;
       vl_linha := '';

       vl_qtd_filial_arquivo := vl_qtd_filial_arquivo + 1;
       vl_qtd_filial_contrato := vl_qtd_filial_contrato + 1;

       select nextval('sc_ssp.sq_faep') into vl_codigo_faep;
       insert into sc_ssp.tbl_faep(cd_faep,cd_caep,cd_fem,ds_fem,cnpj_faep,cep_faep,log_faep,
                                   nr_end_faep,cpl_edr_faep,brr_edr_faep,loc_edr_faep,uf_edr_faep,cd_emp)
       values(vl_codigo_faep,vl_codigo_caep,rg.cd_fem,rg.nm_filial,rg.nr_cpf_cnpj_cun,
              vl_cep,vl_logradouro,vl_numero,vl_complemento,vl_bairro,vl_localidade,vl_uf,rg.cd_emp);

       -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE FILIAL XXXXXXXXXXXXXXXXXXXXXX
     end if;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INICIO LINHA DE DETALHE XXXXXXXXXXXXXXXXXX
     vl_trilha_1 := sc_ssp.gerar_trilha_1(rg.nm_pls);
     vl_trilha_2 := sc_ssp.gerar_trilha_2(rg.cd_pls,rg.dt_vld_pls,'S');

     vl_linha := '41'; -- Identificador de registro
     vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_func,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(40,rg.nm_pls,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || rg.cd_pls;
     vl_linha := vl_linha || to_char(rg.dt_vld_pls,'MM/YYYY');
     vl_linha := vl_linha || sc_arq.preencher(3,rg.nr_scc_pls,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(76,vl_trilha_1,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(37,vl_trilha_2,'0',ALINHAMENTO_A_DIREITA);

     
       vl_linha := vl_linha || sc_arq.preencher(4,0,'0',ALINHAMENTO_A_ESQUERDA);
     
     vl_linha := vl_linha || sc_arq.preencher(40,rg.msg_crt_ssp,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(11,rg.cpf_fnc,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_matricula,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || '00';
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     if (rg.tipo_entrega = 'EMPRESA') then
       vl_tipo_entrega = 'E';
     elsif(rg.tipo_entrega = 'FILIAL') then
       vl_tipo_entrega = 'F';
     elsif(rg.tipo_entrega = 'ADMINISTRADORA') then
       vl_tipo_entrega = 'A';
     else  
       vl_tipo_entrega = null;
     end if;

     if vp_ger_imediata then
       vl_tipo_entrega := 'U';
     end if;

     vl_linha := vl_linha || coalesce(vl_tipo_entrega,' ');
     


     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     insert into sc_ssp.tbl_daep(cd_daep,nm_func_daep,nm_pls_daep,cd_pls,dt_vld_daep,scc_daep,
                                 trl1_daep,trl2_daep,msg_crt_daep,cd_haep,cd_caep,cd_faep,cd_ssp,tp_etr_daep)
     VALUES(nextval('sc_ssp.sq_daep'),rg.nm_func,rg.nm_pls,rg.cd_pls,to_char(rg.dt_vld_pls,'MM/YYYY'),
            rg.nr_scc_pls, vl_trilha_1,vl_trilha_2,rg.msg_crt_ssp,
            vl_codigo_haep,vl_codigo_caep,vl_codigo_faep,rg.cd_ssp,vl_tipo_entrega);

     update sc_ssp.tbl_ssp set st_ssp = 2, dt_grc_ssp = now() where cd_ssp = rg.cd_ssp;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE DETALHE XXXXXXXXXXXXXXXXXX

     vl_qtd_detalhe_arquivo := vl_qtd_detalhe_arquivo + 1;
     vl_qtd_detalhe_filial := vl_qtd_detalhe_filial + 1;
     vl_qtd_detalhe_contrato := vl_qtd_detalhe_contrato + 1;
   end loop;

   if(vl_qtd_detalhe_arquivo > 0) then
     -- TRAILLER DE FILIAL
     vl_linha := '39';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE CONTRATO
     vl_linha := '29';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE ARQUIVO
     vl_linha := '19';
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_contrato_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

    -- atualizando quantidade de plasticos no header
    update sc_ssp.tbl_haep
       set qtd_pls_haep = vl_qtd_detalhe_arquivo
    where cd_haep = vl_codigo_haep;


   else
     perform sc_arq.excluirArquivo(vl_nome_arquivo);
   end if;
  end if;
  end loop;
exception
when others then
  perform sc_arq.excluirArquivo(vl_nome_arquivo); 
  RAISE EXCEPTION 'Problema na geração do arquivo de emissão de plastico. NUM:%, DETAILS:%, CPF:%', SQLSTATE, SQLERRM, rg.cpf_fnc || ' - ' || rg.nm_func;
end;
$$;


ALTER FUNCTION sc_ssp.gerar_arquivo_plastico_temp(vp_ger_imediata boolean, vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1594 (class 1255 OID 564594)
-- Name: gerar_arquivo_senha(boolean); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION gerar_arquivo_senha(vp_ger_imediata boolean DEFAULT false) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

  CD_PARAMETRO_CONTRATO_MODELO sc_cad.tbl_pce.cd_pce%type := 9;
  SITUACAO_SSP_CADASTRADA sc_ssp.tbl_ssp.st_ssp%type := 1;
  SITUACAO_SSP_EM_GERACAO_IMEDIATA sc_ssp.tbl_ssp.st_ssp%type := 4;
  TP_SSP_SENHA sc_ssp.tbl_ssp.tp_ssp%type := 2;

  ALINHAMENTO_A_ESQUERDA numeric(2,0) := 2;
  ALINHAMENTO_A_DIREITA numeric(2,0) := 1;

  PRM_DIRETORIO_ARQ_EMISSAO_PLS sc_cad.tbl_prm.nm_prm%type := 'DIR_ARQ_EMS_PLS';

  vl_diretorio varchar;

  vl_linha varchar;
  vl_nome_arquivo varchar;
  vl_nome_arquivo_aux varchar;

  vl_codigo_haep sc_ssp.tbl_haep.cd_haep%type;
  vl_codigo_caep sc_ssp.tbl_caep.cd_caep%type;
  vl_codigo_faep sc_ssp.tbl_faep.cd_faep%type;

  vl_cod_contrato_aux sc_cad.tbl_ctr.cd_ctr%type := 0;
  vl_cod_filial_aux sc_cad.tbl_fem.cd_fem%type := -1;

  vl_nr_linha numeric(5,0) := 1;

  vl_qtd_contrato_arquivo numeric(3,0) := 0;
  vl_qtd_filial_contrato numeric(3,0) := 0;
  vl_qtd_filial_arquivo numeric(3,0) := 0;
  vl_qtd_detalhe_filial numeric(5,0) := 0;
  vl_qtd_detalhe_contrato numeric(5,0) := 0;
  vl_qtd_detalhe_arquivo numeric(5,0) := 0;

  vl_prioridade_remessa varchar := 'S';

  vl_trilha_1 varchar;
  vl_trilha_2 varchar;

  rg record;
  rg_edr record;
  tem_endereco boolean;
  
  vl_cep sc_cad.vw_edr.cep_edr%type;
  vl_logradouro sc_cad.vw_edr.logradouro%type;
  vl_bairro sc_cad.vw_edr.bairro%type;
  vl_localidade sc_cad.vw_edr.localidade%type;
  vl_uf sc_cad.vw_edr.uf%type;
  vl_complemento sc_cad.vw_edr.cpl_edr%type;
  vl_numero sc_cad.vw_edr.nr_edr%type;
  
  vl_qnt_solicitacao numeric(5,0) := 0;

  vl_local_impressao_array text[];
  vl_local_impressao text;
  vl_tipo_entrega varchar;
begin

  -- locais de impressao
  select string_to_array(pce.lst_dad_pce, '@') 
    into vl_local_impressao_array
  from sc_cad.tbl_pce pce
  where pce.cd_pce = 16;

  for i in 1..array_length(vl_local_impressao_array,1) loop
    vl_local_impressao := vl_local_impressao_array[i];
    vl_qtd_detalhe_arquivo := 0;
 
  select count(*)
   into vl_qnt_solicitacao
  from sc_ssp.tbl_ssp ssp
    inner join sc_opr.tbl_pls pls on pls.cd_pls = ssp.cd_pls
    inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
    inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
    inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 16
  where 
    ((vp_ger_imediata = true and ssp.st_ssp = SITUACAO_SSP_EM_GERACAO_IMEDIATA) or 
    (vp_ger_imediata = false and ssp.st_ssp = SITUACAO_SSP_CADASTRADA))
    and ssp.tp_ssp = TP_SSP_SENHA
    and (ssp.dt_prv_grc_ssp <= now() or vp_ger_imediata = true)
    and pce_ctr.vl_pce_ctr = vl_local_impressao;

  if vl_qnt_solicitacao > 0 then
  -- Obtendo os parametros
  select replace(prm.vl_prm, 'PLASTICO', 'SENHA')
  into vl_diretorio
  from sc_cad.tbl_prm prm
  where prm.nm_prm = PRM_DIRETORIO_ARQ_EMISSAO_PLS;

  select nextval('sc_ssp.sq_haep') into vl_codigo_haep;

  vl_nome_arquivo := 'AES' || to_char(now(),'DDMMYYYY') || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA) || '.DAT';

  vl_nome_arquivo_aux := vl_nome_arquivo;

  vl_nome_arquivo := vl_diretorio || '/' || vl_nome_arquivo;

  -- XXXXXXXXXXXXXXXX GRAVANDO HEADER XXXXXXXXXXXXXXXXXXXXXXXXXX

  vl_linha := '11'; -- Identificador do registro de header
  vl_linha := vl_linha || '001'; -- Versão do layout
  vl_linha := vl_linha || to_char(now(),'DDMMYYYYHH24MISS'); -- Data da geracao
  vl_linha := vl_linha || sc_arq.preencher(6,vl_codigo_haep,'0',ALINHAMENTO_A_ESQUERDA); -- Código da remessa
  vl_linha := vl_linha || vl_prioridade_remessa; -- Prioridade da remessa
  vl_linha := vl_linha || sc_arq.preencher(6,'0','0',ALINHAMENTO_A_ESQUERDA); -- Codigo do arquivo (retorno)
  vl_linha := vl_linha || '00'; -- Retorno do processamento
  vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

  insert into sc_ssp.tbl_haep(cd_haep,vrs_haep,dt_grc_haep,nm_arq_haep,pri_haep,nm_dir_arq_haep, nm_ftp_imp_haep)
  values(vl_codigo_haep,1,now(),vl_nome_arquivo_aux,vl_prioridade_remessa,vl_diretorio, vl_local_impressao);

  perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
  vl_nr_linha := vl_nr_linha + 1;
  vl_linha := '';
  -- XXXXXXXXXXXXXXXXXXX FIM HEADER XXXXXXXXXXXXXXXXXXXXXXXXXXXX

  for rg in select crt.cd_ctr,fnc.cd_emp,emp.nm_emp,mpl.cd_mpl,fem.nm_fem,cun_func.nm_cun nm_func,
                   cun_filial.nr_cpf_cnpj_cun,ssp.cd_ssp,fem.nm_fem nm_filial, pls.nm_pls,
                   pls.dt_vld_pls,pls.nr_scc_pls,pls.nm_snh_pls,pls.cd_pls,fem.cd_fem,cun_func.nr_cpf_cnpj_cun cpf_fnc,
                   fnc.nr_idt_fnc nr_matricula, mpl.fg_snh_mpl,ssp.msg_crt_ssp,edr_ctr.cd_edr,pce_ctr_etr.vl_pce_ctr tipo_entrega
            from sc_ssp.tbl_ssp ssp
                 inner join sc_opr.tbl_pls pls on ssp.cd_pls = pls.cd_pls
                 inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
                 inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
                 inner join sc_cad.tbl_pce_ctr pce_ctr on pce_ctr.cd_ctr = ctr.cd_ctr and pce_ctr.cd_pce = 16
                 left  join sc_cad.tbl_pce_ctr pce_ctr_etr on pce_ctr_etr.cd_ctr = ctr.cd_ctr and pce_ctr_etr.cd_pce = 3
                 inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                 inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
                 inner join sc_cad.tbl_fem fem on fnc.cd_emp = fem.cd_emp and fnc.cd_fem = fem.cd_fem
                 inner join sc_cad.tbl_cun cun_filial on cun_filial.cd_cun = fem.cd_cun
                 inner join sc_cad.tbl_cun cun_func on cun_func.cd_cun = fnc.cd_cun
                 inner join sc_ssp.tbl_mpl mpl on mpl.cd_mpl = ctr.cd_mpl
                 inner join sc_cad.tbl_edr_ctr edr_ctr on edr_ctr.cd_ctr = ctr.cd_ctr and edr_ctr.tp_edr_ctr = 1 and edr_ctr.fg_atv_edr_ctr = 'S'
            where ((vp_ger_imediata = true and ssp.st_ssp = SITUACAO_SSP_EM_GERACAO_IMEDIATA) or (vp_ger_imediata = false and ssp.st_ssp = SITUACAO_SSP_CADASTRADA))
              and ssp.tp_ssp = TP_SSP_SENHA
              and (ssp.dt_prv_grc_ssp <= now() or vp_ger_imediata = true)
              and edr_ctr.tp_edr_ctr = 1
              and pce_ctr.vl_pce_ctr = vl_local_impressao
            order by crt.cd_ctr, fnc.cd_fem, nm_func, fnc.nr_idt_fnc loop

    if( vl_cod_filial_aux <> rg.cd_fem or vl_cod_contrato_aux <> rg.cd_ctr ) then
      if( vl_qtd_filial_contrato > 0 ) then
        -- TRAILLER DE FILIAL
        vl_linha := '39';
        vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_nr_linha := vl_nr_linha + 1;
        vl_linha := '';

        vl_qtd_detalhe_filial := 0;
        vl_qtd_filial_contrato := 0;
      end if;
    end if;

    if( vl_cod_contrato_aux <> rg.cd_ctr ) then
      vl_cod_filial_aux := -1;
      
      if( vl_qtd_contrato_arquivo > 0 ) then
        -- TRAILLER DE CONTRATO
        vl_linha := '29';
        vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(2,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
        vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
        vl_nr_linha := vl_nr_linha + 1;
        vl_linha := '';

        vl_qtd_filial_contrato := 0;
        vl_qtd_filial_contrato := 0;
        vl_qtd_detalhe_contrato := 0;
      end if;

      vl_cod_contrato_aux := rg.cd_ctr;
      -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE CONTRATO XXXXXXXXXXXXXXXX

      vl_linha := '21';-- Identificador de registro
      vl_linha := vl_linha || sc_arq.preencher(8,rg.cd_ctr,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do contrato
      vl_linha := vl_linha || sc_arq.preencher(5,rg.cd_emp,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo da empresa
      vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_emp,' ',ALINHAMENTO_A_DIREITA); -- Nome da empresa
      vl_linha := vl_linha || sc_arq.preencher(2,rg.cd_mpl,'0',ALINHAMENTO_A_ESQUERDA); -- Codigo do modelo de plastico
      vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

      perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
      vl_nr_linha := vl_nr_linha + 1;
      vl_linha := '';

      select nextval('sc_ssp.sq_caep') into vl_codigo_caep;
      
      insert into sc_ssp.tbl_caep(cd_caep,cd_haep,cd_ctr,cd_emp,ds_emp,cd_mpl)
      values(vl_codigo_caep,vl_codigo_haep,rg.cd_ctr,rg.cd_emp,rg.nm_emp,rg.cd_mpl);

      -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE CONTRATO XXXXXXXXXXXXXXXXXXXXXX
      vl_qtd_contrato_arquivo := vl_qtd_contrato_arquivo + 1;
    end if;

    if( vl_cod_filial_aux <> rg.cd_fem ) then
       vl_cod_filial_aux := rg.cd_fem;
       
       -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INSERINDO LINHA DE FILIAL XXXXXXXXXXXXXXXXXX
       vl_linha := '31'; -- Identificador de registro
       vl_linha := vl_linha || sc_arq.preencher(5,rg.cd_fem,'0',ALINHAMENTO_A_ESQUERDA);
       vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_filial,' ',ALINHAMENTO_A_DIREITA);
       vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_cpf_cnpj_cun,'0',ALINHAMENTO_A_ESQUERDA);

       tem_endereco := false;
       vl_cep := 0;
       vl_logradouro := ' ';
       vl_bairro := ' ';
       vl_localidade := ' ';
       vl_uf := ' ';
       vl_complemento := null;
       vl_numero := ' ';
       for rg_edr in select * 
                     from sc_cad.vw_edr edr 
                     where edr.cd_edr = rg.cd_edr loop
         tem_endereco := true;
         vl_linha := vl_linha || sc_arq.preencher(8,rg_edr.cep_edr,'0',ALINHAMENTO_A_ESQUERDA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.logradouro,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(5,rg_edr.nr_edr,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.cpl_edr,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.bairro,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(60,rg_edr.localidade,' ',ALINHAMENTO_A_DIREITA);
         vl_linha := vl_linha || sc_arq.preencher(2,rg_edr.uf,' ',ALINHAMENTO_A_DIREITA);

         vl_cep := rg_edr.cep_edr;
	 vl_logradouro := rg_edr.logradouro;
	 vl_bairro := rg_edr.bairro;
	 vl_localidade := rg_edr.localidade;
	 vl_uf := rg_edr.uf;
	 vl_complemento := rg_edr.cpl_edr;
	 vl_numero := rg_edr.nr_edr;
       end loop;
       
       if not tem_endereco then
         vl_linha := vl_linha || sc_arq.preencher(8+60+5+60+60+60+2, ' ', ' ', ALINHAMENTO_A_DIREITA);
       end if;
       
       vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA); -- Numero da linha

       perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
       vl_nr_linha := vl_nr_linha + 1;
       vl_linha := '';

       vl_qtd_filial_arquivo := vl_qtd_filial_arquivo + 1;
       vl_qtd_filial_contrato := vl_qtd_filial_contrato + 1;

       select nextval('sc_ssp.sq_faep') into vl_codigo_faep;
       insert into sc_ssp.tbl_faep(cd_faep,cd_caep,cd_fem,ds_fem,cnpj_faep,cep_faep,log_faep,
                                   nr_end_faep,cpl_edr_faep,brr_edr_faep,loc_edr_faep,uf_edr_faep,cd_emp)
       values(vl_codigo_faep,vl_codigo_caep,rg.cd_fem,rg.nm_filial,rg.nr_cpf_cnpj_cun,
              vl_cep,vl_logradouro,vl_numero,vl_complemento,vl_bairro,vl_localidade,vl_uf,rg.cd_emp);

       -- XXXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE FILIAL XXXXXXXXXXXXXXXXXXXXXX
     end if;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX INICIO LINHA DE DETALHE XXXXXXXXXXXXXXXXXX
     vl_trilha_1 := sc_ssp.gerar_trilha_1(rg.nm_pls);
     vl_trilha_2 := sc_ssp.gerar_trilha_2(rg.cd_pls,rg.dt_vld_pls,'S');

     vl_linha := '41'; -- Identificador de registro
     vl_linha := vl_linha || sc_arq.preencher(50,rg.nm_func,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(40,rg.nm_pls,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || rg.cd_pls;
     vl_linha := vl_linha || to_char(rg.dt_vld_pls,'MM/YYYY');
     vl_linha := vl_linha || sc_arq.preencher(3,rg.nr_scc_pls,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(76,vl_trilha_1,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(37,vl_trilha_2,'0',ALINHAMENTO_A_DIREITA);

     if(rg.fg_snh_mpl = 'S') then
          vl_linha := vl_linha || sc_arq.preencher(4,((rg.nm_snh_pls::integer)::numeric),'0',ALINHAMENTO_A_ESQUERDA);
       update sc_opr.tbl_pls set nm_snh_pls = md5(rg.nm_snh_pls) where cd_pls = rg.cd_pls;
     else
       vl_linha := vl_linha || sc_arq.preencher(4,0,'0',ALINHAMENTO_A_ESQUERDA);
     end if;

     vl_linha := vl_linha || sc_arq.preencher(40,rg.msg_crt_ssp,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || sc_arq.preencher(11,rg.cpf_fnc,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(14,rg.nr_matricula,' ',ALINHAMENTO_A_DIREITA);
     vl_linha := vl_linha || '00';
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);


     if (rg.tipo_entrega = 'EMPRESA') then
       vl_tipo_entrega = 'E';
     elsif(rg.tipo_entrega = 'FILIAL') then
       vl_tipo_entrega = 'F';
     elsif(rg.tipo_entrega = 'ADMINISTRADORA') then
       vl_tipo_entrega = 'A';
     else  
       vl_tipo_entrega = null;
     end if;

     if vp_ger_imediata then
       vl_tipo_entrega := 'U';
     end if;

     vl_linha := vl_linha || coalesce(vl_tipo_entrega,' ');


     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     insert into sc_ssp.tbl_daep(cd_daep,nm_func_daep,nm_pls_daep,cd_pls,dt_vld_daep,scc_daep,
                                 trl1_daep,trl2_daep,msg_crt_daep,cd_haep,cd_caep,cd_faep,cd_ssp,tp_etr_daep)
     VALUES(nextval('sc_ssp.sq_daep'),rg.nm_func,rg.nm_pls,rg.cd_pls,to_char(rg.dt_vld_pls,'MM/YYYY'),
            rg.nr_scc_pls, vl_trilha_1,vl_trilha_2,rg.msg_crt_ssp,
            vl_codigo_haep,vl_codigo_caep,vl_codigo_faep,rg.cd_ssp,vl_tipo_entrega);

     update sc_ssp.tbl_ssp set st_ssp = 2, dt_grc_ssp = now() where cd_ssp = rg.cd_ssp;

     -- XXXXXXXXXXXXXXXXXXXXXXXXXXX FIM LINHA DE DETALHE XXXXXXXXXXXXXXXXXX

     vl_qtd_detalhe_arquivo := vl_qtd_detalhe_arquivo + 1;
     vl_qtd_detalhe_filial := vl_qtd_detalhe_filial + 1;
     vl_qtd_detalhe_contrato := vl_qtd_detalhe_contrato + 1;
   end loop;

   if(vl_qtd_detalhe_arquivo > 0) then
     -- TRAILLER DE FILIAL
     vl_linha := '39';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_cod_filial_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_filial,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE CONTRATO
     vl_linha := '29';
     vl_linha := vl_linha || sc_arq.preencher(8,vl_cod_contrato_aux,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_contrato,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

     -- TRAILLER DE ARQUIVO
     vl_linha := '19';
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_contrato_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(3,vl_qtd_filial_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_qtd_detalhe_arquivo,'0',ALINHAMENTO_A_ESQUERDA);
     vl_linha := vl_linha || sc_arq.preencher(5,vl_nr_linha,'0',ALINHAMENTO_A_ESQUERDA);

     perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
     vl_nr_linha := vl_nr_linha + 1;
     vl_linha := '';

    -- atualizando quantidade de plasticos no header
    update sc_ssp.tbl_haep
       set qtd_pls_haep = vl_qtd_detalhe_arquivo
    where cd_haep = vl_codigo_haep;


   else
     perform sc_arq.excluirArquivo(vl_nome_arquivo);
   end if;
  end if;
  end loop;
exception
when others then
  perform sc_arq.excluirArquivo(vl_nome_arquivo); 
  RAISE EXCEPTION 'Problema na geração do arquivo de emissão de senha. NUM:%, DETAILS:%, CPF:%', SQLSTATE, SQLERRM, vl_trilha_2;
end;
$$;


ALTER FUNCTION sc_ssp.gerar_arquivo_senha(vp_ger_imediata boolean) OWNER TO scan;

--
-- TOC entry 1417 (class 1255 OID 564597)
-- Name: gerar_trilha_1(character varying); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION gerar_trilha_1(vp_nome_cartao character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  vl_trilha varchar;
  vl_trilhat varchar;
  vl_ultima_posicao numeric;
  vl_nome_final varchar;
begin

   vl_trilhat := upper(vp_nome_cartao);
   vl_trilha := 'A';
   
   vl_ultima_posicao := instr(vl_trilhat,' ', -1);

   if vl_ultima_posicao = 0 then
     raise exception 'nome inválido de cartão: %', vp_nome_cartao;
   end if;
   
   vl_nome_final := vl_trilha ||
                    substr(vl_trilhat::text,(vl_ultima_posicao + 1)::integer,length(vl_trilhat)::integer) ||
                    '/' ||
                    substr(vl_trilhat::text,1,(vl_ultima_posicao-1)::integer) || '=';
                    
   return vl_nome_final;
  
end
$$;


ALTER FUNCTION sc_ssp.gerar_trilha_1(vp_nome_cartao character varying) OWNER TO scan;

--
-- TOC entry 1416 (class 1255 OID 564598)
-- Name: gerar_trilha_2(numeric, timestamp without time zone, character varying); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION gerar_trilha_2(vp_codigo_plastico numeric, vp_dt_vnc_plastico timestamp without time zone, vp_fg_titular character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare
  vl_data_formatada varchar;
  vl_trilha_retorno varchar;
begin
  
  vl_data_formatada := to_char(vp_dt_vnc_plastico,'MMYY');
  vl_trilha_retorno := vp_codigo_plastico || '=';
  vl_trilha_retorno := vl_trilha_retorno || vl_data_formatada;
  
  if (vp_fg_titular = 'S') then
     vl_trilha_retorno := vl_trilha_retorno || vl_data_formatada || '1';
  else
     vl_trilha_retorno := vl_trilha_retorno || vl_data_formatada || '0';   
  end if;   
  
  vl_trilha_retorno := vl_trilha_retorno || vl_data_formatada || '1';   
  return vl_trilha_retorno;
end
$$;


ALTER FUNCTION sc_ssp.gerar_trilha_2(vp_codigo_plastico numeric, vp_dt_vnc_plastico timestamp without time zone, vp_fg_titular character varying) OWNER TO scan;

--
-- TOC entry 1854 (class 1255 OID 998439)
-- Name: reemitir_modelo_soma_tmp(numeric); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION reemitir_modelo_soma_tmp(vp_empresa numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  vl_ultimo_plastico numeric;
  vl_senha varchar;
begin
  for rg in select distinct crt.cd_crt
            from sc_opr.tbl_crt crt 
              --inner join sc_opr.tbl_pls pls on pls.cd_crt = crt.cd_crt
              inner join sc_adp.tbl_rdp rdp on rdp.cd_crt = crt.cd_crt
              inner join sc_adp.tbl_hfe hfe on hfe.cd_hfe = rdp.cd_hfe
              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
              inner join sc_cad.tbl_emp emp on emp.cd_emp = fnc.cd_emp
              inner join sc_cad.tbl_fem fem on fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
            where hfe.dt_dps_hfe > current_date - 45 
              and crt.fg_atv_crt = 'S'
              and fem.fg_emt_crt_fem = 'S'
              and emp.cd_gem not in (366,315,532,533)
              and fnc.cd_emp = vp_empresa
              and rdp.cd_tdp <> 5
              and not exists(select 1 
                         from sc_opr.tbl_pls p 
                         where p.cd_crt = crt.cd_crt 
                           and substr(p.cd_pls::varchar,1,6) = '605868')



  /*select *
            from sc_opr.tbl_pls pls
              inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
            where pls.fg_blq_pls = 'N'
              and crt.fg_atv_crt = 'S'
              and fnc.cd_emp = vp_empresa
              and pls.cd_mpl = 1
              and exists(select 1 
                         from sc_opr.tbl_opr o 
                           inner join sc_opr.tbl_pls p on p.cd_pls = o.cd_pls
                         where p.cd_crt = pls.cd_crt 
                           and o.cd_top = 4 
                           and o.dt_opr > current_date - 90)
              and pls.dt_inc_usr = (select max(dt_inc_usr) from sc_opr.tbl_pls p2 where p2.cd_crt = pls.cd_crt)*/ loop

      vl_ultimo_plastico := null;
      select cd_pls,nm_snh_pls
        into vl_ultimo_plastico,vl_senha
      from sc_opr.tbl_pls
      where cd_crt = rg.cd_crt
        and fg_blq_pls = 'N'
        and dt_inc_usr =(select max(dt_inc_usr) from sc_opr.tbl_pls where cd_crt = rg.cd_crt);
        
     if vl_ultimo_plastico is not null then
      perform sc_opr.emitir_segunda_via_cartao_temp(vl_ultimo_plastico,null,1,'PROJETO REEMISSAO NOVO MODELO PLASTICO','N',1);
      update sc_opr.tbl_pls set nm_snh_pls = vl_senha,fg_blq_pls='N',cd_tbl=null where cd_pls = (select cd_pls from sc_opr.tbl_pls where dt_inc_usr>=current_date and cd_crt = rg.cd_crt);
      update sc_sgr.tbl_ucc set cd_pls = null where cd_pls = vl_ultimo_plastico;
    end if;  
      
              
  end loop;   

  perform sc_ssp.gerar_arquivo_plastico_temp(true,vp_empresa);       
end$$;


ALTER FUNCTION sc_ssp.reemitir_modelo_soma_tmp(vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1858 (class 1255 OID 564599)
-- Name: solicitar_emissao_plastico_senha(); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION solicitar_emissao_plastico_senha() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

   rg record;
   TP_SSP_PLASTICO sc_ssp.tbl_ssp.tp_ssp%type := 1;
   TP_SSP_SENHA    sc_ssp.tbl_ssp.tp_ssp%type := 2;
   
   SITUACAO_SSP_CADASTRADA sc_ssp.tbl_ssp.st_ssp%type := 1;
   
   vl_fg_ems_pls sc_opr.tbl_pls.fg_ems_pls%type;
   vl_fg_ems_snh sc_opr.tbl_pls.fg_ems_snh%type;
   
begin

  for rg in select pls.fg_ems_pls,
                   pls.fg_ems_snh,
                   pls.cd_pls,
                   pls.cd_mpl,
                   mpl.fg_snh_mpl,
                   crt.cd_ctr
            from sc_opr.tbl_pls pls
              inner join sc_ssp.tbl_mpl mpl on mpl.cd_mpl = pls.cd_mpl
              inner join sc_opr.tbl_crt crt on crt.cd_crt = pls.cd_crt
            where (pls.fg_ems_pls = 'N'
               or pls.fg_ems_snh = 'N') loop
     
     if( rg.fg_ems_pls = 'N' )  then

     
         insert into sc_ssp.tbl_ssp(cd_ssp,cd_pls,tp_ssp,st_ssp,cd_mpl,msg_crt_ssp,dt_prv_grc_ssp,
                                    dt_grc_ssp,dt_inc_usr)
                    values(nextval('sc_ssp.sq_ssp'),rg.cd_pls,TP_SSP_PLASTICO,SITUACAO_SSP_CADASTRADA,
                          rg.cd_mpl,sc_cad.get_parametro_contrato(45, rg.cd_Ctr, null),(now() + interval '1 day'),NULL,now());

                            
     end if;
     
    if( rg.fg_ems_snh = 'N' and rg.fg_snh_mpl = 'N')  then
     
         insert into sc_ssp.tbl_ssp(cd_ssp,cd_pls,tp_ssp,st_ssp,cd_mpl,msg_crt_ssp,dt_prv_grc_ssp,
                                    dt_grc_ssp,dt_inc_usr)
                    values(nextval('sc_ssp.sq_ssp'),rg.cd_pls,TP_SSP_SENHA,SITUACAO_SSP_CADASTRADA,
                          rg.cd_mpl,null,(now() + interval '1 day'),NULL,now());
                            
     end if;
     
     update sc_opr.tbl_pls 
     set fg_ems_pls = 'S',
         fg_ems_snh = 'S'
     where cd_pls = rg.cd_pls;
               
  end loop;             
  
end
$$;


ALTER FUNCTION sc_ssp.solicitar_emissao_plastico_senha() OWNER TO scan;

--
-- TOC entry 1707 (class 1255 OID 1004570)
-- Name: solicitar_emissao_plastico_senha_operador(numeric); Type: FUNCTION; Schema: sc_ssp; Owner: scan
--

CREATE FUNCTION solicitar_emissao_plastico_senha_operador(vp_plastico numeric DEFAULT NULL::numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

   rg record;
   TP_SSP_PLASTICO sc_ssp.tbl_ssp.tp_ssp%type := 1;
   TP_SSP_SENHA    sc_ssp.tbl_ssp.tp_ssp%type := 2;
   
   SITUACAO_SSP_CADASTRADA sc_ssp.tbl_ssp.st_ssp%type := 1;
   
   vl_fg_ems_pls sc_rds.tbl_pop.fg_ems_pop%type;
   vl_fg_ems_snh sc_rds.tbl_pop.fg_snh_pop%type;
   
begin

  for rg in select pop.fg_ems_pop,
                   pop.fg_snh_pop,
                   pop.cd_pop,
                   pop.cd_mpl,
                   mpl.fg_snh_mpl
            from sc_rds.tbl_pop pop
              inner join sc_ssp.tbl_mpl mpl on mpl.cd_mpl = pop.cd_mpl
            where pop.cd_pop = coalesce(vp_plastico,pop.cd_pop) 
                 and (pop.fg_ems_pop = 'N'
                      or pop.fg_snh_pop = 'N') loop
     
     if( rg.fg_ems_pop = 'N' )  then
     
         insert into sc_ssp.tbl_ssp(cd_ssp,cd_pop,tp_ssp,st_ssp,cd_mpl,msg_crt_ssp,dt_prv_grc_ssp,
                                    dt_grc_ssp,dt_inc_usr)
                    values(nextval('sc_ssp.sq_ssp'),rg.cd_pop,TP_SSP_PLASTICO,SITUACAO_SSP_CADASTRADA,
                          rg.cd_mpl,null,(now() + interval '1 day'),NULL,now());

                            
     end if;
     
    if( rg.fg_snh_pop = 'N' and rg.fg_snh_mpl = 'N')  then
     
         insert into sc_ssp.tbl_ssp(cd_ssp,cd_pop,tp_ssp,st_ssp,cd_mpl,msg_crt_ssp,dt_prv_grc_ssp,
                                    dt_grc_ssp,dt_inc_usr)
                    values(nextval('sc_ssp.sq_ssp'),rg.cd_pop,TP_SSP_SENHA,SITUACAO_SSP_CADASTRADA,
                          rg.cd_mpl,null,(now() + interval '1 day'),NULL,now());
                            
     end if;
     
     update sc_rds.tbl_pop 
     set fg_ems_pop = 'S',
         fg_snh_pop = 'S'
     where cd_pop = rg.cd_pop;
               
  end loop;             
  
end
$$;


ALTER FUNCTION sc_ssp.solicitar_emissao_plastico_senha_operador(vp_plastico numeric) OWNER TO scan;

SET search_path = sc_svg, pg_catalog;

--
-- TOC entry 1752 (class 1255 OID 1077655)
-- Name: atualizar_processo_seguro_em_grupo(); Type: FUNCTION; Schema: sc_svg; Owner: scan
--

CREATE FUNCTION atualizar_processo_seguro_em_grupo() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

  vl_existe numeric;
  
begin

  -- verifica se existe inconsistencia entre o contrato e a seguradora
  -- caso a segurado tenha sido alterada no contrato a mesma deve ser atualizada no seguro
  select count(*)
    into vl_existe 
  from sc_srv.tbl_sgr sgr
    inner join sc_svg.tbl_csg csg on csg.cd_csg = sgr.cd_csg
  where sgr.cd_sga <> csg.cd_sga; 

  if vl_existe > 0 then

    update sc_srv.tbl_sgr sgr set cd_sga = csg.cd_sga
      from sc_svg.tbl_csg csg 
    where sgr.cd_csg = csg.cd_csg
      and sgr.cd_sga <> csg.cd_sga;

  end if;    


  -- executar as rotinas de cancelamento
  perform sc_svg.cancelar_seguro_funcionario_demitido();
  perform sc_svg.cancelar_seguro_funcionario_transferido();


end$$;


ALTER FUNCTION sc_svg.atualizar_processo_seguro_em_grupo() OWNER TO scan;

--
-- TOC entry 1644 (class 1255 OID 564601)
-- Name: cancelar_seguro_funcionario_demitido(); Type: FUNCTION; Schema: sc_svg; Owner: postgres
--

CREATE FUNCTION cancelar_seguro_funcionario_demitido() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  rg record;
  ST_SEGURO_VIGENTE numeric := 3;
  ST_SEGURO_CANCELADO numeric := 4;
  ST_FUNCIONARIO_DEMITIDO numeric := 2;

  TIPO_OCORRENCIA_SEGURO_CANCELAR numeric := 3;
begin
  for rg in select sgr.cd_sgr
            from sc_srv.tbl_sgr sgr
              inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc
            where fnc.st_fnc = ST_FUNCIONARIO_DEMITIDO
              and sgr.st_sgr = ST_SEGURO_VIGENTE loop

    update sc_srv.tbl_sgr set st_sgr=ST_SEGURO_CANCELADO, cd_cnc_usr = 1, dt_cnc_sgr = now(), dt_vig_fim_sgr = now(), ds_mtv_cnc_sgr = 'FUNCIONARIO DEMITIDO' where cd_sgr = rg.cd_sgr;

    --Cadastrando ocorrencia
    insert into sc_svg.tbl_osg(cd_osg,cd_tos,cd_sgr,cd_inc_usr,dt_inc_usr,ds_osg) 
       values(nextval('sc_svg.sq_osg'),TIPO_OCORRENCIA_SEGURO_CANCELAR,rg.cd_sgr,1,now(),'CANCELAMENTO DE SEGURO: FUNCIONARIO DEMITIDO');

  end loop;
end$$;


ALTER FUNCTION sc_svg.cancelar_seguro_funcionario_demitido() OWNER TO postgres;

--
-- TOC entry 1727 (class 1255 OID 564602)
-- Name: cancelar_seguro_funcionario_transferido(); Type: FUNCTION; Schema: sc_svg; Owner: scan
--

CREATE FUNCTION cancelar_seguro_funcionario_transferido() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   rg record;

   TIPO_OCORRENCIA_CANCELAMENTO_SEGURO numeric := 3;
   ST_SEGURO_VIGENTE numeric := 3;
   ST_SEGURO_CANCELADO numeric := 4;

   vl_cod_seguro numeric;

   vl_cod_contrato numeric;
begin

     for rg in select sgr.cd_sgr, fnc.cd_emp, fnc.cd_fem
               from sc_srv.tbl_sgr sgr
                 inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc
               where not exists(select 1 
                                from sc_svg.tbl_fem_csg fem
                                where fem.cd_csg = sgr.cd_csg
                                  and fem.cd_emp = fnc.cd_emp
                                  and fem.cd_fem = fnc.cd_fem
				  and fem.fg_atv_fem_csg = 'S')
                 and st_sgr = ST_SEGURO_VIGENTE loop              

           -- verifica se funcionario foi transferido para uma empresa onde o contrato de seguro e diferente do atual
           -- em caso afirmativo atualiza o codigo do contrato

           select coalesce(csg.cd_csg,0)
             into vl_cod_contrato
           from sc_svg.tbl_csg csg
             inner join sc_svg.tbl_fem_csg fem on fem.cd_csg = csg.cd_csg
           where csg.fg_atv_csg = 'S'
             and csg.cd_emp = rg.cd_emp
             and fem.cd_fem = rg.cd_fem
             and fem.fg_atv_fem_csg = 'S';
          
           if vl_cod_contrato > 0 then
                       
             update sc_srv.tbl_sgr set cd_csg = vl_cod_contrato where cd_sgr = rg.cd_sgr;
 
           else
  
	     update sc_srv.tbl_sgr set st_sgr = ST_SEGURO_CANCELADO, cd_cnc_usr = 1, dt_cnc_sgr = now(), dt_vig_fim_sgr = now(), ds_mtv_cnc_sgr = 'ALTERACAO NO CONTRATO. FILIAL FORA DO CONTRATO' where cd_sgr = rg.cd_sgr;
           		
             insert into sc_svg.tbl_osg(cd_osg,cd_tos,cd_sgr,cd_inc_usr,dt_inc_usr,ds_osg) 
                  values(nextval('sc_svg.sq_osg'),TIPO_OCORRENCIA_CANCELAMENTO_SEGURO,rg.cd_sgr,1,now(),'CANCELAMENTO POR ALTERACAO DE CONTRATO DE SEGURO. FILIAL FORA DO CONTRATO');

           end if;              

                 
     end loop; 


     for rg in select sgr.cd_fnc, count(sgr.cd_sgr)
               from sc_srv.tbl_sgr sgr
                 inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc
                 inner join sc_svg.tbl_csg csg on csg.cd_csg = sgr.cd_csg
                where sgr.st_sgr = ST_SEGURO_VIGENTE
                  and csg.fg_atv_csg = 'S'
                group by sgr.cd_fnc
                having count(sgr.cd_sgr) > 1 loop              

           select cd_sgr 
             into vl_cod_seguro
             from sc_srv.tbl_sgr 
           where cd_fnc = rg.cd_fnc 
             and dt_vig_ini_sgr = (select min(dt_vig_ini_sgr) from sc_srv.tbl_sgr where cd_fnc = rg.cd_fnc);
           
           if vl_cod_seguro is not null then
               update sc_srv.tbl_sgr set st_sgr = ST_SEGURO_CANCELADO, cd_cnc_usr = 1, dt_cnc_sgr = now(), dt_vig_fim_sgr = now(), ds_mtv_cnc_sgr = 'ALTERACAO NO CONTRATO. FUNCIONARIO DUPLICADO' where cd_sgr = vl_cod_seguro;

                          insert into sc_svg.tbl_osg(cd_osg,cd_tos,cd_sgr,cd_inc_usr,dt_inc_usr,ds_osg) 
              values(nextval('sc_svg.sq_osg'),TIPO_OCORRENCIA_CANCELAMENTO_SEGURO,vl_cod_seguro,1,now(),'CANCELAMENTO POR ALTERACAO DE CONTRATO DE SEGURO. FUNCIONARIO DUPLICADO');

           end if;
            
     end loop;             

end$$;


ALTER FUNCTION sc_svg.cancelar_seguro_funcionario_transferido() OWNER TO scan;

--
-- TOC entry 1485 (class 1255 OID 564603)
-- Name: gerar_arquivo_cotacao(numeric); Type: FUNCTION; Schema: sc_svg; Owner: scan
--

CREATE FUNCTION gerar_arquivo_cotacao(vp_empresa numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  SITUACAO_VIGENTE numeric := 3;
  PRM_DIRETORIO_ARQUIVO VARCHAR := 'NM_DIR_ARQ_RMS_SEGURO_GRUPO';
  CT_TP_ARQ_COTACAO_SEGURO numeric := 5;
  CT_SIT_ARQ_GERADO numeric := 1;
  vl_nome_arquivo varchar;
  vl_nm_arquivo varchar;
  vl_nome_empresa varchar;
  vl_diretorio varchar;
  vl_linha varchar;
  vl_flag_empresa varchar;
  vl_qtde numeric := 0;
  vl_codigo_arquivo numeric;
BEGIN

    select split_part(nm_emp, ' ', 1) || CASE WHEN split_part(nm_emp, ' ', 2) != '' THEN '_' || split_part(nm_emp, ' ', 2) ELSE '' END, fg_atv_emp
      into vl_nome_empresa, vl_flag_empresa
    from sc_cad.tbl_emp
    where cd_emp = vp_empresa;

    if vl_flag_empresa = 'N' then
      raise 'Não é possível gerar o arquivo de cotação pois a empresa encontra-se INATIVA';
    end if;

    select count(distinct fnc.cd_fnc)
      into vl_qtde
    from sc_opr.tbl_crt crt
	inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
    where crt.fg_atv_crt = 'S' 
      and fnc.cd_emp = vp_empresa;

    if vl_qtde = 0 then
      raise 'Não foi possível gerar o arquivo de cotação pois não existe nenhum funcionário ativo para esta empresa';
    end if;

    select nextval('sc_dwn.sq_dwa') 
      into vl_codigo_arquivo;
    
    select prm.vl_prm
      into vl_diretorio
    from sc_cad.tbl_prm prm
    where prm.nm_prm = PRM_DIRETORIO_ARQUIVO;
    
    vl_nm_arquivo := 'COT_' ||vp_empresa || '_' || vl_nome_empresa || '_' || to_char(current_date,'ddmmyyyy') || '_' || vl_codigo_arquivo || '.csv';
    vl_nome_arquivo := vl_diretorio || '/' || vl_nm_arquivo;
    
    vl_linha := 'NOME_SEGURADO;DATA_NASCIMENTO;CPF';
    
    perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
    
    for rg in select cun.nm_cun,
                     cpf.dt_nsc_cpf,
                     cun.nr_cpf_cnpj_cun
              from sc_opr.tbl_crt crt
                inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = crt.cd_fnc
                inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
                left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
              where crt.fg_atv_crt = 'S' 
                and fnc.cd_emp = vp_empresa 
    loop
         
         vl_linha := rg.nm_cun;
         vl_linha := vl_linha || ';';
         if(rg.dt_nsc_cpf is not null) then
	         vl_linha := vl_linha || to_char(rg.dt_nsc_cpf,'dd/mm/yyyy');
         end if;    
         
         vl_linha := vl_linha || ';';
         vl_linha := vl_linha || rg.nr_cpf_cnpj_cun;     
         
         perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);           
    end loop;

    --inserindo registro na tabela de download
    insert into sc_dwn.tbl_dwa values (vl_codigo_arquivo, vl_nm_arquivo, now(), current_date, CT_TP_ARQ_COTACAO_SEGURO, CT_SIT_ARQ_GERADO);
         
    return vl_nm_arquivo;             
END;
$$;


ALTER FUNCTION sc_svg.gerar_arquivo_cotacao(vp_empresa numeric) OWNER TO scan;

--
-- TOC entry 1869 (class 1255 OID 564604)
-- Name: gerar_arquivo_remessa(character varying); Type: FUNCTION; Schema: sc_svg; Owner: scan
--

CREATE FUNCTION gerar_arquivo_remessa(mes_ref character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   rg record;
   vl_mes_ref varchar;

   ct_seguradora_previsul numeric:= 3;
   ct_seguradora_ace numeric:= 4;
   ct_seguradora_pan_seguros numeric:= 5;
   ct_seguradora_metlife numeric:= 6;
   
begin
  if to_char(current_date, 'dd') = '01' then
     
     -- so ira gerar o arquivo de remessa quando for o dia 01 de cada mês
     for rg in  select csg.cd_csg, csg.cd_sga, null as cd_fem
		from sc_svg.tbl_csg csg
	        where csg.fg_atv_csg = 'S'
	          and csg.fg_fat_fem_csg = 'N'
	        UNION ALL 
	        select csg.cd_csg, csg.cd_sga, fem.cd_fem
		from sc_svg.tbl_csg csg
		  inner join sc_svg.tbl_fem_csg fem on fem.cd_csg = csg.cd_csg  
	        where csg.fg_atv_csg = 'S'
	          and csg.fg_fat_fem_csg = 'S'
	          AND fem.fg_atv_fem_csg = 'S'
	        order by cd_csg, cd_fem	       
     loop
        if mes_ref is null then
          select to_char(current_date, 'MM/YYYY') into vl_mes_ref;
        else
          vl_mes_ref := mes_ref;
        end if;

        if rg.cd_sga = ct_seguradora_previsul then
          perform sc_svg.gerar_arquivo_remessa_empresa_previsul(rg.cd_csg, vl_mes_ref, rg.cd_fem);   
        elsif rg.cd_sga = ct_seguradora_pan_seguros then
          perform sc_svg.gerar_arquivo_remessa_empresa_pan_seguros(rg.cd_csg, vl_mes_ref, rg.cd_fem);
        elsif rg.cd_sga = ct_seguradora_ace then
          perform sc_svg.gerar_arquivo_remessa_empresa_ace(rg.cd_csg, vl_mes_ref, rg.cd_fem);    
        elsif rg.cd_sga = ct_seguradora_metlife then
          perform sc_svg.gerar_arquivo_remessa_empresa_metlife(rg.cd_csg, vl_mes_ref, rg.cd_fem);    
        else
          perform sc_svg.gerar_arquivo_remessa_empresa_mapfre(rg.cd_csg, vl_mes_ref, rg.cd_fem);   
        end if;
        
     end loop;          
     
  end if;
end$$;


ALTER FUNCTION sc_svg.gerar_arquivo_remessa(mes_ref character varying) OWNER TO scan;

--
-- TOC entry 1776 (class 1255 OID 902578)
-- Name: gerar_arquivo_remessa_empresa_ace(numeric, character varying, numeric); Type: FUNCTION; Schema: sc_svg; Owner: scan
--

CREATE FUNCTION gerar_arquivo_remessa_empresa_ace(vp_contrato numeric, vp_mes_ref character varying, vp_filial numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  vl_rg_edr sc_cad.vw_edr%rowtype;
  vl_rg_tlf sc_cad.tbl_tlf%rowtype;
  
  SITUACAO_VIGENTE numeric := 3;
  SITUACAO_CANCELADO numeric := 4;
  PRM_DIRETORIO_ARQUIVO VARCHAR := 'NM_DIR_ARQ_RMS_SEGURO_GRUPO';
  CT_TP_ARQ_REMESSA_SEGURO numeric := 6;
  CT_SIT_ARQ_GERADO numeric := 1;
  SITUACAO_ARQUIVO_CADASTRADO numeric := 1;
  vl_nome_arquivo varchar;
  vl_nm_arquivo varchar;
  vl_diretorio varchar;
  vl_linha varchar;
  vl_qtde numeric := 0;

  vl_data_inicio_vigencia date;
  vl_data_fim_vigencia date;
  vl_nome_empresa_split varchar;
  vl_nome_empresa varchar;
  vl_codigo_arquivo numeric;
  vl_contrato_seguradora varchar;
  vl_apolice varchar;
  vl_codigo_empresa numeric;
  vl_cnpj_empresa numeric;
  vl_nome_filial varchar;

  vl_nome_seguradora varchar;
  
BEGIN

    vl_data_inicio_vigencia := to_date('01/' || vp_mes_ref,'dd/mm/yyyy');
    vl_data_fim_vigencia := vl_data_inicio_vigencia + interval '1 month';
    vl_data_fim_vigencia := vl_data_fim_vigencia - interval '1day';
    
    -- verificando se tem funcionario vigente para gerar o arquivo de remessa
    select count(distinct cun.nm_cun)
      into vl_qtde
    from sc_srv.tbl_sgr sgr
        inner join sc_svg.tbl_fem_csg fem on fem.cd_csg = sgr.cd_csg and fem.fg_atv_fem_csg = 'S'
	inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc and fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
	inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
    where sgr.cd_csg = vp_contrato
      and sgr.st_sgr in (SITUACAO_VIGENTE, SITUACAO_CANCELADO)
      and sgr.dt_vig_ini_sgr < vl_data_inicio_vigencia
      and (sgr.dt_vig_fim_sgr > vl_data_inicio_vigencia or sgr.dt_vig_fim_sgr is null)
      and fnc.cd_fem = coalesce(vp_filial,fnc.cd_fem);

    if vl_qtde > 0 then  

        select nextval('sc_dwn.sq_dwa') into vl_codigo_arquivo;
        
        select prm.vl_prm
	  into vl_diretorio
        from sc_cad.tbl_prm prm
        where prm.nm_prm = PRM_DIRETORIO_ARQUIVO;

        select nm_emp, split_part(nm_emp, ' ', 1) || CASE WHEN split_part(nm_emp, ' ', 2) != '' THEN '_' || split_part(nm_emp, ' ', 2) ELSE '' END, emp.cd_emp,
               sga.ds_sga, COALESCE(cd_ctr_sga_csg, ''), csg.nr_apl_sga_csg,
               split_part(nm_fem, ' ', 1) || CASE WHEN split_part(nm_fem, ' ', 2) != '' THEN '_' || split_part(nm_fem, ' ', 2) ELSE '' END
          into vl_nome_empresa, vl_nome_empresa_split, vl_codigo_empresa, 
               vl_nome_seguradora, vl_contrato_seguradora, vl_apolice,
               vl_nome_filial
	from sc_svg.tbl_csg csg
	  inner join sc_svg.tbl_fem_csg f on f.cd_csg = csg.cd_csg and f.fg_atv_fem_csg = 'S'
	  inner join sc_cad.tbl_emp emp on emp.cd_emp = csg.cd_emp
	  inner join sc_srv.tbl_sga sga on sga.cd_sga = csg.cd_sga
	  inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp and fem.cd_fem = f.cd_fem
	where csg.cd_csg = vp_contrato
	and ((vp_filial is not null and fem.cd_fem = vp_filial) or (vp_filial is null and fem.cd_fem = (select min(cd_fem) from sc_svg.tbl_fem_csg where cd_csg = csg.cd_csg and fg_atv_fem_csg = 'S')));

        select cun.nr_cpf_cnpj_cun
          into vl_cnpj_empresa
        from sc_cad.tbl_emp emp
        inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp
        inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
        where emp.cd_emp = vl_codigo_empresa
          and fem.fg_mtz_fem = 'S'
          AND fem.cd_fem = coalesce(vp_filial, fem.cd_fem);

        if vl_cnpj_empresa is null then

          select cun.nr_cpf_cnpj_cun
            into vl_cnpj_empresa
          from sc_cad.tbl_emp emp
            inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp
            inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
          where emp.cd_emp = vl_codigo_empresa
            and fem.cd_fem = (select min(cd_fem) from sc_cad.tbl_fem where cd_emp = vl_codigo_empresa);
            
        end if;

        vl_nome_filial := coalesce(vl_nome_filial,'');

        if length(vl_nome_filial) > 0 then
           vl_nome_filial := '-' || vl_nome_filial;
        end if;
	    
        vl_nm_arquivo := vl_nome_seguradora || '_' || vl_contrato_seguradora || '_' || vl_nome_empresa_split || '_' || replace(vp_mes_ref, '/', '') || vl_nome_filial || '.csv';
        vl_nome_arquivo := vl_diretorio || '/' || vl_nm_arquivo;


        insert into sc_svg.tbl_ars(cd_ars,nm_ars,cd_csg,dt_inc_usr,cd_inc_usr,st_ars,qtd_ars,mes_ars)
           values(nextval('sc_svg.sq_ars'),vl_nm_arquivo,vp_contrato,now(),1,SITUACAO_ARQUIVO_CADASTRADO,vl_qtde,vp_mes_ref);


        vl_linha := 'Nome*;CPF*;Data de Nascimento*;Salário*;Capital*;Ativos / Afastados;CID;Data do Afastamento;Sexo*';
	perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
	    
	for rg in select cun.cd_cun,
	                    cun.nm_cun,
			     cpf.dt_nsc_cpf,
			     cpf.sexo_cpf,
			     trim(TO_CHAR(cun.nr_cpf_cnpj_cun, '00000000000')) as nr_cpf_cnpj_cun,
			     sgr.cd_sgr,
			     sgr.vl_rnd_mes_sgr,
			     sgr.ds_pfs_sgr
		  from sc_srv.tbl_sgr sgr
			inner join sc_svg.tbl_fem_csg fem on fem.cd_csg = sgr.cd_csg and fem.fg_atv_fem_csg = 'S'
	                inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc and fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
			inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
			left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
		  where sgr.cd_csg = vp_contrato
			and sgr.st_sgr in (SITUACAO_VIGENTE, SITUACAO_CANCELADO)
			and sgr.dt_vig_ini_sgr < vl_data_inicio_vigencia
			and (sgr.dt_vig_fim_sgr > vl_data_inicio_vigencia or sgr.dt_vig_fim_sgr is null)
			and fnc.cd_fem = coalesce(vp_filial, fnc.cd_fem)  
	loop
			
           
           --nome
	   vl_linha := sc_pbl.sem_acento(rg.nm_cun);
	   vl_linha := vl_linha || ';';

           --cpf
           vl_linha := vl_linha || rg.nr_cpf_cnpj_cun;
           vl_linha := vl_linha || ';';

          --data de nascimento     
	   if(rg.dt_nsc_cpf is not null) then
		 vl_linha := vl_linha || to_char(rg.dt_nsc_cpf,'dd/mm/yyyy');
	   end if;    
	   vl_linha := vl_linha || ';';

          -- salario
          if rg.vl_rnd_mes_sgr is null then
            vl_linha := vl_linha || ';';
          else
            vl_linha := vl_linha || sc_pbl.valor_formato_ptbr(rg.vl_rnd_mes_sgr);
            vl_linha := vl_linha || ';';
          end if;

           --capital
	   vl_linha := vl_linha || '32.500,00';
	   vl_linha := vl_linha || ';';

	   -- ativos; CID; Data do Afastamento
           vl_linha := vl_linha || ';;;';

           --sexo
	   vl_linha := vl_linha || rg.sexo_cpf;
	   vl_linha := vl_linha || ';';

           perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

	   insert into sc_svg.tbl_drs(cd_drs,cd_sgr,dt_inc_usr,cd_inc_usr,cd_ars)
	   values(nextval('sc_svg.sq_drs'),rg.cd_sgr,now(),1,currval('sc_svg.sq_ars'));
	end loop;

	--inserindo registro na tabela de download
        insert into sc_dwn.tbl_dwa values (vl_codigo_arquivo, vl_nm_arquivo, now(), current_date, CT_TP_ARQ_REMESSA_SEGURO, CT_SIT_ARQ_GERADO);
    end if;
END;
$$;


ALTER FUNCTION sc_svg.gerar_arquivo_remessa_empresa_ace(vp_contrato numeric, vp_mes_ref character varying, vp_filial numeric) OWNER TO scan;

--
-- TOC entry 1777 (class 1255 OID 902577)
-- Name: gerar_arquivo_remessa_empresa_mapfre(numeric, character varying, numeric); Type: FUNCTION; Schema: sc_svg; Owner: scan
--

CREATE FUNCTION gerar_arquivo_remessa_empresa_mapfre(vp_contrato numeric, vp_mes_ref character varying, vp_filial numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  SITUACAO_VIGENTE numeric := 3;
  SITUACAO_CANCELADO numeric := 4;
  
  PRM_DIRETORIO_ARQUIVO VARCHAR := 'NM_DIR_ARQ_RMS_SEGURO_GRUPO';
  CT_TP_ARQ_REMESSA_SEGURO numeric := 6;
  CT_SIT_ARQ_GERADO numeric := 1;
  SITUACAO_ARQUIVO_CADASTRADO numeric := 1;
  vl_nome_arquivo varchar;
  vl_nm_arquivo varchar;
  vl_diretorio varchar;
  vl_linha varchar;
  vl_qtde numeric := 0;

  vl_data_inicio_vigencia date;
  vl_data_ini_vigencia DATE;
  vl_data_fim_vigencia DATE;
  vl_nome_empresa varchar;
  vl_codigo_arquivo numeric;
  vl_contrato_seguradora varchar;
  vl_nome_filial varchar;

  vl_nome_seguradora varchar;
  
BEGIN

    vl_data_inicio_vigencia := to_date('01/' || vp_mes_ref,'dd/mm/yyyy');
    vl_data_ini_vigencia := vl_data_inicio_vigencia + interval '1 month' * -1;
    vl_data_fim_vigencia := vl_data_ini_vigencia + interval '1 month';
    vl_data_fim_vigencia := vl_data_fim_vigencia - interval '1day';
    
    -- verificando se tem funcionario vigente para gerar o arquivo de remessa
    select count(distinct cun.nm_cun)
      into vl_qtde
    from sc_srv.tbl_sgr sgr
        inner join sc_svg.tbl_fem_csg fem on fem.cd_csg = sgr.cd_csg and fem.fg_atv_fem_csg = 'S'
	inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc and fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
	inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
    where sgr.cd_csg = vp_contrato
      and sgr.st_sgr in (SITUACAO_VIGENTE,SITUACAO_CANCELADO)
      and sgr.dt_vig_ini_sgr < vl_data_inicio_vigencia
      and (sgr.dt_vig_fim_sgr > vl_data_inicio_vigencia or sgr.dt_vig_fim_sgr is null)
      and fnc.cd_fem = coalesce(vp_filial,fnc.cd_fem);

    if vl_qtde > 0 then  

        select nextval('sc_dwn.sq_dwa') into vl_codigo_arquivo;
        
        select prm.vl_prm
	  into vl_diretorio
        from sc_cad.tbl_prm prm
        where prm.nm_prm = PRM_DIRETORIO_ARQUIVO;

        select split_part(nm_emp, ' ', 1) || CASE WHEN split_part(nm_emp, ' ', 2) != '' THEN '_' || split_part(nm_emp, ' ', 2) ELSE '' END,
               sga.ds_sga, COALESCE(cd_ctr_sga_csg, ''),
               split_part(nm_fem, ' ', 1) || CASE WHEN split_part(nm_fem, ' ', 2) != '' THEN '_' || split_part(nm_fem, ' ', 2) ELSE '' END
          into vl_nome_empresa,
               vl_nome_seguradora, vl_contrato_seguradora,
               vl_nome_filial
	from sc_svg.tbl_csg csg
	  inner join sc_svg.tbl_fem_csg f on f.cd_csg = csg.cd_csg and f.fg_atv_fem_csg = 'S'
	  inner join sc_cad.tbl_emp emp on emp.cd_emp = csg.cd_emp
	  inner join sc_srv.tbl_sga sga on sga.cd_sga = csg.cd_sga
	  inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp and fem.cd_fem = f.cd_fem
	where csg.cd_csg = vp_contrato
	and ((vp_filial is not null and fem.cd_fem = vp_filial) or (vp_filial is null and fem.cd_fem = (select min(cd_fem) from sc_svg.tbl_fem_csg where cd_csg = csg.cd_csg and fg_atv_fem_csg = 'S')));

        vl_nome_filial := coalesce(vl_nome_filial,'');

        if length(vl_nome_filial) > 0 then
           vl_nome_filial := '-' || vl_nome_filial;
        end if;
	    
        vl_nm_arquivo := vl_nome_empresa || '_' || vl_contrato_seguradora || '_' || replace(vp_mes_ref, '/', '') || vl_nome_filial || '_' || vl_qtde || 'vidas.csv';
        vl_nome_arquivo := vl_diretorio || '/' || vl_nm_arquivo;


        insert into sc_svg.tbl_ars(cd_ars,nm_ars,cd_csg,dt_inc_usr,cd_inc_usr,st_ars,qtd_ars,mes_ars)
           values(nextval('sc_svg.sq_ars'),vl_nm_arquivo,vp_contrato,now(),1,SITUACAO_ARQUIVO_CADASTRADO,vl_qtde,vp_mes_ref);
	    
	vl_linha := 'NOME_SEGURADO;DATA_NASCIMENTO;VALOR IS;CPF;SEXO;CARGO;SALARIO;INICIO DE VIGENCIA;FIM DE VIGENCIA;MATRICULA;PREMIO;CERTIFICADO;';
	
	perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
	    
	for rg in select cun.nm_cun,
			     cpf.dt_nsc_cpf,
			     cpf.sexo_cpf,
			     cun.nr_cpf_cnpj_cun,
			     sgr.cd_sgr,
			     sgr.vl_rnd_mes_sgr,
			     sgr.ds_pfs_sgr,
			     sgr.vl_sgr,
			     csg.nr_apl_sga_csg,
			     fnc.nr_idt_fnc
		  from sc_srv.tbl_sgr sgr
                        inner join sc_svg.tbl_csg csg on csg.cd_csg = sgr.cd_csg
                        inner join sc_svg.tbl_fem_csg fem on fem.cd_csg = csg.cd_csg and fem.fg_atv_fem_csg = 'S'
	                inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc and fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
			inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
			left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
		  where sgr.cd_csg = vp_contrato
			and sgr.st_sgr in (SITUACAO_VIGENTE, SITUACAO_CANCELADO)
			and sgr.dt_vig_ini_sgr < vl_data_inicio_vigencia 
			and (sgr.dt_vig_fim_sgr > vl_data_inicio_vigencia or sgr.dt_vig_fim_sgr is null)
			and fnc.cd_fem = coalesce(vp_filial, fnc.cd_fem)
	loop
			
           -- campo NOME DO SEGURADO
	   vl_linha := rg.nm_cun;
	   vl_linha := vl_linha || ';';

           -- campo DATA DO NASCIMENTO
	   if(rg.dt_nsc_cpf is not null) then
		 vl_linha := vl_linha || to_char(rg.dt_nsc_cpf,'dd/mm/yyyy');
	   end if;
	   vl_linha := vl_linha || ';';    

           -- campo VALOR IS
           vl_linha := vl_linha || '38.316,40';
           vl_linha := vl_linha || ';';
		 
           -- campo CPF
	   vl_linha := vl_linha || rg.nr_cpf_cnpj_cun;     
	   vl_linha := vl_linha || ';';

	   -- campo SEXO
	   vl_linha := vl_linha || rg.sexo_cpf;     
	   vl_linha := vl_linha || ';';

           -- campo CARGO
           if rg.ds_pfs_sgr is NOT null then
              --vl_linha := vl_linha || rg.ds_pfs_sgr;
           end if;
           vl_linha := vl_linha || ';'; 

           -- campo SALARIO
           if rg.vl_rnd_mes_sgr is NOT null then
             --vl_linha := vl_linha || sc_pbl.valor_formato_ptbr(rg.vl_rnd_mes_sgr);
           end if;
           vl_linha := vl_linha || ';';

           -- campo INICO VIGENCIA
	   vl_linha := vl_linha || to_char(vl_data_ini_vigencia,'dd/mm/yyyy');
	   vl_linha := vl_linha || ';';

	   -- campo FIM VIGENCIA
     	   --vl_linha := vl_linha || to_char(vl_data_fim_vigencia,'dd/mm/yyyy');
	   vl_linha := vl_linha || ';';

           -- campo MATRICULA
           --vl_linha := vl_linha || rg.nr_idt_fnc;
	   vl_linha := vl_linha || ';';
          
           -- campo PREMIO
           if rg.vl_sgr is NOT null then
             --vl_linha := vl_linha || sc_pbl.valor_formato_ptbr(rg.vl_sgr);
           end if;
           vl_linha := vl_linha || ';';

           -- campo CERTIFICADO
           if rg.nr_apl_sga_csg is NOT null then
             --vl_linha := vl_linha || rg.nr_apl_sga_csg;
           END IF;
           vl_linha := vl_linha || ';';
	     	 
	   perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

	   insert into sc_svg.tbl_drs(cd_drs,cd_sgr,dt_inc_usr,cd_inc_usr,cd_ars)
	   values(nextval('sc_svg.sq_drs'),rg.cd_sgr,now(),1,currval('sc_svg.sq_ars'));
	end loop;

	--inserindo registro na tabela de download
        insert into sc_dwn.tbl_dwa values (vl_codigo_arquivo, vl_nm_arquivo, now(), current_date, CT_TP_ARQ_REMESSA_SEGURO, CT_SIT_ARQ_GERADO);
    end if;
END;
$$;


ALTER FUNCTION sc_svg.gerar_arquivo_remessa_empresa_mapfre(vp_contrato numeric, vp_mes_ref character varying, vp_filial numeric) OWNER TO scan;

--
-- TOC entry 1754 (class 1255 OID 1029702)
-- Name: gerar_arquivo_remessa_empresa_metlife(numeric, character varying, numeric); Type: FUNCTION; Schema: sc_svg; Owner: scan
--

CREATE FUNCTION gerar_arquivo_remessa_empresa_metlife(vp_contrato numeric, vp_mes_ref character varying, vp_filial numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  vl_rg_edr sc_cad.vw_edr%rowtype;
  vl_rg_tlf sc_cad.tbl_tlf%rowtype;
  
  SITUACAO_VIGENTE numeric := 3;
  SITUACAO_CANCELADO numeric := 4;
  PRM_DIRETORIO_ARQUIVO VARCHAR := 'NM_DIR_ARQ_RMS_SEGURO_GRUPO';
  CT_TP_ARQ_REMESSA_SEGURO numeric := 6;
  CT_SIT_ARQ_GERADO numeric := 1;
  SITUACAO_ARQUIVO_CADASTRADO numeric := 1;
  vl_nome_arquivo varchar;
  vl_nm_arquivo varchar;
  vl_diretorio varchar;
  vl_linha varchar;
  vl_qtde numeric := 0;

  vl_data_inicio_vigencia date;
  vl_data_fim_vigencia date;
  vl_nome_empresa_split varchar;
  vl_nome_empresa varchar;
  vl_codigo_arquivo numeric;
  vl_contrato_seguradora varchar;
  vl_apolice varchar;
  vl_digito_apolice varchar;
  vl_codigo_empresa numeric;
  vl_cnpj_empresa numeric;
  vl_nome_filial varchar;

  vl_nome_seguradora varchar;
  
BEGIN

    vl_data_inicio_vigencia := to_date('01/' || vp_mes_ref,'dd/mm/yyyy');
    vl_data_fim_vigencia := vl_data_inicio_vigencia + interval '1 month';
    vl_data_fim_vigencia := vl_data_fim_vigencia - interval '1day';
    
    -- verificando se tem funcionario vigente para gerar o arquivo de remessa
    select count(distinct cun.nm_cun)
      into vl_qtde
    from sc_srv.tbl_sgr sgr
	inner join sc_svg.tbl_fem_csg fem on fem.cd_csg = sgr.cd_csg and fem.fg_atv_fem_csg = 'S'
	inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc and fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
	inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
    where sgr.cd_csg = vp_contrato
      and sgr.st_sgr in (SITUACAO_VIGENTE, SITUACAO_CANCELADO)
      and sgr.dt_vig_ini_sgr < vl_data_inicio_vigencia
      and (sgr.dt_vig_fim_sgr > vl_data_inicio_vigencia or sgr.dt_vig_fim_sgr is null)
      and fnc.cd_fem = coalesce(vp_filial,fnc.cd_fem);

    if vl_qtde > 0 then  

        select nextval('sc_dwn.sq_dwa') into vl_codigo_arquivo;
        
        select prm.vl_prm
	  into vl_diretorio
        from sc_cad.tbl_prm prm
        where prm.nm_prm = PRM_DIRETORIO_ARQUIVO;

        select nm_emp, split_part(nm_emp, ' ', 1) || CASE WHEN split_part(nm_emp, ' ', 2) != '' THEN '_' || split_part(nm_emp, ' ', 2) ELSE '' END, emp.cd_emp,
               sga.ds_sga, COALESCE(cd_ctr_sga_csg, ''), csg.nr_apl_sga_csg, f.dg_apl_fem_csg,  
               --split_part(nm_fem, ' ', 1) || CASE WHEN split_part(nm_fem, ' ', 2) != '' THEN '_' || split_part(nm_fem, ' ', 2) ELSE '' END
               nm_fem
          into vl_nome_empresa, vl_nome_empresa_split, vl_codigo_empresa, 
               vl_nome_seguradora, vl_contrato_seguradora, vl_apolice, vl_digito_apolice,
               vl_nome_filial
	from sc_svg.tbl_csg csg
	  inner join sc_svg.tbl_fem_csg f on f.cd_csg = csg.cd_csg and f.fg_atv_fem_csg = 'S'
	  inner join sc_cad.tbl_emp emp on emp.cd_emp = csg.cd_emp
	  inner join sc_srv.tbl_sga sga on sga.cd_sga = csg.cd_sga
	  inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp and fem.cd_fem = f.cd_fem
	where csg.cd_csg = vp_contrato
	and ((vp_filial is not null and fem.cd_fem = vp_filial) or (vp_filial is null and fem.cd_fem = (select min(cd_fem) from sc_svg.tbl_fem_csg where cd_csg = csg.cd_csg and fg_atv_fem_csg = 'S')));

        vl_nome_filial := coalesce(vl_nome_filial,'');

        if length(vl_nome_filial) > 0 then
           vl_nome_filial := '-' || vl_nome_filial;
        end if;

        select cun.nr_cpf_cnpj_cun
          into vl_cnpj_empresa
        from sc_cad.tbl_emp emp
        inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp
        inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
        where emp.cd_emp = vl_codigo_empresa
          and fem.fg_mtz_fem = 'S'
          AND fem.cd_fem = coalesce(vp_filial, fem.cd_fem);

        if vl_cnpj_empresa is null then

          select cun.nr_cpf_cnpj_cun
            into vl_cnpj_empresa
          from sc_cad.tbl_emp emp
            inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp
            inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
          where emp.cd_emp = vl_codigo_empresa
            and fem.cd_fem = (select min(cd_fem) from sc_cad.tbl_fem where cd_emp = vl_codigo_empresa);
            
        end if;

        
        vl_nm_arquivo := vl_nome_seguradora || '_' || vl_nome_empresa_split || '_' || replace(vp_mes_ref, '/', '') || '_' || vl_qtde || 'vidas.csv';
        vl_nome_arquivo := vl_diretorio || '/' || vl_nm_arquivo;


        insert into sc_svg.tbl_ars(cd_ars,nm_ars,cd_csg,dt_inc_usr,cd_inc_usr,st_ars,qtd_ars,mes_ars)
           values(nextval('sc_svg.sq_ars'),vl_nm_arquivo,vp_contrato,now(),1,SITUACAO_ARQUIVO_CADASTRADO,vl_qtde,vp_mes_ref);

        --vl_linha := 'tpmvto;NR_MATRICULA;NOME;SEXO;CPF;NASCIMENTO;CAPITAL;PREMIO;VIGENCIA;FIM_VIG;ENDERECO;BAIRRO;CIDADE;ESTADO;CEP';
        vl_linha := 'NOME;CPF;NASCIMENTO;SALARIO;CAPITAL;PLANO;NEGOCIACAO';
	perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
	    
	for rg in select cun.cd_cun,
	                    cun.nm_cun,
			     cpf.dt_nsc_cpf,
			     cpf.sexo_cpf,
			     cun.nr_cpf_cnpj_cun,
			     sgr.cd_sgr,
			     sgr.vl_sgr,
			     sgr.ds_pfs_sgr,
			     sgr.vl_rnd_mes_sgr,
			     fnc.dt_adm_fnc
		  from sc_srv.tbl_sgr sgr
			inner join sc_svg.tbl_fem_csg fem on fem.cd_csg = sgr.cd_csg and fem.fg_atv_fem_csg = 'S'
	                inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc and fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
			inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
			left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
		  where sgr.cd_csg = vp_contrato
			and sgr.st_sgr in (SITUACAO_VIGENTE, SITUACAO_CANCELADO)
			and sgr.dt_vig_ini_sgr < vl_data_inicio_vigencia
			and (sgr.dt_vig_fim_sgr > vl_data_inicio_vigencia or sgr.dt_vig_fim_sgr is null) 
			and fnc.cd_fem = coalesce(vp_filial, fnc.cd_fem)
	loop
			
           vl_linha := '';
           -- tpmvto (NAO PREENCHER)
           --vl_linha := ';';

           --nome
	   vl_linha := vl_linha || sc_pbl.sem_acento(rg.nm_cun);
	   vl_linha := vl_linha || ';';

           --nr_matricula
           --vl_linha := vl_linha || trim(TO_CHAR(rg.nr_cpf_cnpj_cun, '00000000000'));
           --vl_linha := vl_linha || ';';

           --sexo
	   --vl_linha := vl_linha || rg.sexo_cpf;
	   --vl_linha := vl_linha || ';';

           --cpf
           vl_linha := vl_linha || trim(TO_CHAR(rg.nr_cpf_cnpj_cun, '00000000000'));
           vl_linha := vl_linha || ';';

           --data de nascimento     
	   if(rg.dt_nsc_cpf is not null) then
		 vl_linha := vl_linha || to_char(rg.dt_nsc_cpf,'dd/mm/yyyy');
	   end if;    
	   vl_linha := vl_linha || ';';

           -- salario
           if rg.vl_rnd_mes_sgr is null then
             vl_linha := vl_linha || ';';
           else
             vl_linha := vl_linha || sc_pbl.valor_formato_ptbr(rg.vl_rnd_mes_sgr);
             vl_linha := vl_linha || ';';
           end if;

           -- capital e plano
           vl_linha := vl_linha || ';;';

	   -- premio
           --vl_linha := vl_linha || sc_pbl.valor_formato_ptbr(rg.vl_sgr);
           --vl_linha := vl_linha || ';';

           -- vigencia inicial
	   --vl_linha := vl_linha || to_char(vl_data_inicio_vigencia,'dd/mm/yyyy');
	   --vl_linha := vl_linha || ';';

	   -- vigencia final
     	   --vl_linha := vl_linha || to_char(vl_data_fim_vigencia,'dd/mm/yyyy');
	   --vl_linha := vl_linha || ';';

           -- endereco
           /*select *
           into vl_rg_edr
           from sc_aeo.get_endereco(rg.cd_cun);

           if vl_rg_edr is null then
              vl_linha := vl_linha || ';;;;;';
           else
              vl_linha := vl_linha || vl_rg_edr.logradouro || ', ' || vl_rg_edr.nr_edr || coalesce(vl_rg_edr.cpl_edr,' - ') || coalesce(vl_rg_edr.cpl_edr,'');
              vl_linha := vl_linha || ';';

              vl_linha := vl_linha || vl_rg_edr.bairro;
              vl_linha := vl_linha || ';';

              vl_linha := vl_linha || vl_rg_edr.localidade;
              vl_linha := vl_linha || ';';

              vl_linha := vl_linha || vl_rg_edr.uf;
              vl_linha := vl_linha || ';';

              vl_linha := vl_linha || vl_rg_edr.cep_edr;
           end if;
           */

           perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

	   insert into sc_svg.tbl_drs(cd_drs,cd_sgr,dt_inc_usr,cd_inc_usr,cd_ars)
	   values(nextval('sc_svg.sq_drs'),rg.cd_sgr,now(),1,currval('sc_svg.sq_ars'));
	end loop;

	--inserindo registro na tabela de download
        insert into sc_dwn.tbl_dwa values (vl_codigo_arquivo, vl_nm_arquivo, now(), current_date, CT_TP_ARQ_REMESSA_SEGURO, CT_SIT_ARQ_GERADO);
    end if;
END;
$$;


ALTER FUNCTION sc_svg.gerar_arquivo_remessa_empresa_metlife(vp_contrato numeric, vp_mes_ref character varying, vp_filial numeric) OWNER TO scan;

--
-- TOC entry 1775 (class 1255 OID 902581)
-- Name: gerar_arquivo_remessa_empresa_pan_seguros(numeric, character varying, numeric); Type: FUNCTION; Schema: sc_svg; Owner: scan
--

CREATE FUNCTION gerar_arquivo_remessa_empresa_pan_seguros(vp_contrato numeric, vp_mes_ref character varying, vp_filial numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  vl_rg_edr sc_cad.vw_edr%rowtype;
  vl_rg_tlf sc_cad.tbl_tlf%rowtype;
  
  SITUACAO_VIGENTE numeric := 3;
  SITUACAO_CANCELADO numeric := 4;
  PRM_DIRETORIO_ARQUIVO VARCHAR := 'NM_DIR_ARQ_RMS_SEGURO_GRUPO';
  CT_TP_ARQ_REMESSA_SEGURO numeric := 6;
  CT_SIT_ARQ_GERADO numeric := 1;
  SITUACAO_ARQUIVO_CADASTRADO numeric := 1;
  vl_nome_arquivo varchar;
  vl_nm_arquivo varchar;
  vl_diretorio varchar;
  vl_linha varchar;
  vl_qtde numeric := 0;

  vl_data_inicio_vigencia date;
  vl_data_fim_vigencia date;
  vl_nome_empresa_split varchar;
  vl_nome_empresa varchar;
  vl_codigo_arquivo numeric;
  vl_contrato_seguradora varchar;
  vl_apolice varchar;
  vl_digito_apolice varchar;
  vl_codigo_empresa numeric;
  vl_cnpj_empresa numeric;
  vl_nome_filial varchar;

  vl_nome_seguradora varchar;
  
BEGIN

    vl_data_inicio_vigencia := to_date('01/' || vp_mes_ref,'dd/mm/yyyy');
    vl_data_fim_vigencia := vl_data_inicio_vigencia + interval '1 month';
    vl_data_fim_vigencia := vl_data_fim_vigencia - interval '1day';
    
    -- verificando se tem funcionario vigente para gerar o arquivo de remessa
    select count(distinct cun.nm_cun)
      into vl_qtde
    from sc_srv.tbl_sgr sgr
        inner join sc_svg.tbl_fem_csg fem on fem.cd_csg = sgr.cd_csg and fem.fg_atv_fem_csg = 'S'
	inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc and fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
	inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
    where sgr.cd_csg = vp_contrato
      and sgr.st_sgr in (SITUACAO_VIGENTE, SITUACAO_CANCELADO)
      and sgr.dt_vig_ini_sgr < vl_data_inicio_vigencia
      and (sgr.dt_vig_fim_sgr > vl_data_inicio_vigencia or sgr.dt_vig_fim_sgr is null)
      and fnc.cd_fem = coalesce(vp_filial,fnc.cd_fem);

    if vl_qtde > 0 then  

        select nextval('sc_dwn.sq_dwa') into vl_codigo_arquivo;
        
        select prm.vl_prm
	  into vl_diretorio
        from sc_cad.tbl_prm prm
        where prm.nm_prm = PRM_DIRETORIO_ARQUIVO;

        select nm_emp, split_part(nm_emp, ' ', 1) || CASE WHEN split_part(nm_emp, ' ', 2) != '' THEN '_' || split_part(nm_emp, ' ', 2) ELSE '' END, emp.cd_emp,
               sga.ds_sga, COALESCE(cd_ctr_sga_csg, ''), csg.nr_apl_sga_csg, f.dg_apl_fem_csg,  
               --split_part(nm_fem, ' ', 1) || CASE WHEN split_part(nm_fem, ' ', 2) != '' THEN '_' || split_part(nm_fem, ' ', 2) ELSE '' END
               nm_fem
          into vl_nome_empresa, vl_nome_empresa_split, vl_codigo_empresa, 
               vl_nome_seguradora, vl_contrato_seguradora, vl_apolice, vl_digito_apolice,
               vl_nome_filial
	from sc_svg.tbl_csg csg
	  inner join sc_svg.tbl_fem_csg f on f.cd_csg = csg.cd_csg and f.fg_atv_fem_csg = 'S'
	  inner join sc_cad.tbl_emp emp on emp.cd_emp = csg.cd_emp
	  inner join sc_srv.tbl_sga sga on sga.cd_sga = csg.cd_sga
	  inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp and fem.cd_fem = f.cd_fem
	where csg.cd_csg = vp_contrato
	and ((vp_filial is not null and fem.cd_fem = vp_filial) or (vp_filial is null and fem.cd_fem = (select min(cd_fem) from sc_svg.tbl_fem_csg where cd_csg = csg.cd_csg and fg_atv_fem_csg = 'S')));


        vl_nome_filial := coalesce(vl_nome_filial,'');

        if length(vl_nome_filial) > 0 then
           vl_nome_filial := '-' || vl_nome_filial;
        end if;

        select cun.nr_cpf_cnpj_cun
          into vl_cnpj_empresa
        from sc_cad.tbl_emp emp
        inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp
        inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
        where emp.cd_emp = vl_codigo_empresa
          and fem.fg_mtz_fem = 'S'
          AND fem.cd_fem = coalesce(vp_filial, fem.cd_fem);

        if vl_cnpj_empresa is null then

          select cun.nr_cpf_cnpj_cun
            into vl_cnpj_empresa
          from sc_cad.tbl_emp emp
            inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp
            inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
          where emp.cd_emp = vl_codigo_empresa
            and fem.cd_fem = (select min(cd_fem) from sc_cad.tbl_fem where cd_emp = vl_codigo_empresa);
            
        end if;

        if vl_digito_apolice is not null then
          vl_nm_arquivo := vl_nome_seguradora || '_' || vl_apolice || '.' || vl_digito_apolice || '_' || vl_nome_empresa_split || '_' || replace(vp_mes_ref, '/', '') || vl_nome_filial || '_' || vl_cnpj_empresa || '.csv';
        else
          vl_nm_arquivo := vl_nome_seguradora || '_' || vl_apolice || '_' || vl_nome_empresa_split || '_' || replace(vp_mes_ref, '/', '') || vl_nome_filial || '_' || vl_cnpj_empresa || '.csv';
        end if;

        vl_nome_arquivo := vl_diretorio || '/' || vl_nm_arquivo;


        insert into sc_svg.tbl_ars(cd_ars,nm_ars,cd_csg,dt_inc_usr,cd_inc_usr,st_ars,qtd_ars,mes_ars)
           values(nextval('sc_svg.sq_ars'),vl_nm_arquivo,vp_contrato,now(),1,SITUACAO_ARQUIVO_CADASTRADO,vl_qtde,vp_mes_ref);

        --vl_linha := 'tpmvto;NR_MATRICULA;NOME;SEXO;CPF;NASCIMENTO;CAPITAL;PREMIO;VIGENCIA;FIM_VIG;ENDERECO;BAIRRO;CIDADE;ESTADO;CEP';
        vl_linha := 'NR_MATRICULA;NOME;SEXO;CPF;NASCIMENTO;ADMISSAO;CARGO;CAPITAL';
	perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
	    
	for rg in select cun.cd_cun,
	                    cun.nm_cun,
			     cpf.dt_nsc_cpf,
			     cpf.sexo_cpf,
			     cun.nr_cpf_cnpj_cun,
			     sgr.cd_sgr,
			     sgr.vl_sgr,
			     sgr.ds_pfs_sgr,
			     fnc.dt_adm_fnc
		  from sc_srv.tbl_sgr sgr
			inner join sc_svg.tbl_fem_csg fem on fem.cd_csg = sgr.cd_csg and fem.fg_atv_fem_csg = 'S'
	                inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc and fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
			inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
			left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
		  where sgr.cd_csg = vp_contrato
			and sgr.st_sgr in (SITUACAO_VIGENTE, SITUACAO_CANCELADO)
			and sgr.dt_vig_ini_sgr < vl_data_inicio_vigencia
			and (sgr.dt_vig_fim_sgr > vl_data_inicio_vigencia or sgr.dt_vig_fim_sgr is null) 
			and fnc.cd_fem = coalesce(vp_filial, fnc.cd_fem)
	loop
			
           vl_linha := '';
           -- tpmvto (NAO PREENCHER)
           --vl_linha := ';';

           --nr_matricula
           vl_linha := vl_linha || trim(TO_CHAR(rg.nr_cpf_cnpj_cun, '00000000000'));
           vl_linha := vl_linha || ';';

           --nome
	   vl_linha := vl_linha || sc_pbl.sem_acento(rg.nm_cun);
	   vl_linha := vl_linha || ';';

           --sexo
	   vl_linha := vl_linha || rg.sexo_cpf;
	   vl_linha := vl_linha || ';';

           --cpf
           vl_linha := vl_linha || trim(TO_CHAR(rg.nr_cpf_cnpj_cun, '00000000000'));
           vl_linha := vl_linha || ';';

           --data de nascimento     
	   if(rg.dt_nsc_cpf is not null) then
		 vl_linha := vl_linha || to_char(rg.dt_nsc_cpf,'dd/mm/yyyy');
	   end if;    
	   vl_linha := vl_linha || ';';

           --data de admissao    
	   if(rg.dt_adm_fnc is not null) then
		 vl_linha := vl_linha || to_char(rg.dt_adm_fnc,'dd/mm/yyyy');
	   end if;    
	   vl_linha := vl_linha || ';';

           --profissao
           if rg.ds_pfs_sgr is null then
             vl_linha := vl_linha || ';';
           else
             vl_linha := vl_linha || rg.ds_pfs_sgr;
             vl_linha := vl_linha || ';';
           end if;

           --capital
	   vl_linha := vl_linha || '38.316,40';

	   -- premio
           --vl_linha := vl_linha || sc_pbl.valor_formato_ptbr(rg.vl_sgr);
           --vl_linha := vl_linha || ';';

           -- vigencia inicial
	   --vl_linha := vl_linha || to_char(vl_data_inicio_vigencia,'dd/mm/yyyy');
	   --vl_linha := vl_linha || ';';

	   -- vigencia final
     	   --vl_linha := vl_linha || to_char(vl_data_fim_vigencia,'dd/mm/yyyy');
	   --vl_linha := vl_linha || ';';

           -- endereco
           /*select *
           into vl_rg_edr
           from sc_aeo.get_endereco(rg.cd_cun);

           if vl_rg_edr is null then
              vl_linha := vl_linha || ';;;;;';
           else
              vl_linha := vl_linha || vl_rg_edr.logradouro || ', ' || vl_rg_edr.nr_edr || coalesce(vl_rg_edr.cpl_edr,' - ') || coalesce(vl_rg_edr.cpl_edr,'');
              vl_linha := vl_linha || ';';

              vl_linha := vl_linha || vl_rg_edr.bairro;
              vl_linha := vl_linha || ';';

              vl_linha := vl_linha || vl_rg_edr.localidade;
              vl_linha := vl_linha || ';';

              vl_linha := vl_linha || vl_rg_edr.uf;
              vl_linha := vl_linha || ';';

              vl_linha := vl_linha || vl_rg_edr.cep_edr;
           end if;
           */

           perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

	   insert into sc_svg.tbl_drs(cd_drs,cd_sgr,dt_inc_usr,cd_inc_usr,cd_ars)
	   values(nextval('sc_svg.sq_drs'),rg.cd_sgr,now(),1,currval('sc_svg.sq_ars'));
	end loop;

	--inserindo registro na tabela de download
        insert into sc_dwn.tbl_dwa values (vl_codigo_arquivo, vl_nm_arquivo, now(), current_date, CT_TP_ARQ_REMESSA_SEGURO, CT_SIT_ARQ_GERADO);
    end if;
END;
$$;


ALTER FUNCTION sc_svg.gerar_arquivo_remessa_empresa_pan_seguros(vp_contrato numeric, vp_mes_ref character varying, vp_filial numeric) OWNER TO scan;

--
-- TOC entry 1778 (class 1255 OID 902584)
-- Name: gerar_arquivo_remessa_empresa_previsul(numeric, character varying, numeric); Type: FUNCTION; Schema: sc_svg; Owner: scan
--

CREATE FUNCTION gerar_arquivo_remessa_empresa_previsul(vp_contrato numeric, vp_mes_ref character varying, vp_filial numeric) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  vl_rg_edr sc_cad.vw_edr%rowtype;
  vl_rg_tlf sc_cad.tbl_tlf%rowtype;
  
  SITUACAO_VIGENTE numeric := 3;
  SITUACAO_CANCELADO numeric := 4;
  PRM_DIRETORIO_ARQUIVO VARCHAR := 'NM_DIR_ARQ_RMS_SEGURO_GRUPO';
  CT_TP_ARQ_REMESSA_SEGURO numeric := 6;
  CT_SIT_ARQ_GERADO numeric := 1;
  SITUACAO_ARQUIVO_CADASTRADO numeric := 1;
  vl_nome_arquivo varchar;
  vl_nm_arquivo varchar;
  vl_diretorio varchar;
  vl_linha varchar;
  vl_qtde numeric := 0;

  vl_data_inicio_vigencia date;
  vl_nome_empresa_split varchar;
  vl_nome_empresa varchar;
  vl_codigo_arquivo numeric;
  vl_contrato_seguradora varchar;
  vl_apolice varchar;
  vl_codigo_empresa numeric;
  vl_cnpj_empresa numeric;
  vl_nome_filial varchar;

  vl_nome_seguradora varchar;
  
BEGIN

    vl_data_inicio_vigencia := to_date('01/' || vp_mes_ref,'dd/mm/yyyy');
    
    -- verificando se tem funcionario vigente para gerar o arquivo de remessa
    select count(distinct cun.nm_cun)
      into vl_qtde
    from sc_srv.tbl_sgr sgr
	inner join sc_svg.tbl_fem_csg fem on fem.cd_csg = sgr.cd_csg and fem.fg_atv_fem_csg = 'S'
	inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc and fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
	inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
	left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
    where sgr.cd_csg = vp_contrato
      and sgr.st_sgr in (SITUACAO_VIGENTE, SITUACAO_CANCELADO)
      and sgr.dt_vig_ini_sgr < vl_data_inicio_vigencia
      and (sgr.dt_vig_fim_sgr > vl_data_inicio_vigencia or sgr.dt_vig_fim_sgr is null) 
      and fnc.cd_fem = coalesce(vp_filial,fnc.cd_fem);

    if vl_qtde > 0 then  

        select nextval('sc_dwn.sq_dwa') into vl_codigo_arquivo;
        
        select prm.vl_prm
	  into vl_diretorio
        from sc_cad.tbl_prm prm
        where prm.nm_prm = PRM_DIRETORIO_ARQUIVO;

        select nm_emp, split_part(nm_emp, ' ', 1) || CASE WHEN split_part(nm_emp, ' ', 2) != '' THEN '_' || split_part(nm_emp, ' ', 2) ELSE '' END, emp.cd_emp,
               sga.ds_sga, COALESCE(cd_ctr_sga_csg, ''), csg.nr_apl_sga_csg,
               split_part(nm_fem, ' ', 1) || CASE WHEN split_part(nm_fem, ' ', 2) != '' THEN '_' || split_part(nm_fem, ' ', 2) ELSE '' END
          into vl_nome_empresa, vl_nome_empresa_split, vl_codigo_empresa, 
               vl_nome_seguradora, vl_contrato_seguradora, vl_apolice,
               vl_nome_filial
	from sc_svg.tbl_csg csg
	  inner join sc_svg.tbl_fem_csg f on f.cd_csg = csg.cd_csg and f.fg_atv_fem_csg = 'S'
	  inner join sc_cad.tbl_emp emp on emp.cd_emp = csg.cd_emp
	  inner join sc_srv.tbl_sga sga on sga.cd_sga = csg.cd_sga
	  inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp and fem.cd_fem = f.cd_fem
	where csg.cd_csg = vp_contrato
	  and ((vp_filial is not null and fem.cd_fem = vp_filial) or (vp_filial is null and fem.cd_fem = (select min(cd_fem) from sc_svg.tbl_fem_csg where cd_csg = csg.cd_csg and fg_atv_fem_csg = 'S')));

        select cun.nr_cpf_cnpj_cun
          into vl_cnpj_empresa
        from sc_cad.tbl_emp emp
        inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp
        inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
        where emp.cd_emp = vl_codigo_empresa
          and fem.fg_mtz_fem = 'S'
          AND fem.cd_fem = coalesce(vp_filial, fem.cd_fem);

        if vl_cnpj_empresa is null then

          select cun.nr_cpf_cnpj_cun
            into vl_cnpj_empresa
          from sc_cad.tbl_emp emp
            inner join sc_cad.tbl_fem fem on fem.cd_emp = emp.cd_emp
            inner join sc_cad.tbl_cun cun on cun.cd_cun = fem.cd_cun
          where emp.cd_emp = vl_codigo_empresa
            and fem.cd_fem = (select min(cd_fem) from sc_cad.tbl_fem where cd_emp = vl_codigo_empresa);
            
        end if;

        vl_nome_filial := coalesce(vl_nome_filial,'');

        if length(vl_nome_filial) > 0 then
           vl_nome_filial := '-' || vl_nome_filial;
        end if;
	    
        vl_nm_arquivo := vl_nome_seguradora || '_' || vl_contrato_seguradora || '_' || vl_nome_empresa_split || '_' || replace(vp_mes_ref, '/', '') || vl_nome_filial || '_' || vl_qtde || 'vidas.csv';
        vl_nome_arquivo := vl_diretorio || '/' || vl_nm_arquivo;


        insert into sc_svg.tbl_ars(cd_ars,nm_ars,cd_csg,dt_inc_usr,cd_inc_usr,st_ars,qtd_ars,mes_ars)
           values(nextval('sc_svg.sq_ars'),vl_nm_arquivo,vp_contrato,now(),1,SITUACAO_ARQUIVO_CADASTRADO,vl_qtde,vp_mes_ref);

        vl_linha := ';;;;;;;;;;;;;;;;';
        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha); 

        vl_linha := ';;;;;;;;;;;;;;;;';
        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

        vl_linha := 'NOME DA EMPRESA:;'|| vl_nome_empresa ||';;;;CNPJ:;' || REPLACE(REPLACE(TO_CHAR(vl_cnpj_empresa, '00#000#000/0000-00'), '#', '.'), ' ', '') || ';;;;;;;;;;'; 
        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

        vl_linha := ';;;;;APOLICE:;' || vl_apolice || ';;;;;;;;;;';
        perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

	vl_linha := 'NOME COMPLETO (SEM ACENTOS);CPF;NASCIMENTO;ENDERECO(RUA,NUM, COMPLEMENTO);MUNICIPIO;CEP;PROFISSAO;(DDD)TELEFONE;PPE (SIM OU NAO);FAIXA DE RENDA MENSAL;';
	perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);
	    
	for rg in select cun.cd_cun,
	                    cun.nm_cun,
			     cpf.dt_nsc_cpf,
			     cun.nr_cpf_cnpj_cun,
			     sgr.cd_sgr,
			     sgr.vl_rnd_mes_sgr,
			     sgr.ds_pfs_sgr
		  from sc_srv.tbl_sgr sgr
			inner join sc_svg.tbl_fem_csg fem on fem.cd_csg = sgr.cd_csg and fem.fg_atv_fem_csg = 'S'
	                inner join sc_cad.tbl_fnc fnc on fnc.cd_fnc = sgr.cd_fnc and fem.cd_emp = fnc.cd_emp and fem.cd_fem = fnc.cd_fem
			inner join sc_cad.tbl_cun cun on cun.cd_cun = fnc.cd_cun
			left join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
		  where sgr.cd_csg = vp_contrato
			and sgr.st_sgr in (SITUACAO_VIGENTE, SITUACAO_CANCELADO) 
			and sgr.dt_vig_ini_sgr < vl_data_inicio_vigencia
			and (sgr.dt_vig_fim_sgr > vl_data_inicio_vigencia or sgr.dt_vig_fim_sgr is null) 
			and fnc.cd_fem = coalesce(vp_filial, fnc.cd_fem) 
	loop
			
           --nome
	   vl_linha := sc_pbl.sem_acento(rg.nm_cun);
	   vl_linha := vl_linha || ';';

           --cpf
           vl_linha := vl_linha || REPLACE(REPLACE(TO_CHAR(rg.nr_cpf_cnpj_cun, '000#000#000-00'), '#', '.'), ' ', '');
           vl_linha := vl_linha || ';';

           --data de nascimento     
	   if(rg.dt_nsc_cpf is not null) then
		 vl_linha := vl_linha || to_char(rg.dt_nsc_cpf,'dd/mm/yyyy');
	   end if;    
	   vl_linha := vl_linha || ';';

           -- endereco
           select *
           into vl_rg_edr
           from sc_aeo.get_endereco(rg.cd_cun);

           if vl_rg_edr is null then
              vl_linha := vl_linha || ';;;';
           else
              vl_linha := vl_linha || vl_rg_edr.logradouro || ', ' || vl_rg_edr.nr_edr || coalesce(vl_rg_edr.cpl_edr,' - ') || coalesce(vl_rg_edr.cpl_edr,'') || ' - ' || vl_rg_edr.bairro;
              vl_linha := vl_linha || ';';

              vl_linha := vl_linha || vl_rg_edr.localidade ||'-'||vl_rg_edr.uf;
              vl_linha := vl_linha || ';';

              vl_linha := vl_linha || vl_rg_edr.cep_edr;
              vl_linha := vl_linha || ';';
           end if;

          --profissao
          if rg.ds_pfs_sgr is null then
            vl_linha := vl_linha || ';';
          else
            vl_linha := vl_linha || rg.ds_pfs_sgr;
            vl_linha := vl_linha || ';';
          end if;

          -- telefone
          select *
          into vl_rg_tlf
          from sc_aeo.get_telefone(rg.cd_cun,2);

          if vl_rg_tlf is null then
            vl_linha := vl_linha || ';';
          else
            vl_linha := vl_linha || '(' || vl_rg_tlf.nr_ddd_tlf || ')';
            vl_linha := vl_linha || vl_rg_tlf.nr_tlf;
            vl_linha := vl_linha || ';';
          end if;

          -- PPE
          vl_linha := vl_linha || 'NAO';
          vl_linha := vl_linha || ';';

          -- faixa renda mensal
          if rg.vl_rnd_mes_sgr is null then
            vl_linha := vl_linha || ';';
          else
            vl_linha := vl_linha || sc_pbl.valor_formato_ptbr(rg.vl_rnd_mes_sgr);
            vl_linha := vl_linha || ';';
          end if;
          
          perform sc_arq.gravarlinha(vl_nome_arquivo,vl_linha);

	   insert into sc_svg.tbl_drs(cd_drs,cd_sgr,dt_inc_usr,cd_inc_usr,cd_ars)
	   values(nextval('sc_svg.sq_drs'),rg.cd_sgr,now(),1,currval('sc_svg.sq_ars'));
	end loop;

	--inserindo registro na tabela de download
        insert into sc_dwn.tbl_dwa values (vl_codigo_arquivo, vl_nm_arquivo, now(), current_date, CT_TP_ARQ_REMESSA_SEGURO, CT_SIT_ARQ_GERADO);
    end if;
END;
$$;


ALTER FUNCTION sc_svg.gerar_arquivo_remessa_empresa_previsul(vp_contrato numeric, vp_mes_ref character varying, vp_filial numeric) OWNER TO scan;

--
-- TOC entry 1570 (class 1255 OID 564609)
-- Name: inserir_novos_funcionarios(); Type: FUNCTION; Schema: sc_svg; Owner: scan
--

CREATE FUNCTION inserir_novos_funcionarios() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rg record;
  SEGURADORA_TOKIO_MARINE numeric := 2;
  SITUACAO_SEGURO_ADERIDO numeric := 2;

  TIPO_OCORRENCIA_SEGURO_CADASTRO numeric := 1;

BEGIN
   
    for rg in select fnc.cd_fnc,
                     fem_csg.cd_csg,
                     csg.vl_csg,
                     csg.cd_sga
              from sc_cad.tbl_fnc fnc 
                 inner join sc_svg.tbl_fem_csg fem_csg on fnc.cd_emp = fem_csg.cd_emp and fnc.cd_fem = fem_csg.cd_fem
                 inner join sc_svg.tbl_csg csg on csg.cd_csg = fem_csg.cd_csg
               where fem_csg.fg_atv_fem_csg = 'S'
                 and csg.fg_atv_csg = 'S'
                 and fnc.st_fnc in (1,3,4,5) -- ativo, inns, nao remunerado ou ferias
                 --and exists(select 1 from sc_opr.tbl_crt crt where crt.cd_fnc = fnc.cd_fnc and crt.fg_atv_crt = 'S')
                 and not exists(select 1 from sc_srv.tbl_sgr sgr where sgr.cd_csg = fem_csg.cd_csg and sgr.cd_fnc = fnc.cd_fnc) loop
                 
         insert into sc_srv.tbl_sgr(cd_sgr,cd_sga,vl_sgr,vl_prs_sgr,st_sgr,cd_csg,cd_fnc)
            values(nextval('sc_srv.sq_sgr'),rg.cd_sga,rg.vl_csg,rg.vl_csg,SITUACAO_SEGURO_ADERIDO,rg.cd_csg,rg.cd_fnc);

         -- Cadastrando ocorrência de seguro
         insert into sc_svg.tbl_osg(cd_osg,cd_tos,cd_sgr,cd_inc_usr,dt_inc_usr,ds_osg) values(nextval('sc_svg.sq_osg'),TIPO_OCORRENCIA_SEGURO_CADASTRO,currval('sc_srv.sq_sgr'),1,now(),'CADASTRO DE SEGURO AUTOMATICO.');
                 
    end loop;             
                 
END;
$$;


ALTER FUNCTION sc_svg.inserir_novos_funcionarios() OWNER TO scan;

--
-- TOC entry 1486 (class 1255 OID 564610)
-- Name: marcar_seguro_vigente(); Type: FUNCTION; Schema: sc_svg; Owner: scan
--

CREATE FUNCTION marcar_seguro_vigente() RETURNS void
    LANGUAGE plpgsql
    AS $$declare

rg record;

SITUACAO_PARCELA_CADASTRADO sc_svg.tbl_psg.st_psg%type = 2;
begin

    for rg in select cnt_crt.cd_cnt conta_debito,
                     sga.cd_cnt conta_credito,
                     psg.cd_psg,
                     psg.vl_psg,
                     psg.cd_sgr
              from sc_svg.tbl_psg psg
                inner join sc_srv.tbl_sgr sgr on sgr.cd_sgr = psg.cd_sgr
                inner join sc_srv.tbl_sga sga on sga.cd_sga = sgr.cd_sga
                inner join sc_opr.tbl_crt crt on crt.cd_fnc = sgr.cd_fnc
                inner join sc_cad.tbl_ctr ctr on ctr.cd_ctr = crt.cd_ctr
                inner join sc_opr.tbl_cnt_crt cnt_crt on cnt_crt.cd_crt = crt.cd_crt
                inner join sc_cnt.tbl_cnt cnt on cnt.cd_cnt = cnt_crt.cd_cnt
              where dt_vnc_psg < current_date
                and st_psg = 1--SITUACAO_PARCELA_CADASTRADO
                and ctr.cd_prd = 1 -- salario
                and cnt.vl_sld_cnt >= psg.vl_psg loop


          perform sc_cnt.lancar_debito_credito(rg.conta_debito,
                                               rg.conta_credito,
                                               1021,
                                               null,
                                               'REF A PARCELA DE SEGURO NR '||rg.cd_psg,
                                               rg.vl_psg,
                                               now()::timestamp,
                                               1,
                                               17,
                                               rg.cd_psg); 
          
          update sc_srv.tbl_sgr set st_sgr = 3,nr_srt_sgr=99999 where cd_sgr = rg.cd_sgr;    

          update sc_svg.tbl_psg set st_psg = 2 where cd_psg = rg.cd_psg;
                
 
    end loop;
   
end$$;


ALTER FUNCTION sc_svg.marcar_seguro_vigente() OWNER TO scan;

--
-- TOC entry 1420 (class 1255 OID 564611)
-- Name: processar_seguro_aderido(); Type: FUNCTION; Schema: sc_svg; Owner: scan
--

CREATE FUNCTION processar_seguro_aderido() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   rg record;
   rg_prc record;
   SITUACAO_SEGURO_ADERIDO sc_srv.tbl_sgr.st_sgr%type := 2;

   vl_dt_vencimento date;
   
begin

   for rg in select *
             from sc_srv.tbl_sgr sgr
             where sgr.st_sgr = SITUACAO_SEGURO_ADERIDO
               and sgr.dt_prc_sgr is null 
               and cd_csg is null loop
               
        vl_dt_vencimento = rg.dt_vig_ini_sgr;
        
        for rg_prc in 1..rg.qt_prs_sgr loop
        
           insert into sc_svg.tbl_psg(cd_psg,dt_grc_psg,cd_sgr,st_psg,vl_psg,dt_pgt_psg,dt_vnc_psg)
              values(nextval('sc_svg.sq_psg'),now(),rg.cd_sgr,1,rg.vl_prs_sgr,null,vl_dt_vencimento);

           vl_dt_vencimento = vl_dt_vencimento + interval '1 month';
           
        end loop;

        update sc_srv.tbl_sgr set dt_prc_sgr = now() where cd_sgr = rg.cd_sgr;
        
               
   end loop;            
             

end$$;


ALTER FUNCTION sc_svg.processar_seguro_aderido() OWNER TO scan;

SET search_path = sc_tem, pg_catalog;

--
-- TOC entry 1547 (class 1255 OID 872334)
-- Name: desconta_primeira_mensalidade(); Type: FUNCTION; Schema: sc_tem; Owner: scan
--

CREATE FUNCTION desconta_primeira_mensalidade() RETURNS void
    LANGUAGE plpgsql
    AS $$declare
   rg record;
   ct_situacao_aguardando_adesao numeric := 2;
   ct_situacao_vigente numeric := 3;
   ct_conta_receita_tem numeric := 106151;
   ct_tipo_lancamento_receita_mensalidade_tem numeric := 1395;
begin


    for rg in select *
              from sc_tem.tbl_ads ads
                inner join sc_tem.tbl_css css on css.cd_css = ads.cd_css
                inner join sc_opr.tbl_cnt_crt cnt on cnt.cd_crt = ads.cd_crt
                inner join sc_cnt.tbl_cnt conta on conta.cd_cnt = cnt.cd_cnt
              where ads.st_ads = ct_situacao_aguardando_adesao
               and  conta.vl_sld_cnt >= css.vl_msl_css 
               and  cnt.fg_pdr_cnt_crt = 'S' loop

        perform sc_cnt.lancar_debito_credito(conta.cd_cnt,ct_conta_receita_tem,ct_tipo_lancamento_receita_mensalidade_tem,null,'PGT REF A ADESAO NR '||rg.cd_ads,rg.vl_msl_css,now(),1,27,rg.cd_ads);

        update sc_tem.tbl_ads set st_ads = ct_situacao_vigente where cd_ads = rg.cd_ads;

        insert into sc_tem.tbl_oca values(nextval('sc_tem.sq_oca'),rg.cd_ads,3,1,NOW(),'INICIO DA VIGENCIA',NULL);
              
    end loop;          

end$$;


ALTER FUNCTION sc_tem.desconta_primeira_mensalidade() OWNER TO scan;

--
-- TOC entry 1490 (class 1255 OID 564612)
-- Name: gerar_arquivo_adesao(date); Type: FUNCTION; Schema: sc_tem; Owner: scan
--

CREATE FUNCTION gerar_arquivo_adesao(vp_data date) RETURNS void
    LANGUAGE plpgsql
    AS $$declare

   rg record;

   NM_PRM_DIRETORIO_CARTAO_TEM varchar := 'DIR_ARQ_CARTAO_TEM';

   vl_linha varchar;
   vl_acao varchar;
   vl_nm_arquivo varchar;
   vl_diretorio varchar;

   ct_tipo_ocorrencia_vigencia numeric     := 3;
   ct_tipo_ocorrencia_suspensao numeric    := 5;
   ct_tipo_ocorrencia_cancelamento numeric := 4;
   ct_tipo_ocorrencia_reativacao numeric   := 7;

   ct_codigo_produto numeric := 3114;

   vl_nome_download varchar;
   

begin

   select prm.vl_prm
   into vl_diretorio
   from sc_cad.tbl_prm prm
   where prm.nm_prm = NM_PRM_DIRETORIO_CARTAO_TEM;

   vl_nm_arquivo := 'ADESAO' ||  '_P3114_' || TO_CHAR(vp_data,'yyyymmdd') || '.csv';
   vl_nome_download := vl_nm_arquivo;
   vl_nm_arquivo := vl_diretorio || '/' || vl_nm_arquivo;

   
   for rg in select oca.tp_oca,
                    ads.cd_crt_tem,
                    ads.cd_ads,
                    cun.nr_cpf_cnpj_cun cpf_cnpj,
                    cun.nm_cun,
                    cpf.dt_nsc_cpf data_nascimento,
                    cpf.sexo_cpf,
                    oca.cd_oca
             from sc_tem.tbl_oca oca
                inner join sc_tem.tbl_ads ads on ads.cd_ads = oca.cd_ads
                inner join sc_cad.tbl_cun cun on cun.cd_cun = ads.cd_cun
                inner join sc_cad.tbl_cpf cpf on cpf.cd_cun = cun.cd_cun
             where oca.tp_oca in(3,5,4) 
               and oca.dt_prc_oca is null
               and oca.dt_inc_usr::date <= vp_data   loop

      vl_linha := '';       

      if rg.tp_oca = ct_tipo_ocorrencia_vigencia then
         vl_acao = 1;
      elsif rg.tp_oca = ct_tipo_ocorrencia_suspensao then
         vl_acao = 4;    
      elsif rg.tp_oca = ct_tipo_ocorrencia_reativacao then
         vl_acao = 5 ;
      end if;      

      vl_linha := vl_linha || vl_acao; -- acao
      vl_linha := vl_linha || ';';
      vl_linha := vl_linha || rg.cd_crt_tem; -- cartao tem
      vl_linha := vl_linha || ';';
      
      vl_linha := vl_linha || rg.cd_ads; -- identificador externo
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || ct_codigo_produto; -- codigo do produto
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || trim(to_char(rg.cpf_cnpj,'00000000000')); -- cpf
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || ''; -- nome no cartao
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || rg.nm_cun; -- nome completo
      vl_linha := vl_linha || ';';

      -- CAMPOS DE ENDERECO      
      vl_linha := vl_linha || '';
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';
      vl_linha := vl_linha || ';';

      vl_linha := vl_linha || to_char(rg.data_nascimento,'ddmmyyyy');--data de nascimento
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || rg.sexo_cpf;--sexo
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';--raca
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';--naturalidade
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';--escolaridade
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';--profissao cbo
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';--classe rendimento
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';--quantidade de parcelas
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';--data da primeira cobranca
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';--baixa de adesao
      vl_linha := vl_linha || ';';      
      vl_linha := vl_linha || '';--desconto anuidade
      vl_linha := vl_linha || ';';      
      
      update sc_tem.tbl_oca set dt_prc_oca = now() where cd_oca = rg.cd_oca;          

      perform sc_arq.gravarlinha(vl_nm_arquivo,vl_linha);
  
   end loop;             

   insert into sc_dwn.tbl_dwa values(nextval('sc_dwn.sq_dwa'),vl_nome_download,now(),vp_data,12,1);

end$$;


ALTER FUNCTION sc_tem.gerar_arquivo_adesao(vp_data date) OWNER TO scan;

SET search_path = sc_trg, pg_catalog;

--
-- TOC entry 1537 (class 1255 OID 564613)
-- Name: tg_ctr_update(); Type: FUNCTION; Schema: sc_trg; Owner: scan
--

CREATE FUNCTION tg_ctr_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
   TIPO_OCORRENCIA_ALTERACAO_PARAMETRO sc_cad.tbl_toe.cd_toe%type := 6;
   vl_cod_empresa sc_cad.tbl_emp.cd_emp%type;
   vl_nome_parametro varchar;
   vl_valor_antigo varchar;
begin 

  select ctr.cd_emp
  into vl_cod_empresa
  from sc_cad.tbl_ctr ctr
  where ctr.cd_ctr = new.cd_ctr;

  if(new.fg_car_lmt_ctr <> old.fg_car_lmt_ctr) then

    if old.fg_car_lmt_ctr is null then
      vl_valor_antigo := 'S';    
    else
      vl_valor_antigo := old.fg_car_lmt_ctr;
    end if;
    
    insert into sc_cad.tbl_oce(cd_oce, cd_toe, ds_oce, cd_emp, cd_inc_usr, dt_inc_usr) 
                        values(nextval('sc_cad.sq_oce'),5,'ALTERACAO NO CAMPO: FLAG DE CARENCIA. VALOR ANTIGO: ' || vl_valor_antigo || ' VALOR ATUAL: ' ||new.fg_car_lmt_ctr, vl_cod_empresa, new.cd_alt_usr, now());
  end if;

  if new.cd_grt <> old.cd_grt then

    insert into sc_cad.tbl_oce(cd_oce, cd_toe, ds_oce, cd_emp, cd_inc_usr, dt_inc_usr) 
      values(nextval('sc_cad.sq_oce'),TIPO_OCORRENCIA_ALTERACAO_PARAMETRO,'ALTERACAO NO CAMPO: FLAG DE CARENCIA. VALOR ANTIGO: ' || old.cd_grt || ' VALOR ATUAL: ' ||new.cd_grt, vl_cod_empresa, new.cd_alt_usr, now());
  
  end if;
  
  return new; 
end;$$;


ALTER FUNCTION sc_trg.tg_ctr_update() OWNER TO scan;

--
-- TOC entry 1779 (class 1255 OID 1639055)
-- Name: tg_fet_update(); Type: FUNCTION; Schema: sc_trg; Owner: postgres
--

CREATE FUNCTION tg_fet_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
   vl_tipo_ocorrencia sc_rdc.tbl_toe.cd_toe%type;
   vl_cod_filial_estabelecimento sc_rdc.tbl_fet.cd_fet%type;
   
   descricao_ocorrencia varchar := '';
   separador varchar := ''; 
begin 

     
  -- verificando alteracao no valor do parametro
  if(new.nr_lgc_cel_fet <> old.nr_lgc_cel_fet or (new.nr_lgc_cel_fet is null and old.nr_lgc_cel_fet is not null) or (old.nr_lgc_cel_fet is null and new.nr_lgc_cel_fet is not null)) then
    vl_tipo_ocorrencia := 2;
    descricao_ocorrencia := 'ALTERACAO NO NUMERO LOGICO DA CIELO ';
    descricao_ocorrencia := descricao_ocorrencia || separador || ' VALOR - VALOR ANTIGO: ' || coalesce(old.nr_lgc_cel_fet||'','VAZIO') || ' VALOR ATUAL: ' || coalesce(new.nr_lgc_cel_fet||'','VAZIO');
    new.fg_env_hpc_fet = 'S';
    separador := E'\n';
  end if;

  if(new.nr_lgc_fet <> old.nr_lgc_fet) then
    vl_tipo_ocorrencia := 1;
    descricao_ocorrencia := 'ALTERACAO NO NUMERO LOGICO ';
    descricao_ocorrencia := descricao_ocorrencia || separador || 'VALOR - VALOR ANTIGO: ' || coalesce(old.nr_lgc_fet||'','VAZIO') || ' VALOR ATUAL: ' || coalesce(new.nr_lgc_fet||'','VAZIO');  
    separador := E'\n';
  end if;

  if(new.fg_mtz_fet <> old.fg_mtz_fet) then
    vl_tipo_ocorrencia := 3;
    descricao_ocorrencia := 'ALTERACAO DA MATRIZ DO ESTABELECIMENTO';
    descricao_ocorrencia := descricao_ocorrencia || separador || 'VALOR - VALOR ANTIGO: ' || old.fg_mtz_fet || ' VALOR ATUAL: ' || new.fg_mtz_fet;  
    separador := E'\n';
  end if;

  if length(descricao_ocorrencia) > 0 then
    insert into sc_rdc.tbl_oet(cd_oet, cd_toe, ds_oet, cd_fet, cd_inc_usr, dt_inc_usr) 
                        values(nextval('sc_rdc.sq_oet'),vl_tipo_ocorrencia,descricao_ocorrencia, new.cd_fet, new.cd_alt_usr, now());
  end if;                      

 
  
  return new; 
end;$$;


ALTER FUNCTION sc_trg.tg_fet_update() OWNER TO postgres;

--
-- TOC entry 1706 (class 1255 OID 564614)
-- Name: tg_fnc_update(); Type: FUNCTION; Schema: sc_trg; Owner: scan
--

CREATE FUNCTION tg_fnc_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare

vl_historico varchar;
vl_cartao numeric;  

begin 

       if(new.dt_alt_usr <> old.dt_alt_usr) then 

          select cd_crt into vl_cartao from sc_opr.tbl_crt where cd_fnc = old.cd_fnc;
       
	  if(new.st_fnc <> old.st_fnc) then
	      new.dt_alt_sit_fnc = now();

	      vl_historico := 'SITUACAO ALTERADA DE ' || sc_grl.get_descricao_dominio('ST_FNC', old.st_fnc)  || ' PARA ' || sc_grl.get_descricao_dominio('ST_FNC', new.st_fnc);  

	      if vl_cartao is not null then

		      insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
				     values (nextval('sc_opr.sq_ocr'), 30, vl_cartao, null, 
						 vl_historico, 'S', new.cd_alt_usr, now());
              end if;
	      
	  end if;

          vl_historico := 'DADOS ALTERADOS.';

          if new.dt_adm_fnc is not null then
	    if(new.dt_adm_fnc <> old.dt_adm_fnc or old.dt_adm_fnc is null) then

              if old.dt_adm_fnc is null then
                vl_historico := vl_historico || ' ALTERADA DATA DE ADMISSAO PARA ' || to_char(new.dt_adm_fnc,'dd/mm/yyyy');
              else
                vl_historico := vl_historico || ' ALTERADA DATA DE ADMISSAO DE ' || to_char(old.dt_adm_fnc,'dd/mm/yyyy') || ' PARA ' || to_char(new.dt_adm_fnc,'dd/mm/yyyy');
              end if;

	    end if;

	    if vl_cartao is not null then

		      insert into sc_opr.tbl_ocr(cd_ocr, cd_toc, cd_crt, cd_pls, nm_his_ocr, fg_atm_ocr, cd_inc_usr, dt_inc_usr) 
				     values (nextval('sc_opr.sq_ocr'), 36, vl_cartao, null, 
						 vl_historico, 'S', new.cd_alt_usr, now());
            end if;
          end if;  
      end if;	  
  
  return new; 
end;$$;


ALTER FUNCTION sc_trg.tg_fnc_update() OWNER TO scan;

--
-- TOC entry 1487 (class 1255 OID 564615)
-- Name: tg_pce_ctr_update(); Type: FUNCTION; Schema: sc_trg; Owner: scan
--

CREATE FUNCTION tg_pce_ctr_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
   TIPO_OCORRENCIA_ALTERACAO_PARAMETRO sc_cad.tbl_toe.cd_toe%type := 4;
   vl_cod_empresa sc_cad.tbl_emp.cd_emp%type;
   vl_nome_parametro sc_cad.tbl_pce.nm_pce%type;

   
   descricao_ocorrencia varchar := '';
   separador varchar := ''; 
begin 

  select ctr.cd_emp
  into vl_cod_empresa
  from sc_cad.tbl_ctr ctr
  where ctr.cd_ctr = new.cd_ctr;

  select nm_pce
  into vl_nome_parametro
  from sc_cad.tbl_pce pce
  where pce.cd_pce = new.cd_pce;

     
  -- verificando alteracao no valor do parametro
  if(new.vl_pce_ctr <> old.vl_pce_ctr) then
    descricao_ocorrencia := descricao_ocorrencia || separador || 'VALOR - VALOR ANTIGO: ' || old.vl_pce_ctr || ' VALOR ATUAL: ' || new.vl_pce_ctr;  
    separador := E'\n';
  end if;

  -- verificando alteracao no tipo de valor do parametro
  if(new.tp_vlr_pce_ctr <> old.tp_vlr_pce_ctr) then
    descricao_ocorrencia := descricao_ocorrencia || separador || 'TIPO DE VALOR - VALOR ANTIGO: ' || case when old.tp_vlr_pce_ctr = 'V' then 'VALOR' else 'PERCENTUAL' end || ' VALOR ATUAL: ' || case when new.tp_vlr_pce_ctr = 'V' then 'VALOR' else 'PERCENTUAL' end;
    separador := E'\n';  
  end if;

  -- verificando alteracao na cobranca do parametro
  if(new.tp_pgt_pce_ctr <> old.tp_pgt_pce_ctr) then
    descricao_ocorrencia := descricao_ocorrencia || separador || 'COBRANCA - VALOR ANTIGO: ' || sc_grl.get_descricao_dominio('TP_PGT_PCE', old.tp_pgt_pce_ctr) || ' VALOR ATUAL: ' || sc_grl.get_descricao_dominio('TP_PGT_PCE', new.tp_pgt_pce_ctr);
    separador := E'\n';  
  end if;


  if length(descricao_ocorrencia) > 0 then

    descricao_ocorrencia := 'ALTERACAO NO PARAMETRO ' || vl_nome_parametro || separador || descricao_ocorrencia;
    insert into sc_cad.tbl_oce(cd_oce, cd_toe, ds_oce, cd_emp, cd_inc_usr, dt_inc_usr) 
                        values(nextval('sc_cad.sq_oce'),TIPO_OCORRENCIA_ALTERACAO_PARAMETRO,descricao_ocorrencia, vl_cod_empresa, new.cd_alt_usr, now());
  end if;                      

 
  
  return new; 
end;$$;


ALTER FUNCTION sc_trg.tg_pce_ctr_update() OWNER TO scan;

--
-- TOC entry 1747 (class 1255 OID 1025327)
-- Name: tg_tlf_update(); Type: FUNCTION; Schema: sc_trg; Owner: scan
--

CREATE FUNCTION tg_tlf_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare

  qtd_telefone numeric;
begin 
  if new.dt_alt_usr is null then
     raise exception 'A DATA DE ALTERACAO DEVE SER INFORMADA';
   end if;
/*  select count(*)
  into qtd_telefone
  from sc_cad.tbl_tlf
  where tp_org_tlf = new.tp_org_tlf
    and nsu_org_tlf = new.nsu_org_tlf
    and fg_atv_tlf = new.fg_atv_tlf
    and nr_tlf = new.nr_tlf
    and fg_prn_tlf = new.fg_prn_tlf;

  if coalesce(qtd_telefone,0) > 0  then
    raise exception 'ESSE TELEFONE JA EXISTE NA BASE DE DADOS';
  end if;*/

  return new;  

end;$$;


ALTER FUNCTION sc_trg.tg_tlf_update() OWNER TO scan;

--
-- TOC entry 1444 (class 1255 OID 564616)
-- Name: tg_tlt_ctr_update(); Type: FUNCTION; Schema: sc_trg; Owner: scan
--

CREATE FUNCTION tg_tlt_ctr_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
   vl_tipo_ocorrencia sc_cad.tbl_toe.cd_toe%type;
   vl_cod_empresa sc_cad.tbl_emp.cd_emp%type;
   vl_cod_filial sc_cad.tbl_fem.cd_fem%type;
begin 

  select f.cd_emp, f.cd_fem
  into vl_cod_empresa, vl_cod_filial
  from sc_cad.tbl_fem_ctr f
  where f.cd_fem_ctr = new.cd_fem_ctr;
   
  if(new.pr_lmt <> old.pr_lmt) then

    if(coalesce(old.pr_lmt,0) = 0 ) then
      vl_tipo_ocorrencia := 3;  -- CONCESSAO DE LIMITE 	
    elsif(new.pr_lmt > old.pr_lmt) then
       vl_tipo_ocorrencia := 1; -- AUMENTO DE LIMITE
    else
       vl_tipo_ocorrencia := 2; -- DIMINUICAO DE LIMITE
    end if;
    
    insert into sc_cad.tbl_oce(cd_oce, cd_toe, ds_oce, cd_emp, cd_inc_usr, dt_inc_usr) 
                        values(nextval('sc_cad.sq_oce'),vl_tipo_ocorrencia,'ALTERACAO DE LIMITE TIPO ' || new.cd_tlt ||'. VALOR ANTIGO: ' || old.pr_lmt|| ' VALOR ATUAL: ' ||new.pr_lmt || ' FILIAL: ' || vl_cod_filial, vl_cod_empresa, new.cd_alt_usr, now());
  end if;
  
  return new; 
end;$$;


ALTER FUNCTION sc_trg.tg_tlt_ctr_update() OWNER TO scan;

SET search_path = sqlj, pg_catalog;

--
-- TOC entry 1447 (class 1255 OID 564617)
-- Name: add_type_mapping(character varying, character varying); Type: FUNCTION; Schema: sqlj; Owner: postgres
--

CREATE FUNCTION add_type_mapping(character varying, character varying) RETURNS void
    LANGUAGE java SECURITY DEFINER
    AS $$org.postgresql.pljava.management.Commands.addTypeMapping$$;


ALTER FUNCTION sqlj.add_type_mapping(character varying, character varying) OWNER TO postgres;

--
-- TOC entry 1448 (class 1255 OID 564618)
-- Name: drop_type_mapping(character varying); Type: FUNCTION; Schema: sqlj; Owner: postgres
--

CREATE FUNCTION drop_type_mapping(character varying) RETURNS void
    LANGUAGE java SECURITY DEFINER
    AS $$org.postgresql.pljava.management.Commands.dropTypeMapping$$;


ALTER FUNCTION sqlj.drop_type_mapping(character varying) OWNER TO postgres;

--
-- TOC entry 1449 (class 1255 OID 564619)
-- Name: get_classpath(character varying); Type: FUNCTION; Schema: sqlj; Owner: postgres
--

CREATE FUNCTION get_classpath(character varying) RETURNS character varying
    LANGUAGE java STABLE SECURITY DEFINER
    AS $$org.postgresql.pljava.management.Commands.getClassPath$$;


ALTER FUNCTION sqlj.get_classpath(character varying) OWNER TO postgres;

--
-- TOC entry 1451 (class 1255 OID 564621)
-- Name: install_jar(bytea, character varying, boolean); Type: FUNCTION; Schema: sqlj; Owner: postgres
--

CREATE FUNCTION install_jar(bytea, character varying, boolean) RETURNS void
    LANGUAGE java SECURITY DEFINER
    AS $$org.postgresql.pljava.management.Commands.installJar$$;


ALTER FUNCTION sqlj.install_jar(bytea, character varying, boolean) OWNER TO postgres;

--
-- TOC entry 1450 (class 1255 OID 564620)
-- Name: install_jar(character varying, character varying, boolean); Type: FUNCTION; Schema: sqlj; Owner: postgres
--

CREATE FUNCTION install_jar(character varying, character varying, boolean) RETURNS void
    LANGUAGE java SECURITY DEFINER
    AS $$org.postgresql.pljava.management.Commands.installJar$$;


ALTER FUNCTION sqlj.install_jar(character varying, character varying, boolean) OWNER TO postgres;

--
-- TOC entry 1452 (class 1255 OID 564622)
-- Name: remove_jar(character varying, boolean); Type: FUNCTION; Schema: sqlj; Owner: postgres
--

CREATE FUNCTION remove_jar(character varying, boolean) RETURNS void
    LANGUAGE java SECURITY DEFINER
    AS $$org.postgresql.pljava.management.Commands.removeJar$$;


ALTER FUNCTION sqlj.remove_jar(character varying, boolean) OWNER TO postgres;

--
-- TOC entry 1454 (class 1255 OID 564624)
-- Name: replace_jar(bytea, character varying, boolean); Type: FUNCTION; Schema: sqlj; Owner: postgres
--

CREATE FUNCTION replace_jar(bytea, character varying, boolean) RETURNS void
    LANGUAGE java SECURITY DEFINER
    AS $$org.postgresql.pljava.management.Commands.replaceJar$$;


ALTER FUNCTION sqlj.replace_jar(bytea, character varying, boolean) OWNER TO postgres;

--
-- TOC entry 1453 (class 1255 OID 564623)
-- Name: replace_jar(character varying, character varying, boolean); Type: FUNCTION; Schema: sqlj; Owner: postgres
--

CREATE FUNCTION replace_jar(character varying, character varying, boolean) RETURNS void
    LANGUAGE java SECURITY DEFINER
    AS $$org.postgresql.pljava.management.Commands.replaceJar$$;


ALTER FUNCTION sqlj.replace_jar(character varying, character varying, boolean) OWNER TO postgres;

--
-- TOC entry 1455 (class 1255 OID 564625)
-- Name: set_classpath(character varying, character varying); Type: FUNCTION; Schema: sqlj; Owner: postgres
--

CREATE FUNCTION set_classpath(character varying, character varying) RETURNS void
    LANGUAGE java SECURITY DEFINER
    AS $$org.postgresql.pljava.management.Commands.setClassPath$$;


ALTER FUNCTION sqlj.set_classpath(character varying, character varying) OWNER TO postgres;

SET search_path = public, pg_catalog;

--
-- TOC entry 3992 (class 1255 OID 1667424)
-- Name: median(numeric); Type: AGGREGATE; Schema: public; Owner: scan
--

CREATE AGGREGATE median(numeric) (
    SFUNC = array_append,
    STYPE = numeric[],
    INITCOND = '{}',
    FINALFUNC = _final_median
);


ALTER AGGREGATE public.median(numeric) OWNER TO scan;

--
-- TOC entry 972 (class 1259 OID 1648511)
-- Name: vl_existe; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE vl_existe (
    count bigint
);


ALTER TABLE vl_existe OWNER TO postgres;

--
-- TOC entry 968 (class 1259 OID 1638612)
-- Name: vl_nm_arquivo; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE vl_nm_arquivo (
    lcl_arq_ahp character varying(200)
);


ALTER TABLE vl_nm_arquivo OWNER TO postgres;

--
-- TOC entry 977 (class 1259 OID 1650391)
-- Name: vl_qtd; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE vl_qtd (
    count bigint
);


ALTER TABLE vl_qtd OWNER TO postgres;

--
-- TOC entry 980 (class 1259 OID 1653406)
-- Name: vl_qtd_filial; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE vl_qtd_filial (
    count bigint
);


ALTER TABLE vl_qtd_filial OWNER TO postgres;

SET search_path = sc__buxo, pg_catalog;

--
-- TOC entry 231 (class 1259 OID 564809)
-- Name: sq_dvd; Type: SEQUENCE; Schema: sc__buxo; Owner: scan
--

CREATE SEQUENCE sq_dvd
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1
    CYCLE;


ALTER TABLE sq_dvd OWNER TO scan;

--
-- TOC entry 793 (class 1259 OID 862552)
-- Name: sq_svn; Type: SEQUENCE; Schema: sc__buxo; Owner: scan
--

CREATE SEQUENCE sq_svn
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_svn OWNER TO scan;

--
-- TOC entry 895 (class 1259 OID 999580)
-- Name: tbl_cbf_aux; Type: TABLE; Schema: sc__buxo; Owner: postgres
--

CREATE TABLE tbl_cbf_aux (
    cd_bnc numeric(5,0) NOT NULL,
    nr_agc_cbf numeric(20,0) NOT NULL,
    nr_dgt_agc_cbf character varying(1),
    nr_cba_cbf numeric(20,0) NOT NULL,
    nr_dgt_cba_cbf character varying(2) NOT NULL,
    tp_cba_cbf numeric(2,0) NOT NULL,
    nr_cpf_cnpj_cbf numeric(14,0) NOT NULL,
    cd_cbf numeric(10,0),
    dt_grc_cbf timestamp without time zone,
    cd_cbf_aux integer NOT NULL
);


ALTER TABLE tbl_cbf_aux OWNER TO postgres;

--
-- TOC entry 7913 (class 0 OID 0)
-- Dependencies: 895
-- Name: COLUMN tbl_cbf_aux.cd_cbf; Type: COMMENT; Schema: sc__buxo; Owner: postgres
--

COMMENT ON COLUMN tbl_cbf_aux.cd_cbf IS 'código da conta bancária gerada';


--
-- TOC entry 7914 (class 0 OID 0)
-- Dependencies: 895
-- Name: COLUMN tbl_cbf_aux.dt_grc_cbf; Type: COMMENT; Schema: sc__buxo; Owner: postgres
--

COMMENT ON COLUMN tbl_cbf_aux.dt_grc_cbf IS 'data da geração da conta bancária';


--
-- TOC entry 989 (class 1259 OID 1668898)
-- Name: tbl_cbf_aux_cd_cbf_aux_seq; Type: SEQUENCE; Schema: sc__buxo; Owner: postgres
--

CREATE SEQUENCE tbl_cbf_aux_cd_cbf_aux_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tbl_cbf_aux_cd_cbf_aux_seq OWNER TO postgres;

--
-- TOC entry 7915 (class 0 OID 0)
-- Dependencies: 989
-- Name: tbl_cbf_aux_cd_cbf_aux_seq; Type: SEQUENCE OWNED BY; Schema: sc__buxo; Owner: postgres
--

ALTER SEQUENCE tbl_cbf_aux_cd_cbf_aux_seq OWNED BY tbl_cbf_aux.cd_cbf_aux;


--
-- TOC entry 938 (class 1259 OID 1614085)
-- Name: tbl_conta; Type: TABLE; Schema: sc__buxo; Owner: postgres
--

CREATE TABLE tbl_conta (
    cd_cnt numeric(10,0) NOT NULL,
    qtd numeric(10,0)
);


ALTER TABLE tbl_conta OWNER TO postgres;

--
-- TOC entry 939 (class 1259 OID 1614090)
-- Name: tbl_conta_data; Type: TABLE; Schema: sc__buxo; Owner: postgres
--

CREATE TABLE tbl_conta_data (
    cd_cnt numeric(10,0) NOT NULL,
    data date,
    debito numeric(13,2),
    credito numeric(13,2)
);


ALTER TABLE tbl_conta_data OWNER TO postgres;

--
-- TOC entry 232 (class 1259 OID 564811)
-- Name: tbl_crt_aux; Type: TABLE; Schema: sc__buxo; Owner: scan
--

CREATE TABLE tbl_crt_aux (
    cd_crt numeric(14,0) NOT NULL,
    tipo numeric(2,0)
);


ALTER TABLE tbl_crt_aux OWNER TO scan;

--
-- TOC entry 964 (class 1259 OID 1636249)
-- Name: tbl_dados_campanha; Type: TABLE; Schema: sc__buxo; Owner: scan
--

CREATE TABLE tbl_dados_campanha (
    matricula character varying(14) NOT NULL,
    nome character varying(200),
    cpf numeric(14,0)
);


ALTER TABLE tbl_dados_campanha OWNER TO scan;

--
-- TOC entry 233 (class 1259 OID 564814)
-- Name: tbl_dvd; Type: TABLE; Schema: sc__buxo; Owner: scan
--

CREATE TABLE tbl_dvd (
    cd_dvd numeric(10,0) NOT NULL,
    cartao numeric(14,0) NOT NULL,
    vl_fatura numeric(10,2),
    vl_parcela numeric(10,2),
    vl_tarifa_saq_arred numeric(10,2),
    vl_outras_tarifas numeric(10,2)
);


ALTER TABLE tbl_dvd OWNER TO scan;

--
-- TOC entry 904 (class 1259 OID 1002702)
-- Name: tbl_emp_aux; Type: TABLE; Schema: sc__buxo; Owner: scan
--

CREATE TABLE tbl_emp_aux (
    cd_emp numeric(10,0),
    nm_emp character varying(1000)
);


ALTER TABLE tbl_emp_aux OWNER TO scan;

--
-- TOC entry 234 (class 1259 OID 564817)
-- Name: tbl_fnc_aux; Type: TABLE; Schema: sc__buxo; Owner: scan
--

CREATE TABLE tbl_fnc_aux (
    filial numeric(5,0) NOT NULL,
    matricula character varying(14) NOT NULL,
    cpf numeric(14,0),
    empresa numeric(5,0) NOT NULL,
    situacao numeric(1,0),
    codigo numeric(10,0)
);


ALTER TABLE tbl_fnc_aux OWNER TO scan;

--
-- TOC entry 932 (class 1259 OID 1077177)
-- Name: tbl_mat_aux; Type: TABLE; Schema: sc__buxo; Owner: scan
--

CREATE TABLE tbl_mat_aux (
    cpf numeric(11,0),
    atual character varying(20),
    nova character varying(20)
);


ALTER TABLE tbl_mat_aux OWNER TO scan;

--
-- TOC entry 929 (class 1259 OID 1076815)
-- Name: tbl_mnt_tmp; Type: TABLE; Schema: sc__buxo; Owner: scan
--

CREATE TABLE tbl_mnt_tmp (
    trg_rmt character varying(100)
);


ALTER TABLE tbl_mnt_tmp OWNER TO scan;

--
-- TOC entry 235 (class 1259 OID 564820)
-- Name: tbl_pls_aux; Type: TABLE; Schema: sc__buxo; Owner: scan
--

CREATE TABLE tbl_pls_aux (
    cd_pls numeric(20,0) NOT NULL,
    cd_crt numeric(14,0)
);


ALTER TABLE tbl_pls_aux OWNER TO scan;

--
-- TOC entry 894 (class 1259 OID 998904)
-- Name: tbl_snac; Type: TABLE; Schema: sc__buxo; Owner: postgres
--

CREATE TABLE tbl_snac (
    mat character varying(20),
    cpf numeric(14,0)
);


ALTER TABLE tbl_snac OWNER TO postgres;

--
-- TOC entry 783 (class 1259 OID 860571)
-- Name: tbl_svn; Type: TABLE; Schema: sc__buxo; Owner: postgres
--

CREATE TABLE tbl_svn (
    nr_mtr character varying DEFAULT 50,
    nr_loc numeric(10,0)
);


ALTER TABLE tbl_svn OWNER TO postgres;

--
-- TOC entry 879 (class 1259 OID 975175)
-- Name: tbl_svn2; Type: TABLE; Schema: sc__buxo; Owner: scan
--

CREATE TABLE tbl_svn2 (
    cd_svn numeric(10,0) NOT NULL,
    cd_emp numeric(10,0) NOT NULL,
    nr_mtr_svn character varying(50),
    cd_ltc numeric(10,0),
    ds_ltc character varying(100)
);


ALTER TABLE tbl_svn2 OWNER TO scan;

--
-- TOC entry 792 (class 1259 OID 862529)
-- Name: tbl_svn2_org; Type: TABLE; Schema: sc__buxo; Owner: postgres
--

CREATE TABLE tbl_svn2_org (
    cd_svn numeric(10,0) NOT NULL,
    cd_emp numeric(10,0) NOT NULL,
    nr_mtr_svn character varying(50),
    cd_ltc numeric(10,0),
    ds_ltc character varying(100)
);


ALTER TABLE tbl_svn2_org OWNER TO postgres;

--
-- TOC entry 786 (class 1259 OID 862041)
-- Name: tbl_svn_040; Type: TABLE; Schema: sc__buxo; Owner: postgres
--

CREATE TABLE tbl_svn_040 (
    cd_ltc numeric(10,0) NOT NULL,
    nm_ltc character varying(200),
    nr_mtr character varying(10)
);


ALTER TABLE tbl_svn_040 OWNER TO postgres;

--
-- TOC entry 785 (class 1259 OID 862028)
-- Name: tbl_svn_ltc; Type: TABLE; Schema: sc__buxo; Owner: scan
--

CREATE TABLE tbl_svn_ltc (
    cd_ltc numeric(10,0) NOT NULL,
    ds_ltc character varying NOT NULL
);


ALTER TABLE tbl_svn_ltc OWNER TO scan;

--
-- TOC entry 784 (class 1259 OID 861313)
-- Name: tbl_tel_aux; Type: TABLE; Schema: sc__buxo; Owner: scan
--

CREATE TABLE tbl_tel_aux (
    cpf numeric(14,0) NOT NULL,
    matricula character varying(14) NOT NULL,
    tipo numeric(14,0) NOT NULL,
    ddd numeric(2,0) NOT NULL,
    telefone numeric(10,0) NOT NULL
);


ALTER TABLE tbl_tel_aux OWNER TO scan;

--
-- TOC entry 806 (class 1259 OID 874384)
-- Name: tbl_viper; Type: TABLE; Schema: sc__buxo; Owner: scan
--

CREATE TABLE tbl_viper (
    cpf numeric(11,0) NOT NULL
);


ALTER TABLE tbl_viper OWNER TO scan;

SET search_path = sc_acc, pg_catalog;

--
-- TOC entry 236 (class 1259 OID 564823)
-- Name: sq_crt; Type: SEQUENCE; Schema: sc_acc; Owner: scan
--

CREATE SEQUENCE sq_crt
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 9
    CACHE 1
    CYCLE;


ALTER TABLE sq_crt OWNER TO scan;

--
-- TOC entry 7916 (class 0 OID 0)
-- Dependencies: 236
-- Name: SEQUENCE sq_crt; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON SEQUENCE sq_crt IS 'sequence usada para a geracao do numero do cartao';


--
-- TOC entry 237 (class 1259 OID 564825)
-- Name: sq_hdr; Type: SEQUENCE; Schema: sc_acc; Owner: scan
--

CREATE SEQUENCE sq_hdr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_hdr OWNER TO scan;

--
-- TOC entry 238 (class 1259 OID 564827)
-- Name: sq_hfe; Type: SEQUENCE; Schema: sc_acc; Owner: scan
--

CREATE SEQUENCE sq_hfe
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_hfe OWNER TO scan;

--
-- TOC entry 239 (class 1259 OID 564829)
-- Name: sq_rct; Type: SEQUENCE; Schema: sc_acc; Owner: scan
--

CREATE SEQUENCE sq_rct
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_rct OWNER TO scan;

--
-- TOC entry 240 (class 1259 OID 564831)
-- Name: sq_red; Type: SEQUENCE; Schema: sc_acc; Owner: scan
--

CREATE SEQUENCE sq_red
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_red OWNER TO scan;

--
-- TOC entry 241 (class 1259 OID 564833)
-- Name: sq_rtl; Type: SEQUENCE; Schema: sc_acc; Owner: scan
--

CREATE SEQUENCE sq_rtl
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_rtl OWNER TO scan;

--
-- TOC entry 242 (class 1259 OID 564835)
-- Name: sq_tfe; Type: SEQUENCE; Schema: sc_acc; Owner: scan
--

CREATE SEQUENCE sq_tfe
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_tfe OWNER TO scan;

--
-- TOC entry 243 (class 1259 OID 564837)
-- Name: sq_trl; Type: SEQUENCE; Schema: sc_acc; Owner: scan
--

CREATE SEQUENCE sq_trl
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_trl OWNER TO scan;

--
-- TOC entry 244 (class 1259 OID 564839)
-- Name: tbl_hdr; Type: TABLE; Schema: sc_acc; Owner: scan
--

CREATE TABLE tbl_hdr (
    cd_hdr numeric(10,0) NOT NULL,
    nr_vrs_hdr integer NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    dt_grc_hdr timestamp without time zone NOT NULL,
    cd_rms_hdr numeric(7,0),
    st_hdr numeric(2,0) DEFAULT 1 NOT NULL,
    st_prc_hdr numeric(2,0),
    dt_rcb_hdr timestamp without time zone,
    cd_rcb_usr numeric(10,0)
);


ALTER TABLE tbl_hdr OWNER TO scan;

--
-- TOC entry 7917 (class 0 OID 0)
-- Dependencies: 244
-- Name: TABLE tbl_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON TABLE tbl_hdr IS 'TABELA DE HEADER';


--
-- TOC entry 7918 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN tbl_hdr.cd_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.cd_hdr IS 'CODIGO DO HEADER DO ARQUIVO';


--
-- TOC entry 7919 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN tbl_hdr.nr_vrs_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.nr_vrs_hdr IS 'NUMERO DA VERSAO DO LAYOUT DO ARQUIVO';


--
-- TOC entry 7920 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN tbl_hdr.cd_emp; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.cd_emp IS 'CODIGO DA EMPRESA';


--
-- TOC entry 7921 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN tbl_hdr.dt_grc_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.dt_grc_hdr IS 'DATA DE GERACAO DO ARQUIVO';


--
-- TOC entry 7922 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN tbl_hdr.cd_rms_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.cd_rms_hdr IS 'CODIGO DE REMESSA DO ARQUIVO';


--
-- TOC entry 7923 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN tbl_hdr.st_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.st_hdr IS 'SITUACAO DO HEADER DO ARQUIVO';


--
-- TOC entry 7924 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN tbl_hdr.st_prc_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.st_prc_hdr IS 'SITUACAO DE PROCESSAMENTO DO HEADER DO ARQUIVO';


--
-- TOC entry 7925 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN tbl_hdr.dt_rcb_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.dt_rcb_hdr IS 'DATA DO RECEBIMENTO DO ARQUIVO';


--
-- TOC entry 7926 (class 0 OID 0)
-- Dependencies: 244
-- Name: COLUMN tbl_hdr.cd_rcb_usr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.cd_rcb_usr IS 'USUARIO DO RECEBIMENTO DO ARQUIVO';


--
-- TOC entry 245 (class 1259 OID 564843)
-- Name: tbl_red; Type: TABLE; Schema: sc_acc; Owner: scan
--

CREATE TABLE tbl_red (
    cd_red numeric(10,0) NOT NULL,
    tp_pss_red character(1) NOT NULL,
    nr_cpf_cnpj_red numeric(14,0) NOT NULL,
    cep_red numeric(8,0),
    nr_red character(8),
    tp_edr_red numeric(2,0),
    nm_log_red character varying(50),
    nm_brr_red character varying(50),
    nm_loc_red character varying(50),
    uf_red character(2),
    cpl_red character(30),
    st_red numeric(2,0) DEFAULT 1 NOT NULL,
    st_prc_red numeric(2,0),
    cd_hdr numeric(10,0) NOT NULL,
    cd_hfe numeric(10,0) NOT NULL,
    cd_edr numeric(10,0),
    cd_crt_emp_red character varying(14) NOT NULL,
    CONSTRAINT ck_tp_pss_red CHECK ((tp_pss_red = ANY (ARRAY['F'::bpchar, 'J'::bpchar])))
);


ALTER TABLE tbl_red OWNER TO scan;

--
-- TOC entry 7927 (class 0 OID 0)
-- Dependencies: 245
-- Name: TABLE tbl_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON TABLE tbl_red IS 'TABELA DE REGISTRO DE ENDERECO';


--
-- TOC entry 7928 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.cd_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.cd_red IS 'CODIGO DO REGISTRO DE ENDERECO';


--
-- TOC entry 7929 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.tp_pss_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.tp_pss_red IS 'TIPO DE PESSOA. F - PESSOA FISICA; J - PESSOA JURIDICA';


--
-- TOC entry 7930 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.nr_cpf_cnpj_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.nr_cpf_cnpj_red IS 'CPF (PF) OU CNPJ (PJ)';


--
-- TOC entry 7931 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.cep_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.cep_red IS 'CEP';


--
-- TOC entry 7932 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.nr_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.nr_red IS 'NUMERO DO ENDERECO';


--
-- TOC entry 7933 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.tp_edr_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.tp_edr_red IS 'TIPO DE ENDERECO. VER TABELA DE DOMINIO.';


--
-- TOC entry 7934 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.nm_log_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.nm_log_red IS 'LOGRADOURO';


--
-- TOC entry 7935 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.nm_brr_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.nm_brr_red IS 'BAIRRO';


--
-- TOC entry 7936 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.nm_loc_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.nm_loc_red IS 'LOCALIDADE';


--
-- TOC entry 7937 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.uf_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.uf_red IS 'UF';


--
-- TOC entry 7938 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.cpl_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.cpl_red IS 'COMPLEMENTO DO ENDERECO';


--
-- TOC entry 7939 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.st_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.st_red IS 'SITUACAO. VER TABELA DE DOMINIO.';


--
-- TOC entry 7940 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.st_prc_red; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.st_prc_red IS 'SITUACAO DE PROCESSAMENTO. VER TABELA DE DOMINIO.';


--
-- TOC entry 7941 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.cd_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.cd_hdr IS 'CODIGO DO HEADER';


--
-- TOC entry 7942 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN tbl_red.cd_hfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_red.cd_hfe IS 'CODIGO DO HEADER DE FILIAL';


--
-- TOC entry 246 (class 1259 OID 564848)
-- Name: tbl_rtl; Type: TABLE; Schema: sc_acc; Owner: scan
--

CREATE TABLE tbl_rtl (
    cd_rtl numeric(10,0) NOT NULL,
    tp_pss_rtl character(1) NOT NULL,
    nr_cpf_cnpj_rtl numeric(14,0) NOT NULL,
    cd_crt_emp_rtl character varying(14) NOT NULL,
    tp_tlf_rtl numeric(2,0) NOT NULL,
    nr_tlf_rtl numeric(10,0),
    nr_ddd_rtl numeric(2,0),
    st_rtl numeric(2,0) DEFAULT 1 NOT NULL,
    st_prc_rtl numeric(2,0),
    cd_hdr numeric(10,0) NOT NULL,
    cd_hfe numeric(10,0) NOT NULL,
    cd_tlf numeric(10,0),
    CONSTRAINT ck_tp_pss_rtl CHECK ((tp_pss_rtl = ANY (ARRAY['F'::bpchar, 'J'::bpchar])))
);


ALTER TABLE tbl_rtl OWNER TO scan;

--
-- TOC entry 7943 (class 0 OID 0)
-- Dependencies: 246
-- Name: TABLE tbl_rtl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON TABLE tbl_rtl IS 'TABELA DE REGISTRO DE TELEFONE';


--
-- TOC entry 7944 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN tbl_rtl.cd_rtl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rtl.cd_rtl IS 'CODIGO DO REGISTRO DE TELEFONE';


--
-- TOC entry 7945 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN tbl_rtl.tp_pss_rtl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rtl.tp_pss_rtl IS 'TIPO DE PESSOA. F - PESSOA FISICA; J - PESSOA JURIDICA';


--
-- TOC entry 7946 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN tbl_rtl.nr_cpf_cnpj_rtl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rtl.nr_cpf_cnpj_rtl IS 'CPF (PF) OU CNPJ (PJ)';


--
-- TOC entry 7947 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN tbl_rtl.cd_crt_emp_rtl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rtl.cd_crt_emp_rtl IS 'CODIGO DE IDENTIFICACAO DO CARTAO PARA A EMPRESA';


--
-- TOC entry 7948 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN tbl_rtl.tp_tlf_rtl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rtl.tp_tlf_rtl IS 'TIPO DE TELEFONE. VER TABELA DE DOMINIO.';


--
-- TOC entry 7949 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN tbl_rtl.nr_tlf_rtl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rtl.nr_tlf_rtl IS 'NUMERO DO TELEFONE';


--
-- TOC entry 7950 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN tbl_rtl.nr_ddd_rtl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rtl.nr_ddd_rtl IS 'DDD DO TELEFONE';


--
-- TOC entry 7951 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN tbl_rtl.st_rtl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rtl.st_rtl IS 'SITUACAO. VER TABELA DE DOMINIO.';


--
-- TOC entry 7952 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN tbl_rtl.st_prc_rtl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rtl.st_prc_rtl IS 'SITUACAO DE PROCESSAMENTO. VER TABELA DE DOMINIO.';


--
-- TOC entry 7953 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN tbl_rtl.cd_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rtl.cd_hdr IS 'CODIGO DO HEADER DO ARQUIVO';


--
-- TOC entry 7954 (class 0 OID 0)
-- Dependencies: 246
-- Name: COLUMN tbl_rtl.cd_hfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_rtl.cd_hfe IS 'CODIGO DO HEADER DA FILIAL';


--
-- TOC entry 247 (class 1259 OID 564853)
-- Name: tbl_tfe; Type: TABLE; Schema: sc_acc; Owner: scan
--

CREATE TABLE tbl_tfe (
    cd_tfe numeric(10,0) NOT NULL,
    cd_hdr numeric(10,0) NOT NULL,
    cd_hfe numeric(10,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    cd_fem numeric(5,0) NOT NULL,
    tp_pss_tfe character(1) NOT NULL,
    nr_cpf_cnpj_tfe numeric(14,0) NOT NULL,
    cd_prd numeric(5,0) NOT NULL,
    nr_reg_crt_tfe numeric(5,0),
    nr_reg_edr_tfe numeric(5,0),
    nr_reg_tlf_tfe numeric(5,0),
    st_tfe numeric(2,0) DEFAULT 1 NOT NULL,
    st_prc_tfe numeric(2,0),
    CONSTRAINT ck_tp_pss_tfe CHECK ((tp_pss_tfe = ANY (ARRAY['F'::bpchar, 'J'::bpchar])))
);


ALTER TABLE tbl_tfe OWNER TO scan;

--
-- TOC entry 7955 (class 0 OID 0)
-- Dependencies: 247
-- Name: TABLE tbl_tfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON TABLE tbl_tfe IS 'TABELA DE TRAILLER DE FILIAL';


--
-- TOC entry 7956 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.cd_tfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.cd_tfe IS 'CODIGO DO TRAILLER DA FILIAL';


--
-- TOC entry 7957 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.cd_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.cd_hdr IS 'CODIGO DO HEADER DO ARQUIVO';


--
-- TOC entry 7958 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.cd_hfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.cd_hfe IS 'CODIGO DO HEADER DE FILIAL';


--
-- TOC entry 7959 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.cd_emp; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.cd_emp IS 'CODIGO DA EMPRESA';


--
-- TOC entry 7960 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.cd_fem; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.cd_fem IS 'CODIGO DA FILIAL';


--
-- TOC entry 7961 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.tp_pss_tfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.tp_pss_tfe IS 'TIPO DE PESSOA. F - PESSOA FISICA; J - PESSOA JURIDICA';


--
-- TOC entry 7962 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.nr_cpf_cnpj_tfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.nr_cpf_cnpj_tfe IS 'CPF (PF) OU CNPJ (PJ)';


--
-- TOC entry 7963 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.cd_prd; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.cd_prd IS 'CODIGO DO PRODUTO';


--
-- TOC entry 7964 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.nr_reg_crt_tfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.nr_reg_crt_tfe IS 'NUMERO DE REGISTRO DE CARTAO NA FILIAL';


--
-- TOC entry 7965 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.nr_reg_edr_tfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.nr_reg_edr_tfe IS 'NUMERO DE REGISTROS DE ENDERECOS NA FILIAL';


--
-- TOC entry 7966 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.nr_reg_tlf_tfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.nr_reg_tlf_tfe IS 'NUMERO DE REGISTROS DE TELEFONE NA FILIAL';


--
-- TOC entry 7967 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.st_tfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.st_tfe IS 'SITUACAO. VER TABELA DE DOMINIO.';


--
-- TOC entry 7968 (class 0 OID 0)
-- Dependencies: 247
-- Name: COLUMN tbl_tfe.st_prc_tfe; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.st_prc_tfe IS 'SITUACAO DE PROCESSAMENTO. VER TABELA DE DOMINIO.';


--
-- TOC entry 248 (class 1259 OID 564858)
-- Name: tbl_trl; Type: TABLE; Schema: sc_acc; Owner: scan
--

CREATE TABLE tbl_trl (
    cd_trl numeric(10,0) NOT NULL,
    cd_hdr numeric(10,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    nr_reg_fem_trl numeric(5,0) NOT NULL,
    st_trl numeric(2,0) DEFAULT 1 NOT NULL,
    st_prc_trl numeric(2,0)
);


ALTER TABLE tbl_trl OWNER TO scan;

--
-- TOC entry 7969 (class 0 OID 0)
-- Dependencies: 248
-- Name: TABLE tbl_trl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON TABLE tbl_trl IS 'TABELA DE TRAILLER';


--
-- TOC entry 7970 (class 0 OID 0)
-- Dependencies: 248
-- Name: COLUMN tbl_trl.cd_trl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_trl.cd_trl IS 'CODIGO DO TRAILLER DO ARQUIVO';


--
-- TOC entry 7971 (class 0 OID 0)
-- Dependencies: 248
-- Name: COLUMN tbl_trl.cd_hdr; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_trl.cd_hdr IS 'CODIGO DO HEADER DO ARQUIVO';


--
-- TOC entry 7972 (class 0 OID 0)
-- Dependencies: 248
-- Name: COLUMN tbl_trl.cd_emp; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_trl.cd_emp IS 'CODIGO DA EMPRESA';


--
-- TOC entry 7973 (class 0 OID 0)
-- Dependencies: 248
-- Name: COLUMN tbl_trl.nr_reg_fem_trl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_trl.nr_reg_fem_trl IS 'NUMERO DE REGISTRO DE FILIAL';


--
-- TOC entry 7974 (class 0 OID 0)
-- Dependencies: 248
-- Name: COLUMN tbl_trl.st_trl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_trl.st_trl IS 'SITUACAO. VER TABELA DE DOMINIO.';


--
-- TOC entry 7975 (class 0 OID 0)
-- Dependencies: 248
-- Name: COLUMN tbl_trl.st_prc_trl; Type: COMMENT; Schema: sc_acc; Owner: scan
--

COMMENT ON COLUMN tbl_trl.st_prc_trl IS 'SITUACAO DE PROCESSAMENTO. VER TABELA DE DOMINIO.';


SET search_path = sc_ace, pg_catalog;

--
-- TOC entry 249 (class 1259 OID 564862)
-- Name: sq_det_oboe; Type: SEQUENCE; Schema: sc_ace; Owner: scan
--

CREATE SEQUENCE sq_det_oboe
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_det_oboe OWNER TO scan;

--
-- TOC entry 250 (class 1259 OID 564864)
-- Name: sq_hdr_oboe; Type: SEQUENCE; Schema: sc_ace; Owner: scan
--

CREATE SEQUENCE sq_hdr_oboe
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hdr_oboe OWNER TO scan;

--
-- TOC entry 251 (class 1259 OID 564866)
-- Name: tbl_hdr_oboe; Type: TABLE; Schema: sc_ace; Owner: scan
--

CREATE TABLE tbl_hdr_oboe (
    cd_hdr_oboe numeric(10,0) NOT NULL,
    cd_ident_arq numeric(2,0) NOT NULL,
    cd_tp_arq numeric(2,0) NOT NULL,
    nr_vrs_hdr numeric(3,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    cd_fem numeric(5,0) NOT NULL,
    dt_grc_hdr timestamp without time zone NOT NULL,
    nr_reg_hdr_oboe numeric(14,0) NOT NULL,
    st_hdr_oboe numeric(2,0) DEFAULT 1 NOT NULL,
    cd_hdr numeric(10,0),
    st_prc_hdr_oboe numeric(2,0),
    dt_rcb_hdr_oboe timestamp without time zone,
    cd_rcb_usr numeric(10,0)
);


ALTER TABLE tbl_hdr_oboe OWNER TO scan;

--
-- TOC entry 7976 (class 0 OID 0)
-- Dependencies: 251
-- Name: TABLE tbl_hdr_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON TABLE tbl_hdr_oboe IS 'TABELA DE HEADER DE ARQUIVO DE CADASTRO OBOE';


--
-- TOC entry 7977 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN tbl_hdr_oboe.cd_hdr_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_hdr_oboe.cd_hdr_oboe IS 'CÓDIGO';


--
-- TOC entry 7978 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN tbl_hdr_oboe.cd_ident_arq; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_hdr_oboe.cd_ident_arq IS 'IDENTIFICADOR DE LINHA DO HEADER';


--
-- TOC entry 7979 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN tbl_hdr_oboe.cd_tp_arq; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_hdr_oboe.cd_tp_arq IS 'TIPO DE ARQUIVO. VER TABELA DE DOMINIO';


--
-- TOC entry 7980 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN tbl_hdr_oboe.nr_vrs_hdr; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_hdr_oboe.nr_vrs_hdr IS 'NUMERO DA VERSAO DO LAYOUT';


--
-- TOC entry 7981 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN tbl_hdr_oboe.cd_emp; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_hdr_oboe.cd_emp IS 'CÓDIGO DA EMPRESA';


--
-- TOC entry 7982 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN tbl_hdr_oboe.cd_fem; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_hdr_oboe.cd_fem IS 'CÓDIGO DA FILIAL DE EMPRESA';


--
-- TOC entry 7983 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN tbl_hdr_oboe.dt_grc_hdr; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_hdr_oboe.dt_grc_hdr IS 'DATA DE GERACAO DO ARQUIVO';


--
-- TOC entry 7984 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN tbl_hdr_oboe.nr_reg_hdr_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_hdr_oboe.nr_reg_hdr_oboe IS 'NUMERO DE REGISTROS DO DETALHE';


--
-- TOC entry 7985 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN tbl_hdr_oboe.st_hdr_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_hdr_oboe.st_hdr_oboe IS 'SITUACAO DO HEADER. VER TABELA DE DOMINIO';


--
-- TOC entry 7986 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN tbl_hdr_oboe.cd_hdr; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_hdr_oboe.cd_hdr IS 'CODIGO DO ARQUIVO DE HEADER QUE FOI GERADO A PARTIR DESSE ARQUIVO';


--
-- TOC entry 7987 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN tbl_hdr_oboe.dt_rcb_hdr_oboe; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_hdr_oboe.dt_rcb_hdr_oboe IS 'DATA DO RECEBIMENTO DO ARQUIVO';


--
-- TOC entry 7988 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN tbl_hdr_oboe.cd_rcb_usr; Type: COMMENT; Schema: sc_ace; Owner: scan
--

COMMENT ON COLUMN tbl_hdr_oboe.cd_rcb_usr IS 'USUARIO DO RECEBIMENTO DO ARQUIVO';


SET search_path = sc_adp, pg_catalog;

--
-- TOC entry 252 (class 1259 OID 564870)
-- Name: old_tbl_adp; Type: TABLE; Schema: sc_adp; Owner: scan
--

CREATE TABLE old_tbl_adp (
    cd_adp numeric(10,0) NOT NULL,
    cd_ctr numeric(10,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    cd_fem numeric(5,0) NOT NULL,
    vl_adp numeric(13,2) NOT NULL,
    nr_reg_adp numeric(5,0) NOT NULL,
    vl_vld_adp numeric(13,2) NOT NULL,
    nr_reg_vld_adp numeric(5,0) NOT NULL,
    st_adp numeric(2,0) NOT NULL,
    dt_agd_adp date,
    dt_slc_dps_adp date,
    dt_dps_adp date,
    cd_prd numeric(5,0) NOT NULL,
    tp_err_adp numeric(2,0),
    ds_err_adp character(200)
);


ALTER TABLE old_tbl_adp OWNER TO scan;

--
-- TOC entry 7989 (class 0 OID 0)
-- Dependencies: 252
-- Name: TABLE old_tbl_adp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON TABLE old_tbl_adp IS 'TABELA DE ARQUIVO DE DEPOSITO';


--
-- TOC entry 253 (class 1259 OID 564873)
-- Name: old_tbl_ddp; Type: TABLE; Schema: sc_adp; Owner: scan
--

CREATE TABLE old_tbl_ddp (
    cd_ddp numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    cd_adp numeric(10,0) NOT NULL,
    vl_ddp numeric(13,2) NOT NULL,
    cd_tdp numeric(5,0) NOT NULL,
    st_ddp numeric(2,0) NOT NULL,
    tp_err_ddp numeric(2,0) NOT NULL
);


ALTER TABLE old_tbl_ddp OWNER TO scan;

--
-- TOC entry 7990 (class 0 OID 0)
-- Dependencies: 253
-- Name: TABLE old_tbl_ddp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON TABLE old_tbl_ddp IS 'TABELA DE DETALHE DO DEPOSITO';


--
-- TOC entry 7991 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN old_tbl_ddp.cd_ddp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN old_tbl_ddp.cd_ddp IS 'CODIGO DETALHE DO DEPOSITO';


--
-- TOC entry 7992 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN old_tbl_ddp.cd_crt; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN old_tbl_ddp.cd_crt IS 'CODIGO CARTAO';


--
-- TOC entry 7993 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN old_tbl_ddp.cd_adp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN old_tbl_ddp.cd_adp IS 'CODIGO ARQUIVO DE DEPOSITO';


--
-- TOC entry 7994 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN old_tbl_ddp.vl_ddp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN old_tbl_ddp.vl_ddp IS 'VALOR DO DETALHE DO DEPOSITO';


--
-- TOC entry 7995 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN old_tbl_ddp.cd_tdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN old_tbl_ddp.cd_tdp IS 'CODIGO DO TIPO DE DEPOSITO';


--
-- TOC entry 7996 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN old_tbl_ddp.st_ddp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN old_tbl_ddp.st_ddp IS 'SITUACAO DO DETALHE DO DEPOSITO. VER TABELA DE DOMINIO';


--
-- TOC entry 7997 (class 0 OID 0)
-- Dependencies: 253
-- Name: COLUMN old_tbl_ddp.tp_err_ddp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN old_tbl_ddp.tp_err_ddp IS 'TIPO DE ERRO DO DETALHE DE DEPOSITO. VER TABELA DE DOMINIO';


--
-- TOC entry 254 (class 1259 OID 564876)
-- Name: sq_add; Type: SEQUENCE; Schema: sc_adp; Owner: scan
--

CREATE SEQUENCE sq_add
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_add OWNER TO scan;

--
-- TOC entry 255 (class 1259 OID 564878)
-- Name: sq_hdr; Type: SEQUENCE; Schema: sc_adp; Owner: scan
--

CREATE SEQUENCE sq_hdr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hdr OWNER TO scan;

--
-- TOC entry 256 (class 1259 OID 564880)
-- Name: sq_hdr_tmp; Type: SEQUENCE; Schema: sc_adp; Owner: scan
--

CREATE SEQUENCE sq_hdr_tmp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hdr_tmp OWNER TO scan;

--
-- TOC entry 257 (class 1259 OID 564882)
-- Name: sq_hfe; Type: SEQUENCE; Schema: sc_adp; Owner: scan
--

CREATE SEQUENCE sq_hfe
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hfe OWNER TO scan;

--
-- TOC entry 258 (class 1259 OID 564884)
-- Name: sq_rdp; Type: SEQUENCE; Schema: sc_adp; Owner: scan
--

CREATE SEQUENCE sq_rdp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rdp OWNER TO scan;

--
-- TOC entry 259 (class 1259 OID 564886)
-- Name: sq_rdp_tmp; Type: SEQUENCE; Schema: sc_adp; Owner: scan
--

CREATE SEQUENCE sq_rdp_tmp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rdp_tmp OWNER TO scan;

--
-- TOC entry 260 (class 1259 OID 564888)
-- Name: sq_tfe; Type: SEQUENCE; Schema: sc_adp; Owner: scan
--

CREATE SEQUENCE sq_tfe
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tfe OWNER TO scan;

--
-- TOC entry 261 (class 1259 OID 564890)
-- Name: sq_trl; Type: SEQUENCE; Schema: sc_adp; Owner: scan
--

CREATE SEQUENCE sq_trl
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_trl OWNER TO scan;

--
-- TOC entry 262 (class 1259 OID 564892)
-- Name: tbl_add; Type: TABLE; Schema: sc_adp; Owner: scan
--

CREATE TABLE tbl_add (
    cd_add numeric(10,0) NOT NULL,
    cd_hfe numeric(10,0) NOT NULL,
    dt_ant_dep_add timestamp without time zone NOT NULL,
    dt_atl_dep_add timestamp without time zone NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_add OWNER TO scan;

--
-- TOC entry 7998 (class 0 OID 0)
-- Dependencies: 262
-- Name: TABLE tbl_add; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON TABLE tbl_add IS 'ALTERACAO DE DATA DE DEPOSITO';


--
-- TOC entry 7999 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN tbl_add.cd_add; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_add.cd_add IS 'CODIGO';


--
-- TOC entry 8000 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN tbl_add.cd_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_add.cd_hfe IS 'CODIGO DO ARQUIVO';


--
-- TOC entry 8001 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN tbl_add.dt_ant_dep_add; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_add.dt_ant_dep_add IS 'DATA ANTERIOR DO DEPOSITO';


--
-- TOC entry 8002 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN tbl_add.dt_atl_dep_add; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_add.dt_atl_dep_add IS 'DATA ATUAL DO DEPOSITO';


--
-- TOC entry 8003 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN tbl_add.cd_inc_usr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_add.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8004 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN tbl_add.dt_inc_usr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_add.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 263 (class 1259 OID 564895)
-- Name: tbl_hdr; Type: TABLE; Schema: sc_adp; Owner: scan
--

CREATE TABLE tbl_hdr (
    cd_hdr numeric(10,0) NOT NULL,
    nr_vrs_hdr integer NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    cd_prd numeric(10,0) NOT NULL,
    dt_grc_hdr timestamp without time zone NOT NULL,
    cd_rms_hdr numeric(10,0),
    st_hdr numeric(2,0) DEFAULT 1 NOT NULL,
    cd_ret_hdr numeric(2,0),
    dt_rcb_hdr timestamp without time zone,
    cd_rcb_hdr numeric(10,0) NOT NULL,
    dt_cnc_hdr timestamp without time zone,
    cd_cnc_hdr numeric(10,0)
);


ALTER TABLE tbl_hdr OWNER TO scan;

--
-- TOC entry 8005 (class 0 OID 0)
-- Dependencies: 263
-- Name: TABLE tbl_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON TABLE tbl_hdr IS 'TABELA DE HEADER DO ARQUIVO DE DEPOSITO';


--
-- TOC entry 8006 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN tbl_hdr.cd_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.cd_hdr IS 'CÓDIGO';


--
-- TOC entry 8007 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN tbl_hdr.nr_vrs_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.nr_vrs_hdr IS 'NUMERO DA VERSAO DO LAYOUT DO ARQUIVO';


--
-- TOC entry 8008 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN tbl_hdr.cd_emp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.cd_emp IS 'CÓDIGO DA EMPRESA';


--
-- TOC entry 8009 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN tbl_hdr.cd_prd; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.cd_prd IS 'CÓDIGO DO PRODUTO';


--
-- TOC entry 8010 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN tbl_hdr.dt_grc_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.dt_grc_hdr IS 'DATA DE GERACAO DO ARQUIVO';


--
-- TOC entry 8011 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN tbl_hdr.cd_rms_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.cd_rms_hdr IS 'CODIGO DE REMESSA';


--
-- TOC entry 8012 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN tbl_hdr.st_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.st_hdr IS 'SITUACAO DO HEADER';


--
-- TOC entry 8013 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN tbl_hdr.cd_ret_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.cd_ret_hdr IS 'CODIGO DO RETORNO';


--
-- TOC entry 8014 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN tbl_hdr.dt_rcb_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.dt_rcb_hdr IS 'DATA DO RECEBIMENTO DO ARQUIVO';


--
-- TOC entry 8015 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN tbl_hdr.cd_rcb_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.cd_rcb_hdr IS 'CODIGO DO USUARIO DE RECEBIMENTO DO ARQUIVO';


--
-- TOC entry 264 (class 1259 OID 564899)
-- Name: tbl_hdr_tmp; Type: TABLE; Schema: sc_adp; Owner: scan
--

CREATE TABLE tbl_hdr_tmp (
    cd_hdr numeric(10,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    dt_grc_hdr timestamp without time zone NOT NULL,
    cd_usr numeric(10,0) NOT NULL,
    cd_fem numeric(10,0) NOT NULL,
    cd_tdp numeric(10,0),
    qtd_hdr numeric(10,0) NOT NULL,
    dt_prv_dps_hdr date,
    mes_cpt_hdr character varying(7)
);


ALTER TABLE tbl_hdr_tmp OWNER TO scan;

--
-- TOC entry 8016 (class 0 OID 0)
-- Dependencies: 264
-- Name: TABLE tbl_hdr_tmp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON TABLE tbl_hdr_tmp IS 'TABELA DE HEADER DO ARQUIVO DE DEPOSITO TEMPORARIO';


--
-- TOC entry 265 (class 1259 OID 564902)
-- Name: tbl_hfe; Type: TABLE; Schema: sc_adp; Owner: scan
--

CREATE TABLE tbl_hfe (
    cd_hfe numeric(10,0) NOT NULL,
    cd_hdr numeric(10,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    cd_fem numeric(5,0) NOT NULL,
    tp_pss_hfe character varying(1) NOT NULL,
    nr_cpf_cnpj_hfe numeric(14,0) NOT NULL,
    dt_prv_dep_hfe date,
    st_hfe numeric(2,0) DEFAULT 1 NOT NULL,
    cd_ret_hfe numeric(2,0),
    dt_sit_agd_hfe timestamp without time zone,
    cd_usr_agd_hfe numeric(10,0),
    dt_agd_dps_hfe timestamp without time zone,
    dt_dps_hfe timestamp without time zone,
    cd_ctr numeric(10,0),
    mes_comp_hfe character varying(6) NOT NULL,
    dt_cnc_hfe timestamp without time zone,
    cd_cnc_hfe numeric(10,0),
    cd_fep numeric(10,0),
    cd_tdp numeric(5,0),
    dt_cnc_agd_hfe timestamp without time zone,
    cd_cnc_agd_hfe numeric(10,0),
    fg_cbr_hfe character varying(1),
    dt_sit_vld_hfe timestamp without time zone,
    cd_usr_vld_hfe numeric(10,0),
    dt_vnc_hfe date,
    cd_blt numeric(10,0),
    dt_ini_prc_hfe timestamp without time zone,
    dt_fin_prc_hfe timestamp without time zone,
    fg_dbt_aut_hfe character varying(1),
    fg_ppg_hfe character varying(1) DEFAULT 'N'::character varying,
    CONSTRAINT ck_tp_pss_hfe CHECK (((tp_pss_hfe)::bpchar = ANY (ARRAY['F'::bpchar, 'J'::bpchar])))
);


ALTER TABLE tbl_hfe OWNER TO scan;

--
-- TOC entry 8017 (class 0 OID 0)
-- Dependencies: 265
-- Name: TABLE tbl_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON TABLE tbl_hfe IS 'TABELA DE HEADER DE FILIAL DE EMPRESA DE DEPOSITO';


--
-- TOC entry 8018 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.cd_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_hfe IS 'CÓDIGO';


--
-- TOC entry 8019 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.cd_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_hdr IS 'CÓDIGO DO HEADER';


--
-- TOC entry 8020 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.cd_emp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_emp IS 'CÓDIGO DA EMPRESA';


--
-- TOC entry 8021 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.cd_fem; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_fem IS 'CÓDIGO DA FILIAL DE EMPRESA';


--
-- TOC entry 8022 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.tp_pss_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.tp_pss_hfe IS 'TIPO DE PESSOA';


--
-- TOC entry 8023 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.nr_cpf_cnpj_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.nr_cpf_cnpj_hfe IS 'CPF/CNPJ';


--
-- TOC entry 8024 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.dt_prv_dep_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.dt_prv_dep_hfe IS 'DATA QUE A EMPRESA SOLICITOU O DEPOSITO';


--
-- TOC entry 8025 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.st_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.st_hfe IS 'SITUACAO DO HEADER DA FILIAL';


--
-- TOC entry 8026 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.cd_ret_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_ret_hfe IS 'CODIGO DE RETORNO';


--
-- TOC entry 8027 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.dt_sit_agd_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.dt_sit_agd_hfe IS 'DATA EM QUE O ARQUIVO TEVE A SITUACAO ALTERADA PARA AGENDADO';


--
-- TOC entry 8028 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.cd_usr_agd_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_usr_agd_hfe IS 'CODIGO DO USUARIO QUE AGENDOU O ARQUIVO';


--
-- TOC entry 8029 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.dt_agd_dps_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.dt_agd_dps_hfe IS 'DATA PARA A QUAL O ARQUIVO FOI AGENDADO';


--
-- TOC entry 8030 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.dt_dps_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.dt_dps_hfe IS 'DATA QUE EFETIVAMENTE OCORREU O DEPOSITO';


--
-- TOC entry 8031 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.cd_ctr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_ctr IS 'CODIGO DO CONTRATO';


--
-- TOC entry 8032 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.mes_comp_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.mes_comp_hfe IS 'MES DE COMPETENCIA DO DEPOSITO';


--
-- TOC entry 8033 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.cd_fep; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_fep IS 'Codigo da fatura em que foi cobrado as tarifas de deposito do arquivo';


--
-- TOC entry 8034 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.cd_tdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.cd_tdp IS 'CÓDIGO DO TIPO DE DEPOSITO';


--
-- TOC entry 8035 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.dt_ini_prc_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.dt_ini_prc_hfe IS 'data do inicio do processamento';


--
-- TOC entry 8036 (class 0 OID 0)
-- Dependencies: 265
-- Name: COLUMN tbl_hfe.dt_fin_prc_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_hfe.dt_fin_prc_hfe IS 'data final do processamento';


--
-- TOC entry 266 (class 1259 OID 564907)
-- Name: tbl_rdp; Type: TABLE; Schema: sc_adp; Owner: scan
--

CREATE TABLE tbl_rdp (
    cd_rdp numeric(10,0) NOT NULL,
    cd_hfe numeric(10,0) NOT NULL,
    cd_hdr numeric(10,0) NOT NULL,
    nr_mtr_rdp character varying(14) NOT NULL,
    vl_dep_rdp numeric(10,2) NOT NULL,
    st_rdp numeric(2,0) DEFAULT 1 NOT NULL,
    cd_ret_rdp numeric(2,0),
    cd_crt numeric(14,0),
    cd_tdp numeric(5,0) NOT NULL,
    fg_dps_um_dia_rdp character varying(1),
    cd_fep numeric(10,0),
    dt_ini_prc_rdp timestamp without time zone,
    dt_fin_prc_rdp timestamp without time zone,
    CONSTRAINT "ck_st_rdp_Ecd_crt" CHECK (((st_rdp <> ALL (ARRAY[(2)::numeric, (5)::numeric, (6)::numeric])) OR (cd_crt IS NOT NULL)))
);


ALTER TABLE tbl_rdp OWNER TO scan;

--
-- TOC entry 8037 (class 0 OID 0)
-- Dependencies: 266
-- Name: TABLE tbl_rdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON TABLE tbl_rdp IS 'TABELA DE REGISTRO DE DEPOSITO';


--
-- TOC entry 8038 (class 0 OID 0)
-- Dependencies: 266
-- Name: COLUMN tbl_rdp.cd_rdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_rdp.cd_rdp IS 'CÓDIGO';


--
-- TOC entry 8039 (class 0 OID 0)
-- Dependencies: 266
-- Name: COLUMN tbl_rdp.cd_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_rdp.cd_hfe IS 'CÓDIGO DO HEADER DA FILIAL';


--
-- TOC entry 8040 (class 0 OID 0)
-- Dependencies: 266
-- Name: COLUMN tbl_rdp.cd_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_rdp.cd_hdr IS 'CÓDIGO DO HEADER DO ARQUIVO';


--
-- TOC entry 8041 (class 0 OID 0)
-- Dependencies: 266
-- Name: COLUMN tbl_rdp.nr_mtr_rdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_rdp.nr_mtr_rdp IS 'NUMERO DA MATRICULA';


--
-- TOC entry 8042 (class 0 OID 0)
-- Dependencies: 266
-- Name: COLUMN tbl_rdp.vl_dep_rdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_rdp.vl_dep_rdp IS 'VALOR DO DEPOSITO';


--
-- TOC entry 8043 (class 0 OID 0)
-- Dependencies: 266
-- Name: COLUMN tbl_rdp.st_rdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_rdp.st_rdp IS 'SITUACAO DO REGISTRO';


--
-- TOC entry 8044 (class 0 OID 0)
-- Dependencies: 266
-- Name: COLUMN tbl_rdp.cd_ret_rdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_rdp.cd_ret_rdp IS 'CODIGO DO RETORNO';


--
-- TOC entry 8045 (class 0 OID 0)
-- Dependencies: 266
-- Name: COLUMN tbl_rdp.cd_crt; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_rdp.cd_crt IS 'CODIGO DO CARTAO';


--
-- TOC entry 8046 (class 0 OID 0)
-- Dependencies: 266
-- Name: COLUMN tbl_rdp.cd_tdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_rdp.cd_tdp IS 'CODIGO DO TIPO DE DEPOSITO';


--
-- TOC entry 8047 (class 0 OID 0)
-- Dependencies: 266
-- Name: COLUMN tbl_rdp.fg_dps_um_dia_rdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_rdp.fg_dps_um_dia_rdp IS 'flag deposito até 1 dia da data de liberacao do recebimento de recurso';


--
-- TOC entry 267 (class 1259 OID 564912)
-- Name: tbl_rdp_tmp; Type: TABLE; Schema: sc_adp; Owner: scan
--

CREATE TABLE tbl_rdp_tmp (
    cd_rdp numeric(10,0) NOT NULL,
    cd_hdr numeric(10,0) NOT NULL,
    nr_mtr_rdp character varying(14) NOT NULL,
    vl_dep_rdp numeric(10,2) NOT NULL,
    cd_crt numeric(14,0),
    nm_fnc_rdp character varying(100) NOT NULL
);


ALTER TABLE tbl_rdp_tmp OWNER TO scan;

--
-- TOC entry 8048 (class 0 OID 0)
-- Dependencies: 267
-- Name: TABLE tbl_rdp_tmp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON TABLE tbl_rdp_tmp IS 'TABELA DE REGISTRO DE DEPOSITO TEMPORARIO';


--
-- TOC entry 268 (class 1259 OID 564915)
-- Name: tbl_tdp; Type: TABLE; Schema: sc_adp; Owner: scan
--

CREATE TABLE tbl_tdp (
    cd_tdp numeric(5,0) NOT NULL,
    nm_tdp character(50) NOT NULL,
    fg_dsc_tdp "char" NOT NULL,
    tp_cnt_tdp numeric(2,0) NOT NULL,
    cd_tlc numeric(10,0) NOT NULL,
    fg_atv_tdp character varying(1),
    ds_frm_tdp character varying(50),
    fg_imp_cmp_tdp character varying(1) DEFAULT 'N'::character varying NOT NULL,
    CONSTRAINT ck_fg_dsc_tdp CHECK ((fg_dsc_tdp = ANY (ARRAY['S'::"char", 'N'::"char"])))
);


ALTER TABLE tbl_tdp OWNER TO scan;

--
-- TOC entry 8049 (class 0 OID 0)
-- Dependencies: 268
-- Name: TABLE tbl_tdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON TABLE tbl_tdp IS 'TABELA DE TIPO DE DEPOSITO';


--
-- TOC entry 8050 (class 0 OID 0)
-- Dependencies: 268
-- Name: COLUMN tbl_tdp.cd_tdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.cd_tdp IS 'CODIGO DO TIPO DE DEPOSITO';


--
-- TOC entry 8051 (class 0 OID 0)
-- Dependencies: 268
-- Name: COLUMN tbl_tdp.nm_tdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.nm_tdp IS 'NOME DO TIPO DE DEPOSITO';


--
-- TOC entry 8052 (class 0 OID 0)
-- Dependencies: 268
-- Name: COLUMN tbl_tdp.fg_dsc_tdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.fg_dsc_tdp IS 'FLAG DE DESCONTO DE DIVIDA NO MOMENTO DO DEPOSITO';


--
-- TOC entry 8053 (class 0 OID 0)
-- Dependencies: 268
-- Name: COLUMN tbl_tdp.tp_cnt_tdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.tp_cnt_tdp IS 'TIPO DE CONTA DO CARTAO QUE DEVERA RECEBER O DEPOSITO';


--
-- TOC entry 8054 (class 0 OID 0)
-- Dependencies: 268
-- Name: COLUMN tbl_tdp.cd_tlc; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.cd_tlc IS 'TIPO DE LANCAMENTO REFERENTE AO TIPO DE DEPOSITO';


--
-- TOC entry 8055 (class 0 OID 0)
-- Dependencies: 268
-- Name: COLUMN tbl_tdp.fg_atv_tdp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.fg_atv_tdp IS 'FLAG DE ATIVO';


--
-- TOC entry 269 (class 1259 OID 564919)
-- Name: tbl_tfe; Type: TABLE; Schema: sc_adp; Owner: scan
--

CREATE TABLE tbl_tfe (
    cd_tfe numeric(10,0) NOT NULL,
    cd_hfe numeric(10,0) NOT NULL,
    cd_hdr numeric(10,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    cd_fem numeric(5,0) NOT NULL,
    tp_pss_tfe character varying(1) NOT NULL,
    nr_cpf_cnpj_tfe numeric(14,0) NOT NULL,
    nr_reg_env_tfe numeric(8,0) NOT NULL,
    vl_reg_env_tfe numeric(10,2) NOT NULL,
    nr_reg_dep_tfe numeric(8,0),
    vl_reg_dep_tfe numeric(10,2),
    st_tfe numeric(2,0) DEFAULT 1 NOT NULL,
    cd_ret_tfe numeric(2,0),
    nr_reg_vld_tfe numeric(8,0),
    vl_reg_vld_tfe numeric(10,2),
    vl_trf_tfe numeric(14,2),
    dt_pgt_tfe timestamp without time zone,
    CONSTRAINT ck_tp_pss_tfe CHECK (((tp_pss_tfe)::bpchar = ANY (ARRAY['F'::bpchar, 'J'::bpchar])))
);


ALTER TABLE tbl_tfe OWNER TO scan;

--
-- TOC entry 8056 (class 0 OID 0)
-- Dependencies: 269
-- Name: TABLE tbl_tfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON TABLE tbl_tfe IS 'TABELA DE TRAILLER DE FILIAL DE EMPRESA DE DEPOSITO';


--
-- TOC entry 8057 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.cd_tfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.cd_tfe IS 'CÓDIGO DO TRAILLER DA FILIAL DE EMPRESA DO DEPOSITO';


--
-- TOC entry 8058 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.cd_hfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.cd_hfe IS 'CÓDIGO DO HEADER DA FILIAL DA EMPRESA';


--
-- TOC entry 8059 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.cd_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.cd_hdr IS 'CÓDIGO DO HEADER';


--
-- TOC entry 8060 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.cd_emp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.cd_emp IS 'CÓDIGO DA EMPRESA';


--
-- TOC entry 8061 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.cd_fem; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.cd_fem IS 'CÓDIGO DA FILIAL DE EMPRESA';


--
-- TOC entry 8062 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.tp_pss_tfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.tp_pss_tfe IS 'TIPO DE PESSOA';


--
-- TOC entry 8063 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.nr_cpf_cnpj_tfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.nr_cpf_cnpj_tfe IS 'CPF/CNPJ';


--
-- TOC entry 8064 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.nr_reg_env_tfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.nr_reg_env_tfe IS 'NUMERO DE REGISTROS DE DEPOSITO ENVIADOS DA FILIAL';


--
-- TOC entry 8065 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.vl_reg_env_tfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.vl_reg_env_tfe IS 'VALOR TOTAL DE DEPOSITO ENVIADO DA FILIAL';


--
-- TOC entry 8066 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.nr_reg_dep_tfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.nr_reg_dep_tfe IS 'NUMERO DE REGISTROS QUE FORAM DEPOSITADOS NO ARQUIVO';


--
-- TOC entry 8067 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.vl_reg_dep_tfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.vl_reg_dep_tfe IS 'VALOR TOTAL DEPOSITADOS NO ARQUIVO';


--
-- TOC entry 8068 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.st_tfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.st_tfe IS 'SITUACAO DO TRAILLER DA FILIAL';


--
-- TOC entry 8069 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.cd_ret_tfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.cd_ret_tfe IS 'CODIGO DO RETORNO';


--
-- TOC entry 8070 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.nr_reg_vld_tfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.nr_reg_vld_tfe IS 'NÚMEROS DE REGISTROS VALIDOS';


--
-- TOC entry 8071 (class 0 OID 0)
-- Dependencies: 269
-- Name: COLUMN tbl_tfe.vl_reg_vld_tfe; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_tfe.vl_reg_vld_tfe IS 'VALOR DOS REGISTROS VALIDOS';


--
-- TOC entry 270 (class 1259 OID 564924)
-- Name: tbl_trl; Type: TABLE; Schema: sc_adp; Owner: scan
--

CREATE TABLE tbl_trl (
    cd_trl numeric(10,0) NOT NULL,
    cd_hdr numeric(10,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    cd_prd numeric(10,0) NOT NULL,
    nr_fem_trl numeric(8,0) NOT NULL,
    nr_reg_env_trl numeric(8,0) NOT NULL,
    vl_reg_env_trl numeric(10,2) NOT NULL,
    nr_reg_dep_trl numeric(8,0),
    vl_reg_dep_trl numeric(10,2),
    st_trl numeric(2,0) DEFAULT 1 NOT NULL,
    cd_ret_trl numeric(2,0)
);


ALTER TABLE tbl_trl OWNER TO scan;

--
-- TOC entry 8072 (class 0 OID 0)
-- Dependencies: 270
-- Name: TABLE tbl_trl; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON TABLE tbl_trl IS 'TABELA DE TRAILLER DO ARQUIVO DE DEPOSITO';


--
-- TOC entry 8073 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN tbl_trl.cd_trl; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_trl.cd_trl IS 'CÓDIGO';


--
-- TOC entry 8074 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN tbl_trl.cd_hdr; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_trl.cd_hdr IS 'CÓDIGO DO HEADER DO ARQUIVO';


--
-- TOC entry 8075 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN tbl_trl.cd_emp; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_trl.cd_emp IS 'CÓDIGO DA EMPRESA';


--
-- TOC entry 8076 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN tbl_trl.cd_prd; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_trl.cd_prd IS 'CÓDIGO DO PRODUTO';


--
-- TOC entry 8077 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN tbl_trl.nr_fem_trl; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_trl.nr_fem_trl IS 'NUMERO DE FILIAIS ENVIADAS NO ARQUIVO';


--
-- TOC entry 8078 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN tbl_trl.nr_reg_env_trl; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_trl.nr_reg_env_trl IS 'NUMERO DE REGISTROS DE DEPOSITO ENVIADOS DO ARQUIVO';


--
-- TOC entry 8079 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN tbl_trl.vl_reg_env_trl; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_trl.vl_reg_env_trl IS 'VALOR TOTAL DE DEPOSITO ENVIADO DO ARQUIVO';


--
-- TOC entry 8080 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN tbl_trl.nr_reg_dep_trl; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_trl.nr_reg_dep_trl IS 'NUMERO DE REGISTROS DEPOSITADOS DO ARQUIVO';


--
-- TOC entry 8081 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN tbl_trl.vl_reg_dep_trl; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_trl.vl_reg_dep_trl IS 'VALOR TOTAL DEPOSITADOS DO ARQUIVO';


--
-- TOC entry 8082 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN tbl_trl.st_trl; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_trl.st_trl IS 'SITUACAO DO TRAILLER DO ARQUIVO';


--
-- TOC entry 8083 (class 0 OID 0)
-- Dependencies: 270
-- Name: COLUMN tbl_trl.cd_ret_trl; Type: COMMENT; Schema: sc_adp; Owner: scan
--

COMMENT ON COLUMN tbl_trl.cd_ret_trl IS 'CODIGO DO RETORNO';


SET search_path = sc_aeo, pg_catalog;

--
-- TOC entry 271 (class 1259 OID 564928)
-- Name: sq_aeo; Type: SEQUENCE; Schema: sc_aeo; Owner: scan
--

CREATE SEQUENCE sq_aeo
    START WITH 1
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 999999999999
    CACHE 1;


ALTER TABLE sq_aeo OWNER TO scan;

--
-- TOC entry 272 (class 1259 OID 564930)
-- Name: sq_aeop; Type: SEQUENCE; Schema: sc_aeo; Owner: scan
--

CREATE SEQUENCE sq_aeop
    START WITH 1
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 999999999999
    CACHE 1;


ALTER TABLE sq_aeop OWNER TO scan;

--
-- TOC entry 273 (class 1259 OID 564932)
-- Name: sq_eop; Type: SEQUENCE; Schema: sc_aeo; Owner: scan
--

CREATE SEQUENCE sq_eop
    START WITH 1
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 999999999999
    CACHE 1;


ALTER TABLE sq_eop OWNER TO scan;

--
-- TOC entry 274 (class 1259 OID 564934)
-- Name: tbl_aeo; Type: TABLE; Schema: sc_aeo; Owner: scan
--

CREATE TABLE tbl_aeo (
    cd_aeo numeric(10,0) NOT NULL,
    dt_grc_aeo timestamp without time zone NOT NULL,
    dt_ref_aeo timestamp without time zone NOT NULL,
    st_aeo numeric(2,0) DEFAULT 1 NOT NULL,
    vl_prc_aeo numeric(13,2) NOT NULL,
    vl_ttl_aeo numeric(13,2) NOT NULL,
    qt_opr_aeo numeric(5,0) NOT NULL
);


ALTER TABLE tbl_aeo OWNER TO scan;

--
-- TOC entry 8084 (class 0 OID 0)
-- Dependencies: 274
-- Name: TABLE tbl_aeo; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON TABLE tbl_aeo IS 'tabela de lote de exportacao de operacao';


--
-- TOC entry 8085 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN tbl_aeo.cd_aeo; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeo.cd_aeo IS 'codigo';


--
-- TOC entry 8086 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN tbl_aeo.dt_grc_aeo; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeo.dt_grc_aeo IS 'data de geracao';


--
-- TOC entry 8087 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN tbl_aeo.dt_ref_aeo; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeo.dt_ref_aeo IS 'data de referencia';


--
-- TOC entry 8088 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN tbl_aeo.st_aeo; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeo.st_aeo IS 'situacao (ver tabela de dominio)';


--
-- TOC entry 8089 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN tbl_aeo.vl_prc_aeo; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeo.vl_prc_aeo IS 'valor total de principal das operacoes exportadas';


--
-- TOC entry 8090 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN tbl_aeo.vl_ttl_aeo; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeo.vl_ttl_aeo IS 'valor total das operacoes exportadas';


--
-- TOC entry 8091 (class 0 OID 0)
-- Dependencies: 274
-- Name: COLUMN tbl_aeo.qt_opr_aeo; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeo.qt_opr_aeo IS 'quantidade de operacoes exportadas';


--
-- TOC entry 275 (class 1259 OID 564938)
-- Name: tbl_aeop; Type: TABLE; Schema: sc_aeo; Owner: scan
--

CREATE TABLE tbl_aeop (
    cd_aeop numeric(10,0) NOT NULL,
    seq_aeop numeric(2,0) NOT NULL,
    dt_ref_aeop date NOT NULL,
    dt_grc_aeop timestamp without time zone NOT NULL,
    st_aeop numeric(2,0) DEFAULT 1 NOT NULL,
    vl_slc_aeop numeric(13,2) NOT NULL,
    vl_lib_aeop numeric(13,2) NOT NULL,
    vl_ttl_aeop numeric(13,2) NOT NULL,
    qt_opr_aeop numeric(5,0) NOT NULL,
    cd_ccr numeric(10,0),
    dt_dps_aeop date,
    dt_ctb_aeop timestamp without time zone,
    vl_fee_aeop numeric(13,2),
    cd_ivt numeric(10,0) DEFAULT 2 NOT NULL,
    dt_cmp_ccb_aeop timestamp without time zone,
    cd_ccr_cmp_aeop numeric(10,0),
    vl_trf_fnc_aeop numeric(13,2)
);


ALTER TABLE tbl_aeop OWNER TO scan;

--
-- TOC entry 8092 (class 0 OID 0)
-- Dependencies: 275
-- Name: TABLE tbl_aeop; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON TABLE tbl_aeop IS 'tabela de lote de remessa do bracce';


--
-- TOC entry 8093 (class 0 OID 0)
-- Dependencies: 275
-- Name: COLUMN tbl_aeop.cd_aeop; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeop.cd_aeop IS 'codigo';


--
-- TOC entry 8094 (class 0 OID 0)
-- Dependencies: 275
-- Name: COLUMN tbl_aeop.seq_aeop; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeop.seq_aeop IS 'sequencial diario';


--
-- TOC entry 8095 (class 0 OID 0)
-- Dependencies: 275
-- Name: COLUMN tbl_aeop.dt_ref_aeop; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeop.dt_ref_aeop IS 'data de referencia';


--
-- TOC entry 8096 (class 0 OID 0)
-- Dependencies: 275
-- Name: COLUMN tbl_aeop.dt_grc_aeop; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeop.dt_grc_aeop IS 'data de geracao';


--
-- TOC entry 8097 (class 0 OID 0)
-- Dependencies: 275
-- Name: COLUMN tbl_aeop.st_aeop; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeop.st_aeop IS 'situacao (ver tabela de dominio)';


--
-- TOC entry 8098 (class 0 OID 0)
-- Dependencies: 275
-- Name: COLUMN tbl_aeop.vl_slc_aeop; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeop.vl_slc_aeop IS 'valor total solicitado das operacoes exportadas';


--
-- TOC entry 8099 (class 0 OID 0)
-- Dependencies: 275
-- Name: COLUMN tbl_aeop.vl_lib_aeop; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeop.vl_lib_aeop IS 'valor total liberado das operacoes exportadas';


--
-- TOC entry 8100 (class 0 OID 0)
-- Dependencies: 275
-- Name: COLUMN tbl_aeop.vl_ttl_aeop; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeop.vl_ttl_aeop IS 'valor total das operacoes exportadas';


--
-- TOC entry 8101 (class 0 OID 0)
-- Dependencies: 275
-- Name: COLUMN tbl_aeop.qt_opr_aeop; Type: COMMENT; Schema: sc_aeo; Owner: scan
--

COMMENT ON COLUMN tbl_aeop.qt_opr_aeop IS 'quantidade de operacoes exportadas';


--
-- TOC entry 276 (class 1259 OID 564943)
-- Name: tbl_eop; Type: TABLE; Schema: sc_aeo; Owner: scan
--

CREATE TABLE tbl_eop (
    cd_eop numeric(10,0) NOT NULL,
    dt_grc_eop timestamp without time zone NOT NULL,
    cd_opr numeric(10,0) NOT NULL,
    nr_cpf_eop numeric(16,0),
    nm_eop character varying(100),
    vl_tx_eop numeric(10,4),
    trf_eop numeric(13,2),
    iof_eop numeric(13,4),
    vl_slc_eop numeric(13,4),
    vl_opr_eop numeric(13,2),
    qtd_prc_eop numeric(13,2),
    vl_prc_eop numeric(13,2),
    vl_lib_eop numeric(13,2),
    dt_opr_eop timestamp without time zone,
    dt_vnc_opr_eop date,
    dt_base_eop date,
    dt_vnc_eop date,
    rg_eop numeric(20,0),
    uf_rg_eop character(2),
    org_ems_rg_eop character(20),
    dt_ems_rg_eop date,
    cd_est_civ_eop numeric(1,0),
    dt_nsc_eop date,
    cd_nac_eop numeric(2,0),
    cep_eop numeric(8,0),
    log_edr_eop character varying(100),
    nr_edr_eop character varying(8),
    cpl_edr_eop character varying(50),
    brr_edr_eop character varying(50),
    loc_edr_eop character varying(50),
    uf_edr_eop character varying(50),
    rnd_msl_eop numeric(13,2),
    sexo_eop character(1),
    tlf_eop numeric(14,0),
    cd_aeop numeric(10,0),
    dt_rps_eop timestamp without time zone
);


ALTER TABLE tbl_eop OWNER TO scan;

--
-- TOC entry 277 (class 1259 OID 564946)
-- Name: tbl_ivt; Type: TABLE; Schema: sc_aeo; Owner: scan
--

CREATE TABLE tbl_ivt (
    cd_ivt numeric(10,0) NOT NULL,
    nm_ivt character varying(50) NOT NULL
);


ALTER TABLE tbl_ivt OWNER TO scan;

SET search_path = sc_analise, pg_catalog;

--
-- TOC entry 988 (class 1259 OID 1667134)
-- Name: tbl_cartoes_mes; Type: TABLE; Schema: sc_analise; Owner: scan
--

CREATE TABLE tbl_cartoes_mes (
    codigo bigint NOT NULL,
    cartao numeric(14,0),
    mes integer,
    ano integer,
    qtde_mes_ativacao integer,
    qtde_reativacao integer,
    qtde_mes_deposito integer,
    qtde_deposito integer,
    valor_deposito double precision,
    ativo character(1),
    data_ultimo_deposito timestamp without time zone
);


ALTER TABLE tbl_cartoes_mes OWNER TO scan;

--
-- TOC entry 8102 (class 0 OID 0)
-- Dependencies: 988
-- Name: TABLE tbl_cartoes_mes; Type: COMMENT; Schema: sc_analise; Owner: scan
--

COMMENT ON TABLE tbl_cartoes_mes IS 'tabela que armazena mes a mes dados relevantes para analise do comportamento dos cartoes';


--
-- TOC entry 8103 (class 0 OID 0)
-- Dependencies: 988
-- Name: COLUMN tbl_cartoes_mes.qtde_mes_ativacao; Type: COMMENT; Schema: sc_analise; Owner: scan
--

COMMENT ON COLUMN tbl_cartoes_mes.qtde_mes_ativacao IS 'quantidade de mes que o cartao foi ativado, ou seja, recebeu o primeiro depósito';


--
-- TOC entry 8104 (class 0 OID 0)
-- Dependencies: 988
-- Name: COLUMN tbl_cartoes_mes.qtde_reativacao; Type: COMMENT; Schema: sc_analise; Owner: scan
--

COMMENT ON COLUMN tbl_cartoes_mes.qtde_reativacao IS 'quantidade de vezes que o cartao foi reativado';


--
-- TOC entry 8105 (class 0 OID 0)
-- Dependencies: 988
-- Name: COLUMN tbl_cartoes_mes.qtde_mes_deposito; Type: COMMENT; Schema: sc_analise; Owner: scan
--

COMMENT ON COLUMN tbl_cartoes_mes.qtde_mes_deposito IS 'quantidade de meses com deposito';


--
-- TOC entry 8106 (class 0 OID 0)
-- Dependencies: 988
-- Name: COLUMN tbl_cartoes_mes.qtde_deposito; Type: COMMENT; Schema: sc_analise; Owner: scan
--

COMMENT ON COLUMN tbl_cartoes_mes.qtde_deposito IS 'quantidade de depositos no mes';


--
-- TOC entry 8107 (class 0 OID 0)
-- Dependencies: 988
-- Name: COLUMN tbl_cartoes_mes.valor_deposito; Type: COMMENT; Schema: sc_analise; Owner: scan
--

COMMENT ON COLUMN tbl_cartoes_mes.valor_deposito IS 'valor do deposito no mes';


--
-- TOC entry 8108 (class 0 OID 0)
-- Dependencies: 988
-- Name: COLUMN tbl_cartoes_mes.ativo; Type: COMMENT; Schema: sc_analise; Owner: scan
--

COMMENT ON COLUMN tbl_cartoes_mes.ativo IS 'S - ativo; N - inativo';


--
-- TOC entry 987 (class 1259 OID 1667132)
-- Name: tbl_cartoes_mes_codigo_seq; Type: SEQUENCE; Schema: sc_analise; Owner: scan
--

CREATE SEQUENCE tbl_cartoes_mes_codigo_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE tbl_cartoes_mes_codigo_seq OWNER TO scan;

--
-- TOC entry 8109 (class 0 OID 0)
-- Dependencies: 987
-- Name: tbl_cartoes_mes_codigo_seq; Type: SEQUENCE OWNED BY; Schema: sc_analise; Owner: scan
--

ALTER SEQUENCE tbl_cartoes_mes_codigo_seq OWNED BY tbl_cartoes_mes.codigo;


SET search_path = sc_atb, pg_catalog;

--
-- TOC entry 278 (class 1259 OID 564949)
-- Name: sq_art; Type: SEQUENCE; Schema: sc_atb; Owner: scan
--

CREATE SEQUENCE sq_art
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_art OWNER TO scan;

--
-- TOC entry 279 (class 1259 OID 564951)
-- Name: sq_atb; Type: SEQUENCE; Schema: sc_atb; Owner: scan
--

CREATE SEQUENCE sq_atb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_atb OWNER TO scan;

--
-- TOC entry 280 (class 1259 OID 564953)
-- Name: sq_drt; Type: SEQUENCE; Schema: sc_atb; Owner: scan
--

CREATE SEQUENCE sq_drt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_drt OWNER TO scan;

--
-- TOC entry 281 (class 1259 OID 564955)
-- Name: sq_dtb; Type: SEQUENCE; Schema: sc_atb; Owner: scan
--

CREATE SEQUENCE sq_dtb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_dtb OWNER TO scan;

--
-- TOC entry 282 (class 1259 OID 564957)
-- Name: sq_etb; Type: SEQUENCE; Schema: sc_atb; Owner: scan
--

CREATE SEQUENCE sq_etb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_etb OWNER TO scan;

--
-- TOC entry 283 (class 1259 OID 564959)
-- Name: sq_hlt; Type: SEQUENCE; Schema: sc_atb; Owner: scan
--

CREATE SEQUENCE sq_hlt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_hlt OWNER TO scan;

--
-- TOC entry 284 (class 1259 OID 564961)
-- Name: sq_tba; Type: SEQUENCE; Schema: sc_atb; Owner: scan
--

CREATE SEQUENCE sq_tba
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_tba OWNER TO scan;

--
-- TOC entry 285 (class 1259 OID 564963)
-- Name: tbl_etb; Type: TABLE; Schema: sc_atb; Owner: scan
--

CREATE TABLE tbl_etb (
    cd_etb numeric(10,0) NOT NULL,
    cd_tba numeric(10,0) NOT NULL,
    cd_ctr numeric(10,0),
    vl_trf_etb numeric(13,2) NOT NULL,
    cd_fep numeric(10,0),
    cd_fnc numeric(10,0),
    fg_cbr_etb character varying(1)
);


ALTER TABLE tbl_etb OWNER TO scan;

--
-- TOC entry 8110 (class 0 OID 0)
-- Dependencies: 285
-- Name: TABLE tbl_etb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON TABLE tbl_etb IS 'TABELA DE EXTENSAO DE TRANSFERENCIA BANCARIA';


--
-- TOC entry 8111 (class 0 OID 0)
-- Dependencies: 285
-- Name: COLUMN tbl_etb.cd_etb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_etb.cd_etb IS 'CODIGO';


--
-- TOC entry 8112 (class 0 OID 0)
-- Dependencies: 285
-- Name: COLUMN tbl_etb.cd_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_etb.cd_tba IS 'TRANSFERENCIA BANCARIA';


--
-- TOC entry 8113 (class 0 OID 0)
-- Dependencies: 285
-- Name: COLUMN tbl_etb.cd_ctr; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_etb.cd_ctr IS 'CONTRATO';


--
-- TOC entry 8114 (class 0 OID 0)
-- Dependencies: 285
-- Name: COLUMN tbl_etb.vl_trf_etb; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_etb.vl_trf_etb IS 'VALOR DA TARIFA';


--
-- TOC entry 8115 (class 0 OID 0)
-- Dependencies: 285
-- Name: COLUMN tbl_etb.cd_fep; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_etb.cd_fep IS 'FATURA EMPRESA';


--
-- TOC entry 8116 (class 0 OID 0)
-- Dependencies: 285
-- Name: COLUMN tbl_etb.cd_fnc; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_etb.cd_fnc IS 'FUNCIONARIO';


--
-- TOC entry 286 (class 1259 OID 564966)
-- Name: tbl_hlt; Type: TABLE; Schema: sc_atb; Owner: scan
--

CREATE TABLE tbl_hlt (
    cd_art numeric(10,0) NOT NULL,
    cd_hlt numeric(10,0) NOT NULL,
    nr_lte_hlt numeric(5,0) NOT NULL,
    tp_srv_hlt numeric(2,0) NOT NULL,
    frm_lcn_hlt numeric(2,0) NOT NULL
);


ALTER TABLE tbl_hlt OWNER TO scan;

--
-- TOC entry 8117 (class 0 OID 0)
-- Dependencies: 286
-- Name: TABLE tbl_hlt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON TABLE tbl_hlt IS 'tabela de header de lote do arquivo de retorno de transferencia';


--
-- TOC entry 8118 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN tbl_hlt.cd_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_hlt.cd_art IS 'codigo do arquivo';


--
-- TOC entry 8119 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN tbl_hlt.cd_hlt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_hlt.cd_hlt IS 'codigo';


--
-- TOC entry 8120 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN tbl_hlt.nr_lte_hlt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_hlt.nr_lte_hlt IS 'numero do lote';


--
-- TOC entry 8121 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN tbl_hlt.tp_srv_hlt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_hlt.tp_srv_hlt IS 'tipo de servico';


--
-- TOC entry 8122 (class 0 OID 0)
-- Dependencies: 286
-- Name: COLUMN tbl_hlt.frm_lcn_hlt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_hlt.frm_lcn_hlt IS 'forma de lancamento (ver tabela de dominio)';


--
-- TOC entry 287 (class 1259 OID 564969)
-- Name: tbl_ort; Type: TABLE; Schema: sc_atb; Owner: scan
--

CREATE TABLE tbl_ort (
    cd_ort character varying(2) NOT NULL,
    ds_rdz_ort character varying(70) NOT NULL,
    ds_ort character varying(4000) NOT NULL
);


ALTER TABLE tbl_ort OWNER TO scan;

--
-- TOC entry 8123 (class 0 OID 0)
-- Dependencies: 287
-- Name: TABLE tbl_ort; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON TABLE tbl_ort IS 'tabela de ocorrencias de retorno de do arquivo de transferencia';


--
-- TOC entry 8124 (class 0 OID 0)
-- Dependencies: 287
-- Name: COLUMN tbl_ort.cd_ort; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_ort.cd_ort IS 'codigo';


--
-- TOC entry 8125 (class 0 OID 0)
-- Dependencies: 287
-- Name: COLUMN tbl_ort.ds_rdz_ort; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_ort.ds_rdz_ort IS 'descricao reduzida';


--
-- TOC entry 8126 (class 0 OID 0)
-- Dependencies: 287
-- Name: COLUMN tbl_ort.ds_ort; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_ort.ds_ort IS 'descricao';


--
-- TOC entry 288 (class 1259 OID 564975)
-- Name: tbl_tba; Type: TABLE; Schema: sc_atb; Owner: scan
--

CREATE TABLE tbl_tba (
    cd_ccr numeric(5,0) NOT NULL,
    cd_tba numeric(20,0) NOT NULL,
    cd_bnc numeric(5,0) NOT NULL,
    nr_agc_tba numeric(20,0) NOT NULL,
    nr_dgt_agc_tba character varying(1) NOT NULL,
    nr_cba_tba numeric(20,0) NOT NULL,
    nr_dgt_cba_tba character varying(2) NOT NULL,
    nr_cpf_cnpj_tba numeric(14,0) NOT NULL,
    nm_tba character varying(100) NOT NULL,
    tp_pss_tba character varying(1) NOT NULL,
    cd_sst numeric(5,0) NOT NULL,
    nr_nsu_org_tba numeric(20,0) NOT NULL,
    cd_dbt_cnt numeric(10,0) NOT NULL,
    cd_crd_cnt numeric(10,0) NOT NULL,
    ds_mtv_cad_tba character varying(400) NOT NULL,
    ds_mtv_cnc_tba character varying(400),
    ds_mtv_rjc_tba character varying(400),
    vl_tba numeric(13,2) NOT NULL,
    vl_trf_tba numeric(13,2) NOT NULL,
    st_tba numeric(2,0) DEFAULT 1 NOT NULL,
    tp_cba_tba numeric(2,0) NOT NULL,
    cd_inc_usr numeric(5,0) NOT NULL,
    cd_aut_usr numeric(5,0),
    dt_aut_usr timestamp without time zone,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_cnc_usr numeric(5,0),
    dt_cnc_usr timestamp without time zone,
    dt_env_tba timestamp without time zone,
    dt_dps_tba timestamp without time zone,
    dt_rjc_tba timestamp without time zone,
    fg_pgt_tba character varying(1) DEFAULT 'N'::character varying NOT NULL,
    cd_fep numeric(10,0),
    cd_dtb numeric(20,0)
);


ALTER TABLE tbl_tba OWNER TO scan;

--
-- TOC entry 8127 (class 0 OID 0)
-- Dependencies: 288
-- Name: TABLE tbl_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON TABLE tbl_tba IS 'tabela de transferência bancária';


--
-- TOC entry 8128 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.cd_ccr; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.cd_ccr IS 'conta corrente';


--
-- TOC entry 8129 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.cd_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.cd_tba IS 'código';


--
-- TOC entry 8130 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.cd_bnc; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.cd_bnc IS 'banco destino';


--
-- TOC entry 8131 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.nr_agc_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.nr_agc_tba IS 'numero da agencia de destino';


--
-- TOC entry 8132 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.nr_dgt_agc_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.nr_dgt_agc_tba IS 'digito verificador da agencia de destino';


--
-- TOC entry 8133 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.nr_cba_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.nr_cba_tba IS 'numero da conta bancaria de destino';


--
-- TOC entry 8134 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.nr_dgt_cba_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.nr_dgt_cba_tba IS 'numero do digito verificador da conta bancaria de destino';


--
-- TOC entry 8135 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.nr_cpf_cnpj_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.nr_cpf_cnpj_tba IS 'numero do cpf/cnpj do titular da conta bancaria de destino';


--
-- TOC entry 8136 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.nm_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.nm_tba IS 'nome do titular da conta bancaria de destino';


--
-- TOC entry 8137 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.tp_pss_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.tp_pss_tba IS 'tipo de pessoa do titular da conta bancaria de destino';


--
-- TOC entry 8138 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.cd_sst; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.cd_sst IS 'sistema que originou a transferencia bancaria';


--
-- TOC entry 8139 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.nr_nsu_org_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.nr_nsu_org_tba IS 'numero do NSU de origem';


--
-- TOC entry 8140 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.cd_dbt_cnt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.cd_dbt_cnt IS 'codigo da conta que recebeu o lancamento de debito da transferencia';


--
-- TOC entry 8141 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.cd_crd_cnt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.cd_crd_cnt IS 'codigo da conta que recebeu o lancamento de credito da transferencia';


--
-- TOC entry 8142 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.ds_mtv_cad_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.ds_mtv_cad_tba IS 'motivo do cadastro da transferencia';


--
-- TOC entry 8143 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.ds_mtv_cnc_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.ds_mtv_cnc_tba IS 'motivo do cancelamento da transferencia';


--
-- TOC entry 8144 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.ds_mtv_rjc_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.ds_mtv_rjc_tba IS 'motivo da rejeicao da transferencia';


--
-- TOC entry 8145 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.vl_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.vl_tba IS 'valor da transferencia';


--
-- TOC entry 8146 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.vl_trf_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.vl_trf_tba IS 'valor cobrado de tarifa pela transferencia';


--
-- TOC entry 8147 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.st_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.st_tba IS 'situacao da transferencia (ver tabela de dominio)';


--
-- TOC entry 8148 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.tp_cba_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.tp_cba_tba IS 'tipo de conta bancari da transferencia (ver tabela de dominio)';


--
-- TOC entry 8149 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.cd_inc_usr; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8150 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.cd_aut_usr; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.cd_aut_usr IS 'codigo do usuario de autorizacao';


--
-- TOC entry 8151 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.dt_aut_usr; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.dt_aut_usr IS 'data da autorizacao da transferencia';


--
-- TOC entry 8152 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.dt_inc_usr; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8153 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.cd_cnc_usr; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.cd_cnc_usr IS 'usuario de cancelamento';


--
-- TOC entry 8154 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.dt_cnc_usr; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.dt_cnc_usr IS 'data de cancelamento';


--
-- TOC entry 8155 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.dt_env_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.dt_env_tba IS 'data do envio para o banco da transferencia';


--
-- TOC entry 8156 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.dt_dps_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.dt_dps_tba IS 'data da confirmacao de deposito da transferencia';


--
-- TOC entry 8157 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.dt_rjc_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.dt_rjc_tba IS 'data da rejeicao da transferencia';


--
-- TOC entry 8158 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.fg_pgt_tba; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.fg_pgt_tba IS 'flag de pagamento da transferencia';


--
-- TOC entry 8159 (class 0 OID 0)
-- Dependencies: 288
-- Name: COLUMN tbl_tba.cd_fep; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tba.cd_fep IS 'codigo da fatura de empresa onde esta transferencia foi cobrada';


--
-- TOC entry 289 (class 1259 OID 564983)
-- Name: tbl_tlt; Type: TABLE; Schema: sc_atb; Owner: scan
--

CREATE TABLE tbl_tlt (
    cd_art numeric(10,0) NOT NULL,
    cd_hlt numeric(10,0) NOT NULL,
    qt_rgt_tlt numeric(6,0) NOT NULL,
    vl_rgt_tlt numeric(13,2) NOT NULL
);


ALTER TABLE tbl_tlt OWNER TO scan;

--
-- TOC entry 8160 (class 0 OID 0)
-- Dependencies: 289
-- Name: TABLE tbl_tlt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON TABLE tbl_tlt IS 'tabela de trailler de lote do arquivo de retorno de transferencia';


--
-- TOC entry 8161 (class 0 OID 0)
-- Dependencies: 289
-- Name: COLUMN tbl_tlt.cd_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tlt.cd_art IS 'codigo do arquivo';


--
-- TOC entry 8162 (class 0 OID 0)
-- Dependencies: 289
-- Name: COLUMN tbl_tlt.cd_hlt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tlt.cd_hlt IS 'codigo do header do lote';


--
-- TOC entry 8163 (class 0 OID 0)
-- Dependencies: 289
-- Name: COLUMN tbl_tlt.qt_rgt_tlt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tlt.qt_rgt_tlt IS 'quantidade de registros';


--
-- TOC entry 8164 (class 0 OID 0)
-- Dependencies: 289
-- Name: COLUMN tbl_tlt.vl_rgt_tlt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_tlt.vl_rgt_tlt IS 'somatorio dos valores dos registros';


--
-- TOC entry 290 (class 1259 OID 564986)
-- Name: tbl_trt; Type: TABLE; Schema: sc_atb; Owner: scan
--

CREATE TABLE tbl_trt (
    cd_art numeric(10,0) NOT NULL,
    qt_lte_trt numeric(6,0),
    qt_rgt_trt numeric(6,0) NOT NULL,
    vl_ttl_trt numeric(15,2)
);


ALTER TABLE tbl_trt OWNER TO scan;

--
-- TOC entry 8165 (class 0 OID 0)
-- Dependencies: 290
-- Name: TABLE tbl_trt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON TABLE tbl_trt IS 'tabela de trailler do arquivo de retorno de transferencia';


--
-- TOC entry 8166 (class 0 OID 0)
-- Dependencies: 290
-- Name: COLUMN tbl_trt.cd_art; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_trt.cd_art IS 'codigo do arquivo';


--
-- TOC entry 8167 (class 0 OID 0)
-- Dependencies: 290
-- Name: COLUMN tbl_trt.qt_lte_trt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_trt.qt_lte_trt IS 'quantidade de lote';


--
-- TOC entry 8168 (class 0 OID 0)
-- Dependencies: 290
-- Name: COLUMN tbl_trt.qt_rgt_trt; Type: COMMENT; Schema: sc_atb; Owner: scan
--

COMMENT ON COLUMN tbl_trt.qt_rgt_trt IS 'quantidade de registros';


SET search_path = sc_cad, pg_catalog;

--
-- TOC entry 291 (class 1259 OID 564989)
-- Name: sq_cbf; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_cbf
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_cbf OWNER TO scan;

--
-- TOC entry 292 (class 1259 OID 564991)
-- Name: sq_crg; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_crg
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_crg OWNER TO scan;

--
-- TOC entry 293 (class 1259 OID 564993)
-- Name: sq_ctr; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_ctr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ctr OWNER TO scan;

--
-- TOC entry 862 (class 1259 OID 934466)
-- Name: sq_ctr_pcs; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_ctr_pcs
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ctr_pcs OWNER TO scan;

--
-- TOC entry 294 (class 1259 OID 564995)
-- Name: sq_ctt; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_ctt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_ctt OWNER TO scan;

--
-- TOC entry 295 (class 1259 OID 564997)
-- Name: sq_cun; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_cun
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_cun OWNER TO scan;

--
-- TOC entry 296 (class 1259 OID 564999)
-- Name: sq_dmn; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_dmn
    START WITH 26
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dmn OWNER TO scan;

--
-- TOC entry 821 (class 1259 OID 888958)
-- Name: sq_dps; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_dps
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dps OWNER TO scan;

--
-- TOC entry 297 (class 1259 OID 565001)
-- Name: sq_edr; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_edr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_edr OWNER TO scan;

--
-- TOC entry 298 (class 1259 OID 565003)
-- Name: sq_edr_ctr; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_edr_ctr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_edr_ctr OWNER TO scan;

--
-- TOC entry 299 (class 1259 OID 565005)
-- Name: sq_emp; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_emp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_emp OWNER TO scan;

--
-- TOC entry 300 (class 1259 OID 565007)
-- Name: sq_fem; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_fem
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_fem OWNER TO scan;

--
-- TOC entry 301 (class 1259 OID 565009)
-- Name: sq_fem_ctr; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_fem_ctr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_fem_ctr OWNER TO scan;

--
-- TOC entry 8169 (class 0 OID 0)
-- Dependencies: 301
-- Name: SEQUENCE sq_fem_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON SEQUENCE sq_fem_ctr IS 'SEQUENCE DA TABELA SC_CAD.TBL_FEM_CTR';


--
-- TOC entry 302 (class 1259 OID 565011)
-- Name: sq_fnc; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_fnc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_fnc OWNER TO scan;

--
-- TOC entry 303 (class 1259 OID 565013)
-- Name: sq_gem; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_gem
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_gem OWNER TO scan;

--
-- TOC entry 304 (class 1259 OID 565015)
-- Name: sq_haef; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_haef
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_haef OWNER TO scan;

--
-- TOC entry 305 (class 1259 OID 565017)
-- Name: sq_ham; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_ham
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_ham OWNER TO scan;

--
-- TOC entry 930 (class 1259 OID 1076894)
-- Name: sq_luc; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_luc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_luc OWNER TO scan;

--
-- TOC entry 306 (class 1259 OID 565019)
-- Name: sq_oce; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_oce
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_oce OWNER TO scan;

--
-- TOC entry 307 (class 1259 OID 565021)
-- Name: sq_pce; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_pce
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_pce OWNER TO scan;

--
-- TOC entry 839 (class 1259 OID 892069)
-- Name: sq_pce_crt; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_pce_crt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_pce_crt OWNER TO scan;

--
-- TOC entry 308 (class 1259 OID 565023)
-- Name: sq_pce_ctr; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_pce_ctr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_pce_ctr OWNER TO scan;

--
-- TOC entry 781 (class 1259 OID 852251)
-- Name: sq_pce_fem_ctr; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_pce_fem_ctr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_pce_fem_ctr OWNER TO scan;

--
-- TOC entry 820 (class 1259 OID 888956)
-- Name: sq_pcs; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_pcs
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_pcs OWNER TO scan;

--
-- TOC entry 840 (class 1259 OID 892168)
-- Name: sq_pfe; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_pfe
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_pfe OWNER TO scan;

--
-- TOC entry 309 (class 1259 OID 565025)
-- Name: sq_prd; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_prd
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_prd OWNER TO scan;

--
-- TOC entry 310 (class 1259 OID 565027)
-- Name: sq_prm; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_prm
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_prm OWNER TO scan;

--
-- TOC entry 941 (class 1259 OID 1623470)
-- Name: sq_rat; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_rat
    START WITH 19
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rat OWNER TO scan;

--
-- TOC entry 898 (class 1259 OID 1002024)
-- Name: sq_rcf; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_rcf
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rcf OWNER TO scan;

--
-- TOC entry 896 (class 1259 OID 1002020)
-- Name: sq_rel; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_rel
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rel OWNER TO scan;

--
-- TOC entry 897 (class 1259 OID 1002022)
-- Name: sq_rfl; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_rfl
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rfl OWNER TO scan;

--
-- TOC entry 899 (class 1259 OID 1002026)
-- Name: sq_rrl; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_rrl
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rrl OWNER TO scan;

--
-- TOC entry 311 (class 1259 OID 565029)
-- Name: sq_tlf; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_tlf
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tlf OWNER TO scan;

--
-- TOC entry 312 (class 1259 OID 565031)
-- Name: sq_tlt_ctr; Type: SEQUENCE; Schema: sc_cad; Owner: scan
--

CREATE SEQUENCE sq_tlt_ctr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tlt_ctr OWNER TO scan;

--
-- TOC entry 313 (class 1259 OID 565033)
-- Name: tbl_ast; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_ast (
    cd_ast numeric(10,0) NOT NULL,
    nm_ast character varying(50) NOT NULL,
    fg_atv_ast character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_alt_usr numeric(10,0),
    cd_cun numeric(10,0) NOT NULL
);


ALTER TABLE tbl_ast OWNER TO scan;

--
-- TOC entry 8170 (class 0 OID 0)
-- Dependencies: 313
-- Name: TABLE tbl_ast; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_ast IS 'Tabela de Assistente Comercial';


--
-- TOC entry 314 (class 1259 OID 565036)
-- Name: tbl_aux_cun; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_aux_cun (
    cpf numeric,
    nome character varying(80),
    dt_nascimento date,
    salario numeric(13,2),
    cd_emp numeric(5,0)
);


ALTER TABLE tbl_aux_cun OWNER TO scan;

--
-- TOC entry 315 (class 1259 OID 565042)
-- Name: tbl_bin; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_bin (
    cd_bin numeric(6,0) NOT NULL,
    tp_bin numeric(2,0),
    ds_bin character varying(20)
);


ALTER TABLE tbl_bin OWNER TO scan;

--
-- TOC entry 8171 (class 0 OID 0)
-- Dependencies: 315
-- Name: TABLE tbl_bin; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_bin IS 'TABELA DE VERIFICACAO DE BINS';


--
-- TOC entry 8172 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN tbl_bin.cd_bin; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_bin.cd_bin IS 'codigo';


--
-- TOC entry 8173 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN tbl_bin.tp_bin; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_bin.tp_bin IS 'tipo do bin';


--
-- TOC entry 8174 (class 0 OID 0)
-- Dependencies: 315
-- Name: COLUMN tbl_bin.ds_bin; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_bin.ds_bin IS 'descricao do bin';


--
-- TOC entry 316 (class 1259 OID 565045)
-- Name: tbl_cbf; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_cbf (
    cd_cbf numeric(10,0) NOT NULL,
    cd_bnc numeric(5,0) NOT NULL,
    nr_agc_cbf numeric(20,0) NOT NULL,
    nr_dgt_agc_cbf character varying(1) NOT NULL,
    nr_cba_cbf numeric(20,0) NOT NULL,
    nr_dgt_cba_cbf character varying(2) NOT NULL,
    tp_cba_cbf numeric(2,0) NOT NULL,
    fg_atv_cbf character(1) DEFAULT 'S'::bpchar NOT NULL,
    nr_cpf_cnpj_cbf numeric(14,0) NOT NULL,
    tp_pss_cbf character(1) NOT NULL,
    nm_cbf character varying(100) NOT NULL,
    pc_dps_cbf numeric(13,2) DEFAULT 0 NOT NULL,
    cd_inc_usr numeric(5,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(5,0),
    dt_alt_usr timestamp without time zone,
    cd_cun numeric(10,0) NOT NULL,
    CONSTRAINT ck_fg_atv_cbf CHECK ((fg_atv_cbf = ANY (ARRAY['N'::bpchar, 'S'::bpchar]))),
    CONSTRAINT ck_pc_dps_cbf CHECK (((pc_dps_cbf >= (0)::numeric) AND (pc_dps_cbf <= (100)::numeric))),
    CONSTRAINT ck_tp_pss_cbf CHECK ((tp_pss_cbf = ANY (ARRAY['F'::bpchar, 'J'::bpchar])))
);


ALTER TABLE tbl_cbf OWNER TO scan;

--
-- TOC entry 8175 (class 0 OID 0)
-- Dependencies: 316
-- Name: TABLE tbl_cbf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_cbf IS 'tabela de conta bancaria de funcionario';


--
-- TOC entry 8176 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.cd_cbf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.cd_cbf IS 'codigo';


--
-- TOC entry 8177 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.cd_bnc; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.cd_bnc IS 'banco';


--
-- TOC entry 8178 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.nr_agc_cbf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.nr_agc_cbf IS 'numero da agencia';


--
-- TOC entry 8179 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.nr_dgt_agc_cbf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.nr_dgt_agc_cbf IS 'numero do digito verificado da agencia';


--
-- TOC entry 8180 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.nr_cba_cbf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.nr_cba_cbf IS 'numero da conta bancaria do funcionario';


--
-- TOC entry 8181 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.nr_dgt_cba_cbf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.nr_dgt_cba_cbf IS 'numero do digito verificador da conta bancaria do funcionario';


--
-- TOC entry 8182 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.tp_cba_cbf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.tp_cba_cbf IS 'tipo de conta bancaria do funcionario (ver tabela de dominio)';


--
-- TOC entry 8183 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.fg_atv_cbf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.fg_atv_cbf IS 'flag de ativo';


--
-- TOC entry 8184 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.nr_cpf_cnpj_cbf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.nr_cpf_cnpj_cbf IS 'numero do cpf/cnpj do titular da conta bancaria do funcionario';


--
-- TOC entry 8185 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.tp_pss_cbf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.tp_pss_cbf IS 'tipo de pessoa do titular da conta bancaria do funcionario';


--
-- TOC entry 8186 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.nm_cbf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.nm_cbf IS 'nome do titular da conta bancaria do funcionario';


--
-- TOC entry 8187 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.pc_dps_cbf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.pc_dps_cbf IS 'percentual de deposito automatico';


--
-- TOC entry 8188 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.cd_inc_usr IS 'usuario de inclusao';


--
-- TOC entry 8189 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8190 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.cd_alt_usr IS 'usuario que realizou a ultima alteracao';


--
-- TOC entry 8191 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.dt_alt_usr IS 'data da ultima alteracao';


--
-- TOC entry 8192 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN tbl_cbf.cd_cun; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cbf.cd_cun IS 'Código do Cadastro Único';


--
-- TOC entry 885 (class 1259 OID 976466)
-- Name: tbl_cls; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_cls (
    cd_cls numeric(5,0) NOT NULL,
    nm_cls character varying(50) NOT NULL,
    fg_atv_cls character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_cun numeric(10,0) NOT NULL
);


ALTER TABLE tbl_cls OWNER TO scan;

--
-- TOC entry 8193 (class 0 OID 0)
-- Dependencies: 885
-- Name: TABLE tbl_cls; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_cls IS 'TABELA DE GERENTE';


--
-- TOC entry 8194 (class 0 OID 0)
-- Dependencies: 885
-- Name: COLUMN tbl_cls.cd_cls; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cls.cd_cls IS 'CODIGO DO CLOSER';


--
-- TOC entry 8195 (class 0 OID 0)
-- Dependencies: 885
-- Name: COLUMN tbl_cls.nm_cls; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cls.nm_cls IS 'NOME DO CLOSER';


--
-- TOC entry 8196 (class 0 OID 0)
-- Dependencies: 885
-- Name: COLUMN tbl_cls.fg_atv_cls; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cls.fg_atv_cls IS 'FLAG DE ATIVO';


--
-- TOC entry 8197 (class 0 OID 0)
-- Dependencies: 885
-- Name: COLUMN tbl_cls.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cls.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8198 (class 0 OID 0)
-- Dependencies: 885
-- Name: COLUMN tbl_cls.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cls.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 8199 (class 0 OID 0)
-- Dependencies: 885
-- Name: COLUMN tbl_cls.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cls.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 8200 (class 0 OID 0)
-- Dependencies: 885
-- Name: COLUMN tbl_cls.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cls.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 317 (class 1259 OID 565053)
-- Name: tbl_cpf; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_cpf (
    cd_cun numeric(10,0) NOT NULL,
    nr_rg_cpf numeric(20,0),
    nm_mae_cpf character varying(80),
    dt_nsc_cpf date,
    sexo_cpf character varying(1) DEFAULT 'M'::character varying NOT NULL,
    dt_ems_rg_cpf date,
    nm_org_ems_rg_cpf character varying(20),
    ds_nat_cpf character varying(50) NOT NULL,
    ds_nac_cpf character varying(20) NOT NULL,
    cd_est_civil_cpf numeric(2,0),
    uf_org_ems_rg_cpf character varying(2) DEFAULT 'CE'::character varying NOT NULL,
    uf_nat_cpf character varying(2) DEFAULT 'CE'::character varying NOT NULL,
    CONSTRAINT ck_sexo_cpf CHECK (((sexo_cpf)::text = ANY (ARRAY[('M'::"char")::text, ('F'::"char")::text])))
);


ALTER TABLE tbl_cpf OWNER TO scan;

--
-- TOC entry 8201 (class 0 OID 0)
-- Dependencies: 317
-- Name: TABLE tbl_cpf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_cpf IS 'EXTENSAO DA TABELA DE CADASTRO UNICO QUE ARMAZENA OS DADOS ESPECIFICOS DE PESSOA FISICA';


--
-- TOC entry 318 (class 1259 OID 565060)
-- Name: tbl_cpj; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_cpj (
    cd_cun numeric(10,0) NOT NULL,
    nm_fts_cpj character varying(50),
    nr_ins_edl_cpj numeric(14,0),
    dt_reg_cpj date
);


ALTER TABLE tbl_cpj OWNER TO scan;

--
-- TOC entry 8202 (class 0 OID 0)
-- Dependencies: 318
-- Name: TABLE tbl_cpj; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_cpj IS 'EXTENSAO DA TABELA DE CADASTRO UNICO QUE ARMAZENA OS DADOS ESPECIFICOS DE PESSOA JURIDICA';


--
-- TOC entry 319 (class 1259 OID 565063)
-- Name: tbl_crg; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_crg (
    cd_crg numeric(5,0) NOT NULL,
    nm_crg character(50) NOT NULL
);


ALTER TABLE tbl_crg OWNER TO scan;

--
-- TOC entry 8203 (class 0 OID 0)
-- Dependencies: 319
-- Name: TABLE tbl_crg; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_crg IS 'TABELA DE CARGO';


--
-- TOC entry 320 (class 1259 OID 565066)
-- Name: tbl_ctr; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_ctr (
    cd_ctr numeric(10,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    fg_atv_ctr "char" NOT NULL,
    dt_ctr date NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_grt numeric(5,0) NOT NULL,
    cd_prd numeric(10,0) NOT NULL,
    cd_cnt numeric(10,0) NOT NULL,
    cd_mpl numeric(2,0) DEFAULT 1 NOT NULL,
    cd_edr_ctr numeric(20,0),
    cd_ast numeric(10,0),
    fg_car_lmt_ctr character(1) DEFAULT 'S'::bpchar NOT NULL,
    cd_cnt_crd numeric(10,0) NOT NULL,
    fg_fat_fem_ctr character varying(1) DEFAULT 'N'::character varying NOT NULL,
    cd_pcs numeric(10,0) NOT NULL,
    cd_ppt numeric(5,0),
    cd_cls numeric(3,0),
    CONSTRAINT ck_fg_atv_ctr CHECK ((fg_atv_ctr = ANY (ARRAY['N'::"char", 'S'::"char"])))
);


ALTER TABLE tbl_ctr OWNER TO scan;

--
-- TOC entry 8204 (class 0 OID 0)
-- Dependencies: 320
-- Name: TABLE tbl_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_ctr IS 'TABELA DE CONTRATOs EXCLUIDOS';


--
-- TOC entry 8205 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.cd_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.cd_ctr IS 'CÓDIGO';


--
-- TOC entry 8206 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.cd_emp; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.cd_emp IS 'CÓDIGO DA EMPRESA';


--
-- TOC entry 8207 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.fg_atv_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.fg_atv_ctr IS 'FLAG DE ATIVO';


--
-- TOC entry 8208 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.dt_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.dt_ctr IS 'DATA DO CONTRATO';


--
-- TOC entry 8209 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8210 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 8211 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 8212 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 8213 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.cd_grt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.cd_grt IS 'CÓDIGO DO GERENTE';


--
-- TOC entry 8214 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.cd_prd; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.cd_prd IS 'CÓDIGO DO PRODUTO';


--
-- TOC entry 8215 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.cd_cnt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.cd_cnt IS 'Codigo da conta';


--
-- TOC entry 8216 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.fg_car_lmt_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.fg_car_lmt_ctr IS 'FLAG DE CARENCIA DE LIBERACAO DE LIMITE: S - LIBERA COM CARENCIA N - LIBERA SEM CARENCIA';


--
-- TOC entry 8217 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.cd_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.cd_pcs IS 'codigo pacote de servicos';


--
-- TOC entry 8218 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.cd_ppt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.cd_ppt IS 'codigo do prospector';


--
-- TOC entry 8219 (class 0 OID 0)
-- Dependencies: 320
-- Name: COLUMN tbl_ctr.cd_cls; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr.cd_cls IS 'codigo do closer';


--
-- TOC entry 917 (class 1259 OID 1010467)
-- Name: tbl_ctr_exc; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_ctr_exc (
    cd_ctr numeric(10,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    fg_atv_ctr "char" NOT NULL,
    dt_ctr date NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_grt numeric(5,0) NOT NULL,
    cd_prd numeric(10,0) NOT NULL,
    cd_cnt numeric(10,0) NOT NULL,
    cd_mpl numeric(2,0) DEFAULT 1 NOT NULL,
    cd_edr_ctr numeric(20,0),
    cd_ast numeric(10,0),
    fg_car_lmt_ctr character(1) DEFAULT 'S'::bpchar NOT NULL,
    cd_cnt_crd numeric(10,0) NOT NULL,
    fg_fat_fem_ctr character varying(1) DEFAULT 'N'::character varying NOT NULL,
    cd_pcs numeric(10,0) NOT NULL,
    cd_ppt numeric(5,0),
    cd_cls numeric(3,0),
    dt_exc_ctr timestamp without time zone NOT NULL,
    cd_usr_exc_ctr numeric(10,0) NOT NULL,
    mtv_exc_ctr character varying(400),
    CONSTRAINT ck_fg_atv_ctr_exc CHECK ((fg_atv_ctr = ANY (ARRAY['N'::"char", 'S'::"char"])))
);


ALTER TABLE tbl_ctr_exc OWNER TO scan;

--
-- TOC entry 861 (class 1259 OID 934453)
-- Name: tbl_ctr_pcs; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_ctr_pcs (
    cd_ctr_pcs numeric(10,0) NOT NULL,
    cd_ctr numeric(10,0) NOT NULL,
    cd_pcs numeric(10,0) NOT NULL,
    fg_atv_ctr_pcs character varying(1),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    fg_prd_ctr_pcs character varying(1),
    fg_vsv_ctr_pcs character(1) DEFAULT 'S'::bpchar NOT NULL,
    CONSTRAINT ck_fg_atv_ctr_pcs CHECK (((fg_atv_ctr_pcs)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_ctr_pcs OWNER TO scan;

--
-- TOC entry 8220 (class 0 OID 0)
-- Dependencies: 861
-- Name: TABLE tbl_ctr_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_ctr_pcs IS 'tabela pacote de serviços funcionarios para empresas com pacote personalizado';


--
-- TOC entry 8221 (class 0 OID 0)
-- Dependencies: 861
-- Name: COLUMN tbl_ctr_pcs.cd_ctr_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_pcs.cd_ctr_pcs IS 'codigo';


--
-- TOC entry 8222 (class 0 OID 0)
-- Dependencies: 861
-- Name: COLUMN tbl_ctr_pcs.cd_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_pcs.cd_ctr IS 'codigo contrato';


--
-- TOC entry 8223 (class 0 OID 0)
-- Dependencies: 861
-- Name: COLUMN tbl_ctr_pcs.cd_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_pcs.cd_pcs IS 'codigo pacote servicos funcionario';


--
-- TOC entry 8224 (class 0 OID 0)
-- Dependencies: 861
-- Name: COLUMN tbl_ctr_pcs.fg_atv_ctr_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_pcs.fg_atv_ctr_pcs IS 'flag ativo';


--
-- TOC entry 8225 (class 0 OID 0)
-- Dependencies: 861
-- Name: COLUMN tbl_ctr_pcs.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_pcs.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8226 (class 0 OID 0)
-- Dependencies: 861
-- Name: COLUMN tbl_ctr_pcs.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_pcs.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8227 (class 0 OID 0)
-- Dependencies: 861
-- Name: COLUMN tbl_ctr_pcs.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_pcs.cd_alt_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8228 (class 0 OID 0)
-- Dependencies: 861
-- Name: COLUMN tbl_ctr_pcs.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_pcs.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 321 (class 1259 OID 565072)
-- Name: tbl_ctt; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_ctt (
    cd_ctt numeric(10,0) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    cd_crg numeric(5,0),
    nm_ctt character varying(50) NOT NULL,
    dt_nsc_ctt date,
    eml_ctt character varying(50),
    fg_atv_ctt character(1) NOT NULL,
    cd_inc_usr numeric(5,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(5,0),
    dt_alt_usr time without time zone,
    CONSTRAINT ck_fg_atv_ctt CHECK ((fg_atv_ctt = ANY (ARRAY['S'::bpchar, 'N'::bpchar])))
);


ALTER TABLE tbl_ctt OWNER TO scan;

--
-- TOC entry 8229 (class 0 OID 0)
-- Dependencies: 321
-- Name: TABLE tbl_ctt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_ctt IS 'TABELA DE CONTATOS DE PESSOA JURIDICA';


--
-- TOC entry 322 (class 1259 OID 565076)
-- Name: tbl_cun; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_cun (
    cd_cun numeric(10,0) NOT NULL,
    nm_cun character varying(80) NOT NULL,
    eml_cun character varying(50),
    nr_cpf_cnpj_cun numeric(14,0) NOT NULL,
    tp_pss_cun character(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    fg_cdl_atm_cun character(1) DEFAULT 'N'::bpchar NOT NULL,
    fg_saq_out_crt_cun character(1) DEFAULT 'N'::bpchar NOT NULL,
    cd_crt numeric(14,0),
    eml_env_nfs_cun character varying(100),
    CONSTRAINT ck_fg_cdl_atm_cun CHECK ((fg_cdl_atm_cun = ANY (ARRAY['S'::bpchar, 'N'::bpchar]))),
    CONSTRAINT ck_fg_saq_out_crt_cun CHECK ((fg_saq_out_crt_cun = ANY (ARRAY['S'::bpchar, 'N'::bpchar]))),
    CONSTRAINT ck_tp_pss_cun CHECK ((tp_pss_cun = ANY (ARRAY['F'::bpchar, 'J'::bpchar])))
);


ALTER TABLE tbl_cun OWNER TO scan;

--
-- TOC entry 8230 (class 0 OID 0)
-- Dependencies: 322
-- Name: TABLE tbl_cun; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_cun IS 'TABELA DE CADASTRO UNICO';


--
-- TOC entry 8231 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN tbl_cun.fg_cdl_atm_cun; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cun.fg_cdl_atm_cun IS 'FLAG DE EXIBICAO DE CEDULAS NO ATM';


--
-- TOC entry 8232 (class 0 OID 0)
-- Dependencies: 322
-- Name: COLUMN tbl_cun.fg_saq_out_crt_cun; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_cun.fg_saq_out_crt_cun IS 'FLAG DE PERMISSAO DE SAQUE EM OUTRO CARTAO DO MESMO CADASTRO UNICO';


--
-- TOC entry 323 (class 1259 OID 565084)
-- Name: tbl_dmn; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_dmn (
    cd_dmn numeric(10,0) NOT NULL,
    vl_cmp_dmn numeric(5,0) NOT NULL,
    nm_vlr_dmn character varying(100) NOT NULL,
    nm_cmp_dmn character varying(50) NOT NULL
);


ALTER TABLE tbl_dmn OWNER TO scan;

--
-- TOC entry 8233 (class 0 OID 0)
-- Dependencies: 323
-- Name: TABLE tbl_dmn; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_dmn IS 'TABELA DE DOMINIO';


--
-- TOC entry 823 (class 1259 OID 888968)
-- Name: tbl_dps; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_dps (
    cd_dps numeric(10,0) NOT NULL,
    cd_pcs numeric(10,0) NOT NULL,
    cd_pce numeric(10,0) NOT NULL,
    tp_vlr_pce_dps character varying NOT NULL,
    vl_pce_dps character varying(15),
    tp_pgt_pce_dps numeric(2,0),
    fg_atv_dps character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    CONSTRAINT ck_fg_edt_dps CHECK (((fg_atv_dps)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_dps OWNER TO scan;

--
-- TOC entry 8234 (class 0 OID 0)
-- Dependencies: 823
-- Name: TABLE tbl_dps; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_dps IS 'tabela detalhe pacote de serviços';


--
-- TOC entry 8235 (class 0 OID 0)
-- Dependencies: 823
-- Name: COLUMN tbl_dps.cd_dps; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_dps.cd_dps IS 'codigo';


--
-- TOC entry 8236 (class 0 OID 0)
-- Dependencies: 823
-- Name: COLUMN tbl_dps.cd_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_dps.cd_pcs IS 'codigo do pacote de serviços';


--
-- TOC entry 8237 (class 0 OID 0)
-- Dependencies: 823
-- Name: COLUMN tbl_dps.cd_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_dps.cd_pce IS 'codigo do parametro contrato empresa';


--
-- TOC entry 8238 (class 0 OID 0)
-- Dependencies: 823
-- Name: COLUMN tbl_dps.tp_vlr_pce_dps; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_dps.tp_vlr_pce_dps IS 'tipo valor';


--
-- TOC entry 8239 (class 0 OID 0)
-- Dependencies: 823
-- Name: COLUMN tbl_dps.vl_pce_dps; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_dps.vl_pce_dps IS 'valor';


--
-- TOC entry 8240 (class 0 OID 0)
-- Dependencies: 823
-- Name: COLUMN tbl_dps.tp_pgt_pce_dps; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_dps.tp_pgt_pce_dps IS 'tipo pagamento';


--
-- TOC entry 8241 (class 0 OID 0)
-- Dependencies: 823
-- Name: COLUMN tbl_dps.fg_atv_dps; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_dps.fg_atv_dps IS 'flag ativo';


--
-- TOC entry 8242 (class 0 OID 0)
-- Dependencies: 823
-- Name: COLUMN tbl_dps.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_dps.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8243 (class 0 OID 0)
-- Dependencies: 823
-- Name: COLUMN tbl_dps.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_dps.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8244 (class 0 OID 0)
-- Dependencies: 823
-- Name: COLUMN tbl_dps.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_dps.cd_alt_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8245 (class 0 OID 0)
-- Dependencies: 823
-- Name: COLUMN tbl_dps.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_dps.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 324 (class 1259 OID 565087)
-- Name: tbl_edr_ctr; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_edr_ctr (
    cd_edr numeric(10,0) NOT NULL,
    cd_ctr numeric(10,0) NOT NULL,
    tp_edr_ctr numeric(2,0) NOT NULL,
    cd_edr_ctr numeric(10,0) NOT NULL,
    fg_atv_edr_ctr character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_edr_ctr OWNER TO scan;

--
-- TOC entry 8246 (class 0 OID 0)
-- Dependencies: 324
-- Name: COLUMN tbl_edr_ctr.fg_atv_edr_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_edr_ctr.fg_atv_edr_ctr IS 'FLAG DE ATIVO';


--
-- TOC entry 325 (class 1259 OID 565090)
-- Name: tbl_emp; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_emp (
    cd_emp numeric(5,0) NOT NULL,
    nm_emp character varying(50) NOT NULL,
    fg_atv_emp character(1) NOT NULL,
    cd_gem numeric(5,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    nm_rpr1_emp character varying(80),
    nm_rpr2_emp character varying(80),
    cpf_rpr1_emp numeric(14,0),
    cpf_rpr2_emp numeric(14,0),
    rg_rpr1_emp numeric(14,0),
    rg_rpr2_emp numeric(14,0),
    cd_rat numeric(5,0),
    tp_pss_rpr1_emp character(1),
    tp_pss_rpr2_emp character(1),
    CONSTRAINT ck_fg_atv_emp CHECK ((fg_atv_emp = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_emp OWNER TO scan;

--
-- TOC entry 8247 (class 0 OID 0)
-- Dependencies: 325
-- Name: TABLE tbl_emp; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_emp IS 'TABELA DE EMPRESA';


--
-- TOC entry 8248 (class 0 OID 0)
-- Dependencies: 325
-- Name: COLUMN tbl_emp.fg_atv_emp; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_emp.fg_atv_emp IS 'FLAG ATIVO';


--
-- TOC entry 326 (class 1259 OID 565094)
-- Name: tbl_emp_aux; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_emp_aux (
    cd_emp numeric(10,0),
    cd_ast numeric(10,0),
    cd_ctr numeric(10,0),
    fg_atv character varying(1),
    cd_grt numeric(10,0),
    cd_fem numeric(10,0),
    mtr_fnc character varying(14),
    cd_fnc numeric(10,0)
);


ALTER TABLE tbl_emp_aux OWNER TO scan;

--
-- TOC entry 327 (class 1259 OID 565097)
-- Name: tbl_fem; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_fem (
    cd_emp numeric(5,0) NOT NULL,
    cd_fem numeric(5,0) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    nm_fem character varying(50) NOT NULL,
    fg_atv_fem character(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    fg_etd_rec_fem character(1),
    fg_emt_crt_fem character varying(1) NOT NULL,
    fg_mtz_fem character varying(1) DEFAULT 'N'::character varying NOT NULL,
    reg_tbt_fem numeric(5,0),
    nat_opr_fem numeric(5,0),
    CONSTRAINT ck_fg_atv_fem CHECK ((fg_atv_fem = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_fem OWNER TO scan;

--
-- TOC entry 8249 (class 0 OID 0)
-- Dependencies: 327
-- Name: TABLE tbl_fem; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_fem IS 'TABELA DE FILIAL DE EMPRESA';


--
-- TOC entry 8250 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN tbl_fem.fg_emt_crt_fem; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem.fg_emt_crt_fem IS 'FLAG QUE IDENTIFICA SE DEVE EMITIR OU NAO CARTAO PARA OS FUNCIONARIOS DA FILIAL';


--
-- TOC entry 8251 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN tbl_fem.fg_mtz_fem; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem.fg_mtz_fem IS 'FLAG QUE IDENTIFICA SE A FILIAL É MATRIZ OU NÃO';


--
-- TOC entry 8252 (class 0 OID 0)
-- Dependencies: 327
-- Name: COLUMN tbl_fem.nat_opr_fem; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem.nat_opr_fem IS 'natureza da operacao de ISS';


--
-- TOC entry 328 (class 1259 OID 565102)
-- Name: tbl_fem_ctr; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_fem_ctr (
    cd_fem_ctr numeric(10,0) NOT NULL,
    cd_emp numeric(10,0) NOT NULL,
    cd_fem numeric(10,0) NOT NULL,
    cd_ctr numeric(10,0) NOT NULL,
    fg_atv_fem_ctr character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_tvt numeric(5,0),
    CONSTRAINT ck_femctr_fg_atv CHECK (((fg_atv_fem_ctr)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_fem_ctr OWNER TO scan;

--
-- TOC entry 8253 (class 0 OID 0)
-- Dependencies: 328
-- Name: TABLE tbl_fem_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_fem_ctr IS 'TABELA DE FILIAIS DA EMPRESA DO CONTRATO';


--
-- TOC entry 8254 (class 0 OID 0)
-- Dependencies: 328
-- Name: COLUMN tbl_fem_ctr.cd_fem_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem_ctr.cd_fem_ctr IS 'CODIGO';


--
-- TOC entry 8255 (class 0 OID 0)
-- Dependencies: 328
-- Name: COLUMN tbl_fem_ctr.cd_emp; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem_ctr.cd_emp IS 'CODIGO DA EMPRESA';


--
-- TOC entry 8256 (class 0 OID 0)
-- Dependencies: 328
-- Name: COLUMN tbl_fem_ctr.cd_fem; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem_ctr.cd_fem IS 'CODIGO DA FILIAL';


--
-- TOC entry 8257 (class 0 OID 0)
-- Dependencies: 328
-- Name: COLUMN tbl_fem_ctr.cd_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem_ctr.cd_ctr IS 'CODIGO DO CONTRATO';


--
-- TOC entry 8258 (class 0 OID 0)
-- Dependencies: 328
-- Name: COLUMN tbl_fem_ctr.fg_atv_fem_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem_ctr.fg_atv_fem_ctr IS 'FLAG DE ATIVO';


--
-- TOC entry 8259 (class 0 OID 0)
-- Dependencies: 328
-- Name: COLUMN tbl_fem_ctr.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem_ctr.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8260 (class 0 OID 0)
-- Dependencies: 328
-- Name: COLUMN tbl_fem_ctr.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem_ctr.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 8261 (class 0 OID 0)
-- Dependencies: 328
-- Name: COLUMN tbl_fem_ctr.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem_ctr.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 8262 (class 0 OID 0)
-- Dependencies: 328
-- Name: COLUMN tbl_fem_ctr.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem_ctr.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 8263 (class 0 OID 0)
-- Dependencies: 328
-- Name: COLUMN tbl_fem_ctr.cd_tvt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fem_ctr.cd_tvt IS 'CODIGO DA TABELA DE TARIFAS';


--
-- TOC entry 329 (class 1259 OID 565106)
-- Name: tbl_fnc; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_fnc (
    cd_fnc numeric(10,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    cd_fem numeric(5,0) NOT NULL,
    nr_idt_fnc character varying(14) NOT NULL,
    st_fnc numeric(2,0) DEFAULT 1 NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    dt_alt_sit_fnc timestamp without time zone,
    dt_adm_fnc date,
    dt_adm_atu_fnc timestamp without time zone
);


ALTER TABLE tbl_fnc OWNER TO scan;

--
-- TOC entry 8264 (class 0 OID 0)
-- Dependencies: 329
-- Name: TABLE tbl_fnc; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_fnc IS 'TABELA DE FUNCIONARIO';


--
-- TOC entry 8265 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN tbl_fnc.dt_alt_sit_fnc; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fnc.dt_alt_sit_fnc IS 'Data da Alteração da Situação do Funcionario';


--
-- TOC entry 8266 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN tbl_fnc.dt_adm_fnc; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_fnc.dt_adm_fnc IS 'DATA DE ADMISSÃO DO FUNCIONARIO';


--
-- TOC entry 330 (class 1259 OID 565110)
-- Name: tbl_gem; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_gem (
    cd_gem numeric(5,0) NOT NULL,
    nm_gem character varying(50) NOT NULL,
    fg_atv_gem character(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_cnt numeric(10,0) NOT NULL,
    qtd_dias_blq_rrc_gem numeric(5,0),
    dia_crt_rep_com_gem numeric(2,0),
    CONSTRAINT ck_fg_atv_gem CHECK ((fg_atv_gem = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_gem OWNER TO scan;

--
-- TOC entry 8267 (class 0 OID 0)
-- Dependencies: 330
-- Name: TABLE tbl_gem; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_gem IS 'TABELA DE GRUPO EMPRESARIAL';


--
-- TOC entry 8268 (class 0 OID 0)
-- Dependencies: 330
-- Name: COLUMN tbl_gem.cd_gem; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_gem.cd_gem IS 'codigo';


--
-- TOC entry 8269 (class 0 OID 0)
-- Dependencies: 330
-- Name: COLUMN tbl_gem.nm_gem; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_gem.nm_gem IS 'nome';


--
-- TOC entry 8270 (class 0 OID 0)
-- Dependencies: 330
-- Name: COLUMN tbl_gem.fg_atv_gem; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_gem.fg_atv_gem IS 'FLAG ATIVO';


--
-- TOC entry 8271 (class 0 OID 0)
-- Dependencies: 330
-- Name: COLUMN tbl_gem.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_gem.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8272 (class 0 OID 0)
-- Dependencies: 330
-- Name: COLUMN tbl_gem.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_gem.cd_alt_usr IS 'codigo do usuario de alteracao';


--
-- TOC entry 8273 (class 0 OID 0)
-- Dependencies: 330
-- Name: COLUMN tbl_gem.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_gem.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8274 (class 0 OID 0)
-- Dependencies: 330
-- Name: COLUMN tbl_gem.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_gem.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 8275 (class 0 OID 0)
-- Dependencies: 330
-- Name: COLUMN tbl_gem.cd_cnt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_gem.cd_cnt IS 'codigo da conta de recebimento de recurso';


--
-- TOC entry 8276 (class 0 OID 0)
-- Dependencies: 330
-- Name: COLUMN tbl_gem.dia_crt_rep_com_gem; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_gem.dia_crt_rep_com_gem IS 'dia de corte para controle de representacao comercial';


--
-- TOC entry 331 (class 1259 OID 565114)
-- Name: tbl_grt; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_grt (
    cd_grt numeric(5,0) NOT NULL,
    nm_grt character varying(50) NOT NULL,
    fg_atv_grt character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_cun numeric(10,0) NOT NULL
);


ALTER TABLE tbl_grt OWNER TO scan;

--
-- TOC entry 8277 (class 0 OID 0)
-- Dependencies: 331
-- Name: TABLE tbl_grt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_grt IS 'TABELA DE GERENTE';


--
-- TOC entry 8278 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN tbl_grt.cd_grt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_grt.cd_grt IS 'CODIGO DO GERENTE';


--
-- TOC entry 8279 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN tbl_grt.nm_grt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_grt.nm_grt IS 'NOME DO GERENTE';


--
-- TOC entry 8280 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN tbl_grt.fg_atv_grt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_grt.fg_atv_grt IS 'FLAG DE ATIVO';


--
-- TOC entry 8281 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN tbl_grt.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_grt.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8282 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN tbl_grt.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_grt.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 8283 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN tbl_grt.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_grt.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 8284 (class 0 OID 0)
-- Dependencies: 331
-- Name: COLUMN tbl_grt.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_grt.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 332 (class 1259 OID 565117)
-- Name: tbl_haef; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_haef (
    cd_haef numeric(10,0) NOT NULL,
    cd_fnc numeric(10,0) NOT NULL,
    cd_emp_ant_haef numeric(5,0) NOT NULL,
    cd_fem_ant_haef numeric(5,0) NOT NULL,
    cd_emp_atl_haef numeric(5,0) NOT NULL,
    cd_fem_atl_haef numeric(5,0) NOT NULL,
    obs_haef character varying(50) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_haef OWNER TO scan;

--
-- TOC entry 8285 (class 0 OID 0)
-- Dependencies: 332
-- Name: TABLE tbl_haef; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_haef IS 'TABELA DE HISTORICO DE ALTERACAO DE EMPRESA OU FILIAL DO FUNCIONARIO';


--
-- TOC entry 8286 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN tbl_haef.cd_haef; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_haef.cd_haef IS 'CODIGO';


--
-- TOC entry 8287 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN tbl_haef.cd_fnc; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_haef.cd_fnc IS 'FUNCIONARIO';


--
-- TOC entry 8288 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN tbl_haef.cd_emp_ant_haef; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_haef.cd_emp_ant_haef IS 'EMPRESA ANTERIOR';


--
-- TOC entry 8289 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN tbl_haef.cd_fem_ant_haef; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_haef.cd_fem_ant_haef IS 'FILIAL ANTERIOR';


--
-- TOC entry 8290 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN tbl_haef.cd_emp_atl_haef; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_haef.cd_emp_atl_haef IS 'EMPRESA ATUAL';


--
-- TOC entry 8291 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN tbl_haef.cd_fem_atl_haef; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_haef.cd_fem_atl_haef IS 'FILIAL ATUAL';


--
-- TOC entry 8292 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN tbl_haef.obs_haef; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_haef.obs_haef IS 'OBSERVACAO';


--
-- TOC entry 8293 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN tbl_haef.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_haef.cd_inc_usr IS 'USUARIO INCLUSAO';


--
-- TOC entry 8294 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN tbl_haef.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_haef.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 333 (class 1259 OID 565120)
-- Name: tbl_ham; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_ham (
    cd_ham numeric(10,0) NOT NULL,
    cd_fnc numeric(10,0) NOT NULL,
    nr_mtr_ant_ham character varying(14) NOT NULL,
    nr_mtr_atl_ham character varying(14) NOT NULL,
    cd_mtv_ham numeric(2,0) NOT NULL,
    ds_obs_ham character varying(200),
    cd_inc_usr numeric(5,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_ham OWNER TO scan;

--
-- TOC entry 8295 (class 0 OID 0)
-- Dependencies: 333
-- Name: TABLE tbl_ham; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_ham IS 'TABELA DE HISTORICO DE ALTERACAO DE MATRICULA DE FUNCIONARIO';


--
-- TOC entry 8296 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN tbl_ham.cd_ham; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ham.cd_ham IS 'CODIGO';


--
-- TOC entry 8297 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN tbl_ham.cd_fnc; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ham.cd_fnc IS 'CODIGO DO FUNCIONARIO';


--
-- TOC entry 8298 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN tbl_ham.nr_mtr_ant_ham; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ham.nr_mtr_ant_ham IS 'MATRICULA ANTERIOR DO FUNCIONARIO';


--
-- TOC entry 8299 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN tbl_ham.nr_mtr_atl_ham; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ham.nr_mtr_atl_ham IS 'MATRICULA ATUAL DO FUNCIONARIO';


--
-- TOC entry 8300 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN tbl_ham.cd_mtv_ham; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ham.cd_mtv_ham IS 'MOTIVO DE ALTERACAO DE MATRICULA (VER DOMINIO)';


--
-- TOC entry 8301 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN tbl_ham.ds_obs_ham; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ham.ds_obs_ham IS 'DESCRICAO (OBSERVACAO) PELO FATO DA ALTERACAO DE MATRICULA DO FUNCIONARIO';


--
-- TOC entry 8302 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN tbl_ham.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ham.cd_inc_usr IS 'CODIGO DO USUARIO DE INCLUSAO';


--
-- TOC entry 8303 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN tbl_ham.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ham.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 8304 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN tbl_ham.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ham.cd_alt_usr IS 'código do usuário de alteração';


--
-- TOC entry 8305 (class 0 OID 0)
-- Dependencies: 333
-- Name: COLUMN tbl_ham.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ham.dt_alt_usr IS 'data de alteração';


--
-- TOC entry 931 (class 1259 OID 1076896)
-- Name: tbl_luc; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_luc (
    cd_luc numeric(10,0) NOT NULL,
    cd_ucr numeric(10,0),
    nr_lat_luc numeric(10,8) NOT NULL,
    nr_lng_luc numeric(10,8) NOT NULL,
    dt_inc_luc timestamp without time zone NOT NULL,
    dt_ref_luc timestamp without time zone NOT NULL
);


ALTER TABLE tbl_luc OWNER TO scan;

--
-- TOC entry 334 (class 1259 OID 565123)
-- Name: tbl_oce; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_oce (
    cd_oce numeric(10,0) NOT NULL,
    cd_toe numeric(10,0) NOT NULL,
    ds_oce text,
    cd_emp numeric(10,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_oce OWNER TO scan;

--
-- TOC entry 8306 (class 0 OID 0)
-- Dependencies: 334
-- Name: TABLE tbl_oce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_oce IS 'TABELA DE OCORRÊNCIA DE ESTABELECIMENTO';


--
-- TOC entry 8307 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tbl_oce.cd_oce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_oce.cd_oce IS 'codigo';


--
-- TOC entry 8308 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tbl_oce.cd_toe; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_oce.cd_toe IS 'codigo tipo ocorrencia empresa';


--
-- TOC entry 8309 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tbl_oce.ds_oce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_oce.ds_oce IS 'descrição';


--
-- TOC entry 8310 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tbl_oce.cd_emp; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_oce.cd_emp IS 'codigo da empresa';


--
-- TOC entry 8311 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tbl_oce.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_oce.cd_inc_usr IS 'codigo usuario de inclusao';


--
-- TOC entry 8312 (class 0 OID 0)
-- Dependencies: 334
-- Name: COLUMN tbl_oce.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_oce.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 335 (class 1259 OID 565126)
-- Name: tbl_pce; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_pce (
    cd_pce numeric(5,0) NOT NULL,
    nm_pce character varying(50) NOT NULL,
    vl_min_pce character varying(15),
    vl_max_pce character varying(15),
    vl_pad_pce character varying(15),
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    fg_atv_pce character varying(1) NOT NULL,
    tp_pce numeric(2,0) NOT NULL,
    tp_dad_pce numeric(2,0) DEFAULT 1 NOT NULL,
    lst_dad_pce character varying(400),
    fg_imp_ctr_pce character(1) DEFAULT 'N'::bpchar,
    fg_fem_ctr_pce character(1) DEFAULT 'N'::bpchar NOT NULL,
    fg_dsp_pcs character varying(1) NOT NULL,
    fg_fnc_pce character varying(1) NOT NULL,
    CONSTRAINT ck_fg_dsp_pcs CHECK (((fg_dsp_pcs)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar]))),
    CONSTRAINT ck_fg_fnc_pce CHECK (((fg_fnc_pce)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_pce OWNER TO scan;

--
-- TOC entry 8313 (class 0 OID 0)
-- Dependencies: 335
-- Name: TABLE tbl_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_pce IS 'TABELA DE PARAMETROS DO CONTRATO DE EMPRESA';


--
-- TOC entry 8314 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.cd_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.cd_pce IS 'CODIGO DO PARAMETRO';


--
-- TOC entry 8315 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.nm_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.nm_pce IS 'NOME PARAMETRO';


--
-- TOC entry 8316 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.vl_min_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.vl_min_pce IS 'VALOR MINIMO DO PARAMETRO';


--
-- TOC entry 8317 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.vl_max_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.vl_max_pce IS 'VALOR MAXIMO DO PARAMETRO';


--
-- TOC entry 8318 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.vl_pad_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.vl_pad_pce IS 'VALOR PADRAO DO PARAMETRO';


--
-- TOC entry 8319 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8320 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 8321 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 8322 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 8323 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.fg_atv_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.fg_atv_pce IS 'FLAG DE ATIVO';


--
-- TOC entry 8324 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.tp_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.tp_pce IS 'TIPO DO PARAMETRO (VER DOMINIO TP_PCE)';


--
-- TOC entry 8325 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.tp_dad_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.tp_dad_pce IS 'tipo de dado (ver tabela de dominio)';


--
-- TOC entry 8326 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.lst_dad_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.lst_dad_pce IS 'lista de opcoes do parametro, utilizado apenas quando o tipo de dado for lista';


--
-- TOC entry 8327 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.fg_dsp_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.fg_dsp_pcs IS 'flag disponível pacote de serviços';


--
-- TOC entry 8328 (class 0 OID 0)
-- Dependencies: 335
-- Name: COLUMN tbl_pce.fg_fnc_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce.fg_fnc_pce IS 'flag de parametro de funcionario';


--
-- TOC entry 838 (class 1259 OID 892047)
-- Name: tbl_pce_crt; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_pce_crt (
    cd_pce_crt numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    cd_pce numeric(10,0) NOT NULL,
    tp_vlr_pce_crt "char" NOT NULL,
    vl_pce_crt character varying(15) NOT NULL,
    tp_pgt_pce_crt numeric(2,0),
    fg_atv_pce_crt character(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_pce_crt OWNER TO scan;

--
-- TOC entry 336 (class 1259 OID 565134)
-- Name: tbl_pce_ctr; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_pce_ctr (
    cd_ctr numeric(10,0) NOT NULL,
    cd_pce numeric(5,0) NOT NULL,
    tp_vlr_pce_ctr "char" NOT NULL,
    vl_pce_ctr character varying(30) NOT NULL,
    tp_pgt_pce_ctr numeric(2,0),
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_pce_ctr numeric(10,0) NOT NULL,
    CONSTRAINT ck_tp_vlr_pce CHECK ((tp_vlr_pce_ctr = ANY (ARRAY['V'::"char", 'P'::"char"])))
);


ALTER TABLE tbl_pce_ctr OWNER TO scan;

--
-- TOC entry 8329 (class 0 OID 0)
-- Dependencies: 336
-- Name: TABLE tbl_pce_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_pce_ctr IS 'TABELA DE PARAMETROS DO CONTRATO';


--
-- TOC entry 8330 (class 0 OID 0)
-- Dependencies: 336
-- Name: COLUMN tbl_pce_ctr.cd_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce_ctr.cd_ctr IS 'CONTRATO';


--
-- TOC entry 8331 (class 0 OID 0)
-- Dependencies: 336
-- Name: COLUMN tbl_pce_ctr.cd_pce; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce_ctr.cd_pce IS 'PARAMETRO DE CONTRATO DE EMPRESA';


--
-- TOC entry 8332 (class 0 OID 0)
-- Dependencies: 336
-- Name: COLUMN tbl_pce_ctr.tp_vlr_pce_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce_ctr.tp_vlr_pce_ctr IS 'TIPO DE VALOR DO PARAMETRO PARA O CONTRATO. PODE ASSUMIR DOIS VALORES: V - VALOR; P - PERCENTUAL';


--
-- TOC entry 8333 (class 0 OID 0)
-- Dependencies: 336
-- Name: COLUMN tbl_pce_ctr.vl_pce_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce_ctr.vl_pce_ctr IS 'VALOR DO PARAMETRO PARA UM DETERMINADO CONTRATO';


--
-- TOC entry 8334 (class 0 OID 0)
-- Dependencies: 336
-- Name: COLUMN tbl_pce_ctr.tp_pgt_pce_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce_ctr.tp_pgt_pce_ctr IS 'TIPO DE PAGAMENTO DO PARAMETRO PARA UM DETERMINADO CONTRATO. VER TABELA DE DOMINIO.';


--
-- TOC entry 8335 (class 0 OID 0)
-- Dependencies: 336
-- Name: COLUMN tbl_pce_ctr.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce_ctr.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8336 (class 0 OID 0)
-- Dependencies: 336
-- Name: COLUMN tbl_pce_ctr.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce_ctr.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 8337 (class 0 OID 0)
-- Dependencies: 336
-- Name: COLUMN tbl_pce_ctr.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce_ctr.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 8338 (class 0 OID 0)
-- Dependencies: 336
-- Name: COLUMN tbl_pce_ctr.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce_ctr.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 8339 (class 0 OID 0)
-- Dependencies: 336
-- Name: COLUMN tbl_pce_ctr.cd_pce_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pce_ctr.cd_pce_ctr IS 'CODIGO';


--
-- TOC entry 780 (class 1259 OID 852229)
-- Name: tbl_pce_fem_ctr; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_pce_fem_ctr (
    cd_pce_fem_ctr numeric(10,0) NOT NULL,
    cd_fem_ctr numeric(10,0) NOT NULL,
    cd_pce numeric(10,0) NOT NULL,
    tp_vlr_pce_fem_ctr "char" NOT NULL,
    vl_pce_fem_ctr character varying(15) NOT NULL,
    tp_pgt_pce_fem_ctr numeric(2,0),
    fg_atv_pce_fem_ctr character(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_pce_fem_ctr OWNER TO scan;

--
-- TOC entry 822 (class 1259 OID 888960)
-- Name: tbl_pcs; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_pcs (
    cd_pcs numeric(10,0) NOT NULL,
    dsc_pcs character varying(80) NOT NULL,
    fg_atv_pcs character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    tp_pcs numeric(2,0) NOT NULL,
    img_pcs character varying(200),
    CONSTRAINT ck_fg_atv_pcs CHECK (((fg_atv_pcs)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_pcs OWNER TO scan;

--
-- TOC entry 8340 (class 0 OID 0)
-- Dependencies: 822
-- Name: TABLE tbl_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_pcs IS 'tabela pacote de serviços';


--
-- TOC entry 8341 (class 0 OID 0)
-- Dependencies: 822
-- Name: COLUMN tbl_pcs.cd_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pcs.cd_pcs IS 'codigo';


--
-- TOC entry 8342 (class 0 OID 0)
-- Dependencies: 822
-- Name: COLUMN tbl_pcs.dsc_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pcs.dsc_pcs IS 'descrição';


--
-- TOC entry 8343 (class 0 OID 0)
-- Dependencies: 822
-- Name: COLUMN tbl_pcs.fg_atv_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pcs.fg_atv_pcs IS 'flag ativo';


--
-- TOC entry 8344 (class 0 OID 0)
-- Dependencies: 822
-- Name: COLUMN tbl_pcs.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pcs.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8345 (class 0 OID 0)
-- Dependencies: 822
-- Name: COLUMN tbl_pcs.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pcs.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8346 (class 0 OID 0)
-- Dependencies: 822
-- Name: COLUMN tbl_pcs.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pcs.cd_alt_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8347 (class 0 OID 0)
-- Dependencies: 822
-- Name: COLUMN tbl_pcs.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pcs.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 8348 (class 0 OID 0)
-- Dependencies: 822
-- Name: COLUMN tbl_pcs.tp_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pcs.tp_pcs IS 'tipo (ver domínio)';


--
-- TOC entry 8349 (class 0 OID 0)
-- Dependencies: 822
-- Name: COLUMN tbl_pcs.img_pcs; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pcs.img_pcs IS 'diretorio da imagem do pacote de servico';


--
-- TOC entry 841 (class 1259 OID 892170)
-- Name: tbl_pfe; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_pfe (
    cd_pfe numeric(10,0) NOT NULL,
    cd_pcs_emp_pfe numeric(10,0) NOT NULL,
    cd_pcs_fnc_pfe numeric(10,0) NOT NULL,
    fg_atv_pfe character varying(1),
    fg_prd_pfe character varying(1),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    CONSTRAINT ck_fg_atv_pfe CHECK (((fg_atv_pfe)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar]))),
    CONSTRAINT ck_fg_prd_pfe CHECK (((fg_prd_pfe)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_pfe OWNER TO scan;

--
-- TOC entry 8350 (class 0 OID 0)
-- Dependencies: 841
-- Name: TABLE tbl_pfe; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_pfe IS 'tabela pacote de servi�os funcionario empresa';


--
-- TOC entry 8351 (class 0 OID 0)
-- Dependencies: 841
-- Name: COLUMN tbl_pfe.cd_pfe; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.cd_pfe IS 'codigo';


--
-- TOC entry 8352 (class 0 OID 0)
-- Dependencies: 841
-- Name: COLUMN tbl_pfe.cd_pcs_emp_pfe; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.cd_pcs_emp_pfe IS 'codigo pacote servicos empresa';


--
-- TOC entry 8353 (class 0 OID 0)
-- Dependencies: 841
-- Name: COLUMN tbl_pfe.cd_pcs_fnc_pfe; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.cd_pcs_fnc_pfe IS 'codigo pacote servicos funcion�rio';


--
-- TOC entry 8354 (class 0 OID 0)
-- Dependencies: 841
-- Name: COLUMN tbl_pfe.fg_atv_pfe; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.fg_atv_pfe IS 'flag ativo';


--
-- TOC entry 8355 (class 0 OID 0)
-- Dependencies: 841
-- Name: COLUMN tbl_pfe.fg_prd_pfe; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.fg_prd_pfe IS 'flag padrao';


--
-- TOC entry 8356 (class 0 OID 0)
-- Dependencies: 841
-- Name: COLUMN tbl_pfe.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8357 (class 0 OID 0)
-- Dependencies: 841
-- Name: COLUMN tbl_pfe.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8358 (class 0 OID 0)
-- Dependencies: 841
-- Name: COLUMN tbl_pfe.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.cd_alt_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8359 (class 0 OID 0)
-- Dependencies: 841
-- Name: COLUMN tbl_pfe.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 884 (class 1259 OID 976446)
-- Name: tbl_ppt; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_ppt (
    cd_ppt numeric(5,0) NOT NULL,
    nm_ppt character varying(50) NOT NULL,
    fg_atv_ppt character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_cun numeric(10,0) NOT NULL
);


ALTER TABLE tbl_ppt OWNER TO scan;

--
-- TOC entry 8360 (class 0 OID 0)
-- Dependencies: 884
-- Name: TABLE tbl_ppt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_ppt IS 'TABELA DE GERENTE';


--
-- TOC entry 8361 (class 0 OID 0)
-- Dependencies: 884
-- Name: COLUMN tbl_ppt.cd_ppt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ppt.cd_ppt IS 'CODIGO DO PROSPECTOR';


--
-- TOC entry 8362 (class 0 OID 0)
-- Dependencies: 884
-- Name: COLUMN tbl_ppt.nm_ppt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ppt.nm_ppt IS 'NOME DO PROSPECTOR';


--
-- TOC entry 8363 (class 0 OID 0)
-- Dependencies: 884
-- Name: COLUMN tbl_ppt.fg_atv_ppt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ppt.fg_atv_ppt IS 'FLAG DE ATIVO';


--
-- TOC entry 8364 (class 0 OID 0)
-- Dependencies: 884
-- Name: COLUMN tbl_ppt.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ppt.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8365 (class 0 OID 0)
-- Dependencies: 884
-- Name: COLUMN tbl_ppt.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ppt.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 8366 (class 0 OID 0)
-- Dependencies: 884
-- Name: COLUMN tbl_ppt.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ppt.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 8367 (class 0 OID 0)
-- Dependencies: 884
-- Name: COLUMN tbl_ppt.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_ppt.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 337 (class 1259 OID 565138)
-- Name: tbl_prd; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_prd (
    cd_prd numeric(5,0) NOT NULL,
    nm_prd character(50) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    fg_atv_prd character varying(1) NOT NULL
);


ALTER TABLE tbl_prd OWNER TO scan;

--
-- TOC entry 8368 (class 0 OID 0)
-- Dependencies: 337
-- Name: TABLE tbl_prd; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_prd IS 'TABELA DE PRODUTO';


--
-- TOC entry 8369 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN tbl_prd.cd_prd; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_prd.cd_prd IS 'CODIGO';


--
-- TOC entry 8370 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN tbl_prd.nm_prd; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_prd.nm_prd IS 'DESCRICAO';


--
-- TOC entry 8371 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN tbl_prd.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_prd.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8372 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN tbl_prd.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_prd.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 8373 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN tbl_prd.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_prd.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 8374 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN tbl_prd.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_prd.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 8375 (class 0 OID 0)
-- Dependencies: 337
-- Name: COLUMN tbl_prd.fg_atv_prd; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_prd.fg_atv_prd IS 'FLAG DE ATIVO';


--
-- TOC entry 338 (class 1259 OID 565141)
-- Name: tbl_prm; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_prm (
    cd_prm numeric(5,0) NOT NULL,
    nm_prm character varying(50) NOT NULL,
    vl_prm character varying(40000) NOT NULL,
    ds_prm character varying(200) NOT NULL,
    fg_edt_prm character varying(1) DEFAULT 'S'::"char" NOT NULL,
    CONSTRAINT ck_fg_edt_prm CHECK (((fg_edt_prm)::text = ANY (ARRAY[('N'::"char")::text, ('S'::"char")::text])))
);


ALTER TABLE tbl_prm OWNER TO scan;

--
-- TOC entry 8376 (class 0 OID 0)
-- Dependencies: 338
-- Name: TABLE tbl_prm; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_prm IS 'TABELA DE PARAMETROS GERAIS DO SISTEMA';


--
-- TOC entry 8377 (class 0 OID 0)
-- Dependencies: 338
-- Name: COLUMN tbl_prm.cd_prm; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_prm.cd_prm IS 'CODIGO DO PARAMETRO';


--
-- TOC entry 8378 (class 0 OID 0)
-- Dependencies: 338
-- Name: COLUMN tbl_prm.nm_prm; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_prm.nm_prm IS 'NOME DO PARAMETRO';


--
-- TOC entry 8379 (class 0 OID 0)
-- Dependencies: 338
-- Name: COLUMN tbl_prm.vl_prm; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_prm.vl_prm IS 'VALOR DO PARAMETRO';


--
-- TOC entry 8380 (class 0 OID 0)
-- Dependencies: 338
-- Name: COLUMN tbl_prm.ds_prm; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_prm.ds_prm IS 'DESCRICAO DO PARAMETRO';


--
-- TOC entry 8381 (class 0 OID 0)
-- Dependencies: 338
-- Name: COLUMN tbl_prm.fg_edt_prm; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_prm.fg_edt_prm IS 'FLAG DE EDITAVEL DO PARAMETRO';


--
-- TOC entry 339 (class 1259 OID 565149)
-- Name: tbl_rat; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_rat (
    cd_rat numeric(5,0) NOT NULL,
    nm_rat character(50) NOT NULL,
    fg_atv_rat character(1) NOT NULL
);


ALTER TABLE tbl_rat OWNER TO scan;

--
-- TOC entry 8382 (class 0 OID 0)
-- Dependencies: 339
-- Name: TABLE tbl_rat; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_rat IS 'TABELA DE RAMO DE ATIVIDADE';


--
-- TOC entry 8383 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN tbl_rat.cd_rat; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rat.cd_rat IS 'CODIGO';


--
-- TOC entry 8384 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN tbl_rat.nm_rat; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rat.nm_rat IS 'DESCRICAO';


--
-- TOC entry 8385 (class 0 OID 0)
-- Dependencies: 339
-- Name: COLUMN tbl_rat.fg_atv_rat; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rat.fg_atv_rat IS 'FLAG DE ATIVO';


--
-- TOC entry 901 (class 1259 OID 1002037)
-- Name: tbl_rcf; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_rcf (
    cd_rcf numeric(10,0) NOT NULL,
    nm_rcf character varying(40) NOT NULL,
    vl_rcf character varying(40) NOT NULL,
    fg_atv_rcf character varying(1) NOT NULL,
    CONSTRAINT ck_fg_atv_rcf CHECK (((fg_atv_rcf)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_rcf OWNER TO scan;

--
-- TOC entry 8386 (class 0 OID 0)
-- Dependencies: 901
-- Name: TABLE tbl_rcf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_rcf IS 'tabela de relatorio condicao filtros';


--
-- TOC entry 8387 (class 0 OID 0)
-- Dependencies: 901
-- Name: COLUMN tbl_rcf.cd_rcf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rcf.cd_rcf IS 'codigo';


--
-- TOC entry 8388 (class 0 OID 0)
-- Dependencies: 901
-- Name: COLUMN tbl_rcf.nm_rcf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rcf.nm_rcf IS 'nome';


--
-- TOC entry 8389 (class 0 OID 0)
-- Dependencies: 901
-- Name: COLUMN tbl_rcf.vl_rcf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rcf.vl_rcf IS 'valor';


--
-- TOC entry 8390 (class 0 OID 0)
-- Dependencies: 901
-- Name: COLUMN tbl_rcf.fg_atv_rcf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rcf.fg_atv_rcf IS 'flag ativo';


--
-- TOC entry 900 (class 1259 OID 1002028)
-- Name: tbl_rel; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_rel (
    cd_rel numeric(10,0) NOT NULL,
    nm_rel character varying(100) NOT NULL,
    sql_rel character varying(80000) NOT NULL,
    fg_atv_rel character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    CONSTRAINT ck_fg_atv_rel CHECK (((fg_atv_rel)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_rel OWNER TO scan;

--
-- TOC entry 8391 (class 0 OID 0)
-- Dependencies: 900
-- Name: TABLE tbl_rel; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_rel IS 'tabela de relatório';


--
-- TOC entry 8392 (class 0 OID 0)
-- Dependencies: 900
-- Name: COLUMN tbl_rel.cd_rel; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rel.cd_rel IS 'codigo';


--
-- TOC entry 8393 (class 0 OID 0)
-- Dependencies: 900
-- Name: COLUMN tbl_rel.nm_rel; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rel.nm_rel IS 'nome';


--
-- TOC entry 8394 (class 0 OID 0)
-- Dependencies: 900
-- Name: COLUMN tbl_rel.sql_rel; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rel.sql_rel IS 'sql';


--
-- TOC entry 8395 (class 0 OID 0)
-- Dependencies: 900
-- Name: COLUMN tbl_rel.fg_atv_rel; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rel.fg_atv_rel IS 'flag ativo';


--
-- TOC entry 8396 (class 0 OID 0)
-- Dependencies: 900
-- Name: COLUMN tbl_rel.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rel.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8397 (class 0 OID 0)
-- Dependencies: 900
-- Name: COLUMN tbl_rel.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rel.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8398 (class 0 OID 0)
-- Dependencies: 900
-- Name: COLUMN tbl_rel.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rel.cd_alt_usr IS 'codigo do usuario de alteracao';


--
-- TOC entry 8399 (class 0 OID 0)
-- Dependencies: 900
-- Name: COLUMN tbl_rel.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rel.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 902 (class 1259 OID 1002043)
-- Name: tbl_rfl; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_rfl (
    cd_rfl numeric(10,0) NOT NULL,
    cd_rel numeric(10,0) NOT NULL,
    cd_rcf numeric(10,0) NOT NULL,
    tp_rfl numeric(2,0) NOT NULL,
    sq_rfl numeric(2,0) NOT NULL,
    al_rfl character varying(40) NOT NULL,
    nm_rfl character varying(20) NOT NULL,
    dl_rfl character varying(80),
    fg_obr_rfl character varying(1) NOT NULL,
    fg_atv_rfl character varying(1) NOT NULL,
    CONSTRAINT ck_fg_atv_rfl CHECK (((fg_atv_rfl)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar]))),
    CONSTRAINT ck_fg_obr_rfl CHECK (((fg_obr_rfl)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_rfl OWNER TO scan;

--
-- TOC entry 8400 (class 0 OID 0)
-- Dependencies: 902
-- Name: TABLE tbl_rfl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_rfl IS 'tabela de relatorio filtros';


--
-- TOC entry 8401 (class 0 OID 0)
-- Dependencies: 902
-- Name: COLUMN tbl_rfl.cd_rfl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rfl.cd_rfl IS 'codigo';


--
-- TOC entry 8402 (class 0 OID 0)
-- Dependencies: 902
-- Name: COLUMN tbl_rfl.cd_rel; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rfl.cd_rel IS 'codigo do relatorio';


--
-- TOC entry 8403 (class 0 OID 0)
-- Dependencies: 902
-- Name: COLUMN tbl_rfl.cd_rcf; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rfl.cd_rcf IS 'codigo do relat�rio condi��o filtro';


--
-- TOC entry 8404 (class 0 OID 0)
-- Dependencies: 902
-- Name: COLUMN tbl_rfl.tp_rfl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rfl.tp_rfl IS 'tipo (dominio)';


--
-- TOC entry 8405 (class 0 OID 0)
-- Dependencies: 902
-- Name: COLUMN tbl_rfl.sq_rfl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rfl.sq_rfl IS 'sequencia';


--
-- TOC entry 8406 (class 0 OID 0)
-- Dependencies: 902
-- Name: COLUMN tbl_rfl.al_rfl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rfl.al_rfl IS 'alias (descricao na tela)';


--
-- TOC entry 8407 (class 0 OID 0)
-- Dependencies: 902
-- Name: COLUMN tbl_rfl.nm_rfl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rfl.nm_rfl IS 'nome (nome do campo na tabela)';


--
-- TOC entry 8408 (class 0 OID 0)
-- Dependencies: 902
-- Name: COLUMN tbl_rfl.dl_rfl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rfl.dl_rfl IS 'detalhe (em caso de lov serao os campoDestino da variaveisLista separados por ponto e virgula)';


--
-- TOC entry 8409 (class 0 OID 0)
-- Dependencies: 902
-- Name: COLUMN tbl_rfl.fg_obr_rfl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rfl.fg_obr_rfl IS 'flag obrigatorio';


--
-- TOC entry 8410 (class 0 OID 0)
-- Dependencies: 902
-- Name: COLUMN tbl_rfl.fg_atv_rfl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rfl.fg_atv_rfl IS 'flag ativo';


--
-- TOC entry 903 (class 1259 OID 1002055)
-- Name: tbl_rrl; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_rrl (
    cd_rrl numeric(10,0) NOT NULL,
    cd_rel numeric(10,0) NOT NULL,
    tp_rrl numeric(2,0) NOT NULL,
    sq_rrl numeric(2,0) NOT NULL,
    al_rrl character varying(40) NOT NULL,
    nm_rrl character varying(200) NOT NULL,
    dl_rrl character varying(80),
    fg_atv_rrl character varying(1) NOT NULL,
    CONSTRAINT ck_fg_atv_rrl CHECK (((fg_atv_rrl)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_rrl OWNER TO scan;

--
-- TOC entry 8411 (class 0 OID 0)
-- Dependencies: 903
-- Name: TABLE tbl_rrl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_rrl IS 'tabela de relatorio resultados';


--
-- TOC entry 8412 (class 0 OID 0)
-- Dependencies: 903
-- Name: COLUMN tbl_rrl.cd_rrl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rrl.cd_rrl IS 'codigo';


--
-- TOC entry 8413 (class 0 OID 0)
-- Dependencies: 903
-- Name: COLUMN tbl_rrl.cd_rel; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rrl.cd_rel IS 'codigo do relatorio';


--
-- TOC entry 8414 (class 0 OID 0)
-- Dependencies: 903
-- Name: COLUMN tbl_rrl.tp_rrl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rrl.tp_rrl IS 'tipo (dominio)';


--
-- TOC entry 8415 (class 0 OID 0)
-- Dependencies: 903
-- Name: COLUMN tbl_rrl.sq_rrl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rrl.sq_rrl IS 'sequencia';


--
-- TOC entry 8416 (class 0 OID 0)
-- Dependencies: 903
-- Name: COLUMN tbl_rrl.al_rrl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rrl.al_rrl IS 'alias (descricao na tela)';


--
-- TOC entry 8417 (class 0 OID 0)
-- Dependencies: 903
-- Name: COLUMN tbl_rrl.nm_rrl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rrl.nm_rrl IS 'nome (nome do campo na tabela)';


--
-- TOC entry 8418 (class 0 OID 0)
-- Dependencies: 903
-- Name: COLUMN tbl_rrl.dl_rrl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rrl.dl_rrl IS 'detalhe (em caso de lov serao os campoDestino da variaveisLista separados por ponto e virgula)';


--
-- TOC entry 8419 (class 0 OID 0)
-- Dependencies: 903
-- Name: COLUMN tbl_rrl.fg_atv_rrl; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_rrl.fg_atv_rrl IS 'flag ativo';


--
-- TOC entry 866 (class 1259 OID 948952)
-- Name: tbl_tlf_aux; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_tlf_aux (
    cpf numeric(14,0),
    ddd numeric(10,0),
    telefone numeric(10,0)
);


ALTER TABLE tbl_tlf_aux OWNER TO scan;

--
-- TOC entry 340 (class 1259 OID 565152)
-- Name: tbl_tlt_ctr; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_tlt_ctr (
    cd_tlt_ctr numeric(10,0) NOT NULL,
    cd_tlt numeric(10,0) NOT NULL,
    pr_lmt numeric(13,2) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_fem_ctr numeric(10,0) NOT NULL
);


ALTER TABLE tbl_tlt_ctr OWNER TO scan;

--
-- TOC entry 8420 (class 0 OID 0)
-- Dependencies: 340
-- Name: TABLE tbl_tlt_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_tlt_ctr IS 'TABELA DE TIPO DE LIMITES DO CONTRATO';


--
-- TOC entry 8421 (class 0 OID 0)
-- Dependencies: 340
-- Name: COLUMN tbl_tlt_ctr.cd_tlt_ctr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_tlt_ctr.cd_tlt_ctr IS 'CODIGO';


--
-- TOC entry 8422 (class 0 OID 0)
-- Dependencies: 340
-- Name: COLUMN tbl_tlt_ctr.cd_tlt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_tlt_ctr.cd_tlt IS 'CODIGO DO TIPO DE LIMITE';


--
-- TOC entry 8423 (class 0 OID 0)
-- Dependencies: 340
-- Name: COLUMN tbl_tlt_ctr.pr_lmt; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_tlt_ctr.pr_lmt IS 'PERCENTUAL DO LIMITE';


--
-- TOC entry 8424 (class 0 OID 0)
-- Dependencies: 340
-- Name: COLUMN tbl_tlt_ctr.cd_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_tlt_ctr.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8425 (class 0 OID 0)
-- Dependencies: 340
-- Name: COLUMN tbl_tlt_ctr.cd_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_tlt_ctr.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 8426 (class 0 OID 0)
-- Dependencies: 340
-- Name: COLUMN tbl_tlt_ctr.dt_inc_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_tlt_ctr.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 8427 (class 0 OID 0)
-- Dependencies: 340
-- Name: COLUMN tbl_tlt_ctr.dt_alt_usr; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_tlt_ctr.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 341 (class 1259 OID 565155)
-- Name: tbl_toe; Type: TABLE; Schema: sc_cad; Owner: scan
--

CREATE TABLE tbl_toe (
    cd_toe numeric(10,0) NOT NULL,
    nm_toe character varying(50) NOT NULL,
    fg_vsv_toe character varying(1) DEFAULT 'S'::character varying NOT NULL
);


ALTER TABLE tbl_toe OWNER TO scan;

--
-- TOC entry 8428 (class 0 OID 0)
-- Dependencies: 341
-- Name: TABLE tbl_toe; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON TABLE tbl_toe IS 'TABELA DE TIPO DE OCORRÊNCIA DE EMPRESA';


--
-- TOC entry 8429 (class 0 OID 0)
-- Dependencies: 341
-- Name: COLUMN tbl_toe.cd_toe; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_toe.cd_toe IS 'codigo';


--
-- TOC entry 8430 (class 0 OID 0)
-- Dependencies: 341
-- Name: COLUMN tbl_toe.nm_toe; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_toe.nm_toe IS 'descrição';


--
-- TOC entry 8431 (class 0 OID 0)
-- Dependencies: 341
-- Name: COLUMN tbl_toe.fg_vsv_toe; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON COLUMN tbl_toe.fg_vsv_toe IS 'flag visível';


--
-- TOC entry 342 (class 1259 OID 565159)
-- Name: vw_edr_ant; Type: VIEW; Schema: sc_cad; Owner: scan
--

CREATE VIEW vw_edr_ant AS
SELECT edr.cd_cun, edr.cd_edr, edr.cep_edr, edr.tp_edr, edr.nr_edr, edr.cpl_edr, edr.fg_atv_edr, CASE WHEN (crr.logradouro IS NULL) THEN ((eex.nm_log_eex)::text)::character varying ELSE crr.logradouro END AS logradouro, CASE WHEN (crr.logradouro IS NULL) THEN eex.nm_brr_eex ELSE crr.bairro END AS bairro, CASE WHEN (crr.localidade IS NULL) THEN eex.nm_loc_eex ELSE crr.localidade END AS localidade, CASE WHEN (crr.uf IS NULL) THEN (((eex.uf_eex)::character varying)::bpchar)::character varying ELSE crr.uf END AS uf, CASE WHEN (crr.localidade IS NULL) THEN 'N'::text ELSE 'S'::text END AS cep_valido, edr.cd_inc_usr, edr.dt_inc_usr, edr.cd_alt_usr, edr.dt_alt_usr, 'NOME DO TIPO DE ENDERECO' AS nm_tipo FROM ((tbl_edr edr LEFT JOIN sc_crr.vw_crr crr ON ((edr.cep_edr = crr.cep))) LEFT JOIN tbl_eex eex ON ((edr.cd_edr = eex.cd_edr)));


ALTER TABLE vw_edr_ant OWNER TO scan;

--
-- TOC entry 343 (class 1259 OID 565164)
-- Name: vw_edr_cun; Type: VIEW; Schema: sc_cad; Owner: scan
--

CREATE VIEW vw_edr_cun AS
SELECT edr.cd_edr AS codigo_endereco, edr.cd_cun AS cadastro_unico, fem.cd_emp AS codigo_empresa, fem.cd_fem AS codigo_filial, ((((((((((((edr.logradouro)::text || ', '::text) || (edr.nr_edr)::text) || ', '::text) || CASE WHEN (btrim((edr.cpl_edr)::text) <> ''::text) THEN ((edr.cpl_edr)::text || ', '::text) ELSE ''::text END) || (edr.bairro)::text) || ', '::text) || (edr.localidade)::text) || ', '::text) || (edr.uf)::text) || ', '::text) || edr.cep_edr) AS descricao_endereco FROM ((tbl_fem fem JOIN tbl_cun cun ON ((cun.cd_cun = fem.cd_cun))) JOIN vw_edr edr ON ((edr.cd_cun = cun.cd_cun))) WHERE (edr.fg_atv_edr = 'S'::bpchar);


ALTER TABLE vw_edr_cun OWNER TO scan;

SET search_path = sc_sgr, pg_catalog;

--
-- TOC entry 344 (class 1259 OID 565169)
-- Name: tbl_eus; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_eus (
    cd_eus numeric(10,0) NOT NULL,
    cd_usr numeric(10,0) NOT NULL,
    tp_eus numeric(5,0) NOT NULL,
    nsu_eus numeric(10,0) NOT NULL,
    cmp_eus numeric(10,0),
    fg_atv_eus character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_eus OWNER TO scan;

--
-- TOC entry 8432 (class 0 OID 0)
-- Dependencies: 344
-- Name: TABLE tbl_eus; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_eus IS 'EXTENSAO DE USUARIO';


--
-- TOC entry 8433 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN tbl_eus.cd_eus; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_eus.cd_eus IS 'CODIGO';


--
-- TOC entry 8434 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN tbl_eus.cd_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_eus.cd_usr IS 'USUARIO';


--
-- TOC entry 8435 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN tbl_eus.tp_eus; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_eus.tp_eus IS 'TIPO';


--
-- TOC entry 8436 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN tbl_eus.nsu_eus; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_eus.nsu_eus IS 'NSU';


--
-- TOC entry 8437 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN tbl_eus.cmp_eus; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_eus.cmp_eus IS 'COMPLEMENTO';


--
-- TOC entry 8438 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN tbl_eus.fg_atv_eus; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_eus.fg_atv_eus IS 'FLAG ATIVO';


--
-- TOC entry 8439 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN tbl_eus.cd_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_eus.cd_inc_usr IS 'USUARIO INCLUSAO';


--
-- TOC entry 8440 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN tbl_eus.dt_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_eus.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 8441 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN tbl_eus.cd_alt_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_eus.cd_alt_usr IS 'USUARIO ALTERACAO';


--
-- TOC entry 8442 (class 0 OID 0)
-- Dependencies: 344
-- Name: COLUMN tbl_eus.dt_alt_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_eus.dt_alt_usr IS 'DATA ALTERACAO';


SET search_path = sc_cad, pg_catalog;

--
-- TOC entry 345 (class 1259 OID 565172)
-- Name: vw_emp; Type: VIEW; Schema: sc_cad; Owner: scan
--

CREATE VIEW vw_emp AS
SELECT DISTINCT emp.cd_emp, emp.nm_emp, eus.cd_usr FROM (tbl_emp emp JOIN sc_sgr.tbl_eus eus ON ((emp.cd_emp = eus.nsu_eus))) WHERE (((eus.fg_atv_eus)::text = 'S'::text) AND (eus.tp_eus = (1)::numeric));


ALTER TABLE vw_emp OWNER TO scan;

--
-- TOC entry 8443 (class 0 OID 0)
-- Dependencies: 345
-- Name: VIEW vw_emp; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON VIEW vw_emp IS 'VISAO DE EMPRESA QUE MOSTRA AS EMPRESAS QUE OS USUARIOS TEM ACESSO';


--
-- TOC entry 346 (class 1259 OID 565176)
-- Name: vw_fem; Type: VIEW; Schema: sc_cad; Owner: scan
--

CREATE VIEW vw_fem AS
SELECT DISTINCT fem.cd_fem, fem.cd_emp, fem.nm_fem, eus.cd_usr FROM (tbl_fem fem JOIN sc_sgr.tbl_eus eus ON (((fem.cd_emp = eus.nsu_eus) AND ((fem.cd_fem = eus.cmp_eus) OR (eus.cmp_eus IS NULL))))) WHERE (((eus.fg_atv_eus)::text = 'S'::text) AND (eus.tp_eus = (1)::numeric));


ALTER TABLE vw_fem OWNER TO scan;

--
-- TOC entry 8444 (class 0 OID 0)
-- Dependencies: 346
-- Name: VIEW vw_fem; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON VIEW vw_fem IS 'VISAO DE FILIAL QUE MOSTRA AS FILIAIS QUE OS USUARIOS TEM ACESSO';


--
-- TOC entry 347 (class 1259 OID 565180)
-- Name: vw_fnc; Type: VIEW; Schema: sc_cad; Owner: scan
--

CREATE VIEW vw_fnc AS
SELECT DISTINCT fnc.cd_fem, fnc.cd_emp, fnc.nr_idt_fnc, cun.nm_cun, eus.cd_usr FROM ((tbl_fnc fnc JOIN tbl_cun cun ON ((fnc.cd_cun = cun.cd_cun))) JOIN sc_sgr.tbl_eus eus ON (((fnc.cd_emp = eus.nsu_eus) AND ((fnc.cd_fem = eus.cmp_eus) OR (eus.cmp_eus IS NULL))))) WHERE (((eus.fg_atv_eus)::text = 'S'::text) AND (eus.tp_eus = (1)::numeric));


ALTER TABLE vw_fnc OWNER TO scan;

--
-- TOC entry 8445 (class 0 OID 0)
-- Dependencies: 347
-- Name: VIEW vw_fnc; Type: COMMENT; Schema: sc_cad; Owner: scan
--

COMMENT ON VIEW vw_fnc IS 'VISAO DE FUNCIONARIO QUE MOSTRA OS FUNCIONARIOS QUE OS USUARIOS TEM ACESSO';


--
-- TOC entry 348 (class 1259 OID 565185)
-- Name: vw_fnc_cun; Type: VIEW; Schema: sc_cad; Owner: scan
--

CREATE VIEW vw_fnc_cun AS
SELECT fnc.cd_emp, fnc.cd_fem, fnc.nr_idt_fnc, cun.nm_cun FROM (tbl_fnc fnc JOIN tbl_cun cun ON ((cun.cd_cun = fnc.cd_cun))) WHERE (fnc.st_fnc <> (2)::numeric);


ALTER TABLE vw_fnc_cun OWNER TO scan;

SET search_path = sc_svg, pg_catalog;

--
-- TOC entry 746 (class 1259 OID 566459)
-- Name: tbl_csg; Type: TABLE; Schema: sc_svg; Owner: scan
--

CREATE TABLE tbl_csg (
    cd_csg numeric(10,0) NOT NULL,
    cd_emp numeric(10,0) NOT NULL,
    fg_atv_csg character(1) DEFAULT 'S'::bpchar NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_alt_usr numeric(10,0),
    cd_sga numeric(10,0) NOT NULL,
    vl_csg numeric(13,2) NOT NULL,
    cd_ctr_sga_csg character varying(20),
    cd_grt numeric(5,0),
    nr_apl_sga_csg character varying(20),
    idt_ext_csg character varying(20),
    fg_fat_fem_csg character(1) NOT NULL
);


ALTER TABLE tbl_csg OWNER TO scan;

--
-- TOC entry 8446 (class 0 OID 0)
-- Dependencies: 746
-- Name: TABLE tbl_csg; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON TABLE tbl_csg IS 'Tabela de contrato de seguro em grupo';


--
-- TOC entry 8447 (class 0 OID 0)
-- Dependencies: 746
-- Name: COLUMN tbl_csg.cd_csg; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON COLUMN tbl_csg.cd_csg IS 'codigo';


--
-- TOC entry 8448 (class 0 OID 0)
-- Dependencies: 746
-- Name: COLUMN tbl_csg.cd_emp; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON COLUMN tbl_csg.cd_emp IS 'empresa';


--
-- TOC entry 8449 (class 0 OID 0)
-- Dependencies: 746
-- Name: COLUMN tbl_csg.fg_atv_csg; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON COLUMN tbl_csg.fg_atv_csg IS 'flag de ativo';


--
-- TOC entry 8450 (class 0 OID 0)
-- Dependencies: 746
-- Name: COLUMN tbl_csg.dt_inc_usr; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON COLUMN tbl_csg.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8451 (class 0 OID 0)
-- Dependencies: 746
-- Name: COLUMN tbl_csg.cd_inc_usr; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON COLUMN tbl_csg.cd_inc_usr IS 'codigo do usuario de inclusao ';


--
-- TOC entry 8452 (class 0 OID 0)
-- Dependencies: 746
-- Name: COLUMN tbl_csg.dt_alt_usr; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON COLUMN tbl_csg.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 8453 (class 0 OID 0)
-- Dependencies: 746
-- Name: COLUMN tbl_csg.cd_alt_usr; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON COLUMN tbl_csg.cd_alt_usr IS 'codigo do usuario de alteracao';


--
-- TOC entry 8454 (class 0 OID 0)
-- Dependencies: 746
-- Name: COLUMN tbl_csg.cd_sga; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON COLUMN tbl_csg.cd_sga IS 'Codigo da Seguradora';


--
-- TOC entry 8455 (class 0 OID 0)
-- Dependencies: 746
-- Name: COLUMN tbl_csg.vl_csg; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON COLUMN tbl_csg.vl_csg IS 'Valor';


--
-- TOC entry 8456 (class 0 OID 0)
-- Dependencies: 746
-- Name: COLUMN tbl_csg.cd_ctr_sga_csg; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON COLUMN tbl_csg.cd_ctr_sga_csg IS 'CODIGO DO CONTRATO NA SEGURADORA';


--
-- TOC entry 8457 (class 0 OID 0)
-- Dependencies: 746
-- Name: COLUMN tbl_csg.cd_grt; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON COLUMN tbl_csg.cd_grt IS 'CODIGO DO GERENTE';


--
-- TOC entry 8458 (class 0 OID 0)
-- Dependencies: 746
-- Name: COLUMN tbl_csg.idt_ext_csg; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON COLUMN tbl_csg.idt_ext_csg IS 'Identificador extra no contrato para compor no nome do arquivo';


SET search_path = sc_cad, pg_catalog;

--
-- TOC entry 978 (class 1259 OID 1651185)
-- Name: vw_retorna_produtos_usuario; Type: VIEW; Schema: sc_cad; Owner: scan
--

CREATE VIEW vw_retorna_produtos_usuario AS
SELECT DISTINCT CASE WHEN ((ctr.cd_prd IS NULL) AND (csg.cd_csg IS NOT NULL)) THEN (1)::numeric ELSE ctr.cd_prd END AS cd_prd, eus.cd_usr FROM (((((sc_sgr.tbl_eus eus JOIN tbl_emp emp ON (((emp.cd_emp = eus.nsu_eus) AND (eus.tp_eus = (1)::numeric)))) JOIN tbl_fem fem ON ((fem.cd_emp = emp.cd_emp))) LEFT JOIN tbl_fem_ctr fem_ctr ON (((fem_ctr.cd_fem = fem.cd_fem) AND (fem_ctr.cd_emp = emp.cd_emp)))) LEFT JOIN tbl_ctr ctr ON ((ctr.cd_ctr = fem_ctr.cd_ctr))) LEFT JOIN sc_svg.tbl_csg csg ON ((csg.cd_emp = emp.cd_emp))) WHERE ((eus.tp_eus = (1)::numeric) AND ((ctr.cd_prd IS NOT NULL) OR (csg.cd_csg IS NOT NULL))) GROUP BY ctr.cd_prd, csg.cd_csg, eus.cd_usr;


ALTER TABLE vw_retorna_produtos_usuario OWNER TO scan;

SET search_path = sc_cap, pg_catalog;

--
-- TOC entry 349 (class 1259 OID 565189)
-- Name: sq_atd; Type: SEQUENCE; Schema: sc_cap; Owner: scan
--

CREATE SEQUENCE sq_atd
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_atd OWNER TO scan;

--
-- TOC entry 350 (class 1259 OID 565191)
-- Name: sq_cdc; Type: SEQUENCE; Schema: sc_cap; Owner: scan
--

CREATE SEQUENCE sq_cdc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_cdc OWNER TO scan;

--
-- TOC entry 351 (class 1259 OID 565193)
-- Name: sq_dsp; Type: SEQUENCE; Schema: sc_cap; Owner: scan
--

CREATE SEQUENCE sq_dsp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_dsp OWNER TO scan;

--
-- TOC entry 352 (class 1259 OID 565195)
-- Name: sq_frn; Type: SEQUENCE; Schema: sc_cap; Owner: scan
--

CREATE SEQUENCE sq_frn
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_frn OWNER TO scan;

--
-- TOC entry 353 (class 1259 OID 565197)
-- Name: sq_tdp; Type: SEQUENCE; Schema: sc_cap; Owner: scan
--

CREATE SEQUENCE sq_tdp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_tdp OWNER TO scan;

--
-- TOC entry 354 (class 1259 OID 565199)
-- Name: tbl_atd; Type: TABLE; Schema: sc_cap; Owner: scan
--

CREATE TABLE tbl_atd (
    cd_atd numeric(10,0) NOT NULL,
    ds_atd character varying(50) NOT NULL
);


ALTER TABLE tbl_atd OWNER TO scan;

--
-- TOC entry 8459 (class 0 OID 0)
-- Dependencies: 354
-- Name: TABLE tbl_atd; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON TABLE tbl_atd IS 'Tabela de Agrupamento de Tipo de Despesas';


--
-- TOC entry 355 (class 1259 OID 565202)
-- Name: tbl_cdc; Type: TABLE; Schema: sc_cap; Owner: scan
--

CREATE TABLE tbl_cdc (
    cd_cdc numeric(10,0) NOT NULL,
    nm_cdc character varying(100) NOT NULL,
    cd_cdc_pai numeric(10,0),
    fg_atv_cdc character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    tp_cdc numeric(2,0)
);


ALTER TABLE tbl_cdc OWNER TO scan;

--
-- TOC entry 8460 (class 0 OID 0)
-- Dependencies: 355
-- Name: TABLE tbl_cdc; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON TABLE tbl_cdc IS 'Tabela Centro de Custo';


--
-- TOC entry 8461 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN tbl_cdc.cd_cdc; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_cdc.cd_cdc IS 'Codigo';


--
-- TOC entry 8462 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN tbl_cdc.nm_cdc; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_cdc.nm_cdc IS 'Descrição do Centro de Custo';


--
-- TOC entry 8463 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN tbl_cdc.cd_cdc_pai; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_cdc.cd_cdc_pai IS 'Código do Centro de Custo Pai caso tenha';


--
-- TOC entry 8464 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN tbl_cdc.fg_atv_cdc; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_cdc.fg_atv_cdc IS 'Flag de Ativo';


--
-- TOC entry 8465 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN tbl_cdc.cd_inc_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_cdc.cd_inc_usr IS 'Usuario de inclusão';


--
-- TOC entry 8466 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN tbl_cdc.dt_inc_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_cdc.dt_inc_usr IS 'Data de inclusão';


--
-- TOC entry 8467 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN tbl_cdc.cd_alt_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_cdc.cd_alt_usr IS 'Usuario de Alteração';


--
-- TOC entry 8468 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN tbl_cdc.dt_alt_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_cdc.dt_alt_usr IS 'Data de Alteração';


--
-- TOC entry 8469 (class 0 OID 0)
-- Dependencies: 355
-- Name: COLUMN tbl_cdc.tp_cdc; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_cdc.tp_cdc IS 'TIPO DO CENTRO DE CUSTO';


--
-- TOC entry 356 (class 1259 OID 565205)
-- Name: tbl_cdp; Type: TABLE; Schema: sc_cap; Owner: scan
--

CREATE TABLE tbl_cdp (
    cd_dsp numeric(10,0) NOT NULL,
    tp_cdp numeric(2,0)
);


ALTER TABLE tbl_cdp OWNER TO scan;

--
-- TOC entry 8470 (class 0 OID 0)
-- Dependencies: 356
-- Name: TABLE tbl_cdp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON TABLE tbl_cdp IS 'tabela de classificacao de despesa';


--
-- TOC entry 8471 (class 0 OID 0)
-- Dependencies: 356
-- Name: COLUMN tbl_cdp.cd_dsp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_cdp.cd_dsp IS 'despesa';


--
-- TOC entry 8472 (class 0 OID 0)
-- Dependencies: 356
-- Name: COLUMN tbl_cdp.tp_cdp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_cdp.tp_cdp IS 'tipo de classificacao (ver tabela de dominio)';


--
-- TOC entry 357 (class 1259 OID 565208)
-- Name: tbl_dsp; Type: TABLE; Schema: sc_cap; Owner: scan
--

CREATE TABLE tbl_dsp (
    cd_dsp numeric(10,0) NOT NULL,
    cd_cdc numeric(10,0) NOT NULL,
    cd_frn numeric(10,0),
    cd_tdp numeric(10,0) NOT NULL,
    st_dsp numeric(2,0) NOT NULL,
    vl_dsp numeric(13,2) NOT NULL,
    dt_ref_dsp date NOT NULL,
    dt_pgt_dsp date NOT NULL,
    tp_pgt_dsp numeric(2,0) NOT NULL,
    ds_dsp character varying(150) NOT NULL,
    cd_cbf numeric(10,0),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_cnc_usr numeric(10,0),
    dt_cnc_usr timestamp without time zone,
    cd_aut_usr numeric(10,0),
    dt_aut_usr timestamp without time zone,
    cd_cnf_usr numeric(10,0),
    dt_cnf_usr timestamp without time zone,
    cd_cnt numeric(10,0),
    vl_pis_dsp numeric(13,2),
    vl_cofins_dsp numeric(13,2),
    vl_ir_dsp numeric(13,2),
    vl_inss_dsp numeric(13,2),
    vl_csll_dsp numeric(13,2),
    vl_iss_dsp numeric(13,2),
    nr_prc_dsp numeric(2,0) NOT NULL,
    nr_nf_dsp numeric(10,0),
    cd_cnt_dbt_dsp numeric(10,0),
    tp_dbt_dsp numeric(1,0) DEFAULT 1 NOT NULL,
    ord_prc_dsp numeric(2,0) DEFAULT 1 NOT NULL,
    vl_prc_dsp numeric(13,2),
    fg_prv_dsp character(1) DEFAULT 'S'::bpchar NOT NULL,
    vl_dsc_dsp numeric(13,2)
);


ALTER TABLE tbl_dsp OWNER TO scan;

--
-- TOC entry 8473 (class 0 OID 0)
-- Dependencies: 357
-- Name: TABLE tbl_dsp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON TABLE tbl_dsp IS 'Tabela de Despesa';


--
-- TOC entry 8474 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.cd_dsp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_dsp IS 'Codigo';


--
-- TOC entry 8475 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.cd_cdc; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_cdc IS 'Codigo do Centro de Custo';


--
-- TOC entry 8476 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.cd_frn; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_frn IS 'Codigo do Fornecedor';


--
-- TOC entry 8477 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.cd_tdp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_tdp IS 'Codigo do Tipo de Despesa';


--
-- TOC entry 8478 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.st_dsp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.st_dsp IS 'Situação da Despesa (Ver Dominio)';


--
-- TOC entry 8479 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.vl_dsp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.vl_dsp IS 'Valor da Despesa';


--
-- TOC entry 8480 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.dt_ref_dsp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.dt_ref_dsp IS 'Data de Referencia da Despesa';


--
-- TOC entry 8481 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.dt_pgt_dsp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.dt_pgt_dsp IS 'Valor de Pagamento da Despesa';


--
-- TOC entry 8482 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.tp_pgt_dsp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.tp_pgt_dsp IS 'Tipo de Pagamento da Despesa (Ver Dominio)';


--
-- TOC entry 8483 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.ds_dsp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.ds_dsp IS 'Descricao da Despesa';


--
-- TOC entry 8484 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.cd_cbf; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_cbf IS 'Código da Conta Bancária do Fornecedor';


--
-- TOC entry 8485 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.cd_inc_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_inc_usr IS 'Usuario de inclusão';


--
-- TOC entry 8486 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.dt_inc_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.dt_inc_usr IS 'Data de inclusão';


--
-- TOC entry 8487 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.cd_alt_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_alt_usr IS 'Usuario de Alteração';


--
-- TOC entry 8488 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.dt_alt_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.dt_alt_usr IS 'Data de Alteração';


--
-- TOC entry 8489 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.cd_cnc_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_cnc_usr IS 'Usuario de cancelamento';


--
-- TOC entry 8490 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.dt_cnc_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.dt_cnc_usr IS 'Data de cancelamento';


--
-- TOC entry 8491 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.cd_aut_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_aut_usr IS 'Usuario de autorizacao';


--
-- TOC entry 8492 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.dt_aut_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.dt_aut_usr IS 'Data de autorizacao';


--
-- TOC entry 8493 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.cd_cnf_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_cnf_usr IS 'Usuario de confirmacao';


--
-- TOC entry 8494 (class 0 OID 0)
-- Dependencies: 357
-- Name: COLUMN tbl_dsp.dt_cnf_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.dt_cnf_usr IS 'Data de confirmacao';


--
-- TOC entry 358 (class 1259 OID 565214)
-- Name: tbl_frn; Type: TABLE; Schema: sc_cap; Owner: scan
--

CREATE TABLE tbl_frn (
    cd_frn numeric(10,0) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    fg_atv_frn character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_cnt numeric(10,0) NOT NULL,
    cd_tdp numeric(10,0)
);


ALTER TABLE tbl_frn OWNER TO scan;

--
-- TOC entry 8495 (class 0 OID 0)
-- Dependencies: 358
-- Name: TABLE tbl_frn; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON TABLE tbl_frn IS 'Tabela de Fornecedor';


--
-- TOC entry 8496 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN tbl_frn.cd_frn; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_frn.cd_frn IS 'Codigo';


--
-- TOC entry 8497 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN tbl_frn.cd_cun; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_frn.cd_cun IS 'Codigo do Cadastro Unico';


--
-- TOC entry 8498 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN tbl_frn.fg_atv_frn; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_frn.fg_atv_frn IS 'Flag de Ativo';


--
-- TOC entry 8499 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN tbl_frn.cd_inc_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_frn.cd_inc_usr IS 'Usuario de inclusão';


--
-- TOC entry 8500 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN tbl_frn.dt_inc_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_frn.dt_inc_usr IS 'Data de inclusão';


--
-- TOC entry 8501 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN tbl_frn.cd_alt_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_frn.cd_alt_usr IS 'Usuario de Alteração';


--
-- TOC entry 8502 (class 0 OID 0)
-- Dependencies: 358
-- Name: COLUMN tbl_frn.dt_alt_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_frn.dt_alt_usr IS 'Data de Alteração';


--
-- TOC entry 359 (class 1259 OID 565217)
-- Name: tbl_tdp; Type: TABLE; Schema: sc_cap; Owner: scan
--

CREATE TABLE tbl_tdp (
    cd_tdp numeric(10,0) NOT NULL,
    nm_tdp character varying(100) NOT NULL,
    fg_atv_tdp character varying(1) NOT NULL,
    cd_cnt numeric(10,0) NOT NULL,
    cd_tlc numeric(10,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_atd numeric(10,0)
);


ALTER TABLE tbl_tdp OWNER TO scan;

--
-- TOC entry 8503 (class 0 OID 0)
-- Dependencies: 359
-- Name: TABLE tbl_tdp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON TABLE tbl_tdp IS 'Tabela Tipo de Despesa';


--
-- TOC entry 8504 (class 0 OID 0)
-- Dependencies: 359
-- Name: COLUMN tbl_tdp.cd_tdp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.cd_tdp IS 'Codigo';


--
-- TOC entry 8505 (class 0 OID 0)
-- Dependencies: 359
-- Name: COLUMN tbl_tdp.nm_tdp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.nm_tdp IS 'Descrição do Tipo de Despesa';


--
-- TOC entry 8506 (class 0 OID 0)
-- Dependencies: 359
-- Name: COLUMN tbl_tdp.fg_atv_tdp; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.fg_atv_tdp IS 'Flag de Ativo';


--
-- TOC entry 8507 (class 0 OID 0)
-- Dependencies: 359
-- Name: COLUMN tbl_tdp.cd_cnt; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.cd_cnt IS 'Codigo da Conta';


--
-- TOC entry 8508 (class 0 OID 0)
-- Dependencies: 359
-- Name: COLUMN tbl_tdp.cd_tlc; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.cd_tlc IS 'Codigo do Tipo de Lançamento';


--
-- TOC entry 8509 (class 0 OID 0)
-- Dependencies: 359
-- Name: COLUMN tbl_tdp.cd_inc_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.cd_inc_usr IS 'Usuario de inclusão';


--
-- TOC entry 8510 (class 0 OID 0)
-- Dependencies: 359
-- Name: COLUMN tbl_tdp.dt_inc_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.dt_inc_usr IS 'Data de inclusão';


--
-- TOC entry 8511 (class 0 OID 0)
-- Dependencies: 359
-- Name: COLUMN tbl_tdp.cd_alt_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.cd_alt_usr IS 'Usuario de Alteração';


--
-- TOC entry 8512 (class 0 OID 0)
-- Dependencies: 359
-- Name: COLUMN tbl_tdp.dt_alt_usr; Type: COMMENT; Schema: sc_cap; Owner: scan
--

COMMENT ON COLUMN tbl_tdp.dt_alt_usr IS 'Data de Alteração';


SET search_path = sc_cbe, pg_catalog;

--
-- TOC entry 991 (class 1259 OID 1672254)
-- Name: acordo_funcionario_empresa; Type: TABLE; Schema: sc_cbe; Owner: scan
--

CREATE TABLE acordo_funcionario_empresa (
    id bigint NOT NULL,
    empresa integer NOT NULL,
    cartao numeric(14,0) NOT NULL,
    cpf numeric(11,0) NOT NULL,
    valor_entrada double precision NOT NULL,
    valor_parcela_1 double precision NOT NULL,
    valor_parcela_2 double precision,
    valor_parcela_3 double precision,
    valor_parcela_4 double precision,
    valor_parcela_5 double precision,
    valor_parcela_6 double precision,
    valor_parcela_7 double precision,
    valor_parcela_8 double precision,
    valor_parcela_9 double precision,
    valor_parcela_10 double precision,
    valor_parcela_11 double precision,
    valor_parcela_12 double precision,
    cd_acr integer
);


ALTER TABLE acordo_funcionario_empresa OWNER TO scan;

--
-- TOC entry 8513 (class 0 OID 0)
-- Dependencies: 991
-- Name: TABLE acordo_funcionario_empresa; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON TABLE acordo_funcionario_empresa IS 'tabela que armazena os acordos que devem ser realizados com os funcionários de uma determinada empresa';


--
-- TOC entry 990 (class 1259 OID 1672252)
-- Name: acordo_funcionario_empresa_id_seq; Type: SEQUENCE; Schema: sc_cbe; Owner: scan
--

CREATE SEQUENCE acordo_funcionario_empresa_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE acordo_funcionario_empresa_id_seq OWNER TO scan;

--
-- TOC entry 8514 (class 0 OID 0)
-- Dependencies: 990
-- Name: acordo_funcionario_empresa_id_seq; Type: SEQUENCE OWNED BY; Schema: sc_cbe; Owner: scan
--

ALTER SEQUENCE acordo_funcionario_empresa_id_seq OWNED BY acordo_funcionario_empresa.id;


--
-- TOC entry 770 (class 1259 OID 840864)
-- Name: sq_acr; Type: SEQUENCE; Schema: sc_cbe; Owner: scan
--

CREATE SEQUENCE sq_acr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_acr OWNER TO scan;

--
-- TOC entry 846 (class 1259 OID 894939)
-- Name: sq_act; Type: SEQUENCE; Schema: sc_cbe; Owner: scan
--

CREATE SEQUENCE sq_act
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_act OWNER TO scan;

--
-- TOC entry 777 (class 1259 OID 844226)
-- Name: sq_bpr; Type: SEQUENCE; Schema: sc_cbe; Owner: scan
--

CREATE SEQUENCE sq_bpr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_bpr OWNER TO scan;

--
-- TOC entry 847 (class 1259 OID 894941)
-- Name: sq_dct; Type: SEQUENCE; Schema: sc_cbe; Owner: scan
--

CREATE SEQUENCE sq_dct
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dct OWNER TO scan;

--
-- TOC entry 769 (class 1259 OID 840862)
-- Name: sq_dvd; Type: SEQUENCE; Schema: sc_cbe; Owner: scan
--

CREATE SEQUENCE sq_dvd
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dvd OWNER TO scan;

--
-- TOC entry 768 (class 1259 OID 840860)
-- Name: sq_emc; Type: SEQUENCE; Schema: sc_cbe; Owner: scan
--

CREATE SEQUENCE sq_emc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_emc OWNER TO scan;

--
-- TOC entry 775 (class 1259 OID 844222)
-- Name: sq_pgp; Type: SEQUENCE; Schema: sc_cbe; Owner: scan
--

CREATE SEQUENCE sq_pgp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_pgp OWNER TO scan;

--
-- TOC entry 776 (class 1259 OID 844224)
-- Name: sq_prd; Type: SEQUENCE; Schema: sc_cbe; Owner: scan
--

CREATE SEQUENCE sq_prd
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_prd OWNER TO scan;

--
-- TOC entry 878 (class 1259 OID 975110)
-- Name: sq_rce; Type: SEQUENCE; Schema: sc_cbe; Owner: scan
--

CREATE SEQUENCE sq_rce
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rce OWNER TO scan;

--
-- TOC entry 772 (class 1259 OID 840876)
-- Name: tbl_acr; Type: TABLE; Schema: sc_cbe; Owner: scan
--

CREATE TABLE tbl_acr (
    cd_acr numeric(10,0) NOT NULL,
    cd_dvd numeric(10,0) NOT NULL,
    st_acr numeric(2,0) NOT NULL,
    frm_pgm_acr numeric(2,0) NOT NULL,
    vlr_mlt_acr numeric(5,2),
    vlr_mra_acr numeric(5,2),
    vlr_dsc_acr numeric(14,2),
    vlr_ent_acr numeric(14,2),
    vlr_cms_acr numeric(5,2) NOT NULL,
    qnt_prc_acr numeric(2,0) NOT NULL,
    vlr_prc_acr numeric(14,2),
    dt_vnc_ent_acr timestamp without time zone,
    dt_vnc_prm_prc_acr timestamp without time zone NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    vlr_esp_acr numeric(13,2),
    cd_emc numeric(10,0) DEFAULT 2 NOT NULL,
    fg_dbt_aut_acr character varying(1),
    tx_jrs_acr numeric(10,4)
);


ALTER TABLE tbl_acr OWNER TO scan;

--
-- TOC entry 8515 (class 0 OID 0)
-- Dependencies: 772
-- Name: TABLE tbl_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON TABLE tbl_acr IS 'tabela de acordos';


--
-- TOC entry 8516 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.cd_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.cd_acr IS 'codigo';


--
-- TOC entry 8517 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.cd_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.cd_dvd IS 'codigo do ultimo acordo';


--
-- TOC entry 8518 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.st_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.st_acr IS 'situação (ver domínio)';


--
-- TOC entry 8519 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.frm_pgm_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.frm_pgm_acr IS 'forma de pagamento';


--
-- TOC entry 8520 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.vlr_mlt_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.vlr_mlt_acr IS 'valor da multa';


--
-- TOC entry 8521 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.vlr_mra_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.vlr_mra_acr IS 'valor da mora';


--
-- TOC entry 8522 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.vlr_dsc_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.vlr_dsc_acr IS 'valor do desconto';


--
-- TOC entry 8523 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.vlr_ent_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.vlr_ent_acr IS 'valor da entrada';


--
-- TOC entry 8524 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.vlr_cms_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.vlr_cms_acr IS 'valor da comissao';


--
-- TOC entry 8525 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.qnt_prc_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.qnt_prc_acr IS 'quantidade de parcelas';


--
-- TOC entry 8526 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.vlr_prc_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.vlr_prc_acr IS 'valor da parcela';


--
-- TOC entry 8527 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.dt_vnc_ent_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.dt_vnc_ent_acr IS 'data de vencimento da entrada';


--
-- TOC entry 8528 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.dt_vnc_prm_prc_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.dt_vnc_prm_prc_acr IS 'data de vencimento da primeira parcela';


--
-- TOC entry 8529 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.cd_inc_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8530 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.dt_inc_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8531 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.cd_alt_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.cd_alt_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8532 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.dt_alt_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 8533 (class 0 OID 0)
-- Dependencies: 772
-- Name: COLUMN tbl_acr.tx_jrs_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_acr.tx_jrs_acr IS 'taxa de juros aplicada';


--
-- TOC entry 844 (class 1259 OID 894733)
-- Name: tbl_act; Type: TABLE; Schema: sc_cbe; Owner: scan
--

CREATE TABLE tbl_act (
    cd_act numeric(10,0) NOT NULL,
    cd_emc numeric(5,0),
    st_act numeric(1,0) DEFAULT 1 NOT NULL,
    dt_grc_act date,
    nr_reg_act numeric(5,0),
    vl_ttl_prc_act numeric(13,2),
    vl_ttl_act numeric(13,2),
    nr_reg_exc_act numeric(5,0),
    vl_ttl_cmp_act numeric(13,2),
    vl_ttl_ccb_act numeric(13,2),
    vl_ttl_cmp_exc_act numeric(13,2),
    vl_ttl_ccb_exc_act numeric(13,2),
    vl_ttl_prc_exc_act numeric(13,2),
    vl_ttl_exc_act numeric(13,2)
);


ALTER TABLE tbl_act OWNER TO scan;

--
-- TOC entry 8534 (class 0 OID 0)
-- Dependencies: 844
-- Name: COLUMN tbl_act.nr_reg_act; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_act.nr_reg_act IS 'Numero de registros de inclusao do arquivo';


--
-- TOC entry 8535 (class 0 OID 0)
-- Dependencies: 844
-- Name: COLUMN tbl_act.vl_ttl_prc_act; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_act.vl_ttl_prc_act IS 'Valor total de principal dos registros de inclusao do arquivo';


--
-- TOC entry 8536 (class 0 OID 0)
-- Dependencies: 844
-- Name: COLUMN tbl_act.vl_ttl_act; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_act.vl_ttl_act IS 'Valor total da divida dos registros de inclusao do arquivo';


--
-- TOC entry 8537 (class 0 OID 0)
-- Dependencies: 844
-- Name: COLUMN tbl_act.nr_reg_exc_act; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_act.nr_reg_exc_act IS 'Numero de registros de exclusao do arquivo';


--
-- TOC entry 8538 (class 0 OID 0)
-- Dependencies: 844
-- Name: COLUMN tbl_act.vl_ttl_cmp_act; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_act.vl_ttl_cmp_act IS 'Valor total de compra dos registros de inclusao do arquivo';


--
-- TOC entry 8539 (class 0 OID 0)
-- Dependencies: 844
-- Name: COLUMN tbl_act.vl_ttl_ccb_act; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_act.vl_ttl_ccb_act IS 'Valor total de ccb dos registros de inclusao do arquivo';


--
-- TOC entry 8540 (class 0 OID 0)
-- Dependencies: 844
-- Name: COLUMN tbl_act.vl_ttl_cmp_exc_act; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_act.vl_ttl_cmp_exc_act IS 'Valor total de compra dos registros de exclusao do arquivo';


--
-- TOC entry 8541 (class 0 OID 0)
-- Dependencies: 844
-- Name: COLUMN tbl_act.vl_ttl_ccb_exc_act; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_act.vl_ttl_ccb_exc_act IS 'Valor total de ccb dos registros de exclusao do arquivo';


--
-- TOC entry 8542 (class 0 OID 0)
-- Dependencies: 844
-- Name: COLUMN tbl_act.vl_ttl_prc_exc_act; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_act.vl_ttl_prc_exc_act IS 'Valor total de principal dos registros de exclusao do arquivo';


--
-- TOC entry 8543 (class 0 OID 0)
-- Dependencies: 844
-- Name: COLUMN tbl_act.vl_ttl_exc_act; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_act.vl_ttl_exc_act IS 'Valor total da divida dos registros de exclusao do arquivo';


--
-- TOC entry 778 (class 1259 OID 844228)
-- Name: tbl_bpr; Type: TABLE; Schema: sc_cbe; Owner: scan
--

CREATE TABLE tbl_bpr (
    cd_bpr numeric(10,0) NOT NULL,
    cd_prd numeric(10,0) NOT NULL,
    st_bpr numeric(2,0) NOT NULL,
    dsc_bpr character varying(200),
    dt_bpr timestamp without time zone NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    tp_bpr numeric(1,0) NOT NULL,
    cd_emc numeric(10,0) NOT NULL,
    vl_bpr numeric(13,2) NOT NULL,
    cd_rce numeric(10,0)
);


ALTER TABLE tbl_bpr OWNER TO scan;

--
-- TOC entry 8544 (class 0 OID 0)
-- Dependencies: 778
-- Name: TABLE tbl_bpr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON TABLE tbl_bpr IS 'tabela de baixa de pagamento de parcela';


--
-- TOC entry 8545 (class 0 OID 0)
-- Dependencies: 778
-- Name: COLUMN tbl_bpr.cd_bpr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_bpr.cd_bpr IS 'codigo';


--
-- TOC entry 8546 (class 0 OID 0)
-- Dependencies: 778
-- Name: COLUMN tbl_bpr.cd_prd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_bpr.cd_prd IS 'codigo da parcela do acordo';


--
-- TOC entry 8547 (class 0 OID 0)
-- Dependencies: 778
-- Name: COLUMN tbl_bpr.st_bpr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_bpr.st_bpr IS 'situação';


--
-- TOC entry 8548 (class 0 OID 0)
-- Dependencies: 778
-- Name: COLUMN tbl_bpr.dsc_bpr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_bpr.dsc_bpr IS 'descrição';


--
-- TOC entry 8549 (class 0 OID 0)
-- Dependencies: 778
-- Name: COLUMN tbl_bpr.dt_bpr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_bpr.dt_bpr IS 'data da baixa';


--
-- TOC entry 8550 (class 0 OID 0)
-- Dependencies: 778
-- Name: COLUMN tbl_bpr.cd_inc_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_bpr.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8551 (class 0 OID 0)
-- Dependencies: 778
-- Name: COLUMN tbl_bpr.dt_inc_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_bpr.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8552 (class 0 OID 0)
-- Dependencies: 778
-- Name: COLUMN tbl_bpr.cd_alt_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_bpr.cd_alt_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8553 (class 0 OID 0)
-- Dependencies: 778
-- Name: COLUMN tbl_bpr.dt_alt_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_bpr.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 8554 (class 0 OID 0)
-- Dependencies: 778
-- Name: COLUMN tbl_bpr.cd_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_bpr.cd_rce IS 'codigo do repasse';


--
-- TOC entry 845 (class 1259 OID 894744)
-- Name: tbl_dct; Type: TABLE; Schema: sc_cbe; Owner: scan
--

CREATE TABLE tbl_dct (
    cd_dct numeric(10,0) NOT NULL,
    cd_act numeric(10,0),
    cd_dvd numeric(14,0) NOT NULL,
    vl_prc_dct numeric(13,2) NOT NULL,
    vl_ttl_dct numeric(13,2) NOT NULL,
    nr_dia_atr_dct numeric(5,0) NOT NULL,
    dt_dvd_dct date NOT NULL,
    vl_ccb_dct numeric(13,2),
    vl_cmp_dct numeric(13,2),
    tp_dct numeric(2,0)
);


ALTER TABLE tbl_dct OWNER TO scan;

--
-- TOC entry 8555 (class 0 OID 0)
-- Dependencies: 845
-- Name: COLUMN tbl_dct.vl_ccb_dct; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dct.vl_ccb_dct IS 'Valor devido de CCB';


--
-- TOC entry 8556 (class 0 OID 0)
-- Dependencies: 845
-- Name: COLUMN tbl_dct.vl_cmp_dct; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dct.vl_cmp_dct IS 'Valor devido de Compra';


--
-- TOC entry 8557 (class 0 OID 0)
-- Dependencies: 845
-- Name: COLUMN tbl_dct.tp_dct; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dct.tp_dct IS 'Tipo';


--
-- TOC entry 773 (class 1259 OID 840881)
-- Name: tbl_dvd; Type: TABLE; Schema: sc_cbe; Owner: scan
--

CREATE TABLE tbl_dvd (
    cd_dvd numeric(10,0) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    cd_emc numeric(10,0) NOT NULL,
    cd_acr numeric(10,0),
    st_dvd numeric(2,0) NOT NULL,
    tp_org_dvd numeric(2,0) NOT NULL,
    nsu_org_dvd numeric(20,0) NOT NULL,
    vlr_prn_dvd numeric(14,2) NOT NULL,
    vlr_enc_dvd numeric(14,2) NOT NULL,
    dt_dvd timestamp without time zone NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    fg_atv_dvd character varying(1) NOT NULL,
    cd_act numeric(10,0),
    vl_ccb_dvd numeric(14,2),
    vl_cmp_dvd numeric(14,2),
    st_arq_dvd numeric(2,0),
    dt_exc_usr timestamp without time zone,
    mtv_exc_dvd numeric(2,0),
    cd_exc_act numeric(10,0)
);


ALTER TABLE tbl_dvd OWNER TO scan;

--
-- TOC entry 8558 (class 0 OID 0)
-- Dependencies: 773
-- Name: TABLE tbl_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON TABLE tbl_dvd IS 'tabela de divida';


--
-- TOC entry 8559 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.cd_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.cd_dvd IS 'codigo';


--
-- TOC entry 8560 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.cd_cun; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.cd_cun IS 'codigo do cadastro único';


--
-- TOC entry 8561 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.cd_emc; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.cd_emc IS 'codigo do acordo';


--
-- TOC entry 8562 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.st_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.st_dvd IS 'situação (ver domínio)';


--
-- TOC entry 8563 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.tp_org_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.tp_org_dvd IS 'tipo de origem';


--
-- TOC entry 8564 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.nsu_org_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.nsu_org_dvd IS 'nsu de origem';


--
-- TOC entry 8565 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.vlr_prn_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.vlr_prn_dvd IS 'valor principal';


--
-- TOC entry 8566 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.vlr_enc_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.vlr_enc_dvd IS 'valor dos encargos';


--
-- TOC entry 8567 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.dt_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.dt_dvd IS 'data da dívida';


--
-- TOC entry 8568 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.cd_inc_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8569 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.dt_inc_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8570 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.cd_alt_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.cd_alt_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8571 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.dt_alt_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 8572 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.fg_atv_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.fg_atv_dvd IS 'flag ativo';


--
-- TOC entry 8573 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.vl_ccb_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.vl_ccb_dvd IS 'Valor devido de CCB';


--
-- TOC entry 8574 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.vl_cmp_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.vl_cmp_dvd IS 'Valor devido de Compra';


--
-- TOC entry 8575 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.st_arq_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.st_arq_dvd IS 'Situação em relação a geração de arquivo (Ver tabela de dominio)';


--
-- TOC entry 8576 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.dt_exc_usr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.dt_exc_usr IS 'Data de exclusão da divida na empresa de cobranca';


--
-- TOC entry 8577 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.mtv_exc_dvd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.mtv_exc_dvd IS 'Motivo de exclusão da divida na empresa de cobranca';


--
-- TOC entry 8578 (class 0 OID 0)
-- Dependencies: 773
-- Name: COLUMN tbl_dvd.cd_exc_act; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_dvd.cd_exc_act IS 'Código do arquivo de exclusão da divida na empresa de cobranca';


--
-- TOC entry 771 (class 1259 OID 840866)
-- Name: tbl_emc; Type: TABLE; Schema: sc_cbe; Owner: scan
--

CREATE TABLE tbl_emc (
    cd_emc numeric(5,0) NOT NULL,
    nm_emc character varying(40) NOT NULL,
    cd_cun numeric(10,0),
    nr_dia_ini_atr_emc numeric(5,0),
    nr_dia_fim_atr_emc numeric(5,0),
    prc_cms_emc numeric(5,2),
    fg_atv_emc character varying(1) NOT NULL,
    nm_dir_arq character varying(100),
    vlr_min_emc numeric(13,2),
    vlr_max_emc numeric(13,2),
    dbt_cd_cnt numeric(10,0),
    crd_cd_cnt numeric(10,0)
);


ALTER TABLE tbl_emc OWNER TO scan;

--
-- TOC entry 8579 (class 0 OID 0)
-- Dependencies: 771
-- Name: TABLE tbl_emc; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON TABLE tbl_emc IS 'tabela de empresa de cobranca';


--
-- TOC entry 8580 (class 0 OID 0)
-- Dependencies: 771
-- Name: COLUMN tbl_emc.cd_emc; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_emc.cd_emc IS 'codigo';


--
-- TOC entry 8581 (class 0 OID 0)
-- Dependencies: 771
-- Name: COLUMN tbl_emc.nm_emc; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_emc.nm_emc IS 'nome';


--
-- TOC entry 8582 (class 0 OID 0)
-- Dependencies: 771
-- Name: COLUMN tbl_emc.cd_cun; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_emc.cd_cun IS 'codigo do cadastro unico';


--
-- TOC entry 8583 (class 0 OID 0)
-- Dependencies: 771
-- Name: COLUMN tbl_emc.nr_dia_ini_atr_emc; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_emc.nr_dia_ini_atr_emc IS 'dia inicial do atraso';


--
-- TOC entry 8584 (class 0 OID 0)
-- Dependencies: 771
-- Name: COLUMN tbl_emc.nr_dia_fim_atr_emc; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_emc.nr_dia_fim_atr_emc IS 'dia final do atraso';


--
-- TOC entry 8585 (class 0 OID 0)
-- Dependencies: 771
-- Name: COLUMN tbl_emc.prc_cms_emc; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_emc.prc_cms_emc IS 'percentual de comissão';


--
-- TOC entry 8586 (class 0 OID 0)
-- Dependencies: 771
-- Name: COLUMN tbl_emc.fg_atv_emc; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_emc.fg_atv_emc IS 'flag ativo';


--
-- TOC entry 8587 (class 0 OID 0)
-- Dependencies: 771
-- Name: COLUMN tbl_emc.nm_dir_arq; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_emc.nm_dir_arq IS 'diretorio do arquivo';


--
-- TOC entry 779 (class 1259 OID 844238)
-- Name: tbl_pgp; Type: TABLE; Schema: sc_cbe; Owner: scan
--

CREATE TABLE tbl_pgp (
    cd_pgp numeric(10,0) NOT NULL,
    cd_prd numeric(10,0) NOT NULL,
    st_pgp numeric(2,0) NOT NULL,
    vlr_pgp numeric(13,2) NOT NULL,
    dt_inc_pgp timestamp without time zone NOT NULL
);


ALTER TABLE tbl_pgp OWNER TO scan;

--
-- TOC entry 8588 (class 0 OID 0)
-- Dependencies: 779
-- Name: TABLE tbl_pgp; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON TABLE tbl_pgp IS 'tabela de pagamento de parcela';


--
-- TOC entry 8589 (class 0 OID 0)
-- Dependencies: 779
-- Name: COLUMN tbl_pgp.cd_pgp; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_pgp.cd_pgp IS 'codigo';


--
-- TOC entry 8590 (class 0 OID 0)
-- Dependencies: 779
-- Name: COLUMN tbl_pgp.cd_prd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_pgp.cd_prd IS 'codigo da parcela do acordo';


--
-- TOC entry 8591 (class 0 OID 0)
-- Dependencies: 779
-- Name: COLUMN tbl_pgp.st_pgp; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_pgp.st_pgp IS 'situação';


--
-- TOC entry 8592 (class 0 OID 0)
-- Dependencies: 779
-- Name: COLUMN tbl_pgp.vlr_pgp; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_pgp.vlr_pgp IS 'valor pagamento';


--
-- TOC entry 8593 (class 0 OID 0)
-- Dependencies: 779
-- Name: COLUMN tbl_pgp.dt_inc_pgp; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_pgp.dt_inc_pgp IS 'data de inclusão do pagamento';


--
-- TOC entry 774 (class 1259 OID 840907)
-- Name: tbl_prd; Type: TABLE; Schema: sc_cbe; Owner: scan
--

CREATE TABLE tbl_prd (
    cd_prd numeric(10,0) NOT NULL,
    cd_acr numeric(10,0) NOT NULL,
    cd_blt numeric(10,0),
    nr_prd numeric(2,0) NOT NULL,
    vlr_prd numeric(13,2) NOT NULL,
    st_prd numeric(2,0) NOT NULL,
    vlr_pgt_prd numeric(13,2),
    dt_vnc_prd timestamp without time zone,
    dt_ult_pgm_prd timestamp without time zone,
    fg_ent_prd character varying(1),
    fg_dbt_aut_prd character varying(1),
    dt_rps_prd date,
    cd_usr_rps_prd numeric(10,0)
);


ALTER TABLE tbl_prd OWNER TO scan;

--
-- TOC entry 8594 (class 0 OID 0)
-- Dependencies: 774
-- Name: TABLE tbl_prd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON TABLE tbl_prd IS 'tabela de parcela de acordo';


--
-- TOC entry 8595 (class 0 OID 0)
-- Dependencies: 774
-- Name: COLUMN tbl_prd.cd_prd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_prd.cd_prd IS 'codigo';


--
-- TOC entry 8596 (class 0 OID 0)
-- Dependencies: 774
-- Name: COLUMN tbl_prd.cd_acr; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_prd.cd_acr IS 'codigo do acordo';


--
-- TOC entry 8597 (class 0 OID 0)
-- Dependencies: 774
-- Name: COLUMN tbl_prd.cd_blt; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_prd.cd_blt IS 'codigo do boleto';


--
-- TOC entry 8598 (class 0 OID 0)
-- Dependencies: 774
-- Name: COLUMN tbl_prd.nr_prd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_prd.nr_prd IS 'numero da parcela';


--
-- TOC entry 8599 (class 0 OID 0)
-- Dependencies: 774
-- Name: COLUMN tbl_prd.vlr_prd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_prd.vlr_prd IS 'valor da parcela';


--
-- TOC entry 8600 (class 0 OID 0)
-- Dependencies: 774
-- Name: COLUMN tbl_prd.dt_rps_prd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_prd.dt_rps_prd IS 'data do repasse';


--
-- TOC entry 8601 (class 0 OID 0)
-- Dependencies: 774
-- Name: COLUMN tbl_prd.cd_usr_rps_prd; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_prd.cd_usr_rps_prd IS 'usuario de repasse';


--
-- TOC entry 877 (class 1259 OID 975071)
-- Name: tbl_rce; Type: TABLE; Schema: sc_cbe; Owner: scan
--

CREATE TABLE tbl_rce (
    cd_rce numeric(10,0) NOT NULL,
    cd_emc numeric(5,0),
    dt_rce date,
    st_rce numeric(5,0),
    vl_rce numeric(13,2),
    vl_cms_rce numeric(13,2),
    vl_bpr_rce numeric(13,2),
    qtd_bpr_rce numeric(5,0),
    cd_usr_inc_rce numeric(10,0),
    dt_inc_rce timestamp without time zone,
    cd_usr_prc_rce numeric(10,0),
    dt_prc_rce timestamp without time zone,
    cd_usr_cnc_rce numeric(10,0),
    dt_cnc_rce timestamp without time zone,
    dt_cmp_bnc_rce date
);


ALTER TABLE tbl_rce OWNER TO scan;

--
-- TOC entry 8602 (class 0 OID 0)
-- Dependencies: 877
-- Name: TABLE tbl_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON TABLE tbl_rce IS 'repasse da cobranca externa';


--
-- TOC entry 8603 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.cd_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.cd_rce IS 'codigo';


--
-- TOC entry 8604 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.cd_emc; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.cd_emc IS 'empresa de cobranca do repasse';


--
-- TOC entry 8605 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.dt_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.dt_rce IS 'data do repasse';


--
-- TOC entry 8606 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.st_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.st_rce IS 'situacao';


--
-- TOC entry 8607 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.vl_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.vl_rce IS 'valor';


--
-- TOC entry 8608 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.vl_cms_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.vl_cms_rce IS 'valor da comissao';


--
-- TOC entry 8609 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.vl_bpr_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.vl_bpr_rce IS 'valor total das baixas';


--
-- TOC entry 8610 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.qtd_bpr_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.qtd_bpr_rce IS 'quantidade total de baixas';


--
-- TOC entry 8611 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.cd_usr_inc_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.cd_usr_inc_rce IS 'codigo usuario inclusao';


--
-- TOC entry 8612 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.dt_inc_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.dt_inc_rce IS 'data de inclusao';


--
-- TOC entry 8613 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.cd_usr_prc_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.cd_usr_prc_rce IS 'codigo usuario de processamento';


--
-- TOC entry 8614 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.dt_prc_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.dt_prc_rce IS 'data de processamento';


--
-- TOC entry 8615 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.cd_usr_cnc_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.cd_usr_cnc_rce IS 'codigo usuario de cancelamento';


--
-- TOC entry 8616 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.dt_cnc_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.dt_cnc_rce IS 'data de cancelamento';


--
-- TOC entry 8617 (class 0 OID 0)
-- Dependencies: 877
-- Name: COLUMN tbl_rce.dt_cmp_bnc_rce; Type: COMMENT; Schema: sc_cbe; Owner: scan
--

COMMENT ON COLUMN tbl_rce.dt_cmp_bnc_rce IS 'data da compensacao bancaria';


SET search_path = sc_cbr, pg_catalog;

--
-- TOC entry 360 (class 1259 OID 565220)
-- Name: sq_bac; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_bac
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_bac OWNER TO scan;

--
-- TOC entry 361 (class 1259 OID 565222)
-- Name: sq_blt; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_blt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_blt OWNER TO scan;

--
-- TOC entry 362 (class 1259 OID 565224)
-- Name: sq_ccb; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_ccb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_ccb OWNER TO scan;

--
-- TOC entry 363 (class 1259 OID 565226)
-- Name: sq_cdt; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_cdt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_cdt OWNER TO scan;

--
-- TOC entry 364 (class 1259 OID 565228)
-- Name: sq_darcg; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_darcg
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_darcg OWNER TO scan;

--
-- TOC entry 365 (class 1259 OID 565230)
-- Name: sq_drb; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_drb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_drb OWNER TO scan;

--
-- TOC entry 366 (class 1259 OID 565232)
-- Name: sq_drc; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_drc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_drc OWNER TO scan;

--
-- TOC entry 367 (class 1259 OID 565234)
-- Name: sq_hadb; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_hadb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_hadb OWNER TO scan;

--
-- TOC entry 368 (class 1259 OID 565236)
-- Name: sq_harc; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_harc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_harc OWNER TO scan;

--
-- TOC entry 369 (class 1259 OID 565238)
-- Name: sq_harcg; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_harcg
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_harcg OWNER TO scan;

--
-- TOC entry 370 (class 1259 OID 565240)
-- Name: sq_hlsc; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_hlsc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_hlsc OWNER TO scan;

--
-- TOC entry 371 (class 1259 OID 565242)
-- Name: sq_hrb; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_hrb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_hrb OWNER TO scan;

--
-- TOC entry 372 (class 1259 OID 565244)
-- Name: sq_prc; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_prc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_prc OWNER TO scan;

--
-- TOC entry 373 (class 1259 OID 565246)
-- Name: sq_tarcg; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_tarcg
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tarcg OWNER TO scan;

--
-- TOC entry 374 (class 1259 OID 565248)
-- Name: sq_tcb; Type: SEQUENCE; Schema: sc_cbr; Owner: scan
--

CREATE SEQUENCE sq_tcb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999
    CACHE 1;


ALTER TABLE sq_tcb OWNER TO scan;

--
-- TOC entry 375 (class 1259 OID 565250)
-- Name: tbl_bac; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_bac (
    cd_bac numeric(10,0) NOT NULL,
    cd_blt numeric(10,0),
    cd_crt numeric(14,0) NOT NULL,
    ds_bac character varying(200) NOT NULL,
    st_bac numeric(2,0) NOT NULL,
    vlr_bac numeric(14,2) NOT NULL,
    dt_vnc_bac timestamp without time zone NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_bac OWNER TO scan;

--
-- TOC entry 8618 (class 0 OID 0)
-- Dependencies: 375
-- Name: TABLE tbl_bac; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON TABLE tbl_bac IS 'Tabela de Boleto Avulso Cartão';


--
-- TOC entry 8619 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN tbl_bac.cd_bac; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_bac.cd_bac IS 'codigo';


--
-- TOC entry 8620 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN tbl_bac.cd_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_bac.cd_blt IS 'codigo do boleto';


--
-- TOC entry 8621 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN tbl_bac.cd_crt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_bac.cd_crt IS 'codigo cartão';


--
-- TOC entry 8622 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN tbl_bac.ds_bac; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_bac.ds_bac IS 'descrição';


--
-- TOC entry 8623 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN tbl_bac.st_bac; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_bac.st_bac IS 'situação';


--
-- TOC entry 8624 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN tbl_bac.vlr_bac; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_bac.vlr_bac IS 'valor';


--
-- TOC entry 8625 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN tbl_bac.dt_vnc_bac; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_bac.dt_vnc_bac IS 'data de vencimento';


--
-- TOC entry 8626 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN tbl_bac.cd_inc_usr; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_bac.cd_inc_usr IS 'usuário de inclusão';


--
-- TOC entry 8627 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN tbl_bac.dt_inc_usr; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_bac.dt_inc_usr IS 'data de inclusão';


--
-- TOC entry 8628 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN tbl_bac.cd_alt_usr; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_bac.cd_alt_usr IS 'usuário de alteração';


--
-- TOC entry 8629 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN tbl_bac.dt_alt_usr; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_bac.dt_alt_usr IS 'data de alteração';


--
-- TOC entry 376 (class 1259 OID 565253)
-- Name: tbl_blt; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_blt (
    cd_blt numeric(10,0) NOT NULL,
    cd_ccb numeric(10,0) NOT NULL,
    cd_brr_blt character varying(50) NOT NULL,
    nr_lin_dgt_blt character varying(50) NOT NULL,
    vl_blt numeric(13,2) NOT NULL,
    dt_vnc_blt date NOT NULL,
    dt_grc_blt timestamp without time zone NOT NULL,
    dt_pgt_blt date,
    cd_doc_blt numeric(16,0) NOT NULL,
    st_blt numeric(2,0) DEFAULT 1 NOT NULL,
    tp_org_blt numeric(1,0) NOT NULL,
    nr_nsu_org_blt numeric(10,0) NOT NULL,
    nm_sac_blt character varying(80) NOT NULL,
    nr_cpfcnpj_sac_blt numeric(14,0) NOT NULL,
    ds_end_sac_blt character varying(300),
    pc_atr_blt numeric(5,2),
    vl_atr_blt numeric(13,2),
    pc_jrs_blt numeric(5,2),
    vl_jrs_blt numeric(13,2),
    pc_dsc_blt numeric(5,2),
    vl_dsc_blt numeric(13,2),
    dt_lmt_dsc_blt date,
    vl_pgt_blt numeric(13,2),
    vl_mlt_cbr_blt numeric(13,2),
    vl_jrs_cbr_blt numeric(13,2),
    vl_dsc_cbr_blt numeric(13,2),
    ds_ins_blt character varying(400),
    ds_out_inf_blt character varying(200),
    dt_prc_ret_blt timestamp without time zone,
    dgt_cd_doc_blt character(3),
    cd_drb numeric(10,0),
    nr_cpf_cnpj_avl_blt numeric(14,0),
    nm_avl_blt character varying(100),
    tp_pss_blt numeric(1,0)
);


ALTER TABLE tbl_blt OWNER TO scan;

--
-- TOC entry 8630 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.cd_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.cd_blt IS 'Codigo do boleto';


--
-- TOC entry 8631 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.cd_ccb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.cd_ccb IS 'Codigo do contrato de cobrança do boleto';


--
-- TOC entry 8632 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.cd_brr_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.cd_brr_blt IS 'Código de Barras do boleto';


--
-- TOC entry 8633 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.nr_lin_dgt_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.nr_lin_dgt_blt IS 'Linha digitavel do boleto';


--
-- TOC entry 8634 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.vl_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.vl_blt IS 'Valor do boleto';


--
-- TOC entry 8635 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.dt_vnc_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.dt_vnc_blt IS 'Data de Vencimento';


--
-- TOC entry 8636 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.dt_grc_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.dt_grc_blt IS 'Data de Geração';


--
-- TOC entry 8637 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.dt_pgt_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.dt_pgt_blt IS 'Data de Pagamento';


--
-- TOC entry 8638 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.cd_doc_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.cd_doc_blt IS 'Codigo do documento(nosso numero)';


--
-- TOC entry 8639 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.st_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.st_blt IS 'Situacao do boleto';


--
-- TOC entry 8640 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.tp_org_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.tp_org_blt IS 'Tipo de origem';


--
-- TOC entry 8641 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.nr_nsu_org_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.nr_nsu_org_blt IS 'Nsu de origem';


--
-- TOC entry 8642 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.nm_sac_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.nm_sac_blt IS 'Nome do Sacado';


--
-- TOC entry 8643 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.nr_cpfcnpj_sac_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.nr_cpfcnpj_sac_blt IS 'CPF/CNPJ do Sacado';


--
-- TOC entry 8644 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.ds_end_sac_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.ds_end_sac_blt IS 'Endereço do Sacado';


--
-- TOC entry 8645 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.pc_atr_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.pc_atr_blt IS 'Percentual de Atraso ao dia';


--
-- TOC entry 8646 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.vl_atr_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.vl_atr_blt IS 'Valor do Atraso ao dia';


--
-- TOC entry 8647 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.pc_jrs_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.pc_jrs_blt IS 'Percentual de Juros ao dia';


--
-- TOC entry 8648 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.vl_jrs_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.vl_jrs_blt IS 'Valor dos Juros ao dia';


--
-- TOC entry 8649 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.pc_dsc_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.pc_dsc_blt IS 'Percentual de Desconto ao dia';


--
-- TOC entry 8650 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.vl_dsc_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.vl_dsc_blt IS 'Valor do Desconto ao dia';


--
-- TOC entry 8651 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.dt_lmt_dsc_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.dt_lmt_dsc_blt IS 'Data Limite para conceder o desconto';


--
-- TOC entry 8652 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.vl_pgt_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.vl_pgt_blt IS 'Valor pago do boleto';


--
-- TOC entry 8653 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.vl_mlt_cbr_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.vl_mlt_cbr_blt IS 'Valor de Multa paga';


--
-- TOC entry 8654 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.vl_jrs_cbr_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.vl_jrs_cbr_blt IS 'Valor de Juros pago';


--
-- TOC entry 8655 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.vl_dsc_cbr_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.vl_dsc_cbr_blt IS 'Valor de Desconto pago';


--
-- TOC entry 8656 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.ds_ins_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.ds_ins_blt IS 'Descriçao da Instruções';


--
-- TOC entry 8657 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.ds_out_inf_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.ds_out_inf_blt IS 'Descrição das observaçoes adicionais';


--
-- TOC entry 8658 (class 0 OID 0)
-- Dependencies: 376
-- Name: COLUMN tbl_blt.dt_prc_ret_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_blt.dt_prc_ret_blt IS 'Data do processamento do arquivo de retorno';


--
-- TOC entry 377 (class 1259 OID 565260)
-- Name: tbl_cdt; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_cdt (
    cd_cdt numeric(10,0) NOT NULL,
    cd_cun numeric(10,0) NOT NULL
);


ALTER TABLE tbl_cdt OWNER TO scan;

--
-- TOC entry 8659 (class 0 OID 0)
-- Dependencies: 377
-- Name: TABLE tbl_cdt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON TABLE tbl_cdt IS 'Tabela de Cedente';


--
-- TOC entry 8660 (class 0 OID 0)
-- Dependencies: 377
-- Name: COLUMN tbl_cdt.cd_cdt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_cdt.cd_cdt IS 'Codigo do Cedente';


--
-- TOC entry 8661 (class 0 OID 0)
-- Dependencies: 377
-- Name: COLUMN tbl_cdt.cd_cun; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_cdt.cd_cun IS 'Codigo do Cadastro Unico';


--
-- TOC entry 378 (class 1259 OID 565263)
-- Name: tbl_darcg; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_darcg (
    cd_darcg numeric(10,0) NOT NULL,
    nr_ocr_darcg numeric(10,0) NOT NULL,
    dt_ocb_darcg date,
    vl_ttl_darcg numeric(13,2) NOT NULL,
    bnc_cbr_darcg numeric(3,0),
    ag_cbr_darcg numeric(5,0),
    vl_dsp_cbr_darcg numeric(13,2),
    dt_vnc_ttl_darcg date,
    vl_otr_dsp_darcg numeric(13,2),
    vl_iof_darcg numeric(13,2),
    vl_abt_darcg numeric(13,2),
    vl_dsc_darcg numeric(13,2),
    vl_pgt_darcg numeric(13,2) NOT NULL,
    vl_jrs_darcg numeric(13,2),
    vl_otr_crd_darcg numeric(13,2),
    mtv_cd_ocr_darcg character varying(1),
    dt_crd_darcg date,
    org_pgt_darcg numeric(3,0),
    mtv_rjc_darcg numeric(10,0),
    cd_harcg numeric(10,0) NOT NULL,
    idt_ttl_darcg numeric(12,0) NOT NULL,
    st_darcg numeric(1,0) DEFAULT 1 NOT NULL,
    cd_err_darcg numeric(2,0),
    cd_blt numeric(10,0)
);


ALTER TABLE tbl_darcg OWNER TO scan;

--
-- TOC entry 8662 (class 0 OID 0)
-- Dependencies: 378
-- Name: COLUMN tbl_darcg.idt_ttl_darcg; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_darcg.idt_ttl_darcg IS 'nosso número do boleto pago';


--
-- TOC entry 379 (class 1259 OID 565267)
-- Name: tbl_drb; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_drb (
    cd_drb numeric(10,0) NOT NULL,
    cd_hrb numeric(10,0) NOT NULL,
    idt_emp_ben_drb character varying(17) NOT NULL,
    nr_ctl_drb character varying(25) NOT NULL,
    multa_drb numeric(1,0) NOT NULL,
    prc_multa_drb numeric(6,5) NOT NULL,
    nr_doc_drb numeric(11,0) NOT NULL,
    dg_nr_doc_drb character varying(1) NOT NULL,
    idt_ocr_drb numeric(2,0) NOT NULL,
    cd_doc_drb numeric(10,0) NOT NULL,
    dt_vnc_drb date NOT NULL,
    vl_drb numeric(13,2) NOT NULL,
    dt_ems_drb date NOT NULL,
    vl_mora_drb numeric(13,2) NOT NULL,
    idt_tpi_pgd_drb numeric(2,0) NOT NULL,
    nr_insc_pgd_drb numeric(14,0) NOT NULL,
    nm_pgd_drb character varying(40) NOT NULL,
    nr_cpf_cnpj_avl_drb numeric(14,0),
    nm_avl_drb character varying(100)
);


ALTER TABLE tbl_drb OWNER TO scan;

--
-- TOC entry 8663 (class 0 OID 0)
-- Dependencies: 379
-- Name: TABLE tbl_drb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON TABLE tbl_drb IS 'tabela de detalhe do arquivo de remessa de boleto';


--
-- TOC entry 380 (class 1259 OID 565270)
-- Name: tbl_drc_t; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_drc_t (
    cd_drc numeric(10,0) NOT NULL,
    st_drc numeric(2,0) DEFAULT 1 NOT NULL,
    cd_doc_drc numeric(16,0) NOT NULL,
    nr_prc_drc character varying(3),
    nr_ttl_prc_drc character varying(3),
    nr_doc_ext_drc numeric(6,0),
    st_prc_drc numeric(1,0),
    rcb_avl_drc character varying(1),
    dt_vnc_prc_drc timestamp without time zone,
    vlr_nmn_prc_drc numeric(13,2),
    bnc_cbr_drc numeric(3,0),
    ag_cbr_drc numeric(5,0),
    id_tit_emp_drc numeric(25,0),
    vl_trf_drc numeric(13,2),
    tp_lqd_drc numeric(1,0),
    cd_hlsc numeric(10,0) NOT NULL,
    cd_err_drc numeric(2,0),
    cd_blt numeric(10,0)
);
ALTER TABLE ONLY tbl_drc_t ALTER COLUMN cd_drc SET STATISTICS 0;


ALTER TABLE tbl_drc_t OWNER TO scan;

--
-- TOC entry 8664 (class 0 OID 0)
-- Dependencies: 380
-- Name: TABLE tbl_drc_t; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON TABLE tbl_drc_t IS 'Tabela de detalhe de retorno da cobranca - segmento T';


--
-- TOC entry 8665 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.cd_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.cd_drc IS 'Codigo do detalhe';


--
-- TOC entry 8666 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.st_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.st_drc IS 'Situacao do detalhe';


--
-- TOC entry 8667 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.cd_doc_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.cd_doc_drc IS 'Codigo do documento(Nosso numero)';


--
-- TOC entry 8668 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.nr_prc_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.nr_prc_drc IS 'Numero da parcela';


--
-- TOC entry 8669 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.nr_ttl_prc_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.nr_ttl_prc_drc IS 'Numero total de parcelas';


--
-- TOC entry 8670 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.nr_doc_ext_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.nr_doc_ext_drc IS 'Numero do doc no extrato C/C';


--
-- TOC entry 8671 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.st_prc_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.st_prc_drc IS 'Status da parcela';


--
-- TOC entry 8672 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.rcb_avl_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.rcb_avl_drc IS 'Recebimento avulso';


--
-- TOC entry 8673 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.dt_vnc_prc_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.dt_vnc_prc_drc IS 'Data de Vencimento da parcela';


--
-- TOC entry 8674 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.vlr_nmn_prc_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.vlr_nmn_prc_drc IS 'Valor nominal da parcela';


--
-- TOC entry 8675 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.bnc_cbr_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.bnc_cbr_drc IS 'Banco cobrador';


--
-- TOC entry 8676 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.ag_cbr_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.ag_cbr_drc IS 'Agencia cobradora';


--
-- TOC entry 8677 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.id_tit_emp_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.id_tit_emp_drc IS 'Identificacao do titulo na empresa';


--
-- TOC entry 8678 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.vl_trf_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.vl_trf_drc IS 'Valor da tarifa';


--
-- TOC entry 8679 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.tp_lqd_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.tp_lqd_drc IS 'Tipo de liquidacao';


--
-- TOC entry 8680 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.cd_hlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.cd_hlsc IS 'Codigo do header do lote de servico de cobranca';


--
-- TOC entry 8681 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.cd_err_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.cd_err_drc IS 'Codigo do erro na validacao';


--
-- TOC entry 8682 (class 0 OID 0)
-- Dependencies: 380
-- Name: COLUMN tbl_drc_t.cd_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_t.cd_blt IS 'Codigo do boleto';


--
-- TOC entry 381 (class 1259 OID 565274)
-- Name: tbl_drc_u; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_drc_u (
    cd_drc numeric(10,0) NOT NULL,
    cd_hlsc numeric(10,0) NOT NULL,
    cd_mov_drc numeric(10,0) NOT NULL,
    vl_acr_drc numeric(13,2),
    vl_dsc_drc numeric(13,2),
    vl_pgt_drc numeric(13,2) NOT NULL,
    vl_lqd_drc numeric(13,2) NOT NULL,
    dt_lqd_drc timestamp without time zone NOT NULL,
    dt_crd_drc timestamp without time zone NOT NULL,
    vlr_abt_drc numeric(13,2),
    vlr_iof_drc numeric(13,2)
);


ALTER TABLE tbl_drc_u OWNER TO scan;

--
-- TOC entry 8683 (class 0 OID 0)
-- Dependencies: 381
-- Name: TABLE tbl_drc_u; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON TABLE tbl_drc_u IS 'Tabela de detalhe de retorno da cobranca - segmento U';


--
-- TOC entry 8684 (class 0 OID 0)
-- Dependencies: 381
-- Name: COLUMN tbl_drc_u.cd_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_u.cd_drc IS 'Codigo do detalhe de retorno';


--
-- TOC entry 8685 (class 0 OID 0)
-- Dependencies: 381
-- Name: COLUMN tbl_drc_u.cd_hlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_u.cd_hlsc IS 'Codigo do header do lote de servico';


--
-- TOC entry 8686 (class 0 OID 0)
-- Dependencies: 381
-- Name: COLUMN tbl_drc_u.cd_mov_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_u.cd_mov_drc IS 'Codigo do movimento';


--
-- TOC entry 8687 (class 0 OID 0)
-- Dependencies: 381
-- Name: COLUMN tbl_drc_u.vl_acr_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_u.vl_acr_drc IS 'Valor do acrescimo';


--
-- TOC entry 8688 (class 0 OID 0)
-- Dependencies: 381
-- Name: COLUMN tbl_drc_u.vl_dsc_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_u.vl_dsc_drc IS 'Valor do desconto';


--
-- TOC entry 8689 (class 0 OID 0)
-- Dependencies: 381
-- Name: COLUMN tbl_drc_u.vl_pgt_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_u.vl_pgt_drc IS 'Valor do pagamento';


--
-- TOC entry 8690 (class 0 OID 0)
-- Dependencies: 381
-- Name: COLUMN tbl_drc_u.vl_lqd_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_u.vl_lqd_drc IS 'Valor liquido';


--
-- TOC entry 8691 (class 0 OID 0)
-- Dependencies: 381
-- Name: COLUMN tbl_drc_u.dt_lqd_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_u.dt_lqd_drc IS 'Data da liquidacao';


--
-- TOC entry 8692 (class 0 OID 0)
-- Dependencies: 381
-- Name: COLUMN tbl_drc_u.dt_crd_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_u.dt_crd_drc IS 'Data de credito';


--
-- TOC entry 8693 (class 0 OID 0)
-- Dependencies: 381
-- Name: COLUMN tbl_drc_u.vlr_abt_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_u.vlr_abt_drc IS 'Valor do abatimento';


--
-- TOC entry 8694 (class 0 OID 0)
-- Dependencies: 381
-- Name: COLUMN tbl_drc_u.vlr_iof_drc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_drc_u.vlr_iof_drc IS 'Valor do iof';


--
-- TOC entry 382 (class 1259 OID 565277)
-- Name: tbl_hadb; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_hadb (
    cd_hadb numeric(10,0) NOT NULL,
    cd_blt numeric(10,0) NOT NULL,
    tp_hadb numeric(2,0) NOT NULL,
    vl_ant_hadb character varying(100),
    vl_atl_hadb character varying(100) NOT NULL,
    mt_alt_hadb character varying(100) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_hadb OWNER TO scan;

--
-- TOC entry 8695 (class 0 OID 0)
-- Dependencies: 382
-- Name: TABLE tbl_hadb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON TABLE tbl_hadb IS 'Tabela de Historico de Alteracao dos Dados do Boleto';


--
-- TOC entry 8696 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN tbl_hadb.cd_hadb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hadb.cd_hadb IS 'Codigo';


--
-- TOC entry 8697 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN tbl_hadb.cd_blt; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hadb.cd_blt IS 'Codigo do Boleto';


--
-- TOC entry 8698 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN tbl_hadb.tp_hadb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hadb.tp_hadb IS 'Tipo de Alteracao do Boleto (ver dominio)';


--
-- TOC entry 8699 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN tbl_hadb.vl_ant_hadb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hadb.vl_ant_hadb IS 'Valor Anterior a alteraçao';


--
-- TOC entry 8700 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN tbl_hadb.vl_atl_hadb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hadb.vl_atl_hadb IS 'Valor Atual após a alteração';


--
-- TOC entry 8701 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN tbl_hadb.mt_alt_hadb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hadb.mt_alt_hadb IS 'Motivo da Alteracao';


--
-- TOC entry 8702 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN tbl_hadb.cd_inc_usr; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hadb.cd_inc_usr IS 'Usuario de inclusão';


--
-- TOC entry 8703 (class 0 OID 0)
-- Dependencies: 382
-- Name: COLUMN tbl_hadb.dt_inc_usr; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hadb.dt_inc_usr IS 'Data de inclusão';


--
-- TOC entry 383 (class 1259 OID 565280)
-- Name: tbl_harc; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_harc (
    cd_harc numeric(10,0) NOT NULL,
    cd_bnc numeric(10,0) NOT NULL,
    cd_ag_harc numeric(5,0) NOT NULL,
    dv_ag_harc character varying(1) NOT NULL,
    cd_cc_harc numeric(12,0) NOT NULL,
    dv_cc_harc character varying(1) NOT NULL,
    dt_grc_harc timestamp without time zone NOT NULL,
    dt_rcb_harc timestamp without time zone NOT NULL,
    nr_ctr_harc numeric(13,0) NOT NULL,
    nr_seq_harc numeric(10,0) NOT NULL,
    st_harc numeric(1,0) DEFAULT 1 NOT NULL,
    cd_err_harc numeric(1,0)
);


ALTER TABLE tbl_harc OWNER TO scan;

--
-- TOC entry 8704 (class 0 OID 0)
-- Dependencies: 383
-- Name: TABLE tbl_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON TABLE tbl_harc IS 'Tabela de header do arquivo de retorno de cob';


--
-- TOC entry 8705 (class 0 OID 0)
-- Dependencies: 383
-- Name: COLUMN tbl_harc.cd_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_harc.cd_harc IS 'Codigo do arquivo';


--
-- TOC entry 8706 (class 0 OID 0)
-- Dependencies: 383
-- Name: COLUMN tbl_harc.cd_bnc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_harc.cd_bnc IS 'Codigo do banco';


--
-- TOC entry 8707 (class 0 OID 0)
-- Dependencies: 383
-- Name: COLUMN tbl_harc.cd_ag_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_harc.cd_ag_harc IS 'Codigo da agencia';


--
-- TOC entry 8708 (class 0 OID 0)
-- Dependencies: 383
-- Name: COLUMN tbl_harc.dv_ag_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_harc.dv_ag_harc IS 'Digito verificador da agencia';


--
-- TOC entry 8709 (class 0 OID 0)
-- Dependencies: 383
-- Name: COLUMN tbl_harc.cd_cc_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_harc.cd_cc_harc IS 'Codigo da conta corrente';


--
-- TOC entry 8710 (class 0 OID 0)
-- Dependencies: 383
-- Name: COLUMN tbl_harc.dv_cc_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_harc.dv_cc_harc IS 'Digito verificador da conta';


--
-- TOC entry 8711 (class 0 OID 0)
-- Dependencies: 383
-- Name: COLUMN tbl_harc.dt_grc_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_harc.dt_grc_harc IS 'Data da geracao do arquivo';


--
-- TOC entry 8712 (class 0 OID 0)
-- Dependencies: 383
-- Name: COLUMN tbl_harc.dt_rcb_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_harc.dt_rcb_harc IS 'Data do recebimento do arquivo';


--
-- TOC entry 8713 (class 0 OID 0)
-- Dependencies: 383
-- Name: COLUMN tbl_harc.nr_ctr_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_harc.nr_ctr_harc IS 'Numero do contrato';


--
-- TOC entry 8714 (class 0 OID 0)
-- Dependencies: 383
-- Name: COLUMN tbl_harc.nr_seq_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_harc.nr_seq_harc IS 'Numero sequencial do arquivo';


--
-- TOC entry 8715 (class 0 OID 0)
-- Dependencies: 383
-- Name: COLUMN tbl_harc.st_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_harc.st_harc IS 'Situaçao do arquivo. Ver tabela de dominio.';


--
-- TOC entry 8716 (class 0 OID 0)
-- Dependencies: 383
-- Name: COLUMN tbl_harc.cd_err_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_harc.cd_err_harc IS 'Codigo do erro';


--
-- TOC entry 384 (class 1259 OID 565284)
-- Name: tbl_harcg; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_harcg (
    cd_harcg numeric(10,0) NOT NULL,
    dt_grc_harcg timestamp without time zone NOT NULL,
    dt_crd_harcg timestamp without time zone NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    nr_rms_harcg numeric(5,0),
    nr_cdt_harcg numeric(10,0) NOT NULL,
    st_harcg numeric(1,0) DEFAULT 1 NOT NULL,
    cd_err_harcg numeric(2,0),
    cd_ccb numeric(10,0),
    cd_bnc numeric(5,0) NOT NULL,
    nr_abc_harcg numeric(5,0) NOT NULL
);


ALTER TABLE tbl_harcg OWNER TO scan;

--
-- TOC entry 385 (class 1259 OID 565288)
-- Name: tbl_hlsc; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_hlsc (
    cd_hlsc numeric(10,0) NOT NULL,
    cd_harc numeric(10,0) NOT NULL,
    tp_opr_hlsc character varying(1) NOT NULL,
    nr_lte_hlsc numeric(4,0) NOT NULL,
    tp_srv_hlsc numeric(2,0) NOT NULL,
    nr_ret_hlsc numeric(8,0) NOT NULL,
    dt_ret_hlsc timestamp without time zone NOT NULL,
    dt_crd_hlsc timestamp without time zone NOT NULL
);


ALTER TABLE tbl_hlsc OWNER TO scan;

--
-- TOC entry 8717 (class 0 OID 0)
-- Dependencies: 385
-- Name: COLUMN tbl_hlsc.cd_hlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hlsc.cd_hlsc IS 'Codigo que identifica o header do lote de servico';


--
-- TOC entry 8718 (class 0 OID 0)
-- Dependencies: 385
-- Name: COLUMN tbl_hlsc.cd_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hlsc.cd_harc IS 'Codigo do header do arquivo';


--
-- TOC entry 8719 (class 0 OID 0)
-- Dependencies: 385
-- Name: COLUMN tbl_hlsc.tp_opr_hlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hlsc.tp_opr_hlsc IS 'Tipo de operacao';


--
-- TOC entry 8720 (class 0 OID 0)
-- Dependencies: 385
-- Name: COLUMN tbl_hlsc.nr_lte_hlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hlsc.nr_lte_hlsc IS 'Numero do lote';


--
-- TOC entry 8721 (class 0 OID 0)
-- Dependencies: 385
-- Name: COLUMN tbl_hlsc.tp_srv_hlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hlsc.tp_srv_hlsc IS 'Tipo de servico';


--
-- TOC entry 8722 (class 0 OID 0)
-- Dependencies: 385
-- Name: COLUMN tbl_hlsc.nr_ret_hlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hlsc.nr_ret_hlsc IS 'Numero do retorno';


--
-- TOC entry 8723 (class 0 OID 0)
-- Dependencies: 385
-- Name: COLUMN tbl_hlsc.dt_ret_hlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hlsc.dt_ret_hlsc IS 'Data de gravacao do retorno';


--
-- TOC entry 8724 (class 0 OID 0)
-- Dependencies: 385
-- Name: COLUMN tbl_hlsc.dt_crd_hlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_hlsc.dt_crd_hlsc IS 'Data de credito';


--
-- TOC entry 386 (class 1259 OID 565291)
-- Name: tbl_hrb; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_hrb (
    cd_hrb numeric(10,0) NOT NULL,
    cd_ccb numeric(10,0) NOT NULL,
    nm_arq_hrb character varying(20) NOT NULL,
    st_hrb numeric(5,0) NOT NULL,
    dt_grc_hrb timestamp without time zone,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    nr_seq_rem_hrb numeric(7,0) NOT NULL
);


ALTER TABLE tbl_hrb OWNER TO scan;

--
-- TOC entry 8725 (class 0 OID 0)
-- Dependencies: 386
-- Name: TABLE tbl_hrb; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON TABLE tbl_hrb IS 'tabela de header do arquivo de remessa de boleto';


--
-- TOC entry 387 (class 1259 OID 565294)
-- Name: tbl_ocb; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_ocb (
    cd_ocb numeric(10,0) NOT NULL,
    cd_bnc numeric(10,0) NOT NULL,
    nr_ocb numeric(3,0) NOT NULL,
    ds_ocb character varying(50) NOT NULL
);


ALTER TABLE tbl_ocb OWNER TO scan;

--
-- TOC entry 388 (class 1259 OID 565297)
-- Name: tbl_prc; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_prc (
    cd_prc numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    nr_prc numeric(5,0) NOT NULL,
    vl_prc numeric(13,2) NOT NULL,
    dt_vnc_prc date NOT NULL,
    st_prc numeric(5,0) NOT NULL,
    nr_ttl_prc numeric(5,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_blt numeric(10,0)
);


ALTER TABLE tbl_prc OWNER TO scan;

--
-- TOC entry 8726 (class 0 OID 0)
-- Dependencies: 388
-- Name: COLUMN tbl_prc.st_prc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_prc.st_prc IS 'DOMINIO ST_PRC_CBR';


--
-- TOC entry 389 (class 1259 OID 565300)
-- Name: tbl_tarc; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_tarc (
    cd_harc numeric(10,0) NOT NULL,
    qtd_lte_tarc numeric(2,0) NOT NULL,
    qtd_reg_tarc numeric(10,0) NOT NULL,
    vl_ttl_iof_tarc numeric(13,2)
);


ALTER TABLE tbl_tarc OWNER TO scan;

--
-- TOC entry 8727 (class 0 OID 0)
-- Dependencies: 389
-- Name: TABLE tbl_tarc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON TABLE tbl_tarc IS 'Tabela de trailer do arquivo de retorno de cobranca';


--
-- TOC entry 8728 (class 0 OID 0)
-- Dependencies: 389
-- Name: COLUMN tbl_tarc.cd_harc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_tarc.cd_harc IS 'Codigo do header do arquivo de retorno de cobranca';


--
-- TOC entry 8729 (class 0 OID 0)
-- Dependencies: 389
-- Name: COLUMN tbl_tarc.qtd_lte_tarc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_tarc.qtd_lte_tarc IS 'Quantidade de lotes de servicos';


--
-- TOC entry 8730 (class 0 OID 0)
-- Dependencies: 389
-- Name: COLUMN tbl_tarc.qtd_reg_tarc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_tarc.qtd_reg_tarc IS 'Quantidade de registros no arquivo';


--
-- TOC entry 8731 (class 0 OID 0)
-- Dependencies: 389
-- Name: COLUMN tbl_tarc.vl_ttl_iof_tarc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_tarc.vl_ttl_iof_tarc IS 'Valor total do IOF recolhido';


--
-- TOC entry 390 (class 1259 OID 565303)
-- Name: tbl_tarcg; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_tarcg (
    cd_tarcg numeric(10,0) NOT NULL,
    cd_harcg numeric(10,0) NOT NULL,
    qtd_ttl_cbr_tarcg numeric(10,0) NOT NULL,
    vl_ttl_cbr_tarcg numeric(13,2) NOT NULL,
    nr_avs_tarcg numeric(8,0),
    qtd_cnf_ent_tarcg numeric(10,0) NOT NULL,
    vl_cnf_ent_tarcg numeric(13,2) NOT NULL,
    qtd_lqd_tarcg numeric(10,0) NOT NULL,
    vl_lqd_tarcg numeric(13,2) NOT NULL,
    qtd_bx_tarcg numeric(10,0) NOT NULL,
    vl_bx_tarcg numeric(13,2) NOT NULL
);


ALTER TABLE tbl_tarcg OWNER TO scan;

--
-- TOC entry 391 (class 1259 OID 565306)
-- Name: tbl_tlsc; Type: TABLE; Schema: sc_cbr; Owner: scan
--

CREATE TABLE tbl_tlsc (
    cd_hlsc numeric(10,0) NOT NULL,
    qtd_reg_tlsc numeric(8,0) NOT NULL,
    qtd_prc_tlsc numeric(8,0) NOT NULL,
    vl_ttl_tlsc numeric(13,2) NOT NULL
);


ALTER TABLE tbl_tlsc OWNER TO scan;

--
-- TOC entry 8732 (class 0 OID 0)
-- Dependencies: 391
-- Name: TABLE tbl_tlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON TABLE tbl_tlsc IS 'Tabela de trailer de lote de sevicos de cobranca';


--
-- TOC entry 8733 (class 0 OID 0)
-- Dependencies: 391
-- Name: COLUMN tbl_tlsc.cd_hlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_tlsc.cd_hlsc IS 'Codigo do header do lote de sevico';


--
-- TOC entry 8734 (class 0 OID 0)
-- Dependencies: 391
-- Name: COLUMN tbl_tlsc.qtd_reg_tlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_tlsc.qtd_reg_tlsc IS 'Quantidade de registros do lote';


--
-- TOC entry 8735 (class 0 OID 0)
-- Dependencies: 391
-- Name: COLUMN tbl_tlsc.qtd_prc_tlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_tlsc.qtd_prc_tlsc IS 'Quantidade de parcelas liquidadas';


--
-- TOC entry 8736 (class 0 OID 0)
-- Dependencies: 391
-- Name: COLUMN tbl_tlsc.vl_ttl_tlsc; Type: COMMENT; Schema: sc_cbr; Owner: scan
--

COMMENT ON COLUMN tbl_tlsc.vl_ttl_tlsc IS 'Valor total de parcelas liquidadas';


SET search_path = sc_ccb, pg_catalog;

--
-- TOC entry 816 (class 1259 OID 885422)
-- Name: sq_ccb; Type: SEQUENCE; Schema: sc_ccb; Owner: scan
--

CREATE SEQUENCE sq_ccb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ccb OWNER TO scan;

--
-- TOC entry 855 (class 1259 OID 909477)
-- Name: sq_ccb_ant; Type: SEQUENCE; Schema: sc_ccb; Owner: scan
--

CREATE SEQUENCE sq_ccb_ant
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ccb_ant OWNER TO scan;

--
-- TOC entry 842 (class 1259 OID 892521)
-- Name: sq_ccb_pfc; Type: SEQUENCE; Schema: sc_ccb; Owner: scan
--

CREATE SEQUENCE sq_ccb_pfc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ccb_pfc OWNER TO scan;

--
-- TOC entry 858 (class 1259 OID 915835)
-- Name: sq_ccb_pfc_ant; Type: SEQUENCE; Schema: sc_ccb; Owner: scan
--

CREATE SEQUENCE sq_ccb_pfc_ant
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ccb_pfc_ant OWNER TO scan;

--
-- TOC entry 893 (class 1259 OID 997744)
-- Name: sq_occ; Type: SEQUENCE; Schema: sc_ccb; Owner: scan
--

CREATE SEQUENCE sq_occ
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_occ OWNER TO scan;

--
-- TOC entry 837 (class 1259 OID 891047)
-- Name: sq_rps; Type: SEQUENCE; Schema: sc_ccb; Owner: scan
--

CREATE SEQUENCE sq_rps
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rps OWNER TO scan;

--
-- TOC entry 857 (class 1259 OID 910780)
-- Name: sq_rps_ant; Type: SEQUENCE; Schema: sc_ccb; Owner: scan
--

CREATE SEQUENCE sq_rps_ant
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rps_ant OWNER TO scan;

--
-- TOC entry 940 (class 1259 OID 1622613)
-- Name: sq_tit; Type: SEQUENCE; Schema: sc_ccb; Owner: scan
--

CREATE SEQUENCE sq_tit
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tit OWNER TO scan;

--
-- TOC entry 817 (class 1259 OID 885424)
-- Name: tbl_ccb; Type: TABLE; Schema: sc_ccb; Owner: scan
--

CREATE TABLE tbl_ccb (
    cd_ccb numeric(10,0) NOT NULL,
    cd_opr numeric(10,0) NOT NULL,
    cd_csn numeric(10,0) NOT NULL,
    vlr_ccb numeric(13,2) NOT NULL,
    vlr_org_ccb numeric(13,2) NOT NULL,
    vlr_iof_ccb numeric(13,2),
    vlr_jrs_ccb numeric(13,2),
    vlr_mlt_ccb numeric(13,2),
    vlr_fee_ccb numeric(13,2),
    st_ccb numeric(2,0) NOT NULL,
    dt_inc_ccb timestamp without time zone DEFAULT now(),
    dt_lqd_ccb timestamp without time zone,
    dt_vnc_ccb timestamp without time zone NOT NULL,
    vlr_sld_dvd_ccb numeric(13,2) NOT NULL,
    vl_pgt_ccb numeric(13,2),
    vl_pgt_jrs_ccb numeric(13,2),
    vl_pgt_mlt_ccb numeric(13,2),
    dt_ult_pgt_ccb timestamp without time zone,
    dt_ult_atu_ccb timestamp without time zone,
    vlr_slc_ccb numeric(13,2),
    vlr_lib_ccb numeric(13,2),
    vlr_tx_ccb numeric(13,2),
    vl_pgt_pri_ccb numeric(13,2),
    dt_rps_ccb timestamp without time zone,
    dt_rfr_ccb timestamp without time zone,
    cd_rps numeric(10,0),
    dt_cmp_ccb timestamp without time zone
);


ALTER TABLE tbl_ccb OWNER TO scan;

--
-- TOC entry 8737 (class 0 OID 0)
-- Dependencies: 817
-- Name: TABLE tbl_ccb; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON TABLE tbl_ccb IS 'tabela de ccb';


--
-- TOC entry 8738 (class 0 OID 0)
-- Dependencies: 817
-- Name: COLUMN tbl_ccb.cd_ccb; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.cd_ccb IS 'codigo';


--
-- TOC entry 8739 (class 0 OID 0)
-- Dependencies: 817
-- Name: COLUMN tbl_ccb.cd_opr; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.cd_opr IS 'código da operação';


--
-- TOC entry 8740 (class 0 OID 0)
-- Dependencies: 817
-- Name: COLUMN tbl_ccb.cd_csn; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.cd_csn IS 'código do cessionário';


--
-- TOC entry 8741 (class 0 OID 0)
-- Dependencies: 817
-- Name: COLUMN tbl_ccb.vlr_ccb; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.vlr_ccb IS 'valor da ccb';


--
-- TOC entry 8742 (class 0 OID 0)
-- Dependencies: 817
-- Name: COLUMN tbl_ccb.vlr_iof_ccb; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.vlr_iof_ccb IS 'valor do IOF';


--
-- TOC entry 8743 (class 0 OID 0)
-- Dependencies: 817
-- Name: COLUMN tbl_ccb.vlr_jrs_ccb; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.vlr_jrs_ccb IS 'valor do juros';


--
-- TOC entry 8744 (class 0 OID 0)
-- Dependencies: 817
-- Name: COLUMN tbl_ccb.vlr_mlt_ccb; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.vlr_mlt_ccb IS 'valor da multa';


--
-- TOC entry 8745 (class 0 OID 0)
-- Dependencies: 817
-- Name: COLUMN tbl_ccb.vlr_fee_ccb; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.vlr_fee_ccb IS 'valor do fee';


--
-- TOC entry 8746 (class 0 OID 0)
-- Dependencies: 817
-- Name: COLUMN tbl_ccb.st_ccb; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.st_ccb IS 'situação (ver domínio)';


--
-- TOC entry 8747 (class 0 OID 0)
-- Dependencies: 817
-- Name: COLUMN tbl_ccb.dt_inc_ccb; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.dt_inc_ccb IS 'data de inclusão';


--
-- TOC entry 8748 (class 0 OID 0)
-- Dependencies: 817
-- Name: COLUMN tbl_ccb.dt_lqd_ccb; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.dt_lqd_ccb IS 'data da liquidação';


--
-- TOC entry 8749 (class 0 OID 0)
-- Dependencies: 817
-- Name: COLUMN tbl_ccb.dt_vnc_ccb; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_ccb.dt_vnc_ccb IS 'data de vencimento';


--
-- TOC entry 853 (class 1259 OID 909381)
-- Name: tbl_ccb_ant; Type: TABLE; Schema: sc_ccb; Owner: scan
--

CREATE TABLE tbl_ccb_ant (
    cd_ccb numeric(10,0) NOT NULL,
    cd_opr numeric(10,0) NOT NULL,
    cd_csn numeric(10,0) NOT NULL,
    vlr_ccb numeric(13,2) NOT NULL,
    vlr_org_ccb numeric(13,2) NOT NULL,
    vlr_iof_ccb numeric(13,2),
    vlr_jrs_ccb numeric(13,2),
    vlr_mlt_ccb numeric(13,2),
    vlr_fee_ccb numeric(13,2),
    st_ccb numeric(2,0) NOT NULL,
    dt_inc_ccb timestamp without time zone DEFAULT now(),
    dt_lqd_ccb timestamp without time zone,
    dt_vnc_ccb timestamp without time zone NOT NULL,
    vlr_sld_dvd_ccb numeric(13,2) NOT NULL,
    vl_pgt_ccb numeric(13,2),
    vl_pgt_jrs_ccb numeric(13,2),
    vl_pgt_mlt_ccb numeric(13,2),
    dt_ult_pgt_ccb timestamp without time zone,
    dt_ult_atu_ccb timestamp without time zone,
    vlr_slc_ccb numeric(13,2),
    vlr_lib_ccb numeric(13,2),
    vlr_tx_ccb numeric(13,2),
    vl_pgt_pri_ccb numeric(13,2),
    dt_rps_ccb timestamp without time zone,
    dt_rfr_ccb timestamp without time zone,
    cd_rps numeric(10,0),
    dt_cmp_ccb timestamp without time zone
);


ALTER TABLE tbl_ccb_ant OWNER TO scan;

--
-- TOC entry 818 (class 1259 OID 885447)
-- Name: tbl_ccb_pfc; Type: TABLE; Schema: sc_ccb; Owner: scan
--

CREATE TABLE tbl_ccb_pfc (
    cd_ccb numeric(10,0) NOT NULL,
    cd_pfc numeric(10,0) NOT NULL,
    vl_pgt_jrs_ccb_pfc numeric(13,2),
    vl_pgt_mlt_ccb_pfc numeric(13,2),
    vl_pgt_prc_ccb_pfc numeric(13,2),
    dt_inc_ccb_pfc timestamp without time zone NOT NULL,
    dt_ctb_ccb_pfc timestamp without time zone,
    cd_ccb_pfc numeric(10,0) NOT NULL
);


ALTER TABLE tbl_ccb_pfc OWNER TO scan;

--
-- TOC entry 854 (class 1259 OID 909400)
-- Name: tbl_ccb_pfc_ant; Type: TABLE; Schema: sc_ccb; Owner: scan
--

CREATE TABLE tbl_ccb_pfc_ant (
    cd_ccb numeric(10,0) NOT NULL,
    cd_pfc numeric(10,0) NOT NULL,
    vl_pgt_jrs_ccb_pfc numeric(13,2),
    vl_pgt_mlt_ccb_pfc numeric(13,2),
    vl_pgt_prc_ccb_pfc numeric(13,2),
    dt_inc_ccb_pfc timestamp without time zone NOT NULL,
    dt_ctb_ccb_pfc timestamp without time zone,
    cd_ccb_pfc numeric(10,0) NOT NULL
);


ALTER TABLE tbl_ccb_pfc_ant OWNER TO scan;

--
-- TOC entry 815 (class 1259 OID 885394)
-- Name: tbl_csn; Type: TABLE; Schema: sc_ccb; Owner: scan
--

CREATE TABLE tbl_csn (
    cd_csn numeric(10,0) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    nm_csn character varying(20) NOT NULL,
    fg_atv_csn character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_cnt_cbr_csn numeric(10,0),
    cd_cnt_lqd_csn numeric(10,0),
    CONSTRAINT ck_fg_atv_csn CHECK (((fg_atv_csn)::bpchar = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_csn OWNER TO scan;

--
-- TOC entry 8750 (class 0 OID 0)
-- Dependencies: 815
-- Name: TABLE tbl_csn; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON TABLE tbl_csn IS 'tabela de cessionario';


--
-- TOC entry 8751 (class 0 OID 0)
-- Dependencies: 815
-- Name: COLUMN tbl_csn.cd_csn; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_csn.cd_csn IS 'codigo';


--
-- TOC entry 8752 (class 0 OID 0)
-- Dependencies: 815
-- Name: COLUMN tbl_csn.nm_csn; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_csn.nm_csn IS 'descrição';


--
-- TOC entry 8753 (class 0 OID 0)
-- Dependencies: 815
-- Name: COLUMN tbl_csn.fg_atv_csn; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_csn.fg_atv_csn IS 'flag ativo';


--
-- TOC entry 8754 (class 0 OID 0)
-- Dependencies: 815
-- Name: COLUMN tbl_csn.cd_inc_usr; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_csn.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8755 (class 0 OID 0)
-- Dependencies: 815
-- Name: COLUMN tbl_csn.dt_inc_usr; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_csn.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 8756 (class 0 OID 0)
-- Dependencies: 815
-- Name: COLUMN tbl_csn.cd_alt_usr; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_csn.cd_alt_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8757 (class 0 OID 0)
-- Dependencies: 815
-- Name: COLUMN tbl_csn.dt_alt_usr; Type: COMMENT; Schema: sc_ccb; Owner: scan
--

COMMENT ON COLUMN tbl_csn.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 892 (class 1259 OID 997738)
-- Name: tbl_occ; Type: TABLE; Schema: sc_ccb; Owner: scan
--

CREATE TABLE tbl_occ (
    cd_occ numeric(10,0) NOT NULL,
    cd_ccb numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    ds_ccb character varying(50)
);


ALTER TABLE tbl_occ OWNER TO scan;

--
-- TOC entry 819 (class 1259 OID 888684)
-- Name: tbl_rps; Type: TABLE; Schema: sc_ccb; Owner: scan
--

CREATE TABLE tbl_rps (
    cd_rps numeric(10,0) NOT NULL,
    dt_rps timestamp without time zone,
    vl_prc_rps numeric(13,2) NOT NULL,
    vl_jrs_mlt_rps numeric(13,2),
    st_rps numeric(1,0) DEFAULT 1 NOT NULL
);


ALTER TABLE tbl_rps OWNER TO scan;

--
-- TOC entry 856 (class 1259 OID 910774)
-- Name: tbl_rps_ant; Type: TABLE; Schema: sc_ccb; Owner: scan
--

CREATE TABLE tbl_rps_ant (
    cd_rps numeric(10,0) NOT NULL,
    dt_rps timestamp without time zone,
    vl_prc_rps numeric(13,2) NOT NULL,
    vl_jrs_mlt_rps numeric(13,2),
    st_rps numeric(1,0) DEFAULT 1 NOT NULL
);


ALTER TABLE tbl_rps_ant OWNER TO scan;

--
-- TOC entry 907 (class 1259 OID 1006376)
-- Name: tbl_tmp; Type: TABLE; Schema: sc_ccb; Owner: scan
--

CREATE TABLE tbl_tmp (
    cd_ccb numeric(10,0) NOT NULL
);


ALTER TABLE tbl_tmp OWNER TO scan;

SET search_path = sc_cce, pg_catalog;

--
-- TOC entry 957 (class 1259 OID 1631917)
-- Name: sq_darc; Type: SEQUENCE; Schema: sc_cce; Owner: scan
--

CREATE SEQUENCE sq_darc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_darc OWNER TO scan;

--
-- TOC entry 951 (class 1259 OID 1630930)
-- Name: sq_drb; Type: SEQUENCE; Schema: sc_cce; Owner: scan
--

CREATE SEQUENCE sq_drb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_drb OWNER TO scan;

--
-- TOC entry 956 (class 1259 OID 1631915)
-- Name: sq_harc; Type: SEQUENCE; Schema: sc_cce; Owner: scan
--

CREATE SEQUENCE sq_harc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_harc OWNER TO scan;

--
-- TOC entry 950 (class 1259 OID 1630928)
-- Name: sq_hrb; Type: SEQUENCE; Schema: sc_cce; Owner: scan
--

CREATE SEQUENCE sq_hrb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hrb OWNER TO scan;

--
-- TOC entry 958 (class 1259 OID 1631921)
-- Name: sq_mti; Type: SEQUENCE; Schema: sc_cce; Owner: scan
--

CREATE SEQUENCE sq_mti
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_mti OWNER TO scan;

--
-- TOC entry 946 (class 1259 OID 1630898)
-- Name: sq_scd; Type: SEQUENCE; Schema: sc_cce; Owner: scan
--

CREATE SEQUENCE sq_scd
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_scd OWNER TO scan;

--
-- TOC entry 959 (class 1259 OID 1631924)
-- Name: sq_tarc; Type: SEQUENCE; Schema: sc_cce; Owner: scan
--

CREATE SEQUENCE sq_tarc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tarc OWNER TO scan;

--
-- TOC entry 947 (class 1259 OID 1630900)
-- Name: sq_tit; Type: SEQUENCE; Schema: sc_cce; Owner: scan
--

CREATE SEQUENCE sq_tit
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tit OWNER TO scan;

--
-- TOC entry 943 (class 1259 OID 1630842)
-- Name: tbl_cce; Type: TABLE; Schema: sc_cce; Owner: scan
--

CREATE TABLE tbl_cce (
    cd_cce numeric(10,0) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    cd_ccb numeric(10,0) NOT NULL,
    ns_nmr_ini_cce numeric(16,0) NOT NULL,
    ns_nmr_fin_cce numeric(16,0),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_cnt numeric(10,0) NOT NULL,
    idt_cce character varying(17),
    qtd_dias_bx_aut_cce numeric(3,0)
);


ALTER TABLE tbl_cce OWNER TO scan;

--
-- TOC entry 953 (class 1259 OID 1631829)
-- Name: tbl_darc; Type: TABLE; Schema: sc_cce; Owner: scan
--

CREATE TABLE tbl_darc (
    cd_darc numeric(10,0) NOT NULL,
    nr_ocr_darc numeric(10,0) NOT NULL,
    dt_ocb_darc date,
    vl_ttl_darc numeric(13,2) NOT NULL,
    bnc_cbr_darc numeric(3,0),
    ag_cbr_darc numeric(5,0),
    vl_dsp_cbr_darc numeric(13,2),
    dt_vnc_ttl_darc date,
    vl_otr_dsp_darc numeric(13,2),
    vl_iof_darc numeric(13,2),
    vl_abt_darc numeric(13,2),
    vl_dsc_darc numeric(13,2),
    vl_pgt_darc numeric(13,2) NOT NULL,
    vl_jrs_darc numeric(13,2),
    vl_otr_crd_darc numeric(13,2),
    mtv_cd_ocr_darc character varying(1),
    dt_crd_darc date,
    org_pgt_darc numeric(3,0),
    mtv_rjc_darc numeric(10,0),
    cd_harc numeric(10,0) NOT NULL,
    idt_ttl_darc numeric(12,0) NOT NULL,
    st_darc numeric(1,0) DEFAULT 1 NOT NULL,
    cd_err_darc numeric(2,0),
    cd_blt numeric(10,0),
    nr_doc_darc character varying(10),
    idt_emp_ben_darc numeric(17,0)
);


ALTER TABLE tbl_darc OWNER TO scan;

--
-- TOC entry 949 (class 1259 OID 1630917)
-- Name: tbl_drb; Type: TABLE; Schema: sc_cce; Owner: scan
--

CREATE TABLE tbl_drb (
    cd_drb numeric(10,0) NOT NULL,
    cd_hrb numeric(10,0) NOT NULL,
    idt_emp_ben_drb character varying(17) NOT NULL,
    nr_ctl_drb character varying(25) NOT NULL,
    multa_drb numeric(1,0) NOT NULL,
    prc_multa_drb numeric(13,5) NOT NULL,
    nr_doc_drb numeric(11,0) NOT NULL,
    dg_nr_doc_drb character varying(1) NOT NULL,
    idt_ocr_drb numeric(2,0) NOT NULL,
    cd_doc_drb numeric(10,0),
    dt_vnc_drb date NOT NULL,
    vl_drb numeric(13,2) NOT NULL,
    dt_ems_drb date NOT NULL,
    vl_mora_drb numeric(13,2) NOT NULL,
    idt_tpi_pgd_drb numeric(2,0) NOT NULL,
    nr_insc_pgd_drb numeric(14,0) NOT NULL,
    nm_pgd_drb character varying(40) NOT NULL,
    pri_ins_drb numeric(2,0),
    seg_ins_drb numeric(2,0),
    fg_bnc_emt_drb character(1) DEFAULT 'N'::bpchar,
    edr_drb character varying(100),
    cep_drb numeric(8,0),
    cd_blt numeric(10,0)
);


ALTER TABLE tbl_drb OWNER TO scan;

--
-- TOC entry 8758 (class 0 OID 0)
-- Dependencies: 949
-- Name: TABLE tbl_drb; Type: COMMENT; Schema: sc_cce; Owner: scan
--

COMMENT ON TABLE tbl_drb IS 'tabela de detalhe do arquivo de remessa de boleto';


--
-- TOC entry 981 (class 1259 OID 1656459)
-- Name: tbl_fnn; Type: TABLE; Schema: sc_cce; Owner: scan
--

CREATE TABLE tbl_fnn (
    cd_cce numeric(10,0) NOT NULL,
    nr_ini_fnn numeric(20,0) NOT NULL,
    nr_fim_fnn numeric(20,0) NOT NULL
);


ALTER TABLE tbl_fnn OWNER TO scan;

--
-- TOC entry 952 (class 1259 OID 1631816)
-- Name: tbl_harc; Type: TABLE; Schema: sc_cce; Owner: scan
--

CREATE TABLE tbl_harc (
    cd_harc numeric(10,0) NOT NULL,
    dt_grc_harc timestamp without time zone NOT NULL,
    dt_crd_harc timestamp without time zone NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    nr_rms_harc numeric(5,0),
    nr_cdt_harc numeric(10,0) NOT NULL,
    st_harc numeric(1,0) DEFAULT 1 NOT NULL,
    cd_err_harc numeric(2,0),
    cd_cce numeric(10,0),
    cd_bnc numeric(5,0) NOT NULL,
    nr_abc_harc numeric(5,0)
);


ALTER TABLE tbl_harc OWNER TO scan;

--
-- TOC entry 948 (class 1259 OID 1630902)
-- Name: tbl_hrb; Type: TABLE; Schema: sc_cce; Owner: scan
--

CREATE TABLE tbl_hrb (
    cd_hrb numeric(10,0) NOT NULL,
    cd_cce numeric(10,0),
    nm_arq_hrb character varying(20),
    st_hrb numeric(5,0) NOT NULL,
    dt_grc_hrb timestamp without time zone,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    nr_seq_rem_hrb numeric(7,0) NOT NULL,
    idt_emp_hrb character varying(20) NOT NULL
);


ALTER TABLE tbl_hrb OWNER TO scan;

--
-- TOC entry 8759 (class 0 OID 0)
-- Dependencies: 948
-- Name: TABLE tbl_hrb; Type: COMMENT; Schema: sc_cce; Owner: scan
--

COMMENT ON TABLE tbl_hrb IS 'tabela de header do arquivo de remessa de boleto';


--
-- TOC entry 955 (class 1259 OID 1631884)
-- Name: tbl_mti; Type: TABLE; Schema: sc_cce; Owner: scan
--

CREATE TABLE tbl_mti (
    cd_mti numeric(10,0) NOT NULL,
    cd_darc_cbr_mti numeric(10,0) NOT NULL,
    cd_darc_ext_mti numeric(10,0) NOT NULL,
    cd_tit numeric(10,0) NOT NULL,
    st_mti numeric(1,0) NOT NULL
);


ALTER TABLE tbl_mti OWNER TO scan;

--
-- TOC entry 8760 (class 0 OID 0)
-- Dependencies: 955
-- Name: TABLE tbl_mti; Type: COMMENT; Schema: sc_cce; Owner: scan
--

COMMENT ON TABLE tbl_mti IS 'Tabela de Mapeamento DE-PARA de Titulos';


--
-- TOC entry 945 (class 1259 OID 1630882)
-- Name: tbl_scd; Type: TABLE; Schema: sc_cce; Owner: scan
--

CREATE TABLE tbl_scd (
    cd_scd numeric(10,0) NOT NULL,
    cd_cun numeric(10,0),
    cd_cce numeric(10,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    fg_atv_scd character(1) DEFAULT 'S'::bpchar NOT NULL,
    nr_cpf_cnpj_scd numeric(16,0),
    nm_scd character varying(50),
    end_scd character varying(100)
);


ALTER TABLE tbl_scd OWNER TO scan;

--
-- TOC entry 954 (class 1259 OID 1631848)
-- Name: tbl_tarc; Type: TABLE; Schema: sc_cce; Owner: scan
--

CREATE TABLE tbl_tarc (
    cd_tarc numeric(10,0) NOT NULL,
    cd_harc numeric(10,0) NOT NULL,
    qtd_ttl_cbr_tarc numeric(10,0) NOT NULL,
    vl_ttl_cbr_tarc numeric(13,2) NOT NULL,
    nr_avs_tarc numeric(8,0),
    qtd_cnf_ent_tarc numeric(10,0),
    vl_cnf_ent_tarc numeric(13,2),
    qtd_lqd_tarc numeric(10,0),
    vl_lqd_tarc numeric(13,2),
    qtd_bx_tarc numeric(10,0),
    vl_bx_tarc numeric(13,2),
    qtd_abt_cnc_tarc numeric(10,0),
    vl_abt_cnc_tarc numeric(13,2),
    qtd_vnc_alt_tarc numeric(10,0),
    vl_vnc_alt_tarc numeric(13,2),
    qtd_abt_ccd_tarc numeric(10,0),
    vl_abt_ccd_tarc numeric(13,2),
    qtd_ptt_tarc numeric(10,0),
    vl_ptt_tarc numeric(13,2)
);


ALTER TABLE tbl_tarc OWNER TO scan;

--
-- TOC entry 944 (class 1259 OID 1630872)
-- Name: tbl_tit; Type: TABLE; Schema: sc_cce; Owner: scan
--

CREATE TABLE tbl_tit (
    cd_tit numeric(10,0) NOT NULL,
    cd_cce numeric(10,0) NOT NULL,
    ns_nmr_tit numeric(16,0) NOT NULL,
    vl_tit numeric(13,2) NOT NULL,
    dt_vnc_tit date NOT NULL,
    cd_scd numeric(10,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    st_tit numeric(1,0) NOT NULL,
    cd_blt numeric(10,0),
    dt_pgt_tit date,
    dt_rcb_tit timestamp without time zone,
    vl_pgt_tit numeric(13,2),
    dt_bx_tit timestamp with time zone,
    cd_usr_bx_tit numeric(10,0)
);


ALTER TABLE tbl_tit OWNER TO scan;

SET search_path = sc_cci, pg_catalog;

--
-- TOC entry 392 (class 1259 OID 565309)
-- Name: sq_act; Type: SEQUENCE; Schema: sc_cci; Owner: scan
--

CREATE SEQUENCE sq_act
    START WITH 3
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_act OWNER TO scan;

--
-- TOC entry 393 (class 1259 OID 565311)
-- Name: sq_ans; Type: SEQUENCE; Schema: sc_cci; Owner: scan
--

CREATE SEQUENCE sq_ans
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ans OWNER TO scan;

--
-- TOC entry 394 (class 1259 OID 565313)
-- Name: sq_dct; Type: SEQUENCE; Schema: sc_cci; Owner: scan
--

CREATE SEQUENCE sq_dct
    START WITH 1178
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dct OWNER TO scan;

--
-- TOC entry 395 (class 1259 OID 565315)
-- Name: sq_hcc; Type: SEQUENCE; Schema: sc_cci; Owner: scan
--

CREATE SEQUENCE sq_hcc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hcc OWNER TO scan;

--
-- TOC entry 396 (class 1259 OID 565317)
-- Name: sq_hci; Type: SEQUENCE; Schema: sc_cci; Owner: scan
--

CREATE SEQUENCE sq_hci
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hci OWNER TO scan;

--
-- TOC entry 397 (class 1259 OID 565319)
-- Name: tbl_act; Type: TABLE; Schema: sc_cci; Owner: scan
--

CREATE TABLE tbl_act (
    cd_act numeric(10,0) NOT NULL,
    cd_emc numeric(5,0),
    st_act numeric(1,0) DEFAULT 1 NOT NULL,
    dt_grc_act date,
    nr_reg_act numeric(5,0),
    vl_ttl_prc_act numeric(13,2),
    vl_ttl_act numeric(13,2)
);


ALTER TABLE tbl_act OWNER TO scan;

--
-- TOC entry 398 (class 1259 OID 565323)
-- Name: tbl_ans; Type: TABLE; Schema: sc_cci; Owner: scan
--

CREATE TABLE tbl_ans (
    cd_ans numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    tp_ans numeric(2,0) NOT NULL,
    st_ans numeric(2,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_env_ans timestamp without time zone,
    cd_det numeric(10,0)
);


ALTER TABLE tbl_ans OWNER TO scan;

--
-- TOC entry 8761 (class 0 OID 0)
-- Dependencies: 398
-- Name: TABLE tbl_ans; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON TABLE tbl_ans IS 'tabela de arquivo de negativacao spc';


--
-- TOC entry 8762 (class 0 OID 0)
-- Dependencies: 398
-- Name: COLUMN tbl_ans.cd_ans; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_ans.cd_ans IS 'Codigo';


--
-- TOC entry 8763 (class 0 OID 0)
-- Dependencies: 398
-- Name: COLUMN tbl_ans.cd_crt; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_ans.cd_crt IS 'Codigo do Cartao';


--
-- TOC entry 8764 (class 0 OID 0)
-- Dependencies: 398
-- Name: COLUMN tbl_ans.tp_ans; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_ans.tp_ans IS 'Tipo do Registro (1 - INCLUSAO / 2 - EXCLUSAO)';


--
-- TOC entry 8765 (class 0 OID 0)
-- Dependencies: 398
-- Name: COLUMN tbl_ans.st_ans; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_ans.st_ans IS 'Situacao (1 - CADASTRADA / 2 - ENVIADA / 3 - CANCELADA)';


--
-- TOC entry 8766 (class 0 OID 0)
-- Dependencies: 398
-- Name: COLUMN tbl_ans.dt_inc_usr; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_ans.dt_inc_usr IS 'Data de Inclusao';


--
-- TOC entry 8767 (class 0 OID 0)
-- Dependencies: 398
-- Name: COLUMN tbl_ans.dt_env_ans; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_ans.dt_env_ans IS 'Data do Envio';


--
-- TOC entry 8768 (class 0 OID 0)
-- Dependencies: 398
-- Name: COLUMN tbl_ans.cd_det; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_ans.cd_det IS 'Codigo do Detalhe do Arquivo de Envio de Remessa ao SPC';


--
-- TOC entry 399 (class 1259 OID 565326)
-- Name: tbl_cci; Type: TABLE; Schema: sc_cci; Owner: scan
--

CREATE TABLE tbl_cci (
    cd_crt numeric(14,0) NOT NULL,
    fg_pas_cbr_cci character(1) NOT NULL,
    fg_pas_ngv_cci character(1) NOT NULL,
    cd_emc numeric(5,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    fg_atv_cci character(1) NOT NULL,
    cd_hci numeric(10,0),
    cd_hcc numeric(10,0),
    dt_agd_cci date,
    fg_ngt_spc_cci character varying(1) DEFAULT 'N'::character varying NOT NULL,
    dt_ngt_spc_cci timestamp without time zone
);


ALTER TABLE tbl_cci OWNER TO scan;

--
-- TOC entry 8769 (class 0 OID 0)
-- Dependencies: 399
-- Name: TABLE tbl_cci; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON TABLE tbl_cci IS 'tabela de controle de cobranca de cartao individual';


--
-- TOC entry 400 (class 1259 OID 565330)
-- Name: tbl_cct; Type: TABLE; Schema: sc_cci; Owner: scan
--

CREATE TABLE tbl_cct (
    cd_crt numeric(14,0) NOT NULL,
    cd_emc numeric(5,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    vl_sld_cct numeric(10,2) NOT NULL,
    tp_cct numeric(2,0) NOT NULL,
    fg_env_cct character(1) NOT NULL,
    dt_env_cct timestamp without time zone,
    cd_dct numeric(10,0)
);


ALTER TABLE tbl_cct OWNER TO scan;

--
-- TOC entry 8770 (class 0 OID 0)
-- Dependencies: 400
-- Name: TABLE tbl_cct; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON TABLE tbl_cct IS 'tabela de controle cartoes a serem enviados para cobranca tercerizada';


--
-- TOC entry 8771 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN tbl_cct.cd_crt; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_cct.cd_crt IS 'Numero do Cartao';


--
-- TOC entry 8772 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN tbl_cct.cd_emc; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_cct.cd_emc IS 'Codigo da Empresa de Cobranca';


--
-- TOC entry 8773 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN tbl_cct.dt_inc_usr; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_cct.dt_inc_usr IS 'Data de Inclusao';


--
-- TOC entry 8774 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN tbl_cct.vl_sld_cct; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_cct.vl_sld_cct IS 'Valor do Saldo Devedor Enviado para Empresa de Cobrança Tercerizada';


--
-- TOC entry 8775 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN tbl_cct.tp_cct; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_cct.tp_cct IS 'Tipo de registro (VER DOMINIO)';


--
-- TOC entry 8776 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN tbl_cct.fg_env_cct; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_cct.fg_env_cct IS 'Flag de Envio para identificar se o cartão foi enviado ou não';


--
-- TOC entry 8777 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN tbl_cct.dt_env_cct; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_cct.dt_env_cct IS 'Data do Envio';


--
-- TOC entry 8778 (class 0 OID 0)
-- Dependencies: 400
-- Name: COLUMN tbl_cct.cd_dct; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON COLUMN tbl_cct.cd_dct IS 'Codido do detalhe do arquivo em que o cartao foi enviado para cobranca tercerizada';


--
-- TOC entry 401 (class 1259 OID 565333)
-- Name: tbl_dct; Type: TABLE; Schema: sc_cci; Owner: scan
--

CREATE TABLE tbl_dct (
    cd_dct numeric(10,0) NOT NULL,
    cd_act numeric(10,0),
    cd_crt numeric(14,0) NOT NULL,
    vl_prc_dct numeric(13,2) NOT NULL,
    vl_ttl_dct numeric(13,2) NOT NULL,
    nr_dia_atr_dct numeric(5,0) NOT NULL
);


ALTER TABLE tbl_dct OWNER TO scan;

--
-- TOC entry 402 (class 1259 OID 565336)
-- Name: tbl_emc; Type: TABLE; Schema: sc_cci; Owner: scan
--

CREATE TABLE tbl_emc (
    cd_emc numeric(5,0) NOT NULL,
    nm_emc character varying(40) NOT NULL,
    cd_cun numeric(10,0),
    cd_tci numeric(5,0),
    nr_dia_ini_atr_emc numeric(5,0),
    nr_dia_fim_atr_emc numeric(5,0),
    fg_atv_emc character varying(1),
    nm_dir_arq character varying(100)
);


ALTER TABLE tbl_emc OWNER TO scan;

--
-- TOC entry 8779 (class 0 OID 0)
-- Dependencies: 402
-- Name: TABLE tbl_emc; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON TABLE tbl_emc IS 'tabela de empresa de cobranca';


--
-- TOC entry 403 (class 1259 OID 565339)
-- Name: tbl_hcc; Type: TABLE; Schema: sc_cci; Owner: scan
--

CREATE TABLE tbl_hcc (
    cd_hcc numeric(10,0) NOT NULL,
    tp_hcc numeric(5,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_crt numeric(14,0) NOT NULL,
    obs_hcc character varying(400) NOT NULL
);


ALTER TABLE tbl_hcc OWNER TO scan;

--
-- TOC entry 8780 (class 0 OID 0)
-- Dependencies: 403
-- Name: TABLE tbl_hcc; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON TABLE tbl_hcc IS 'tabela de historico de cobranca do cartao';


--
-- TOC entry 404 (class 1259 OID 565342)
-- Name: tbl_hci; Type: TABLE; Schema: sc_cci; Owner: scan
--

CREATE TABLE tbl_hci (
    cd_crt numeric(14,0) NOT NULL,
    cd_tci numeric(5,0) NOT NULL,
    dt_ent_hci date NOT NULL,
    dt_sai_hci date,
    cd_hci numeric(10,0) NOT NULL
);


ALTER TABLE tbl_hci OWNER TO scan;

--
-- TOC entry 8781 (class 0 OID 0)
-- Dependencies: 404
-- Name: TABLE tbl_hci; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON TABLE tbl_hci IS 'tabela de historico de cobranca individual';


--
-- TOC entry 405 (class 1259 OID 565345)
-- Name: tbl_tci; Type: TABLE; Schema: sc_cci; Owner: scan
--

CREATE TABLE tbl_tci (
    cd_tci numeric(5,0) NOT NULL,
    nm_tci character varying(40) NOT NULL
);


ALTER TABLE tbl_tci OWNER TO scan;

--
-- TOC entry 8782 (class 0 OID 0)
-- Dependencies: 405
-- Name: TABLE tbl_tci; Type: COMMENT; Schema: sc_cci; Owner: scan
--

COMMENT ON TABLE tbl_tci IS 'tipo de cobranca individual';


--
-- TOC entry 406 (class 1259 OID 565348)
-- Name: tbl_teste; Type: TABLE; Schema: sc_cci; Owner: scan
--

CREATE TABLE tbl_teste (
    cpf numeric(14,0) NOT NULL,
    cd_crt numeric(14,0),
    dt_inc timestamp without time zone,
    tipo numeric(1,0),
    dt_vnc date,
    dt_rgt date,
    vl_dvd numeric(15,2),
    contrato character varying(30)
);


ALTER TABLE tbl_teste OWNER TO scan;

SET search_path = sc_cnt, pg_catalog;

--
-- TOC entry 407 (class 1259 OID 565351)
-- Name: sc_scn; Type: SEQUENCE; Schema: sc_cnt; Owner: scan
--

CREATE SEQUENCE sc_scn
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sc_scn OWNER TO scan;

--
-- TOC entry 408 (class 1259 OID 565353)
-- Name: sc_tbc; Type: SEQUENCE; Schema: sc_cnt; Owner: scan
--

CREATE SEQUENCE sc_tbc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sc_tbc OWNER TO scan;

--
-- TOC entry 409 (class 1259 OID 565355)
-- Name: sc_tbc_cnt; Type: SEQUENCE; Schema: sc_cnt; Owner: scan
--

CREATE SEQUENCE sc_tbc_cnt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sc_tbc_cnt OWNER TO scan;

--
-- TOC entry 410 (class 1259 OID 565357)
-- Name: sq_arr; Type: SEQUENCE; Schema: sc_cnt; Owner: scan
--

CREATE SEQUENCE sq_arr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999
    CACHE 1;


ALTER TABLE sq_arr OWNER TO scan;

--
-- TOC entry 411 (class 1259 OID 565359)
-- Name: sq_cnt; Type: SEQUENCE; Schema: sc_cnt; Owner: scan
--

CREATE SEQUENCE sq_cnt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_cnt OWNER TO scan;

--
-- TOC entry 412 (class 1259 OID 565361)
-- Name: sq_lcn; Type: SEQUENCE; Schema: sc_cnt; Owner: scan
--

CREATE SEQUENCE sq_lcn
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_lcn OWNER TO scan;

--
-- TOC entry 413 (class 1259 OID 565363)
-- Name: sq_lpd; Type: SEQUENCE; Schema: sc_cnt; Owner: scan
--

CREATE SEQUENCE sq_lpd
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_lpd OWNER TO scan;

--
-- TOC entry 414 (class 1259 OID 565365)
-- Name: sq_scn; Type: SEQUENCE; Schema: sc_cnt; Owner: scan
--

CREATE SEQUENCE sq_scn
    START WITH 46
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_scn OWNER TO scan;

--
-- TOC entry 415 (class 1259 OID 565367)
-- Name: sq_sds; Type: SEQUENCE; Schema: sc_cnt; Owner: scan
--

CREATE SEQUENCE sq_sds
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_sds OWNER TO scan;

--
-- TOC entry 416 (class 1259 OID 565369)
-- Name: sq_tbc_cnt; Type: SEQUENCE; Schema: sc_cnt; Owner: scan
--

CREATE SEQUENCE sq_tbc_cnt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tbc_cnt OWNER TO scan;

--
-- TOC entry 417 (class 1259 OID 565371)
-- Name: sq_tsr; Type: SEQUENCE; Schema: sc_cnt; Owner: scan
--

CREATE SEQUENCE sq_tsr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tsr OWNER TO scan;

--
-- TOC entry 418 (class 1259 OID 565373)
-- Name: tbl_cnt; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_cnt (
    cd_cnt numeric(10,0) NOT NULL,
    nm_cnt character varying(80) NOT NULL,
    vl_sld_cnt numeric(13,2) NOT NULL,
    fg_ntr_cnt "char" NOT NULL,
    cd_inc_usr numeric(5,0) NOT NULL,
    cd_alt_usr numeric(5,0),
    dt_inc_usr timestamp without time zone DEFAULT now() NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_tcn numeric(10,0),
    cd_pcn numeric(10,0),
    cd_scn numeric(10,0),
    cd_cnt_ctb character varying(50),
    obs_cnt character varying(200),
    slc_ivt_cnt character varying(4000),
    fg_rpc_cnt character(1) DEFAULT 'N'::bpchar NOT NULL,
    dt_rpc_cnt date,
    cd_cnt_ctb1 character varying(50),
    dt_ult_fch_fll_cnt date,
    sld_ult_fch_cnt numeric(13,2),
    CONSTRAINT ck_fg_ntr_cnt CHECK ((fg_ntr_cnt = ANY (ARRAY['D'::"char", 'C'::"char"])))
);


ALTER TABLE tbl_cnt OWNER TO scan;

--
-- TOC entry 8783 (class 0 OID 0)
-- Dependencies: 418
-- Name: TABLE tbl_cnt; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON TABLE tbl_cnt IS 'TABELA DE CONTA';


--
-- TOC entry 8784 (class 0 OID 0)
-- Dependencies: 418
-- Name: COLUMN tbl_cnt.cd_cnt_ctb; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_cnt.cd_cnt_ctb IS 'CODIGO DA CONTA NO SISTEMA CONTABIL';


--
-- TOC entry 419 (class 1259 OID 565378)
-- Name: tbl_gcn; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_gcn (
    cd_gcn numeric(2,0) NOT NULL,
    ds_gcn character varying(50) NOT NULL
);


ALTER TABLE tbl_gcn OWNER TO scan;

--
-- TOC entry 420 (class 1259 OID 565381)
-- Name: tbl_lcn; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_lcn (
    cd_lcn numeric(10,0) NOT NULL,
    cd_ctp_lcn numeric(10,0),
    cd_tlc numeric(10,0) NOT NULL,
    dt_lcn timestamp without time zone NOT NULL,
    dt_ref_lcn timestamp without time zone NOT NULL,
    fg_dcr_lcn "char" NOT NULL,
    nm_his_lcn character varying(50) NOT NULL,
    nm_cpl_his_lcn character varying(400),
    cd_cnt numeric(10,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    vl_lcn numeric(13,2) NOT NULL,
    vl_sld_ant_cnt_lcn numeric(13,2) NOT NULL,
    cd_sst numeric(5,0),
    nsu_lcn numeric(10,0),
    cd_est_lcn numeric(10,0)
);


ALTER TABLE tbl_lcn OWNER TO scan;

--
-- TOC entry 8785 (class 0 OID 0)
-- Dependencies: 420
-- Name: TABLE tbl_lcn; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON TABLE tbl_lcn IS 'TABELA DE LANCAMENTO DE CONTA';


--
-- TOC entry 421 (class 1259 OID 565387)
-- Name: tbl_lcn_exc; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_lcn_exc (
    cd_lcn numeric(10,0) NOT NULL,
    cd_ctp_lcn numeric(10,0),
    cd_tlc numeric(10,0) NOT NULL,
    dt_lcn timestamp without time zone NOT NULL,
    dt_ref_lcn timestamp without time zone NOT NULL,
    fg_dcr_lcn "char" NOT NULL,
    nm_his_lcn character varying(50) NOT NULL,
    nm_cpl_his_lcn character varying(400),
    cd_cnt numeric(10,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    vl_lcn numeric(13,2) NOT NULL,
    vl_sld_ant_cnt_lcn numeric(13,2) NOT NULL,
    cd_sst numeric(5,0),
    nsu_lcn numeric(10,0),
    cd_est_lcn numeric(10,0),
    dt_exc_lcn timestamp without time zone NOT NULL,
    cd_usr_exc_lcn numeric(10,0) NOT NULL,
    mtv_exc_lcn character varying(400)
);


ALTER TABLE tbl_lcn_exc OWNER TO scan;

--
-- TOC entry 8786 (class 0 OID 0)
-- Dependencies: 421
-- Name: TABLE tbl_lcn_exc; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON TABLE tbl_lcn_exc IS 'TABELA DE LANCAMENTO EXCLUIDOS DE CONTA';


--
-- TOC entry 422 (class 1259 OID 565393)
-- Name: tbl_lpd; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_lpd (
    cd_lpd numeric(10,0) NOT NULL,
    cd_cnt_dbt_lpd numeric(10,0),
    cd_cnt_crd_lpd numeric(10,0),
    cd_tlc numeric(10,0),
    ds_lpd character varying(80) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    fg_atv_lpd character(1) DEFAULT 'S'::bpchar NOT NULL
);


ALTER TABLE tbl_lpd OWNER TO scan;

--
-- TOC entry 423 (class 1259 OID 565397)
-- Name: tbl_pcn; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_pcn (
    cd_pcn numeric(10,0) NOT NULL,
    ds_pcn character varying(60) NOT NULL
);


ALTER TABLE tbl_pcn OWNER TO scan;

--
-- TOC entry 424 (class 1259 OID 565400)
-- Name: tbl_scn; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_scn (
    cd_scn numeric(10,0) NOT NULL,
    ds_scn character varying(100) NOT NULL,
    pai_scn numeric(10,0),
    nr_scn character varying(15) NOT NULL,
    fg_atc_scn character varying(1) DEFAULT 'S'::character varying NOT NULL,
    cd_cnt_ctb character varying(50),
    fg_ntr_scn character(1),
    nr_scn1 character varying(15),
    cd_cnt_ctb1 character varying(50)
);


ALTER TABLE tbl_scn OWNER TO scan;

--
-- TOC entry 8787 (class 0 OID 0)
-- Dependencies: 424
-- Name: COLUMN tbl_scn.fg_atc_scn; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_scn.fg_atc_scn IS 'FLAG DE ANALITICO';


--
-- TOC entry 8788 (class 0 OID 0)
-- Dependencies: 424
-- Name: COLUMN tbl_scn.cd_cnt_ctb; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_scn.cd_cnt_ctb IS 'CODIGO DA CONTA NO SISTEMA CONTABIL';


--
-- TOC entry 425 (class 1259 OID 565404)
-- Name: tbl_sdc; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_sdc (
    cd_cnt numeric(10,0) NOT NULL,
    dt_sdc date NOT NULL,
    vl_ini_sdc numeric(13,2) NOT NULL,
    vl_dbt_sdc numeric(13,2) NOT NULL,
    vl_crd_sdc numeric(13,2) NOT NULL,
    vl_fin_sdc numeric(13,2) NOT NULL
);


ALTER TABLE tbl_sdc OWNER TO scan;

--
-- TOC entry 8789 (class 0 OID 0)
-- Dependencies: 425
-- Name: TABLE tbl_sdc; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON TABLE tbl_sdc IS 'TABELA DE SALDO DIARIO DE CONTA';


--
-- TOC entry 426 (class 1259 OID 565407)
-- Name: tbl_sds; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_sds (
    cd_sds numeric(10,0) NOT NULL,
    dt_sds date NOT NULL,
    cd_scn numeric(10,0) NOT NULL,
    vl_ini_sds numeric(13,2) NOT NULL,
    vl_crd_sds numeric(13,2) NOT NULL,
    vl_dbt_sds numeric(13,2) NOT NULL,
    vl_fin_sds numeric(13,2) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_sds OWNER TO scan;

--
-- TOC entry 427 (class 1259 OID 565410)
-- Name: tbl_sgc; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_sgc (
    cd_sgc numeric(10,0) NOT NULL,
    cd_gcn numeric(10,0) NOT NULL,
    ds_sgc character varying(50) NOT NULL
);


ALTER TABLE tbl_sgc OWNER TO scan;

--
-- TOC entry 428 (class 1259 OID 565413)
-- Name: tbl_sst; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_sst (
    cd_sst numeric(5,0) NOT NULL,
    nm_sst character varying(50) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_sst OWNER TO scan;

--
-- TOC entry 8790 (class 0 OID 0)
-- Dependencies: 428
-- Name: TABLE tbl_sst; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON TABLE tbl_sst IS 'TABELA DE SISTEMAS';


--
-- TOC entry 429 (class 1259 OID 565416)
-- Name: tbl_tbc; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_tbc (
    cd_tbc numeric(5,0) NOT NULL,
    nm_tbc character varying(50) NOT NULL,
    fg_atv_tbc character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr time without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr time without time zone
);


ALTER TABLE tbl_tbc OWNER TO scan;

--
-- TOC entry 8791 (class 0 OID 0)
-- Dependencies: 429
-- Name: TABLE tbl_tbc; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON TABLE tbl_tbc IS 'TABELA DE TIPO DE BLOQUEIO DE CONTA';


--
-- TOC entry 8792 (class 0 OID 0)
-- Dependencies: 429
-- Name: COLUMN tbl_tbc.cd_tbc; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc.cd_tbc IS 'CODIGO';


--
-- TOC entry 8793 (class 0 OID 0)
-- Dependencies: 429
-- Name: COLUMN tbl_tbc.nm_tbc; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc.nm_tbc IS 'NOME DO TIPO DE BLOQUEIO DA CONTA';


--
-- TOC entry 8794 (class 0 OID 0)
-- Dependencies: 429
-- Name: COLUMN tbl_tbc.fg_atv_tbc; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc.fg_atv_tbc IS 'FLAG DE ATIVO';


--
-- TOC entry 8795 (class 0 OID 0)
-- Dependencies: 429
-- Name: COLUMN tbl_tbc.cd_inc_usr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8796 (class 0 OID 0)
-- Dependencies: 429
-- Name: COLUMN tbl_tbc.dt_inc_usr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 8797 (class 0 OID 0)
-- Dependencies: 429
-- Name: COLUMN tbl_tbc.cd_alt_usr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 8798 (class 0 OID 0)
-- Dependencies: 429
-- Name: COLUMN tbl_tbc.dt_alt_usr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 430 (class 1259 OID 565419)
-- Name: tbl_tbc_cnt; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_tbc_cnt (
    cd_tbc_cnt numeric(10,0) NOT NULL,
    cd_tbc numeric(5,0) NOT NULL,
    cd_cnt numeric(10,0) NOT NULL,
    vl_blq_tbc_cnt numeric(13,2) NOT NULL,
    fg_atv_tbc_cnt character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone DEFAULT now() NOT NULL,
    dt_alt_usr timestamp without time zone,
    dt_fin_blq_tbc_cnt timestamp without time zone
);


ALTER TABLE tbl_tbc_cnt OWNER TO scan;

--
-- TOC entry 8799 (class 0 OID 0)
-- Dependencies: 430
-- Name: TABLE tbl_tbc_cnt; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON TABLE tbl_tbc_cnt IS 'TABELA DE RELACIONAMENTO ENTRE O TIPO DE BLOQUEIO DE CONTA E A CONTA';


--
-- TOC entry 8800 (class 0 OID 0)
-- Dependencies: 430
-- Name: COLUMN tbl_tbc_cnt.cd_tbc_cnt; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc_cnt.cd_tbc_cnt IS 'CODIGO';


--
-- TOC entry 8801 (class 0 OID 0)
-- Dependencies: 430
-- Name: COLUMN tbl_tbc_cnt.cd_tbc; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc_cnt.cd_tbc IS 'CODIGO DO TIPO DE BLOQUEIO';


--
-- TOC entry 8802 (class 0 OID 0)
-- Dependencies: 430
-- Name: COLUMN tbl_tbc_cnt.cd_cnt; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc_cnt.cd_cnt IS 'CODIGO DA CONTA';


--
-- TOC entry 8803 (class 0 OID 0)
-- Dependencies: 430
-- Name: COLUMN tbl_tbc_cnt.vl_blq_tbc_cnt; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc_cnt.vl_blq_tbc_cnt IS 'VALOR BLOQUEADO DA CONTA POR ESTE TIPO DE BLOQUEIO';


--
-- TOC entry 8804 (class 0 OID 0)
-- Dependencies: 430
-- Name: COLUMN tbl_tbc_cnt.fg_atv_tbc_cnt; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc_cnt.fg_atv_tbc_cnt IS 'FLAG DE ATIVO';


--
-- TOC entry 8805 (class 0 OID 0)
-- Dependencies: 430
-- Name: COLUMN tbl_tbc_cnt.cd_inc_usr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc_cnt.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8806 (class 0 OID 0)
-- Dependencies: 430
-- Name: COLUMN tbl_tbc_cnt.cd_alt_usr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tbc_cnt.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 431 (class 1259 OID 565423)
-- Name: tbl_tcn; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_tcn (
    cd_tcn numeric(10,0) NOT NULL,
    ds_tcn character varying(50) NOT NULL,
    cd_sgc numeric(10,0) NOT NULL
);


ALTER TABLE tbl_tcn OWNER TO scan;

--
-- TOC entry 432 (class 1259 OID 565426)
-- Name: tbl_tlc; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_tlc (
    cd_tlc numeric(10,0) NOT NULL,
    ds_tlc character varying(50) NOT NULL,
    cd_alt_usr numeric(10,0),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_alt_usr timestamp without time zone,
    dt_inc_usr timestamp without time zone DEFAULT now() NOT NULL,
    fg_atv_tlc character varying(1) DEFAULT 'S'::bpchar NOT NULL,
    cd_est_tlc numeric(10,0)
);


ALTER TABLE tbl_tlc OWNER TO scan;

--
-- TOC entry 8807 (class 0 OID 0)
-- Dependencies: 432
-- Name: TABLE tbl_tlc; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON TABLE tbl_tlc IS 'TABELA DE TIPO DE LANCAMENTO DE CONTA';


--
-- TOC entry 8808 (class 0 OID 0)
-- Dependencies: 432
-- Name: COLUMN tbl_tlc.cd_tlc; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tlc.cd_tlc IS 'CODIGO';


--
-- TOC entry 8809 (class 0 OID 0)
-- Dependencies: 432
-- Name: COLUMN tbl_tlc.ds_tlc; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tlc.ds_tlc IS 'DESCRICAO';


--
-- TOC entry 433 (class 1259 OID 565431)
-- Name: tbl_tsr; Type: TABLE; Schema: sc_cnt; Owner: scan
--

CREATE TABLE tbl_tsr (
    cd_tsr numeric(10,0) NOT NULL,
    ds_tsr character varying(100) NOT NULL,
    cd_cnt numeric(10,0) NOT NULL,
    fg_atv_tsr character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_cnt_nr_trs_tsr numeric(10,0)
);


ALTER TABLE tbl_tsr OWNER TO scan;

--
-- TOC entry 8810 (class 0 OID 0)
-- Dependencies: 433
-- Name: TABLE tbl_tsr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON TABLE tbl_tsr IS 'TESORARIA';


--
-- TOC entry 8811 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tbl_tsr.cd_tsr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.cd_tsr IS 'CODIGO';


--
-- TOC entry 8812 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tbl_tsr.ds_tsr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.ds_tsr IS 'TESOURARIA';


--
-- TOC entry 8813 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tbl_tsr.cd_cnt; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.cd_cnt IS 'CONTA';


--
-- TOC entry 8814 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tbl_tsr.fg_atv_tsr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.fg_atv_tsr IS 'FLAG ATIVO';


--
-- TOC entry 8815 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tbl_tsr.cd_inc_usr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.cd_inc_usr IS 'USUARIO INCLUSAO';


--
-- TOC entry 8816 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tbl_tsr.dt_inc_usr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 8817 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tbl_tsr.cd_alt_usr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.cd_alt_usr IS 'USUARIO ALTERACAO';


--
-- TOC entry 8818 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tbl_tsr.dt_alt_usr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.dt_alt_usr IS 'DATA ALTERACAO';


--
-- TOC entry 8819 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN tbl_tsr.cd_cnt_nr_trs_tsr; Type: COMMENT; Schema: sc_cnt; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.cd_cnt_nr_trs_tsr IS 'CONTA DE NUMERARIO EM TRANSITO';


--
-- TOC entry 434 (class 1259 OID 565434)
-- Name: vw_cnt; Type: VIEW; Schema: sc_cnt; Owner: scan
--

CREATE VIEW vw_cnt AS
SELECT DISTINCT cnt.cd_cnt, cnt.nm_cnt, ctr.cd_emp FROM (tbl_cnt cnt JOIN sc_cad.tbl_ctr ctr ON ((ctr.cd_cnt = cnt.cd_cnt))) WHERE (ctr.fg_atv_ctr = 'S'::"char");


ALTER TABLE vw_cnt OWNER TO scan;

--
-- TOC entry 435 (class 1259 OID 565438)
-- Name: vw_cnt_gem; Type: VIEW; Schema: sc_cnt; Owner: scan
--

CREATE VIEW vw_cnt_gem AS
SELECT DISTINCT cnt.cd_cnt, cnt.nm_cnt, gem.cd_gem, gem.nm_gem FROM (tbl_cnt cnt JOIN sc_cad.tbl_gem gem ON ((gem.cd_cnt = cnt.cd_cnt)));


ALTER TABLE vw_cnt_gem OWNER TO scan;

SET search_path = sc_ctb, pg_catalog;

--
-- TOC entry 436 (class 1259 OID 565442)
-- Name: sq_aec; Type: SEQUENCE; Schema: sc_ctb; Owner: scan
--

CREATE SEQUENCE sq_aec
    START WITH 1
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE sq_aec OWNER TO scan;

--
-- TOC entry 864 (class 1259 OID 938463)
-- Name: sq_arq_ctb; Type: SEQUENCE; Schema: sc_ctb; Owner: scan
--

CREATE SEQUENCE sq_arq_ctb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_arq_ctb OWNER TO scan;

--
-- TOC entry 437 (class 1259 OID 565444)
-- Name: sq_cte; Type: SEQUENCE; Schema: sc_ctb; Owner: scan
--

CREATE SEQUENCE sq_cte
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE sq_cte OWNER TO scan;

--
-- TOC entry 438 (class 1259 OID 565446)
-- Name: sq_daec_cpl; Type: SEQUENCE; Schema: sc_ctb; Owner: scan
--

CREATE SEQUENCE sq_daec_cpl
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE sq_daec_cpl OWNER TO scan;

--
-- TOC entry 439 (class 1259 OID 565448)
-- Name: sq_daec_lcn; Type: SEQUENCE; Schema: sc_ctb; Owner: scan
--

CREATE SEQUENCE sq_daec_lcn
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE sq_daec_lcn OWNER TO scan;

--
-- TOC entry 440 (class 1259 OID 565450)
-- Name: sq_evt; Type: SEQUENCE; Schema: sc_ctb; Owner: scan
--

CREATE SEQUENCE sq_evt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE sq_evt OWNER TO scan;

--
-- TOC entry 441 (class 1259 OID 565452)
-- Name: sq_ext_lcn; Type: SEQUENCE; Schema: sc_ctb; Owner: scan
--

CREATE SEQUENCE sq_ext_lcn
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE sq_ext_lcn OWNER TO scan;

--
-- TOC entry 442 (class 1259 OID 565454)
-- Name: sq_tve; Type: SEQUENCE; Schema: sc_ctb; Owner: scan
--

CREATE SEQUENCE sq_tve
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE sq_tve OWNER TO scan;

--
-- TOC entry 863 (class 1259 OID 938427)
-- Name: tbl_arq_ctb; Type: TABLE; Schema: sc_ctb; Owner: scan
--

CREATE TABLE tbl_arq_ctb (
    cd_arq_ctb numeric(10,0) NOT NULL,
    dt_arq_ctb date NOT NULL,
    st_arq_ctb numeric(1,0) DEFAULT 1 NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr date NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr date,
    cd_dwa numeric(10,0)
);


ALTER TABLE tbl_arq_ctb OWNER TO scan;

--
-- TOC entry 443 (class 1259 OID 565456)
-- Name: tbl_cte; Type: TABLE; Schema: sc_ctb; Owner: scan
--

CREATE TABLE tbl_cte (
    cd_cte numeric(10,0) DEFAULT 0 NOT NULL,
    cd_evt numeric(10,0) DEFAULT 0 NOT NULL,
    cd_tve numeric(10,0) DEFAULT 0 NOT NULL,
    cnt_dbt_cte character varying(50) NOT NULL,
    cnt_crd_cte character varying(50) NOT NULL,
    hst_cte character varying(50) NOT NULL,
    fg_atv_cte character(1) NOT NULL,
    cd_inc_usr numeric(5,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(5,0),
    dt_alt_usr timestamp without time zone,
    CONSTRAINT ck_fg_atv_cte CHECK ((fg_atv_cte = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_cte OWNER TO scan;

--
-- TOC entry 8820 (class 0 OID 0)
-- Dependencies: 443
-- Name: TABLE tbl_cte; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON TABLE tbl_cte IS 'tabela de contabilizacao dos eventos';


--
-- TOC entry 8821 (class 0 OID 0)
-- Dependencies: 443
-- Name: COLUMN tbl_cte.cd_cte; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_cte.cd_cte IS 'codigo';


--
-- TOC entry 8822 (class 0 OID 0)
-- Dependencies: 443
-- Name: COLUMN tbl_cte.cd_evt; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_cte.cd_evt IS 'codigo do evento';


--
-- TOC entry 8823 (class 0 OID 0)
-- Dependencies: 443
-- Name: COLUMN tbl_cte.cd_tve; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_cte.cd_tve IS 'codigo do tipo de valor';


--
-- TOC entry 8824 (class 0 OID 0)
-- Dependencies: 443
-- Name: COLUMN tbl_cte.cnt_dbt_cte; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_cte.cnt_dbt_cte IS 'conta de debito';


--
-- TOC entry 8825 (class 0 OID 0)
-- Dependencies: 443
-- Name: COLUMN tbl_cte.cnt_crd_cte; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_cte.cnt_crd_cte IS 'conta de credito';


--
-- TOC entry 8826 (class 0 OID 0)
-- Dependencies: 443
-- Name: COLUMN tbl_cte.hst_cte; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_cte.hst_cte IS 'historico';


--
-- TOC entry 8827 (class 0 OID 0)
-- Dependencies: 443
-- Name: COLUMN tbl_cte.fg_atv_cte; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_cte.fg_atv_cte IS 'flag de ativo';


--
-- TOC entry 8828 (class 0 OID 0)
-- Dependencies: 443
-- Name: COLUMN tbl_cte.cd_inc_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_cte.cd_inc_usr IS 'usuario de inclusão';


--
-- TOC entry 8829 (class 0 OID 0)
-- Dependencies: 443
-- Name: COLUMN tbl_cte.dt_inc_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_cte.dt_inc_usr IS 'data de inclusão';


--
-- TOC entry 8830 (class 0 OID 0)
-- Dependencies: 443
-- Name: COLUMN tbl_cte.cd_alt_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_cte.cd_alt_usr IS 'usuario da ultima alteracao';


--
-- TOC entry 8831 (class 0 OID 0)
-- Dependencies: 443
-- Name: COLUMN tbl_cte.dt_alt_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_cte.dt_alt_usr IS 'data da ultima alteracao';


--
-- TOC entry 444 (class 1259 OID 565463)
-- Name: tbl_daec; Type: TABLE; Schema: sc_ctb; Owner: scan
--

CREATE TABLE tbl_daec (
    cd_daec numeric(10,0) NOT NULL,
    cd_aec numeric(10,0) NOT NULL,
    cnt_dbt_daec character varying(50) NOT NULL,
    cnt_crd_daec character varying(50) NOT NULL,
    hst_daec character varying(50) NOT NULL,
    vl_daec numeric(13,2) NOT NULL,
    dt_rfr_daec date NOT NULL,
    sq_dia_daec numeric(10,0) NOT NULL,
    ds_cmp_hst_daec character varying(4000)
);


ALTER TABLE tbl_daec OWNER TO scan;

--
-- TOC entry 8832 (class 0 OID 0)
-- Dependencies: 444
-- Name: TABLE tbl_daec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON TABLE tbl_daec IS 'tabela de detalhe do arquivo de exportacao de contabilidade';


--
-- TOC entry 8833 (class 0 OID 0)
-- Dependencies: 444
-- Name: COLUMN tbl_daec.cd_daec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_daec.cd_daec IS 'codigo';


--
-- TOC entry 8834 (class 0 OID 0)
-- Dependencies: 444
-- Name: COLUMN tbl_daec.cd_aec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_daec.cd_aec IS 'codigo do arquivo';


--
-- TOC entry 8835 (class 0 OID 0)
-- Dependencies: 444
-- Name: COLUMN tbl_daec.cnt_dbt_daec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_daec.cnt_dbt_daec IS 'conta de debito';


--
-- TOC entry 8836 (class 0 OID 0)
-- Dependencies: 444
-- Name: COLUMN tbl_daec.cnt_crd_daec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_daec.cnt_crd_daec IS 'conta de credito';


--
-- TOC entry 8837 (class 0 OID 0)
-- Dependencies: 444
-- Name: COLUMN tbl_daec.hst_daec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_daec.hst_daec IS 'historico';


--
-- TOC entry 8838 (class 0 OID 0)
-- Dependencies: 444
-- Name: COLUMN tbl_daec.vl_daec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_daec.vl_daec IS 'valor';


--
-- TOC entry 8839 (class 0 OID 0)
-- Dependencies: 444
-- Name: COLUMN tbl_daec.dt_rfr_daec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_daec.dt_rfr_daec IS 'data de referencia';


--
-- TOC entry 8840 (class 0 OID 0)
-- Dependencies: 444
-- Name: COLUMN tbl_daec.sq_dia_daec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_daec.sq_dia_daec IS 'sequencia do dia';


--
-- TOC entry 8841 (class 0 OID 0)
-- Dependencies: 444
-- Name: COLUMN tbl_daec.ds_cmp_hst_daec; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_daec.ds_cmp_hst_daec IS 'complemento de historico do lancamento';


--
-- TOC entry 445 (class 1259 OID 565469)
-- Name: tbl_evt; Type: TABLE; Schema: sc_ctb; Owner: scan
--

CREATE TABLE tbl_evt (
    cd_evt numeric(10,0) DEFAULT 0 NOT NULL,
    ds_evt character varying(50) NOT NULL,
    fg_atv_evt character(1) NOT NULL,
    cd_inc_usr numeric(5,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(5,0),
    dt_alt_usr timestamp without time zone,
    CONSTRAINT ck_fg_atv_evt CHECK ((fg_atv_evt = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_evt OWNER TO scan;

--
-- TOC entry 8842 (class 0 OID 0)
-- Dependencies: 445
-- Name: TABLE tbl_evt; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON TABLE tbl_evt IS 'tabela de eventos contabeis';


--
-- TOC entry 8843 (class 0 OID 0)
-- Dependencies: 445
-- Name: COLUMN tbl_evt.cd_evt; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_evt.cd_evt IS 'codigo';


--
-- TOC entry 8844 (class 0 OID 0)
-- Dependencies: 445
-- Name: COLUMN tbl_evt.ds_evt; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_evt.ds_evt IS 'descricao';


--
-- TOC entry 8845 (class 0 OID 0)
-- Dependencies: 445
-- Name: COLUMN tbl_evt.fg_atv_evt; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_evt.fg_atv_evt IS 'flag de ativo';


--
-- TOC entry 8846 (class 0 OID 0)
-- Dependencies: 445
-- Name: COLUMN tbl_evt.cd_inc_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_evt.cd_inc_usr IS 'usuario de inclusão';


--
-- TOC entry 8847 (class 0 OID 0)
-- Dependencies: 445
-- Name: COLUMN tbl_evt.dt_inc_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_evt.dt_inc_usr IS 'data de inclusão';


--
-- TOC entry 8848 (class 0 OID 0)
-- Dependencies: 445
-- Name: COLUMN tbl_evt.cd_alt_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_evt.cd_alt_usr IS 'usuario da ultima alteracao';


--
-- TOC entry 8849 (class 0 OID 0)
-- Dependencies: 445
-- Name: COLUMN tbl_evt.dt_alt_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_evt.dt_alt_usr IS 'data da ultima alteracao';


--
-- TOC entry 933 (class 1259 OID 1077245)
-- Name: tbl_ext_lcn; Type: TABLE; Schema: sc_ctb; Owner: scan
--

CREATE TABLE tbl_ext_lcn (
    cd_ext_lcn numeric(10,0) NOT NULL,
    nr_seq_ext_lcn numeric(10,0) NOT NULL,
    cd_lcn numeric(10,0) NOT NULL,
    cd_cnt_ctb character varying(50) NOT NULL,
    err_ext_lcn numeric(5,0)
);


ALTER TABLE tbl_ext_lcn OWNER TO scan;

--
-- TOC entry 8850 (class 0 OID 0)
-- Dependencies: 933
-- Name: TABLE tbl_ext_lcn; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON TABLE tbl_ext_lcn IS 'TABELA DE EXTENSAO DE LANCAMENTO';


--
-- TOC entry 446 (class 1259 OID 565474)
-- Name: tbl_ext_lcn2; Type: TABLE; Schema: sc_ctb; Owner: scan
--

CREATE TABLE tbl_ext_lcn2 (
    cd_ext_lcn numeric(10,0) NOT NULL,
    nr_seq_ext_lcn numeric(10,0) NOT NULL,
    cd_lcn numeric(10,0) NOT NULL,
    cd_cnt_ctb character varying(50) NOT NULL,
    err_ext_lcn numeric(5,0)
);


ALTER TABLE tbl_ext_lcn2 OWNER TO scan;

--
-- TOC entry 8851 (class 0 OID 0)
-- Dependencies: 446
-- Name: TABLE tbl_ext_lcn2; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON TABLE tbl_ext_lcn2 IS 'TABELA DE EXTENSAO DE LANCAMENTO';


--
-- TOC entry 447 (class 1259 OID 565477)
-- Name: tbl_tve; Type: TABLE; Schema: sc_ctb; Owner: scan
--

CREATE TABLE tbl_tve (
    cd_tve numeric(10,0) DEFAULT 0 NOT NULL,
    cd_evt numeric(10,0) DEFAULT 0 NOT NULL,
    ds_tve character varying(50) NOT NULL,
    fg_atv_tve character(1) NOT NULL,
    cd_inc_usr numeric(5,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(5,0),
    dt_alt_usr timestamp without time zone,
    CONSTRAINT ck_fg_atv_tve CHECK ((fg_atv_tve = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_tve OWNER TO scan;

--
-- TOC entry 8852 (class 0 OID 0)
-- Dependencies: 447
-- Name: TABLE tbl_tve; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON TABLE tbl_tve IS 'tabela de tipos de valores dos eventos';


--
-- TOC entry 8853 (class 0 OID 0)
-- Dependencies: 447
-- Name: COLUMN tbl_tve.cd_tve; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_tve.cd_tve IS 'codigo';


--
-- TOC entry 8854 (class 0 OID 0)
-- Dependencies: 447
-- Name: COLUMN tbl_tve.cd_evt; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_tve.cd_evt IS 'codigo do evento';


--
-- TOC entry 8855 (class 0 OID 0)
-- Dependencies: 447
-- Name: COLUMN tbl_tve.ds_tve; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_tve.ds_tve IS 'descricao';


--
-- TOC entry 8856 (class 0 OID 0)
-- Dependencies: 447
-- Name: COLUMN tbl_tve.fg_atv_tve; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_tve.fg_atv_tve IS 'flag de ativo';


--
-- TOC entry 8857 (class 0 OID 0)
-- Dependencies: 447
-- Name: COLUMN tbl_tve.cd_inc_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_tve.cd_inc_usr IS 'usuario de inclusão';


--
-- TOC entry 8858 (class 0 OID 0)
-- Dependencies: 447
-- Name: COLUMN tbl_tve.dt_inc_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_tve.dt_inc_usr IS 'data de inclusão';


--
-- TOC entry 8859 (class 0 OID 0)
-- Dependencies: 447
-- Name: COLUMN tbl_tve.cd_alt_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_tve.cd_alt_usr IS 'usuario da ultima alteracao';


--
-- TOC entry 8860 (class 0 OID 0)
-- Dependencies: 447
-- Name: COLUMN tbl_tve.dt_alt_usr; Type: COMMENT; Schema: sc_ctb; Owner: scan
--

COMMENT ON COLUMN tbl_tve.dt_alt_usr IS 'data da ultima alteracao';


SET search_path = sc_dgt, pg_catalog;

--
-- TOC entry 871 (class 1259 OID 966394)
-- Name: sq_arq; Type: SEQUENCE; Schema: sc_dgt; Owner: scan
--

CREATE SEQUENCE sq_arq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_arq OWNER TO scan;

--
-- TOC entry 869 (class 1259 OID 966387)
-- Name: sq_tar; Type: SEQUENCE; Schema: sc_dgt; Owner: scan
--

CREATE SEQUENCE sq_tar
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tar OWNER TO scan;

--
-- TOC entry 873 (class 1259 OID 966406)
-- Name: sq_var; Type: SEQUENCE; Schema: sc_dgt; Owner: scan
--

CREATE SEQUENCE sq_var
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_var OWNER TO scan;

--
-- TOC entry 872 (class 1259 OID 966396)
-- Name: tbl_arq; Type: TABLE; Schema: sc_dgt; Owner: scan
--

CREATE TABLE tbl_arq (
    cd_arq numeric(10,0) NOT NULL,
    cd_tar numeric(2,0) NOT NULL,
    ds_arq character varying(80),
    ex_arq character varying(4) NOT NULL,
    st_arq numeric(2,0) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    dt_inc_arq timestamp without time zone NOT NULL,
    fg_atv_arq character varying(1) NOT NULL,
    cd_arq_pai numeric(10,0),
    fg_env_arq character(1) DEFAULT 'N'::bpchar NOT NULL,
    cd_usr_alt numeric(10,0),
    dt_usr_alt timestamp without time zone,
    tp_org_arq numeric(2,0)
);


ALTER TABLE tbl_arq OWNER TO scan;

--
-- TOC entry 8861 (class 0 OID 0)
-- Dependencies: 872
-- Name: TABLE tbl_arq; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON TABLE tbl_arq IS 'tabela de  tipo de arquivo';


--
-- TOC entry 8862 (class 0 OID 0)
-- Dependencies: 872
-- Name: COLUMN tbl_arq.cd_arq; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_arq.cd_arq IS 'codigo';


--
-- TOC entry 8863 (class 0 OID 0)
-- Dependencies: 872
-- Name: COLUMN tbl_arq.cd_tar; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_arq.cd_tar IS 'codigo do tipo de arquivo';


--
-- TOC entry 8864 (class 0 OID 0)
-- Dependencies: 872
-- Name: COLUMN tbl_arq.ds_arq; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_arq.ds_arq IS 'descrição';


--
-- TOC entry 8865 (class 0 OID 0)
-- Dependencies: 872
-- Name: COLUMN tbl_arq.ex_arq; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_arq.ex_arq IS 'situação (ver domínio)';


--
-- TOC entry 8866 (class 0 OID 0)
-- Dependencies: 872
-- Name: COLUMN tbl_arq.cd_cun; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_arq.cd_cun IS 'cadastro unico';


--
-- TOC entry 8867 (class 0 OID 0)
-- Dependencies: 872
-- Name: COLUMN tbl_arq.dt_inc_arq; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_arq.dt_inc_arq IS 'data de inclusão';


--
-- TOC entry 8868 (class 0 OID 0)
-- Dependencies: 872
-- Name: COLUMN tbl_arq.fg_atv_arq; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_arq.fg_atv_arq IS 'flag ativo';


--
-- TOC entry 870 (class 1259 OID 966389)
-- Name: tbl_tar; Type: TABLE; Schema: sc_dgt; Owner: scan
--

CREATE TABLE tbl_tar (
    cd_tar numeric(2,0) NOT NULL,
    nm_tar character varying(80) NOT NULL,
    fg_atv_tar character varying(1) NOT NULL,
    fg_vsv_usr_tar character varying(1)
);


ALTER TABLE tbl_tar OWNER TO scan;

--
-- TOC entry 8869 (class 0 OID 0)
-- Dependencies: 870
-- Name: TABLE tbl_tar; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON TABLE tbl_tar IS 'tabela de  tipo de arquivo';


--
-- TOC entry 8870 (class 0 OID 0)
-- Dependencies: 870
-- Name: COLUMN tbl_tar.cd_tar; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_tar.cd_tar IS 'codigo';


--
-- TOC entry 8871 (class 0 OID 0)
-- Dependencies: 870
-- Name: COLUMN tbl_tar.nm_tar; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_tar.nm_tar IS 'nome';


--
-- TOC entry 8872 (class 0 OID 0)
-- Dependencies: 870
-- Name: COLUMN tbl_tar.fg_atv_tar; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_tar.fg_atv_tar IS 'flag ativo';


--
-- TOC entry 874 (class 1259 OID 966408)
-- Name: tbl_var; Type: TABLE; Schema: sc_dgt; Owner: scan
--

CREATE TABLE tbl_var (
    cd_var numeric(10,0) NOT NULL,
    cd_arq numeric(10,0) NOT NULL,
    st_ant_arq numeric(2,0),
    st_arq numeric(2,0) NOT NULL,
    ds_var character varying(200),
    cd_cun numeric(10,0) NOT NULL,
    dt_inc_var timestamp without time zone NOT NULL
);


ALTER TABLE tbl_var OWNER TO scan;

--
-- TOC entry 8873 (class 0 OID 0)
-- Dependencies: 874
-- Name: TABLE tbl_var; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON TABLE tbl_var IS 'tabela de  validação de arquivo';


--
-- TOC entry 8874 (class 0 OID 0)
-- Dependencies: 874
-- Name: COLUMN tbl_var.cd_var; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_var.cd_var IS 'codigo';


--
-- TOC entry 8875 (class 0 OID 0)
-- Dependencies: 874
-- Name: COLUMN tbl_var.cd_arq; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_var.cd_arq IS 'codigo do arquivo';


--
-- TOC entry 8876 (class 0 OID 0)
-- Dependencies: 874
-- Name: COLUMN tbl_var.st_ant_arq; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_var.st_ant_arq IS 'situação anterior';


--
-- TOC entry 8877 (class 0 OID 0)
-- Dependencies: 874
-- Name: COLUMN tbl_var.st_arq; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_var.st_arq IS 'situação';


--
-- TOC entry 8878 (class 0 OID 0)
-- Dependencies: 874
-- Name: COLUMN tbl_var.ds_var; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_var.ds_var IS 'descrição';


--
-- TOC entry 8879 (class 0 OID 0)
-- Dependencies: 874
-- Name: COLUMN tbl_var.cd_cun; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_var.cd_cun IS 'cadastro único';


--
-- TOC entry 8880 (class 0 OID 0)
-- Dependencies: 874
-- Name: COLUMN tbl_var.dt_inc_var; Type: COMMENT; Schema: sc_dgt; Owner: scan
--

COMMENT ON COLUMN tbl_var.dt_inc_var IS 'data de inclusão';


SET search_path = sc_dsp, pg_catalog;

--
-- TOC entry 448 (class 1259 OID 565483)
-- Name: sq_dsp; Type: SEQUENCE; Schema: sc_dsp; Owner: scan
--

CREATE SEQUENCE sq_dsp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dsp OWNER TO scan;

--
-- TOC entry 449 (class 1259 OID 565485)
-- Name: sq_fvd; Type: SEQUENCE; Schema: sc_dsp; Owner: scan
--

CREATE SEQUENCE sq_fvd
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_fvd OWNER TO scan;

--
-- TOC entry 450 (class 1259 OID 565487)
-- Name: tbl_dsp; Type: TABLE; Schema: sc_dsp; Owner: scan
--

CREATE TABLE tbl_dsp (
    cd_dsp numeric(10,0) NOT NULL,
    dt_dsp date NOT NULL,
    vl_dsp numeric(13,2) NOT NULL
);


ALTER TABLE tbl_dsp OWNER TO scan;

--
-- TOC entry 8881 (class 0 OID 0)
-- Dependencies: 450
-- Name: TABLE tbl_dsp; Type: COMMENT; Schema: sc_dsp; Owner: scan
--

COMMENT ON TABLE tbl_dsp IS 'Tabela de disponibilidade diario';


--
-- TOC entry 451 (class 1259 OID 565490)
-- Name: tbl_fvd; Type: TABLE; Schema: sc_dsp; Owner: scan
--

CREATE TABLE tbl_fvd (
    cd_fvd numeric(10,0) NOT NULL,
    cd_vds numeric(10,0) NOT NULL,
    dt_fvd date NOT NULL,
    vl_fvd character varying(20)
);


ALTER TABLE tbl_fvd OWNER TO scan;

--
-- TOC entry 8882 (class 0 OID 0)
-- Dependencies: 451
-- Name: TABLE tbl_fvd; Type: COMMENT; Schema: sc_dsp; Owner: scan
--

COMMENT ON TABLE tbl_fvd IS 'Tabela de fechamento das variaveis de disponibilidade';


--
-- TOC entry 795 (class 1259 OID 871431)
-- Name: tbl_mdp; Type: TABLE; Schema: sc_dsp; Owner: scan
--

CREATE TABLE tbl_mdp (
    cd_mdp numeric(5,0) NOT NULL,
    ds_mdp character varying(50) NOT NULL,
    cd_pai_mdp numeric(5,0),
    tp_mdp numeric(5,0),
    col_mdp numeric(2,0),
    nr_ord_mdp numeric(5,0) NOT NULL
);


ALTER TABLE tbl_mdp OWNER TO scan;

--
-- TOC entry 452 (class 1259 OID 565493)
-- Name: tbl_vds; Type: TABLE; Schema: sc_dsp; Owner: scan
--

CREATE TABLE tbl_vds (
    cd_vds numeric(10,0) NOT NULL,
    sql_vds character varying(4000) NOT NULL,
    fg_dcr_vds character(1) NOT NULL,
    fg_atv_vds character(1) DEFAULT 'S'::bpchar NOT NULL,
    ds_vds character varying(100) NOT NULL,
    cd_mdp numeric(5,0),
    nr_ord_vds numeric(5,0),
    tp_res_vds numeric(5,0)
);


ALTER TABLE tbl_vds OWNER TO scan;

--
-- TOC entry 8883 (class 0 OID 0)
-- Dependencies: 452
-- Name: TABLE tbl_vds; Type: COMMENT; Schema: sc_dsp; Owner: scan
--

COMMENT ON TABLE tbl_vds IS 'Tabela de variaveis de disponibilidade';


SET search_path = sc_dwn, pg_catalog;

--
-- TOC entry 453 (class 1259 OID 565500)
-- Name: sq_dwa; Type: SEQUENCE; Schema: sc_dwn; Owner: scan
--

CREATE SEQUENCE sq_dwa
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999
    CACHE 1;


ALTER TABLE sq_dwa OWNER TO scan;

--
-- TOC entry 454 (class 1259 OID 565502)
-- Name: tbl_dwa; Type: TABLE; Schema: sc_dwn; Owner: scan
--

CREATE TABLE tbl_dwa (
    cd_dwa numeric(10,0) NOT NULL,
    nm_dwa character varying(400) NOT NULL,
    dt_grc_dwa date NOT NULL,
    dt_ref_dwa date NOT NULL,
    cd_tda numeric(5,0) NOT NULL,
    st_dwa numeric(5,0) NOT NULL
);


ALTER TABLE tbl_dwa OWNER TO scan;

--
-- TOC entry 8884 (class 0 OID 0)
-- Dependencies: 454
-- Name: TABLE tbl_dwa; Type: COMMENT; Schema: sc_dwn; Owner: scan
--

COMMENT ON TABLE tbl_dwa IS 'tabela de download de arquivos';


--
-- TOC entry 8885 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN tbl_dwa.cd_dwa; Type: COMMENT; Schema: sc_dwn; Owner: scan
--

COMMENT ON COLUMN tbl_dwa.cd_dwa IS 'codigo';


--
-- TOC entry 8886 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN tbl_dwa.nm_dwa; Type: COMMENT; Schema: sc_dwn; Owner: scan
--

COMMENT ON COLUMN tbl_dwa.nm_dwa IS 'nome';


--
-- TOC entry 8887 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN tbl_dwa.dt_grc_dwa; Type: COMMENT; Schema: sc_dwn; Owner: scan
--

COMMENT ON COLUMN tbl_dwa.dt_grc_dwa IS 'data de geracao do arquivo';


--
-- TOC entry 8888 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN tbl_dwa.dt_ref_dwa; Type: COMMENT; Schema: sc_dwn; Owner: scan
--

COMMENT ON COLUMN tbl_dwa.dt_ref_dwa IS 'data de referencia do arquivo';


--
-- TOC entry 8889 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN tbl_dwa.cd_tda; Type: COMMENT; Schema: sc_dwn; Owner: scan
--

COMMENT ON COLUMN tbl_dwa.cd_tda IS 'codigo do tipo do arquivo';


--
-- TOC entry 8890 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN tbl_dwa.st_dwa; Type: COMMENT; Schema: sc_dwn; Owner: scan
--

COMMENT ON COLUMN tbl_dwa.st_dwa IS 'situacao do arquivo';


--
-- TOC entry 455 (class 1259 OID 565505)
-- Name: tbl_tda; Type: TABLE; Schema: sc_dwn; Owner: scan
--

CREATE TABLE tbl_tda (
    cd_tda numeric(5,0) NOT NULL,
    nm_tda character varying(40) NOT NULL,
    dir_tda character varying(200) NOT NULL
);


ALTER TABLE tbl_tda OWNER TO scan;

--
-- TOC entry 8891 (class 0 OID 0)
-- Dependencies: 455
-- Name: TABLE tbl_tda; Type: COMMENT; Schema: sc_dwn; Owner: scan
--

COMMENT ON TABLE tbl_tda IS 'tabela de tipo de download de arquivo';


--
-- TOC entry 8892 (class 0 OID 0)
-- Dependencies: 455
-- Name: COLUMN tbl_tda.cd_tda; Type: COMMENT; Schema: sc_dwn; Owner: scan
--

COMMENT ON COLUMN tbl_tda.cd_tda IS 'codigo';


--
-- TOC entry 8893 (class 0 OID 0)
-- Dependencies: 455
-- Name: COLUMN tbl_tda.nm_tda; Type: COMMENT; Schema: sc_dwn; Owner: scan
--

COMMENT ON COLUMN tbl_tda.nm_tda IS 'nome';


--
-- TOC entry 8894 (class 0 OID 0)
-- Dependencies: 455
-- Name: COLUMN tbl_tda.dir_tda; Type: COMMENT; Schema: sc_dwn; Owner: scan
--

COMMENT ON COLUMN tbl_tda.dir_tda IS 'diretorio';


SET search_path = sc_exp, pg_catalog;

--
-- TOC entry 937 (class 1259 OID 1611251)
-- Name: sc_pgc_tbl_lgt; Type: TABLE; Schema: sc_exp; Owner: scan
--

CREATE TABLE sc_pgc_tbl_lgt (
    cd_lgt numeric(10,0) NOT NULL,
    cd_pgt numeric(10,0),
    tp_tsc_lgt numeric(5,0),
    dt_env_lgt timestamp without time zone,
    dt_ret_lgt timestamp without time zone,
    xml_env_lgt character varying(8000),
    xml_ret_lgt character varying(8000)
);


ALTER TABLE sc_pgc_tbl_lgt OWNER TO scan;

--
-- TOC entry 8895 (class 0 OID 0)
-- Dependencies: 937
-- Name: TABLE sc_pgc_tbl_lgt; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON TABLE sc_pgc_tbl_lgt IS 'tabela de log de transacao de pagamento de contas';


--
-- TOC entry 8896 (class 0 OID 0)
-- Dependencies: 937
-- Name: COLUMN sc_pgc_tbl_lgt.cd_lgt; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_pgc_tbl_lgt.cd_lgt IS 'codigo';


--
-- TOC entry 8897 (class 0 OID 0)
-- Dependencies: 937
-- Name: COLUMN sc_pgc_tbl_lgt.cd_pgt; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_pgc_tbl_lgt.cd_pgt IS 'codigo do pagamento';


--
-- TOC entry 8898 (class 0 OID 0)
-- Dependencies: 937
-- Name: COLUMN sc_pgc_tbl_lgt.tp_tsc_lgt; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_pgc_tbl_lgt.tp_tsc_lgt IS 'tipo de transacao';


--
-- TOC entry 8899 (class 0 OID 0)
-- Dependencies: 937
-- Name: COLUMN sc_pgc_tbl_lgt.dt_env_lgt; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_pgc_tbl_lgt.dt_env_lgt IS 'data do envio';


--
-- TOC entry 8900 (class 0 OID 0)
-- Dependencies: 937
-- Name: COLUMN sc_pgc_tbl_lgt.dt_ret_lgt; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_pgc_tbl_lgt.dt_ret_lgt IS 'data do retorno';


--
-- TOC entry 8901 (class 0 OID 0)
-- Dependencies: 937
-- Name: COLUMN sc_pgc_tbl_lgt.xml_env_lgt; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_pgc_tbl_lgt.xml_env_lgt IS 'dados de envio';


--
-- TOC entry 936 (class 1259 OID 1348521)
-- Name: sc_rds_tbl_drqa; Type: TABLE; Schema: sc_exp; Owner: scan
--

CREATE TABLE sc_rds_tbl_drqa (
    cd_drqa numeric(15,0) NOT NULL,
    cd_rqa numeric(10,0) NOT NULL,
    cd_opr numeric(10,0) NOT NULL,
    nm_ltr_drqa "char" NOT NULL,
    nr_cdl_drqa numeric(5,0) NOT NULL,
    vl_cdl_drqa numeric(13,2) NOT NULL,
    nr_ttl_cdl_drqa numeric(5,0) NOT NULL,
    nr_cdl_rjt_drqa numeric(5,0) DEFAULT 0 NOT NULL
);


ALTER TABLE sc_rds_tbl_drqa OWNER TO scan;

--
-- TOC entry 8902 (class 0 OID 0)
-- Dependencies: 936
-- Name: TABLE sc_rds_tbl_drqa; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON TABLE sc_rds_tbl_drqa IS 'TABELA DE DETALHE DA REQUISICAO DE OPERACAO DA INTEGRACAO';


--
-- TOC entry 935 (class 1259 OID 1085832)
-- Name: sc_rds_tbl_rqa; Type: TABLE; Schema: sc_exp; Owner: scan
--

CREATE TABLE sc_rds_tbl_rqa (
    cd_rqa numeric(10,0) NOT NULL,
    cd_atm numeric(5,0) NOT NULL,
    cd_pls numeric(16,0),
    ds_aca_rqa character varying(50) NOT NULL,
    cd_top numeric(10,0),
    cd_opr numeric(10,0),
    vl_sac_opr numeric(13,2),
    st_rqa numeric(5,0) NOT NULL,
    nsu_rqa numeric(10,0) NOT NULL,
    dt_rqa timestamp without time zone NOT NULL,
    xml_env_rqa text,
    xml_ret_rqa text,
    st_opr numeric(5,0)
);


ALTER TABLE sc_rds_tbl_rqa OWNER TO scan;

--
-- TOC entry 8903 (class 0 OID 0)
-- Dependencies: 935
-- Name: TABLE sc_rds_tbl_rqa; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON TABLE sc_rds_tbl_rqa IS 'TABELA DE REQUISICAO DE INTEGRACAO SAQCARD';


--
-- TOC entry 8904 (class 0 OID 0)
-- Dependencies: 935
-- Name: COLUMN sc_rds_tbl_rqa.cd_rqa; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_rds_tbl_rqa.cd_rqa IS 'codigo da requisicao';


--
-- TOC entry 8905 (class 0 OID 0)
-- Dependencies: 935
-- Name: COLUMN sc_rds_tbl_rqa.cd_atm; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_rds_tbl_rqa.cd_atm IS 'codigo do atm';


--
-- TOC entry 8906 (class 0 OID 0)
-- Dependencies: 935
-- Name: COLUMN sc_rds_tbl_rqa.cd_pls; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_rds_tbl_rqa.cd_pls IS 'codigo do plastico na saqcard';


--
-- TOC entry 8907 (class 0 OID 0)
-- Dependencies: 935
-- Name: COLUMN sc_rds_tbl_rqa.ds_aca_rqa; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_rds_tbl_rqa.ds_aca_rqa IS 'descricao da acao da requisicao';


--
-- TOC entry 8908 (class 0 OID 0)
-- Dependencies: 935
-- Name: COLUMN sc_rds_tbl_rqa.cd_top; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_rds_tbl_rqa.cd_top IS 'codigo do tipo de operacao';


--
-- TOC entry 8909 (class 0 OID 0)
-- Dependencies: 935
-- Name: COLUMN sc_rds_tbl_rqa.cd_opr; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_rds_tbl_rqa.cd_opr IS 'codigo da operacao na saqcard';


--
-- TOC entry 8910 (class 0 OID 0)
-- Dependencies: 935
-- Name: COLUMN sc_rds_tbl_rqa.vl_sac_opr; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_rds_tbl_rqa.vl_sac_opr IS 'valor sacado da operacao saqcard no atm da soma';


--
-- TOC entry 8911 (class 0 OID 0)
-- Dependencies: 935
-- Name: COLUMN sc_rds_tbl_rqa.st_rqa; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_rds_tbl_rqa.st_rqa IS 'situacao da requisicao (ver tabela de dominio)';


--
-- TOC entry 8912 (class 0 OID 0)
-- Dependencies: 935
-- Name: COLUMN sc_rds_tbl_rqa.nsu_rqa; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_rds_tbl_rqa.nsu_rqa IS 'codigo da nsu de origem da requisicao';


--
-- TOC entry 8913 (class 0 OID 0)
-- Dependencies: 935
-- Name: COLUMN sc_rds_tbl_rqa.dt_rqa; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_rds_tbl_rqa.dt_rqa IS 'data da requisicao';


--
-- TOC entry 8914 (class 0 OID 0)
-- Dependencies: 935
-- Name: COLUMN sc_rds_tbl_rqa.xml_env_rqa; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_rds_tbl_rqa.xml_env_rqa IS 'xml de envio ao autorizador saqcard';


--
-- TOC entry 8915 (class 0 OID 0)
-- Dependencies: 935
-- Name: COLUMN sc_rds_tbl_rqa.xml_ret_rqa; Type: COMMENT; Schema: sc_exp; Owner: scan
--

COMMENT ON COLUMN sc_rds_tbl_rqa.xml_ret_rqa IS 'xml de retorno do autorizador saqcard';


SET search_path = sc_fcr, pg_catalog;

--
-- TOC entry 456 (class 1259 OID 565508)
-- Name: sq_fcr; Type: SEQUENCE; Schema: sc_fcr; Owner: scan
--

CREATE SEQUENCE sq_fcr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_fcr OWNER TO scan;

--
-- TOC entry 457 (class 1259 OID 565510)
-- Name: sq_pfc; Type: SEQUENCE; Schema: sc_fcr; Owner: scan
--

CREATE SEQUENCE sq_pfc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE sq_pfc OWNER TO scan;

--
-- TOC entry 458 (class 1259 OID 565512)
-- Name: sq_prc; Type: SEQUENCE; Schema: sc_fcr; Owner: scan
--

CREATE SEQUENCE sq_prc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_prc OWNER TO scan;

--
-- TOC entry 459 (class 1259 OID 565514)
-- Name: sq_tfc; Type: SEQUENCE; Schema: sc_fcr; Owner: scan
--

CREATE SEQUENCE sq_tfc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tfc OWNER TO scan;

--
-- TOC entry 460 (class 1259 OID 565516)
-- Name: tbl_fcr; Type: TABLE; Schema: sc_fcr; Owner: scan
--

CREATE TABLE tbl_fcr (
    cd_fcr numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    vl_fcr numeric(13,2) NOT NULL,
    dt_vnc_fcr date NOT NULL,
    vl_sld_dvd_fcr numeric(13,2) NOT NULL,
    vl_ttl_pgt_fcr numeric(13,2) DEFAULT 0 NOT NULL,
    dt_ems_fcr timestamp without time zone NOT NULL,
    dt_ult_pgt_fcr date,
    st_fcr numeric(2,0) NOT NULL,
    nr_dia_atr_fcr numeric(5,0) NOT NULL,
    vl_jrs_fcr numeric(13,2),
    vl_trf_fcr numeric(13,2),
    vl_mlt_fcr numeric(13,2),
    vl_enc_ctr_fcr numeric(13,2) DEFAULT 0 NOT NULL,
    vl_mnm_fcr numeric(13,2) NOT NULL,
    vl_crd_fcr numeric(13,2) DEFAULT 0 NOT NULL,
    vl_rst_enc_fcr numeric(13,2),
    cd_ant_fcr numeric(10,0),
    dt_ctb_fcr timestamp without time zone,
    cd_blt numeric(10,0),
    dt_vnc_org_fcr date
);


ALTER TABLE tbl_fcr OWNER TO scan;

--
-- TOC entry 8916 (class 0 OID 0)
-- Dependencies: 460
-- Name: TABLE tbl_fcr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON TABLE tbl_fcr IS 'TABELA DE FATURA DE CARTAO EXCLUIDA';


--
-- TOC entry 8917 (class 0 OID 0)
-- Dependencies: 460
-- Name: COLUMN tbl_fcr.vl_jrs_fcr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_fcr.vl_jrs_fcr IS 'Valor cobrado de juros na fatura';


--
-- TOC entry 8918 (class 0 OID 0)
-- Dependencies: 460
-- Name: COLUMN tbl_fcr.vl_trf_fcr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_fcr.vl_trf_fcr IS 'Valor de Tarifa cobrado na fatura';


--
-- TOC entry 8919 (class 0 OID 0)
-- Dependencies: 460
-- Name: COLUMN tbl_fcr.vl_mlt_fcr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_fcr.vl_mlt_fcr IS 'Valor de multa cobrado na fatura';


--
-- TOC entry 8920 (class 0 OID 0)
-- Dependencies: 460
-- Name: COLUMN tbl_fcr.vl_enc_ctr_fcr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_fcr.vl_enc_ctr_fcr IS 'Valor de encargos contratuais';


--
-- TOC entry 8921 (class 0 OID 0)
-- Dependencies: 460
-- Name: COLUMN tbl_fcr.vl_mnm_fcr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_fcr.vl_mnm_fcr IS 'VALOR MINIMO DA FATURA';


--
-- TOC entry 8922 (class 0 OID 0)
-- Dependencies: 460
-- Name: COLUMN tbl_fcr.vl_crd_fcr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_fcr.vl_crd_fcr IS 'Valor de crédito para o proximo faturamento';


--
-- TOC entry 8923 (class 0 OID 0)
-- Dependencies: 460
-- Name: COLUMN tbl_fcr.vl_rst_enc_fcr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_fcr.vl_rst_enc_fcr IS 'Valor a restituir de encargos';


--
-- TOC entry 887 (class 1259 OID 989084)
-- Name: tbl_fcr_exc; Type: TABLE; Schema: sc_fcr; Owner: postgres
--

CREATE TABLE tbl_fcr_exc (
    cd_fcr numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    vl_fcr numeric(13,2) NOT NULL,
    dt_vnc_fcr date NOT NULL,
    vl_sld_dvd_fcr numeric(13,2) NOT NULL,
    vl_ttl_pgt_fcr numeric(13,2) DEFAULT 0 NOT NULL,
    dt_ems_fcr timestamp without time zone NOT NULL,
    dt_ult_pgt_fcr date,
    st_fcr numeric(2,0) NOT NULL,
    nr_dia_atr_fcr numeric(5,0) NOT NULL,
    vl_jrs_fcr numeric(13,2),
    vl_trf_fcr numeric(13,2),
    vl_mlt_fcr numeric(13,2),
    vl_enc_ctr_fcr numeric(13,2) DEFAULT 0 NOT NULL,
    vl_mnm_fcr numeric(13,2) NOT NULL,
    vl_crd_fcr numeric(13,2) DEFAULT 0 NOT NULL,
    vl_rst_enc_fcr numeric(13,2),
    cd_ant_fcr numeric(10,0),
    dt_ctb_fcr timestamp without time zone,
    cd_blt numeric(10,0),
    dt_vnc_org_fcr date,
    dt_exc_fcr timestamp without time zone NOT NULL,
    cd_usr_exc_fcr numeric(10,0) NOT NULL,
    mtv_exc_fcr character varying(400)
);


ALTER TABLE tbl_fcr_exc OWNER TO postgres;

--
-- TOC entry 461 (class 1259 OID 565522)
-- Name: tbl_fcr_tlt; Type: TABLE; Schema: sc_fcr; Owner: scan
--

CREATE TABLE tbl_fcr_tlt (
    cd_fcr numeric(10,0) NOT NULL,
    cd_tlt numeric(2,0) NOT NULL,
    vl_ttl_fcr_tlt numeric(13,2) NOT NULL,
    vl_rst_fcr_tlt numeric(13,2) NOT NULL
);


ALTER TABLE tbl_fcr_tlt OWNER TO scan;

--
-- TOC entry 8924 (class 0 OID 0)
-- Dependencies: 461
-- Name: TABLE tbl_fcr_tlt; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON TABLE tbl_fcr_tlt IS 'Tabela que relaciona fatura com tipo de limite';


--
-- TOC entry 8925 (class 0 OID 0)
-- Dependencies: 461
-- Name: COLUMN tbl_fcr_tlt.cd_fcr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_fcr_tlt.cd_fcr IS 'Codigo da fatura';


--
-- TOC entry 8926 (class 0 OID 0)
-- Dependencies: 461
-- Name: COLUMN tbl_fcr_tlt.cd_tlt; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_fcr_tlt.cd_tlt IS 'Codigo do tipo de limite';


--
-- TOC entry 8927 (class 0 OID 0)
-- Dependencies: 461
-- Name: COLUMN tbl_fcr_tlt.vl_ttl_fcr_tlt; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_fcr_tlt.vl_ttl_fcr_tlt IS 'Valor total do tipo de limite no fatura';


--
-- TOC entry 8928 (class 0 OID 0)
-- Dependencies: 461
-- Name: COLUMN tbl_fcr_tlt.vl_rst_fcr_tlt; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_fcr_tlt.vl_rst_fcr_tlt IS 'Valor a ser restituído do tipo de limite';


--
-- TOC entry 462 (class 1259 OID 565525)
-- Name: tbl_fcr_top; Type: TABLE; Schema: sc_fcr; Owner: scan
--

CREATE TABLE tbl_fcr_top (
    cd_fcr numeric(10,0) NOT NULL,
    cd_top numeric(5,0) NOT NULL,
    vl_ttl_fcr_top numeric(13,2) NOT NULL,
    vl_rst_fcr_top numeric(13,2) NOT NULL,
    vl_rct_fcr_top numeric(13,2) NOT NULL
);


ALTER TABLE tbl_fcr_top OWNER TO scan;

--
-- TOC entry 463 (class 1259 OID 565528)
-- Name: tbl_pfc; Type: TABLE; Schema: sc_fcr; Owner: scan
--

CREATE TABLE tbl_pfc (
    cd_pfc numeric(10,0) NOT NULL,
    cd_fcr numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    nr_dia_atr_pfc numeric(5,0) NOT NULL,
    dt_pgt_pfc date NOT NULL,
    dt_rcb_pfc date NOT NULL,
    vl_pfc numeric(13,2) NOT NULL,
    st_pfc numeric(2,0) NOT NULL,
    vl_rst_enc_pfc numeric(13,2) DEFAULT 0 NOT NULL,
    cnt_org_pfc numeric(10,0) NOT NULL,
    cd_tpc numeric(2,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    vl_pgt_rsc_pfc numeric(13,2),
    cd_cnc_usr numeric(10,0),
    dt_cnc_pfc date,
    vl_ttl_pgt_ccb_pfc numeric(13,2)
);


ALTER TABLE tbl_pfc OWNER TO scan;

--
-- TOC entry 8929 (class 0 OID 0)
-- Dependencies: 463
-- Name: TABLE tbl_pfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON TABLE tbl_pfc IS 'TABELA DE PAGAMENTO DE FATURA DE CARTAO';


--
-- TOC entry 8930 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.cd_pfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.cd_pfc IS 'codigo';


--
-- TOC entry 8931 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.cd_fcr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.cd_fcr IS 'codigo da fatura do cartao';


--
-- TOC entry 8932 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.cd_crt; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.cd_crt IS 'codigo do cartao';


--
-- TOC entry 8933 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.nr_dia_atr_pfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.nr_dia_atr_pfc IS 'numero de dias de atraso ate o pagamento';


--
-- TOC entry 8934 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.dt_pgt_pfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.dt_pgt_pfc IS 'data de referencia do pagamento';


--
-- TOC entry 8935 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.dt_rcb_pfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.dt_rcb_pfc IS 'data de recebimento do pagamento';


--
-- TOC entry 8936 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.vl_pfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.vl_pfc IS 'valor do pagamento';


--
-- TOC entry 8937 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.st_pfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.st_pfc IS 'situacao do pagamento';


--
-- TOC entry 8938 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.vl_rst_enc_pfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.vl_rst_enc_pfc IS 'Valor restituido de encargos';


--
-- TOC entry 8939 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.cnt_org_pfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.cnt_org_pfc IS 'conta de origem do pagamento';


--
-- TOC entry 8940 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.cd_tpc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.cd_tpc IS 'tipo de pagamento';


--
-- TOC entry 8941 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.cd_inc_usr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 8942 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.vl_pgt_rsc_pfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.vl_pgt_rsc_pfc IS 'Valor da baixa de rescisao';


--
-- TOC entry 8943 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.cd_cnc_usr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.cd_cnc_usr IS 'usuario de cancelamento do pagamento';


--
-- TOC entry 8944 (class 0 OID 0)
-- Dependencies: 463
-- Name: COLUMN tbl_pfc.dt_cnc_pfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc.dt_cnc_pfc IS 'data de cancelamento do pagamento';


--
-- TOC entry 464 (class 1259 OID 565532)
-- Name: tbl_pfc_prc; Type: TABLE; Schema: sc_fcr; Owner: scan
--

CREATE TABLE tbl_pfc_prc (
    cd_pfc numeric(10,0) NOT NULL,
    cd_prc numeric(10,0) NOT NULL,
    vl_pfc_prc numeric(13,2) NOT NULL,
    vl_prn_pfc_prc numeric(13,2),
    dt_ctb_pfc_prc timestamp without time zone
);


ALTER TABLE tbl_pfc_prc OWNER TO scan;

--
-- TOC entry 465 (class 1259 OID 565535)
-- Name: tbl_pfc_tlt; Type: TABLE; Schema: sc_fcr; Owner: scan
--

CREATE TABLE tbl_pfc_tlt (
    cd_pfc numeric(10,0) NOT NULL,
    cd_tlt numeric(2,0) NOT NULL,
    vl_pfc_tlt numeric(13,2)
);


ALTER TABLE tbl_pfc_tlt OWNER TO scan;

--
-- TOC entry 8945 (class 0 OID 0)
-- Dependencies: 465
-- Name: TABLE tbl_pfc_tlt; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON TABLE tbl_pfc_tlt IS 'Tabela que relaciona pagamento a tipo de limite';


--
-- TOC entry 8946 (class 0 OID 0)
-- Dependencies: 465
-- Name: COLUMN tbl_pfc_tlt.cd_pfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc_tlt.cd_pfc IS 'codigo do pagamento';


--
-- TOC entry 8947 (class 0 OID 0)
-- Dependencies: 465
-- Name: COLUMN tbl_pfc_tlt.cd_tlt; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc_tlt.cd_tlt IS 'Codigo do tipo de limite';


--
-- TOC entry 8948 (class 0 OID 0)
-- Dependencies: 465
-- Name: COLUMN tbl_pfc_tlt.vl_pfc_tlt; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_pfc_tlt.vl_pfc_tlt IS 'Valor restituido do tipo de limite';


--
-- TOC entry 466 (class 1259 OID 565538)
-- Name: tbl_prc; Type: TABLE; Schema: sc_fcr; Owner: scan
--

CREATE TABLE tbl_prc (
    cd_prc numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    cd_fcr numeric(10,0),
    vl_prc numeric(13,2) NOT NULL,
    fg_dcr_prc "char" NOT NULL,
    st_prc numeric(2,0) NOT NULL,
    cd_opr numeric(10,0) NOT NULL,
    dt_grc_prc timestamp without time zone NOT NULL,
    dt_vnc_prc date NOT NULL,
    ds_prc character varying(50) NOT NULL,
    nr_prc numeric(5,0),
    cd_fcr_atu_prc numeric(10,0),
    vl_pgt_prc numeric(13,2) DEFAULT 0 NOT NULL,
    CONSTRAINT ck_fg_dcr_prc CHECK ((fg_dcr_prc = ANY (ARRAY['D'::"char", 'C'::"char"])))
);


ALTER TABLE tbl_prc OWNER TO scan;

--
-- TOC entry 8949 (class 0 OID 0)
-- Dependencies: 466
-- Name: TABLE tbl_prc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON TABLE tbl_prc IS 'TABELA DE PARCELAS DAS FATURAS DE CARTAO';


--
-- TOC entry 467 (class 1259 OID 565543)
-- Name: tbl_tfc; Type: TABLE; Schema: sc_fcr; Owner: scan
--

CREATE TABLE tbl_tfc (
    cd_tfc numeric(10,0) NOT NULL,
    cd_ant_crt numeric(14,0) NOT NULL,
    cd_atl_crt numeric(14,0) NOT NULL,
    cd_fcr numeric(10,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_tfc OWNER TO scan;

--
-- TOC entry 8950 (class 0 OID 0)
-- Dependencies: 467
-- Name: TABLE tbl_tfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON TABLE tbl_tfc IS 'TABELA DE TRANSFERENCIA DE FATURA DE CARTAO';


--
-- TOC entry 8951 (class 0 OID 0)
-- Dependencies: 467
-- Name: COLUMN tbl_tfc.cd_tfc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_tfc.cd_tfc IS 'CODIGO';


--
-- TOC entry 8952 (class 0 OID 0)
-- Dependencies: 467
-- Name: COLUMN tbl_tfc.cd_ant_crt; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_tfc.cd_ant_crt IS 'CARTAO ANTERIOR';


--
-- TOC entry 8953 (class 0 OID 0)
-- Dependencies: 467
-- Name: COLUMN tbl_tfc.cd_atl_crt; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_tfc.cd_atl_crt IS 'CARTAO ATUAL';


--
-- TOC entry 8954 (class 0 OID 0)
-- Dependencies: 467
-- Name: COLUMN tbl_tfc.cd_inc_usr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_tfc.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 8955 (class 0 OID 0)
-- Dependencies: 467
-- Name: COLUMN tbl_tfc.dt_inc_usr; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_tfc.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 468 (class 1259 OID 565546)
-- Name: tbl_tpc; Type: TABLE; Schema: sc_fcr; Owner: scan
--

CREATE TABLE tbl_tpc (
    cd_tpc numeric(2,0) NOT NULL,
    ds_tpc character varying(40) NOT NULL,
    cd_tlc numeric(10,0) NOT NULL,
    fg_atv_tpc "char" NOT NULL,
    cd_cnt numeric(10,0),
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_tpc OWNER TO scan;

--
-- TOC entry 8956 (class 0 OID 0)
-- Dependencies: 468
-- Name: TABLE tbl_tpc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON TABLE tbl_tpc IS 'tabela de tipo de pagamento de fatura de cartao';


--
-- TOC entry 8957 (class 0 OID 0)
-- Dependencies: 468
-- Name: COLUMN tbl_tpc.cd_tpc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_tpc.cd_tpc IS 'codigo';


--
-- TOC entry 8958 (class 0 OID 0)
-- Dependencies: 468
-- Name: COLUMN tbl_tpc.ds_tpc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_tpc.ds_tpc IS 'descricao';


--
-- TOC entry 8959 (class 0 OID 0)
-- Dependencies: 468
-- Name: COLUMN tbl_tpc.cd_tlc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_tpc.cd_tlc IS 'codigo do tipo de lancamento';


--
-- TOC entry 8960 (class 0 OID 0)
-- Dependencies: 468
-- Name: COLUMN tbl_tpc.fg_atv_tpc; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_tpc.fg_atv_tpc IS 'flag de ativo';


--
-- TOC entry 8961 (class 0 OID 0)
-- Dependencies: 468
-- Name: COLUMN tbl_tpc.cd_cnt; Type: COMMENT; Schema: sc_fcr; Owner: scan
--

COMMENT ON COLUMN tbl_tpc.cd_cnt IS 'conta de origem do pagamento';


SET search_path = sc_opr, pg_catalog;

--
-- TOC entry 469 (class 1259 OID 565549)
-- Name: tbl_crt; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_crt (
    cd_crt numeric(14,0) NOT NULL,
    cd_fnc numeric(10,0) NOT NULL,
    fg_atv_crt "char" NOT NULL,
    fg_ind_crt "char" DEFAULT 'N'::"char" NOT NULL,
    dt_ini_atr_crt date,
    cd_inc_usr numeric(5,0) NOT NULL,
    cd_prd numeric(5,0),
    cd_ult_fcr numeric(10,0),
    dt_prx_vnc_crt date NOT NULL,
    cd_tvt numeric(5,0),
    dt_prx_apr_crt date NOT NULL,
    cd_fcr numeric(10,0),
    cd_ctr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone DEFAULT now() NOT NULL,
    dt_pri_dps_crt timestamp without time zone,
    dt_ult_dps_crt timestamp without time zone,
    dt_fim_atr_crt date,
    qtd_saq_crt numeric(5,0) DEFAULT 0,
    cd_cnt numeric(10,0) NOT NULL,
    qtd_abn_trf_crt numeric(1,0),
    cd_pcs numeric(10,0),
    dt_ads_pcs_crt timestamp without time zone,
    CONSTRAINT ck_fg_atv_crt CHECK ((fg_atv_crt = ANY (ARRAY['N'::"char", 'S'::"char"]))),
    CONSTRAINT ck_fg_ind_crt CHECK ((fg_ind_crt = ANY (ARRAY['N'::"char", 'S'::"char"])))
);


ALTER TABLE tbl_crt OWNER TO scan;

--
-- TOC entry 8962 (class 0 OID 0)
-- Dependencies: 469
-- Name: TABLE tbl_crt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_crt IS 'TABELA DE CARTAO EXCLUIDO';


--
-- TOC entry 8963 (class 0 OID 0)
-- Dependencies: 469
-- Name: COLUMN tbl_crt.dt_pri_dps_crt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_crt.dt_pri_dps_crt IS 'DATA DO PRIMEIRO DEPOSITO';


--
-- TOC entry 8964 (class 0 OID 0)
-- Dependencies: 469
-- Name: COLUMN tbl_crt.dt_ult_dps_crt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_crt.dt_ult_dps_crt IS 'DATA DO ULTIMO DEPOSITO';


--
-- TOC entry 8965 (class 0 OID 0)
-- Dependencies: 469
-- Name: COLUMN tbl_crt.dt_ads_pcs_crt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_crt.dt_ads_pcs_crt IS 'data da adesao ao pacote de servico';


SET search_path = sc_fcr, pg_catalog;

--
-- TOC entry 470 (class 1259 OID 565557)
-- Name: vw_pfc; Type: VIEW; Schema: sc_fcr; Owner: scan
--

CREATE VIEW vw_pfc AS
SELECT pfc.cd_pfc, crt.cd_crt, cun.nm_cun, emp.cd_emp, emp.nm_emp, fem.cd_fem, fem.nm_fem, pfc.vl_pfc, pfc.dt_pgt_pfc, pfc.dt_rcb_pfc, fcr.dt_vnc_fcr, to_char((fcr.dt_vnc_fcr)::timestamp with time zone, 'MM/YYYY'::text) AS mes_vnc_ref, to_char((pfc.dt_pgt_pfc)::timestamp with time zone, 'MM/YYYY'::text) AS mes_pgt_ref, to_char((pfc.dt_rcb_pfc)::timestamp with time zone, 'MM/YYYY'::text) AS mes_rcb_ref, grt.cd_grt, grt.nm_grt, gem.cd_gem, gem.nm_gem, tpc.ds_tpc, dmn.nm_vlr_dmn AS situacao, to_char((fcr.dt_vnc_fcr)::timestamp with time zone, 'YYYYMM'::text) AS mes_vnc_order, to_char((pfc.dt_pgt_pfc)::timestamp with time zone, 'YYYYMM'::text) AS mes_pgt_order, to_char((pfc.dt_rcb_pfc)::timestamp with time zone, 'YYYYMM'::text) AS mes_rcb_order FROM (((((((((((tbl_pfc pfc JOIN tbl_fcr fcr ON ((fcr.cd_fcr = pfc.cd_fcr))) JOIN tbl_tpc tpc ON ((tpc.cd_tpc = pfc.cd_tpc))) JOIN sc_opr.tbl_crt crt ON ((crt.cd_crt = pfc.cd_crt))) JOIN sc_cad.tbl_fnc fnc ON ((fnc.cd_fnc = crt.cd_fnc))) JOIN sc_cad.tbl_cun cun ON ((cun.cd_cun = fnc.cd_cun))) JOIN sc_cad.tbl_emp emp ON ((emp.cd_emp = fnc.cd_emp))) JOIN sc_cad.tbl_fem fem ON (((fem.cd_emp = emp.cd_emp) AND (fem.cd_fem = fnc.cd_fem)))) JOIN sc_cad.tbl_gem gem ON ((gem.cd_gem = emp.cd_gem))) JOIN sc_cad.tbl_ctr ctr ON ((ctr.cd_emp = emp.cd_emp))) JOIN sc_cad.tbl_dmn dmn ON (((pfc.st_pfc = dmn.vl_cmp_dmn) AND ((dmn.nm_cmp_dmn)::text = 'ST_PFC'::text)))) JOIN sc_cad.tbl_grt grt ON ((grt.cd_grt = ctr.cd_grt)));


ALTER TABLE vw_pfc OWNER TO scan;

SET search_path = sc_opr, pg_catalog;

--
-- TOC entry 471 (class 1259 OID 565562)
-- Name: tbl_opr; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_opr (
    cd_opr numeric(10,0) NOT NULL,
    cd_top numeric(5,0) NOT NULL,
    cd_pls numeric(16,0),
    cd_atm numeric(5,0),
    dt_opr timestamp without time zone NOT NULL,
    vl_opr numeric(13,2) NOT NULL,
    vl_jrs_opr numeric(13,2) NOT NULL,
    vl_trf_opr numeric(13,2) NOT NULL,
    nr_prc_opr numeric(2,0) NOT NULL,
    vl_prc_opr numeric(13,2) DEFAULT 0 NOT NULL,
    vl_iof_opr numeric(13,2) DEFAULT 0 NOT NULL,
    nr_nsu_org_opr numeric(10,0) NOT NULL,
    st_opr numeric(5,0) NOT NULL,
    st_saq_opr numeric(2,0),
    dt_prc_opr timestamp without time zone,
    cd_pai_opr numeric(10,0),
    tp_err_exp_opr numeric(2,0),
    cd_aeo numeric(10,0),
    cd_fet numeric(10,0),
    dt_ctb_opr timestamp without time zone,
    dt_pet_opr timestamp without time zone,
    vl_crd_opr numeric(13,2),
    vl_tx_adm_opr numeric(13,2)
);


ALTER TABLE tbl_opr OWNER TO scan;

--
-- TOC entry 8966 (class 0 OID 0)
-- Dependencies: 471
-- Name: TABLE tbl_opr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_opr IS 'TABELA DE OPERACAO';


--
-- TOC entry 8967 (class 0 OID 0)
-- Dependencies: 471
-- Name: COLUMN tbl_opr.st_saq_opr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_opr.st_saq_opr IS 'situacao da operacao de saque. ver tabela de dominio';


--
-- TOC entry 8968 (class 0 OID 0)
-- Dependencies: 471
-- Name: COLUMN tbl_opr.tp_err_exp_opr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_opr.tp_err_exp_opr IS 'tipo de erro de exportacao (ver tabela de dominio)';


--
-- TOC entry 8969 (class 0 OID 0)
-- Dependencies: 471
-- Name: COLUMN tbl_opr.cd_aeo; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_opr.cd_aeo IS 'codigo do arquivo de exportacao';


--
-- TOC entry 472 (class 1259 OID 565567)
-- Name: tbl_pls; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_pls (
    cd_pls numeric(16,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    dt_vld_pls date NOT NULL,
    nm_snh_pls character varying(40) NOT NULL,
    nm_pls character varying(30) NOT NULL,
    cd_inc_usr numeric(5,0) NOT NULL,
    cd_tbl numeric(5,0),
    fg_blq_pls character(1) DEFAULT 'N'::bpchar NOT NULL,
    nr_scc_pls character varying(3) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    nr_tnt_dsb_pls numeric(2,0) DEFAULT 0 NOT NULL,
    nr_err_snh_pls numeric(2,0),
    fg_ems_pls character(1) DEFAULT 'N'::bpchar NOT NULL,
    fg_ems_snh character(1) DEFAULT 'N'::bpchar NOT NULL,
    cd_mpl numeric(1,0) NOT NULL,
    dt_inc_usr timestamp without time zone DEFAULT now() NOT NULL,
    fg_prm_via character(1) DEFAULT 'S'::bpchar NOT NULL,
    fg_emt_pls character varying DEFAULT 'S'::character varying,
    nr_err_vld_sgr_pls numeric(2,0),
    CONSTRAINT ck_fg_blq_pls CHECK ((fg_blq_pls = ANY (ARRAY['N'::bpchar, 'S'::bpchar]))),
    CONSTRAINT ck_fg_ems_pls CHECK ((fg_ems_pls = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_pls OWNER TO scan;

--
-- TOC entry 8970 (class 0 OID 0)
-- Dependencies: 472
-- Name: TABLE tbl_pls; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_pls IS 'TABELA DE PLASTICO';


--
-- TOC entry 8971 (class 0 OID 0)
-- Dependencies: 472
-- Name: COLUMN tbl_pls.cd_cun; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_pls.cd_cun IS 'cadastro unico';


--
-- TOC entry 8972 (class 0 OID 0)
-- Dependencies: 472
-- Name: COLUMN tbl_pls.nr_tnt_dsb_pls; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_pls.nr_tnt_dsb_pls IS 'numero de tentativas de desbloqueio';


--
-- TOC entry 8973 (class 0 OID 0)
-- Dependencies: 472
-- Name: COLUMN tbl_pls.nr_err_snh_pls; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_pls.nr_err_snh_pls IS 'numero de erros consecutivos de senha';


--
-- TOC entry 8974 (class 0 OID 0)
-- Dependencies: 472
-- Name: COLUMN tbl_pls.fg_prm_via; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_pls.fg_prm_via IS 'Flag que indica se é o plástico é a primeira via do cartão.';


--
-- TOC entry 8975 (class 0 OID 0)
-- Dependencies: 472
-- Name: COLUMN tbl_pls.fg_emt_pls; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_pls.fg_emt_pls IS 'FLAG PRA SABER SE É PRA EMITIR O PLASTICO';


--
-- TOC entry 473 (class 1259 OID 565582)
-- Name: tbl_top; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_top (
    cd_top numeric(5,0) NOT NULL,
    nm_top character varying(50) NOT NULL,
    fg_atm_top character(1) DEFAULT 'S'::bpchar NOT NULL,
    fg_crd_top character(1) DEFAULT 'N'::bpchar NOT NULL,
    fg_abr_ctc_top character varying(1) NOT NULL,
    cd_cnt numeric(10,0),
    cd_tlc numeric(10,0),
    ord_pri_rst_top numeric(3,0),
    CONSTRAINT ck_fg_atm_top CHECK ((fg_atm_top = ANY (ARRAY['N'::bpchar, 'S'::bpchar]))),
    CONSTRAINT ck_fg_crd_top CHECK ((fg_crd_top = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_top OWNER TO scan;

--
-- TOC entry 8976 (class 0 OID 0)
-- Dependencies: 473
-- Name: TABLE tbl_top; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_top IS 'TABELA DE TIPO DE OPERACAO';


--
-- TOC entry 8977 (class 0 OID 0)
-- Dependencies: 473
-- Name: COLUMN tbl_top.fg_abr_ctc_top; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_top.fg_abr_ctc_top IS 'Flag que identifica se pode ou não abrir Contestação';


SET search_path = sc_fcr, pg_catalog;

--
-- TOC entry 474 (class 1259 OID 565589)
-- Name: vw_prc; Type: VIEW; Schema: sc_fcr; Owner: scan
--

CREATE VIEW vw_prc AS
SELECT prc.cd_prc, top.cd_top, crt.cd_crt, cun.nm_cun, grt.cd_grt, grt.nm_grt, ast.cd_ast, ast.nm_ast, gem.cd_gem, gem.nm_gem, emp.cd_emp, emp.nm_emp, fem.cd_fem, fem.nm_fem, prc.vl_prc, COALESCE(opr.vl_iof_opr, (0)::numeric) AS vl_iof_opr, COALESCE(opr.vl_jrs_opr, (0)::numeric) AS vl_jrs_opr, COALESCE(opr.vl_trf_opr, (0)::numeric) AS vl_trf_opr, top.nm_top, COALESCE(fcr.dt_vnc_fcr, prc.dt_vnc_prc) AS dt_vnc_prc, opr.dt_opr, to_char(opr.dt_opr, 'mm/yyyy'::text) AS mes_operacao, to_char(opr.dt_opr, 'yyyymm'::text) AS mes_operacao_order, to_char((COALESCE(fcr.dt_vnc_fcr, prc.dt_vnc_prc))::timestamp with time zone, 'mm/yyyy'::text) AS mes_vencimento, to_char((COALESCE(fcr.dt_vnc_fcr, prc.dt_vnc_prc))::timestamp with time zone, 'yyyymm'::text) AS mes_vencimento_order FROM (((((((((((((tbl_prc prc JOIN sc_opr.tbl_opr opr ON ((opr.cd_opr = prc.cd_opr))) JOIN sc_opr.tbl_top top ON ((top.cd_top = opr.cd_top))) LEFT JOIN tbl_fcr fcr ON ((fcr.cd_fcr = prc.cd_fcr))) JOIN sc_opr.tbl_pls pls ON ((pls.cd_pls = opr.cd_pls))) JOIN sc_opr.tbl_crt crt ON ((crt.cd_crt = pls.cd_crt))) JOIN sc_cad.tbl_fnc fnc ON ((fnc.cd_fnc = crt.cd_fnc))) JOIN sc_cad.tbl_cun cun ON ((cun.cd_cun = fnc.cd_cun))) JOIN sc_cad.tbl_emp emp ON ((emp.cd_emp = fnc.cd_emp))) JOIN sc_cad.tbl_gem gem ON ((gem.cd_gem = emp.cd_gem))) JOIN sc_cad.tbl_fem fem ON (((fem.cd_emp = fnc.cd_emp) AND (fem.cd_fem = fnc.cd_fem)))) JOIN sc_cad.tbl_ctr ctr ON ((ctr.cd_ctr = crt.cd_ctr))) LEFT JOIN sc_cad.tbl_ast ast ON ((ast.cd_ast = ctr.cd_ast))) JOIN sc_cad.tbl_grt grt ON ((grt.cd_grt = ctr.cd_grt))) WHERE (opr.st_opr = (2)::numeric);


ALTER TABLE vw_prc OWNER TO scan;

SET search_path = sc_fep, pg_catalog;

--
-- TOC entry 475 (class 1259 OID 565594)
-- Name: sq_apf; Type: SEQUENCE; Schema: sc_fep; Owner: scan
--

CREATE SEQUENCE sq_apf
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE sq_apf OWNER TO scan;

--
-- TOC entry 476 (class 1259 OID 565596)
-- Name: sq_fep; Type: SEQUENCE; Schema: sc_fep; Owner: scan
--

CREATE SEQUENCE sq_fep
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE sq_fep OWNER TO scan;

--
-- TOC entry 477 (class 1259 OID 565598)
-- Name: sq_fep_sfe; Type: SEQUENCE; Schema: sc_fep; Owner: scan
--

CREATE SEQUENCE sq_fep_sfe
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999
    CACHE 1;


ALTER TABLE sq_fep_sfe OWNER TO scan;

--
-- TOC entry 478 (class 1259 OID 565600)
-- Name: sq_pfe; Type: SEQUENCE; Schema: sc_fep; Owner: scan
--

CREATE SEQUENCE sq_pfe
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_pfe OWNER TO scan;

--
-- TOC entry 479 (class 1259 OID 565602)
-- Name: tbl_apf; Type: TABLE; Schema: sc_fep; Owner: scan
--

CREATE TABLE tbl_apf (
    cd_apf numeric(10,0) NOT NULL,
    cd_fep numeric(10,0) NOT NULL,
    dt_vnc_apf date NOT NULL,
    vl_apf numeric(13,2) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    vl_mlt_apf numeric(10,2),
    vl_jrs_apf numeric(10,2),
    dt_ctb_apf timestamp without time zone,
    vl_trf_apf numeric(13,2)
);


ALTER TABLE tbl_apf OWNER TO scan;

--
-- TOC entry 8978 (class 0 OID 0)
-- Dependencies: 479
-- Name: TABLE tbl_apf; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON TABLE tbl_apf IS 'tabela de auditoria de prorrogacao de fatura';


--
-- TOC entry 480 (class 1259 OID 565605)
-- Name: tbl_fep; Type: TABLE; Schema: sc_fep; Owner: scan
--

CREATE TABLE tbl_fep (
    cd_fep numeric(10,0) NOT NULL,
    cd_ctr numeric(10,0) NOT NULL,
    vl_fep numeric(13,2) NOT NULL,
    dt_vnc_fep date,
    st_fep numeric NOT NULL,
    vl_pgt_fep numeric(13,2),
    dt_grc_fep timestamp without time zone NOT NULL,
    mes_ref_fep character(7) NOT NULL,
    vl_nfs_fep numeric(13,2),
    fg_eml_env_fep character(1),
    dt_eml_env_fep timestamp without time zone,
    cd_cun numeric(10,0),
    dt_ctb_fep timestamp without time zone,
    dt_vnc_org_fep date,
    vl_org_fep numeric(13,2),
    cd_blt numeric(10,0),
    fg_vld_atr_fep character(1) NOT NULL,
    dt_fg_vld_atr_fep timestamp without time zone,
    cd_usr_fg_vld_atr_fep numeric(10,0)
);


ALTER TABLE tbl_fep OWNER TO scan;

--
-- TOC entry 8979 (class 0 OID 0)
-- Dependencies: 480
-- Name: TABLE tbl_fep; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON TABLE tbl_fep IS 'Tabela de fatura de empresa';


--
-- TOC entry 8980 (class 0 OID 0)
-- Dependencies: 480
-- Name: COLUMN tbl_fep.cd_fep; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep.cd_fep IS 'Codigo da fatura';


--
-- TOC entry 8981 (class 0 OID 0)
-- Dependencies: 480
-- Name: COLUMN tbl_fep.cd_ctr; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep.cd_ctr IS 'Codigo do contrato';


--
-- TOC entry 8982 (class 0 OID 0)
-- Dependencies: 480
-- Name: COLUMN tbl_fep.vl_fep; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep.vl_fep IS 'Valor da fatura';


--
-- TOC entry 8983 (class 0 OID 0)
-- Dependencies: 480
-- Name: COLUMN tbl_fep.dt_vnc_fep; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep.dt_vnc_fep IS 'Data de Vencimento da fatura';


--
-- TOC entry 8984 (class 0 OID 0)
-- Dependencies: 480
-- Name: COLUMN tbl_fep.st_fep; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep.st_fep IS 'Situacao da fatura';


--
-- TOC entry 8985 (class 0 OID 0)
-- Dependencies: 480
-- Name: COLUMN tbl_fep.vl_pgt_fep; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep.vl_pgt_fep IS 'Valor pago da fatura';


--
-- TOC entry 8986 (class 0 OID 0)
-- Dependencies: 480
-- Name: COLUMN tbl_fep.dt_grc_fep; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep.dt_grc_fep IS 'Data de geração da fatura';


--
-- TOC entry 8987 (class 0 OID 0)
-- Dependencies: 480
-- Name: COLUMN tbl_fep.mes_ref_fep; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep.mes_ref_fep IS 'MES DE REFERENCIA DA FATURA';


--
-- TOC entry 8988 (class 0 OID 0)
-- Dependencies: 480
-- Name: COLUMN tbl_fep.cd_cun; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep.cd_cun IS 'cadastro unico da pessoa juridica vinculada a nota fiscal gerada por esta fatura';


--
-- TOC entry 481 (class 1259 OID 565611)
-- Name: tbl_fep_sfe; Type: TABLE; Schema: sc_fep; Owner: scan
--

CREATE TABLE tbl_fep_sfe (
    cd_fep_sfe numeric(10,0) NOT NULL,
    cd_fep numeric(10,0),
    cd_sfe numeric(3,0) NOT NULL,
    vl_und_fep_sfe numeric(13,3) NOT NULL,
    qtd_fep_sfe numeric(5,0) NOT NULL,
    vl_ttl_fep_sfe numeric(13,3) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    cd_fem numeric(5,0),
    fg_dcr_fep_sfe character(1)
);


ALTER TABLE tbl_fep_sfe OWNER TO scan;

--
-- TOC entry 8989 (class 0 OID 0)
-- Dependencies: 481
-- Name: COLUMN tbl_fep_sfe.cd_fep; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep_sfe.cd_fep IS 'Codigo da fatura de empresa';


--
-- TOC entry 8990 (class 0 OID 0)
-- Dependencies: 481
-- Name: COLUMN tbl_fep_sfe.cd_sfe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep_sfe.cd_sfe IS 'Codigo do servico';


--
-- TOC entry 8991 (class 0 OID 0)
-- Dependencies: 481
-- Name: COLUMN tbl_fep_sfe.vl_und_fep_sfe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep_sfe.vl_und_fep_sfe IS 'Valor unitario do servico na fatura';


--
-- TOC entry 8992 (class 0 OID 0)
-- Dependencies: 481
-- Name: COLUMN tbl_fep_sfe.qtd_fep_sfe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep_sfe.qtd_fep_sfe IS 'Quantidade de servicos na fatura';


--
-- TOC entry 8993 (class 0 OID 0)
-- Dependencies: 481
-- Name: COLUMN tbl_fep_sfe.vl_ttl_fep_sfe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep_sfe.vl_ttl_fep_sfe IS 'Valor total cobrado do servico na fatura';


--
-- TOC entry 8994 (class 0 OID 0)
-- Dependencies: 481
-- Name: COLUMN tbl_fep_sfe.cd_emp; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep_sfe.cd_emp IS 'codigo da empresa';


--
-- TOC entry 8995 (class 0 OID 0)
-- Dependencies: 481
-- Name: COLUMN tbl_fep_sfe.cd_fem; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_fep_sfe.cd_fem IS 'codigo da filial de empresa';


--
-- TOC entry 482 (class 1259 OID 565614)
-- Name: tbl_pfe; Type: TABLE; Schema: sc_fep; Owner: scan
--

CREATE TABLE tbl_pfe (
    cd_pfe numeric(10,0) NOT NULL,
    cd_fep numeric(10,0) NOT NULL,
    dt_pgt_pfe timestamp without time zone NOT NULL,
    dt_rcb_pfe timestamp without time zone NOT NULL,
    st_pfe numeric(1,0) DEFAULT 1 NOT NULL,
    cd_tpe numeric(1,0) NOT NULL,
    vl_pfe numeric(13,2) NOT NULL,
    cnt_cd numeric(10,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL
);


ALTER TABLE tbl_pfe OWNER TO scan;

--
-- TOC entry 8996 (class 0 OID 0)
-- Dependencies: 482
-- Name: TABLE tbl_pfe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON TABLE tbl_pfe IS 'Tabela de pagamento de fatura de empresa';


--
-- TOC entry 8997 (class 0 OID 0)
-- Dependencies: 482
-- Name: COLUMN tbl_pfe.cd_pfe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.cd_pfe IS 'Codigo do pagamento';


--
-- TOC entry 8998 (class 0 OID 0)
-- Dependencies: 482
-- Name: COLUMN tbl_pfe.cd_fep; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.cd_fep IS 'Codigo da fatura';


--
-- TOC entry 8999 (class 0 OID 0)
-- Dependencies: 482
-- Name: COLUMN tbl_pfe.dt_pgt_pfe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.dt_pgt_pfe IS 'Data em que o pagamento foi realizado';


--
-- TOC entry 9000 (class 0 OID 0)
-- Dependencies: 482
-- Name: COLUMN tbl_pfe.dt_rcb_pfe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.dt_rcb_pfe IS 'Data em que o pagamento foi recebido';


--
-- TOC entry 9001 (class 0 OID 0)
-- Dependencies: 482
-- Name: COLUMN tbl_pfe.st_pfe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.st_pfe IS 'Situacao do pagamento';


--
-- TOC entry 9002 (class 0 OID 0)
-- Dependencies: 482
-- Name: COLUMN tbl_pfe.cd_tpe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.cd_tpe IS 'Tipo do pagamento. Ver tabela de dominio';


--
-- TOC entry 9003 (class 0 OID 0)
-- Dependencies: 482
-- Name: COLUMN tbl_pfe.vl_pfe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.vl_pfe IS 'Valor do pagamento';


--
-- TOC entry 9004 (class 0 OID 0)
-- Dependencies: 482
-- Name: COLUMN tbl_pfe.cnt_cd; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.cnt_cd IS 'Conta de origem do pagamento';


--
-- TOC entry 9005 (class 0 OID 0)
-- Dependencies: 482
-- Name: COLUMN tbl_pfe.cd_inc_usr; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_pfe.cd_inc_usr IS 'Codigo do usuario';


--
-- TOC entry 483 (class 1259 OID 565618)
-- Name: tbl_sfe; Type: TABLE; Schema: sc_fep; Owner: scan
--

CREATE TABLE tbl_sfe (
    cd_sfe numeric(3,0) NOT NULL,
    ds_sfe character varying(50) NOT NULL,
    fg_crd_dbt_sfe character(1) DEFAULT 'C'::bpchar NOT NULL,
    cd_tlc numeric(10,0),
    cd_cnt numeric(10,0)
);


ALTER TABLE tbl_sfe OWNER TO scan;

--
-- TOC entry 9006 (class 0 OID 0)
-- Dependencies: 483
-- Name: COLUMN tbl_sfe.cd_sfe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_sfe.cd_sfe IS 'Codigo do servico';


--
-- TOC entry 9007 (class 0 OID 0)
-- Dependencies: 483
-- Name: COLUMN tbl_sfe.ds_sfe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_sfe.ds_sfe IS 'Descricao do servico';


--
-- TOC entry 484 (class 1259 OID 565622)
-- Name: tbl_tpe; Type: TABLE; Schema: sc_fep; Owner: scan
--

CREATE TABLE tbl_tpe (
    cd_tpe numeric(10,0) NOT NULL,
    ds_tpe character varying(50) NOT NULL,
    cd_tlc numeric(10,0) NOT NULL,
    cd_cnt numeric(10,0)
);


ALTER TABLE tbl_tpe OWNER TO scan;

--
-- TOC entry 9008 (class 0 OID 0)
-- Dependencies: 484
-- Name: TABLE tbl_tpe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON TABLE tbl_tpe IS 'Tabela de tipo de pagamento de fatura de empresa';


--
-- TOC entry 9009 (class 0 OID 0)
-- Dependencies: 484
-- Name: COLUMN tbl_tpe.cd_tpe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_tpe.cd_tpe IS 'Codigo do tipo de pagamento';


--
-- TOC entry 9010 (class 0 OID 0)
-- Dependencies: 484
-- Name: COLUMN tbl_tpe.ds_tpe; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_tpe.ds_tpe IS 'Descricao do tipo de pagamento';


--
-- TOC entry 9011 (class 0 OID 0)
-- Dependencies: 484
-- Name: COLUMN tbl_tpe.cd_tlc; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_tpe.cd_tlc IS 'Codigo do tipo de lancamento';


--
-- TOC entry 9012 (class 0 OID 0)
-- Dependencies: 484
-- Name: COLUMN tbl_tpe.cd_cnt; Type: COMMENT; Schema: sc_fep; Owner: scan
--

COMMENT ON COLUMN tbl_tpe.cd_cnt IS 'Codigo da conta de debito';


SET search_path = sc_fin, pg_catalog;

--
-- TOC entry 485 (class 1259 OID 565625)
-- Name: sq_alr; Type: SEQUENCE; Schema: sc_fin; Owner: scan
--

CREATE SEQUENCE sq_alr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_alr OWNER TO scan;

--
-- TOC entry 486 (class 1259 OID 565627)
-- Name: sq_bla; Type: SEQUENCE; Schema: sc_fin; Owner: scan
--

CREATE SEQUENCE sq_bla
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_bla OWNER TO scan;

--
-- TOC entry 487 (class 1259 OID 565629)
-- Name: sq_ccr; Type: SEQUENCE; Schema: sc_fin; Owner: scan
--

CREATE SEQUENCE sq_ccr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ccr OWNER TO scan;

--
-- TOC entry 488 (class 1259 OID 565631)
-- Name: sq_did; Type: SEQUENCE; Schema: sc_fin; Owner: scan
--

CREATE SEQUENCE sq_did
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE sq_did OWNER TO scan;

--
-- TOC entry 489 (class 1259 OID 565633)
-- Name: sq_drr; Type: SEQUENCE; Schema: sc_fin; Owner: scan
--

CREATE SEQUENCE sq_drr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_drr OWNER TO scan;

--
-- TOC entry 490 (class 1259 OID 565635)
-- Name: sq_drr_hfe; Type: SEQUENCE; Schema: sc_fin; Owner: scan
--

CREATE SEQUENCE sq_drr_hfe
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_drr_hfe OWNER TO scan;

--
-- TOC entry 491 (class 1259 OID 565637)
-- Name: sq_hadr; Type: SEQUENCE; Schema: sc_fin; Owner: scan
--

CREATE SEQUENCE sq_hadr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hadr OWNER TO scan;

--
-- TOC entry 492 (class 1259 OID 565639)
-- Name: sq_idp; Type: SEQUENCE; Schema: sc_fin; Owner: scan
--

CREATE SEQUENCE sq_idp
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE sq_idp OWNER TO scan;

--
-- TOC entry 493 (class 1259 OID 565641)
-- Name: sq_rrc; Type: SEQUENCE; Schema: sc_fin; Owner: scan
--

CREATE SEQUENCE sq_rrc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rrc OWNER TO scan;

--
-- TOC entry 494 (class 1259 OID 565643)
-- Name: sq_tec; Type: SEQUENCE; Schema: sc_fin; Owner: scan
--

CREATE SEQUENCE sq_tec
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 99999999999999999
    CACHE 1;


ALTER TABLE sq_tec OWNER TO scan;

--
-- TOC entry 495 (class 1259 OID 565645)
-- Name: tbl_alr; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_alr (
    cd_alr numeric(10,0) NOT NULL,
    cd_rrc numeric(10,0) NOT NULL,
    qt_dias_alr numeric(3,0) NOT NULL,
    tx_dia_alr numeric(13,2) NOT NULL,
    vl_alr numeric(13,2) NOT NULL,
    vl_cbr_alr numeric(13,2) NOT NULL,
    st_alr numeric(2,0) NOT NULL,
    frm_cbr_alr numeric(2,0) NOT NULL,
    cd_cnt_dbt_alr numeric(10,0),
    cd_tlc numeric(10,0),
    cd_fep numeric(10,0),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_drr numeric(10,0) NOT NULL,
    cd_cnc_usr numeric(10,0),
    dt_cnc_alr timestamp without time zone,
    mtv_cnc_alr character varying(400)
);


ALTER TABLE tbl_alr OWNER TO scan;

--
-- TOC entry 9013 (class 0 OID 0)
-- Dependencies: 495
-- Name: TABLE tbl_alr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON TABLE tbl_alr IS 'ANTECIPACAO DE LIBERACAO DE RECURSO';


--
-- TOC entry 9014 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.cd_alr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.cd_alr IS 'CODIGO';


--
-- TOC entry 9015 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.cd_rrc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.cd_rrc IS 'RECEBIMENTO DE RECURSO';


--
-- TOC entry 9016 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.qt_dias_alr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.qt_dias_alr IS 'QUANTIDADES DE DIAS ANTECIPADOS';


--
-- TOC entry 9017 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.tx_dia_alr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.tx_dia_alr IS 'TAXA AO DIA';


--
-- TOC entry 9018 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.vl_alr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.vl_alr IS 'VALOR ANTECIPADO';


--
-- TOC entry 9019 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.vl_cbr_alr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.vl_cbr_alr IS 'VALOR COBRADO PELA ATENCIPACAO';


--
-- TOC entry 9020 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.st_alr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.st_alr IS 'SITUACAO';


--
-- TOC entry 9021 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.frm_cbr_alr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.frm_cbr_alr IS 'FORMA DE COBRANCA';


--
-- TOC entry 9022 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.cd_cnt_dbt_alr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.cd_cnt_dbt_alr IS 'CONTA DE DEBITO';


--
-- TOC entry 9023 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.cd_tlc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.cd_tlc IS 'TIPO DE LANCAMENTO';


--
-- TOC entry 9024 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.cd_fep; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.cd_fep IS 'FATURA';


--
-- TOC entry 9025 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.cd_inc_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9026 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.dt_inc_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9027 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.cd_alt_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 9028 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.dt_alt_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 9029 (class 0 OID 0)
-- Dependencies: 495
-- Name: COLUMN tbl_alr.cd_drr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_alr.cd_drr IS 'CODIGO DE DISTRIBUICAO DE RECEBIMENTO DE RECURSO';


--
-- TOC entry 496 (class 1259 OID 565648)
-- Name: tbl_bla; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_bla (
    cd_bla numeric(10,0) NOT NULL,
    tp_bla numeric(2,0) NOT NULL,
    st_bla numeric(2,0) NOT NULL,
    cd_emp numeric(10,0) NOT NULL,
    cd_fem numeric(10,0),
    vl_bla numeric(13,2) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    dt_pgt_bla timestamp without time zone,
    cd_blt numeric(10,0),
    dt_vnc_bla date,
    ds_inf_bla character varying(4000)
);


ALTER TABLE tbl_bla OWNER TO scan;

--
-- TOC entry 9030 (class 0 OID 0)
-- Dependencies: 496
-- Name: TABLE tbl_bla; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON TABLE tbl_bla IS 'TABELA DE BOLETO AVULSO';


--
-- TOC entry 9031 (class 0 OID 0)
-- Dependencies: 496
-- Name: COLUMN tbl_bla.cd_bla; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_bla.cd_bla IS 'codigo';


--
-- TOC entry 9032 (class 0 OID 0)
-- Dependencies: 496
-- Name: COLUMN tbl_bla.tp_bla; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_bla.tp_bla IS 'tipo';


--
-- TOC entry 9033 (class 0 OID 0)
-- Dependencies: 496
-- Name: COLUMN tbl_bla.st_bla; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_bla.st_bla IS 'situacao';


--
-- TOC entry 9034 (class 0 OID 0)
-- Dependencies: 496
-- Name: COLUMN tbl_bla.cd_emp; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_bla.cd_emp IS 'codigo da empresa';


--
-- TOC entry 9035 (class 0 OID 0)
-- Dependencies: 496
-- Name: COLUMN tbl_bla.cd_fem; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_bla.cd_fem IS 'codigo da filial da empresa';


--
-- TOC entry 9036 (class 0 OID 0)
-- Dependencies: 496
-- Name: COLUMN tbl_bla.vl_bla; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_bla.vl_bla IS 'valor';


--
-- TOC entry 9037 (class 0 OID 0)
-- Dependencies: 496
-- Name: COLUMN tbl_bla.dt_inc_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_bla.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 9038 (class 0 OID 0)
-- Dependencies: 496
-- Name: COLUMN tbl_bla.cd_alt_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_bla.cd_alt_usr IS 'codigo usuario de alteracao';


--
-- TOC entry 9039 (class 0 OID 0)
-- Dependencies: 496
-- Name: COLUMN tbl_bla.dt_alt_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_bla.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 9040 (class 0 OID 0)
-- Dependencies: 496
-- Name: COLUMN tbl_bla.dt_pgt_bla; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_bla.dt_pgt_bla IS 'Data do Pagamento do Boleto';


--
-- TOC entry 497 (class 1259 OID 565651)
-- Name: tbl_bnc; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_bnc (
    cd_bnc numeric(5,0) NOT NULL,
    nm_bnc character varying(40) NOT NULL,
    nm_rdz_bnc character varying(20) NOT NULL,
    fg_atv_bnc character varying(1) DEFAULT 'S'::character varying NOT NULL
);


ALTER TABLE tbl_bnc OWNER TO scan;

--
-- TOC entry 9041 (class 0 OID 0)
-- Dependencies: 497
-- Name: TABLE tbl_bnc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON TABLE tbl_bnc IS 'TABELA DE CONTAS NO BANCO';


--
-- TOC entry 498 (class 1259 OID 565655)
-- Name: tbl_did; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_did (
    cd_did numeric(10,0) NOT NULL,
    cd_idp numeric(10,0) NOT NULL,
    cd_emp numeric(10,0) NOT NULL,
    cd_cnt numeric(10,0) NOT NULL,
    vl_did numeric(13,2) NOT NULL,
    fg_atv_did character(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_ctr numeric(10,0) NOT NULL
);


ALTER TABLE tbl_did OWNER TO scan;

--
-- TOC entry 499 (class 1259 OID 565658)
-- Name: tbl_drr; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_drr (
    cd_drr numeric(10,0) NOT NULL,
    cd_rrc numeric(10,0) NOT NULL,
    cd_emp numeric(5,0) NOT NULL,
    cd_ctr numeric(10,0) NOT NULL,
    vl_drr numeric(13,2) NOT NULL,
    st_drr numeric(2,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_alt_usr numeric(10,0),
    vl_lbr_ant_drr numeric(13,2) NOT NULL,
    vl_lbr_prz_drr numeric(13,2) NOT NULL
);


ALTER TABLE tbl_drr OWNER TO scan;

--
-- TOC entry 9042 (class 0 OID 0)
-- Dependencies: 499
-- Name: TABLE tbl_drr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON TABLE tbl_drr IS 'tabela de distribuicao de recebimento de recurso';


--
-- TOC entry 9043 (class 0 OID 0)
-- Dependencies: 499
-- Name: COLUMN tbl_drr.cd_drr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr.cd_drr IS 'codigo';


--
-- TOC entry 9044 (class 0 OID 0)
-- Dependencies: 499
-- Name: COLUMN tbl_drr.cd_rrc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr.cd_rrc IS 'codigo do recebimento de recurso';


--
-- TOC entry 9045 (class 0 OID 0)
-- Dependencies: 499
-- Name: COLUMN tbl_drr.cd_emp; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr.cd_emp IS 'codigo da empresa';


--
-- TOC entry 9046 (class 0 OID 0)
-- Dependencies: 499
-- Name: COLUMN tbl_drr.cd_ctr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr.cd_ctr IS 'codigo do contrato';


--
-- TOC entry 9047 (class 0 OID 0)
-- Dependencies: 499
-- Name: COLUMN tbl_drr.vl_drr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr.vl_drr IS 'valor';


--
-- TOC entry 9048 (class 0 OID 0)
-- Dependencies: 499
-- Name: COLUMN tbl_drr.st_drr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr.st_drr IS 'situacao (ver tabela de dominio)';


--
-- TOC entry 9049 (class 0 OID 0)
-- Dependencies: 499
-- Name: COLUMN tbl_drr.dt_inc_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 9050 (class 0 OID 0)
-- Dependencies: 499
-- Name: COLUMN tbl_drr.cd_inc_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 9051 (class 0 OID 0)
-- Dependencies: 499
-- Name: COLUMN tbl_drr.dt_alt_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 9052 (class 0 OID 0)
-- Dependencies: 499
-- Name: COLUMN tbl_drr.cd_alt_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr.cd_alt_usr IS 'codigo do usuario de alteracao';


--
-- TOC entry 9053 (class 0 OID 0)
-- Dependencies: 499
-- Name: COLUMN tbl_drr.vl_lbr_ant_drr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr.vl_lbr_ant_drr IS 'VALOR LIBERADO POR ANTECIPACAO';


--
-- TOC entry 9054 (class 0 OID 0)
-- Dependencies: 499
-- Name: COLUMN tbl_drr.vl_lbr_prz_drr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr.vl_lbr_prz_drr IS 'VALOR LIBERADO POR TERMINO DE PRAZO DE BLOQUEIO';


--
-- TOC entry 500 (class 1259 OID 565661)
-- Name: tbl_drr_hfe; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_drr_hfe (
    cd_drr_hfe numeric(10,0) NOT NULL,
    cd_drr numeric(10,0) NOT NULL,
    cd_hfe numeric(10,0) NOT NULL,
    vl_drr_hfe numeric(13,2) NOT NULL,
    fg_rcs_drr_hfe character varying(1) DEFAULT 'N'::character varying NOT NULL
);


ALTER TABLE tbl_drr_hfe OWNER TO scan;

--
-- TOC entry 9055 (class 0 OID 0)
-- Dependencies: 500
-- Name: TABLE tbl_drr_hfe; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON TABLE tbl_drr_hfe IS 'tabela de relacionamento entre as distribuicoes de recebimento de recurso e os arquivos de deposito';


--
-- TOC entry 9056 (class 0 OID 0)
-- Dependencies: 500
-- Name: COLUMN tbl_drr_hfe.cd_drr_hfe; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr_hfe.cd_drr_hfe IS 'codigo';


--
-- TOC entry 9057 (class 0 OID 0)
-- Dependencies: 500
-- Name: COLUMN tbl_drr_hfe.cd_drr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr_hfe.cd_drr IS 'distribuicao de recurso';


--
-- TOC entry 9058 (class 0 OID 0)
-- Dependencies: 500
-- Name: COLUMN tbl_drr_hfe.cd_hfe; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr_hfe.cd_hfe IS 'arquivo de deposito';


--
-- TOC entry 9059 (class 0 OID 0)
-- Dependencies: 500
-- Name: COLUMN tbl_drr_hfe.vl_drr_hfe; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_drr_hfe.vl_drr_hfe IS 'valor liberado de saldo por conta do agendamento do arquivo';


--
-- TOC entry 501 (class 1259 OID 565665)
-- Name: tbl_hadr; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_hadr (
    cd_hadr numeric(10,0) NOT NULL,
    cd_drr numeric(10,0) NOT NULL,
    vl_ant_hadr numeric(13,2) NOT NULL,
    vl_atl_hadr numeric(13,2) NOT NULL,
    tp_hadr numeric(2,0) NOT NULL,
    ds_hadr character varying(100),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_hadr OWNER TO scan;

--
-- TOC entry 9060 (class 0 OID 0)
-- Dependencies: 501
-- Name: COLUMN tbl_hadr.cd_hadr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_hadr.cd_hadr IS 'CODIGO';


--
-- TOC entry 9061 (class 0 OID 0)
-- Dependencies: 501
-- Name: COLUMN tbl_hadr.cd_drr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_hadr.cd_drr IS 'CODIGO DA DISTRIBUICAO DE RECURSO QUE FOI ALTERADA';


--
-- TOC entry 9062 (class 0 OID 0)
-- Dependencies: 501
-- Name: COLUMN tbl_hadr.vl_ant_hadr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_hadr.vl_ant_hadr IS 'VALOR ANTERIOR';


--
-- TOC entry 9063 (class 0 OID 0)
-- Dependencies: 501
-- Name: COLUMN tbl_hadr.vl_atl_hadr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_hadr.vl_atl_hadr IS 'VALOR ATUAL';


--
-- TOC entry 9064 (class 0 OID 0)
-- Dependencies: 501
-- Name: COLUMN tbl_hadr.tp_hadr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_hadr.tp_hadr IS 'TIPO DE ALTERACAO (VER DOMINIO)';


--
-- TOC entry 9065 (class 0 OID 0)
-- Dependencies: 501
-- Name: COLUMN tbl_hadr.ds_hadr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_hadr.ds_hadr IS 'DESCRICAO DO HISTORICO';


--
-- TOC entry 9066 (class 0 OID 0)
-- Dependencies: 501
-- Name: COLUMN tbl_hadr.cd_inc_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_hadr.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9067 (class 0 OID 0)
-- Dependencies: 501
-- Name: COLUMN tbl_hadr.dt_inc_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_hadr.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 502 (class 1259 OID 565668)
-- Name: tbl_idp; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_idp (
    cd_idp numeric(10,0) NOT NULL,
    cd_ccr numeric(3,0) NOT NULL,
    dt_ref_idp date NOT NULL,
    vl_idp numeric(13,2) NOT NULL,
    prd_idp numeric(1,0) NOT NULL,
    nr_doc_idp character varying(20),
    nm_arq_idp character varying(40) NOT NULL,
    ctt_type_arq_idp character varying(40) NOT NULL,
    st_idp numeric(1,0) NOT NULL,
    tp_idp numeric(1,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_cnc_usr numeric(10,0),
    dt_cnc_idp timestamp without time zone,
    cd_prc_usr numeric(10,0),
    dt_prc_idp timestamp without time zone,
    mtv_rej_idp numeric(5,0),
    cd_rrc numeric(10,0),
    eml_idp character varying(100),
    fg_eml_env_idp character(1) DEFAULT 'N'::bpchar NOT NULL,
    dt_eml_env_idp timestamp without time zone,
    cd_hfe numeric(10,0)
);


ALTER TABLE tbl_idp OWNER TO scan;

--
-- TOC entry 9068 (class 0 OID 0)
-- Dependencies: 502
-- Name: TABLE tbl_idp; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON TABLE tbl_idp IS 'TABELA DE INFORME DE DEPOSITO E ENVIO DE COMPROVANTE DE DEPOSITO PELO SISTEMA DE EMPRESA';


--
-- TOC entry 503 (class 1259 OID 565672)
-- Name: tbl_rrc; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_rrc (
    cd_rrc numeric(10,0) NOT NULL,
    cd_emp_old numeric(5,0),
    cd_fem_old numeric(5,0),
    cd_cnt_crd numeric(10,0),
    cd_cnt_dbt numeric(10,0) NOT NULL,
    dt_ref_rrc timestamp without time zone NOT NULL,
    vl_rrc numeric(13,2) NOT NULL,
    st_rrc numeric(2,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_trc numeric(5,0),
    vl_lbr_rrc numeric(13,2),
    dt_prv_lbr_rrc timestamp without time zone,
    cd_gem numeric(5,0) NOT NULL,
    dt_fnz_rrc timestamp without time zone
);


ALTER TABLE tbl_rrc OWNER TO scan;

--
-- TOC entry 9069 (class 0 OID 0)
-- Dependencies: 503
-- Name: TABLE tbl_rrc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON TABLE tbl_rrc IS 'tabela de recebimento de recurso';


--
-- TOC entry 9070 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.cd_rrc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.cd_rrc IS 'codigo';


--
-- TOC entry 9071 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.cd_emp_old; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.cd_emp_old IS 'codigo da empresa (campo obsoleto, nao esta mais sendo utilizado)';


--
-- TOC entry 9072 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.cd_fem_old; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.cd_fem_old IS 'codigo da filial da empresa (campo obsoleto, nao esta mais sendo utilizado)';


--
-- TOC entry 9073 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.cd_cnt_crd; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.cd_cnt_crd IS 'codigo da conta de credito';


--
-- TOC entry 9074 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.cd_cnt_dbt; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.cd_cnt_dbt IS 'codigo da conta de debito';


--
-- TOC entry 9075 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.dt_ref_rrc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.dt_ref_rrc IS 'data de referencia';


--
-- TOC entry 9076 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.vl_rrc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.vl_rrc IS 'valor';


--
-- TOC entry 9077 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.st_rrc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.st_rrc IS 'situacao';


--
-- TOC entry 9078 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.cd_inc_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.cd_inc_usr IS 'usuario de inclusao';


--
-- TOC entry 9079 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.dt_inc_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 9080 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.cd_alt_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.cd_alt_usr IS 'usuario de alteracao';


--
-- TOC entry 9081 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.dt_alt_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 9082 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.cd_trc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.cd_trc IS 'codigo do tipo de recebimento';


--
-- TOC entry 9083 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.vl_lbr_rrc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.vl_lbr_rrc IS 'valor liberado';


--
-- TOC entry 9084 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.dt_prv_lbr_rrc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.dt_prv_lbr_rrc IS 'data prevista de liberacao';


--
-- TOC entry 9085 (class 0 OID 0)
-- Dependencies: 503
-- Name: COLUMN tbl_rrc.cd_gem; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_rrc.cd_gem IS 'codigo do grupo empresarial';


--
-- TOC entry 504 (class 1259 OID 565675)
-- Name: tbl_trc; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_trc (
    cd_trc numeric(5,0) NOT NULL,
    ds_trc character varying(100) NOT NULL,
    fg_atv_trc character varying(1) NOT NULL,
    qt_hrs_rrc_trc numeric(3,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_trc OWNER TO scan;

--
-- TOC entry 9086 (class 0 OID 0)
-- Dependencies: 504
-- Name: TABLE tbl_trc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON TABLE tbl_trc IS 'TIPO DE RECEBIMENTO DE RECURSO';


--
-- TOC entry 9087 (class 0 OID 0)
-- Dependencies: 504
-- Name: COLUMN tbl_trc.cd_trc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_trc.cd_trc IS 'CODIGO';


--
-- TOC entry 9088 (class 0 OID 0)
-- Dependencies: 504
-- Name: COLUMN tbl_trc.ds_trc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_trc.ds_trc IS 'DESCRICAO';


--
-- TOC entry 9089 (class 0 OID 0)
-- Dependencies: 504
-- Name: COLUMN tbl_trc.fg_atv_trc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_trc.fg_atv_trc IS 'FLAG ATIVO';


--
-- TOC entry 9090 (class 0 OID 0)
-- Dependencies: 504
-- Name: COLUMN tbl_trc.qt_hrs_rrc_trc; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_trc.qt_hrs_rrc_trc IS 'QUANTIDADE DE HORAS';


--
-- TOC entry 9091 (class 0 OID 0)
-- Dependencies: 504
-- Name: COLUMN tbl_trc.cd_inc_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_trc.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9092 (class 0 OID 0)
-- Dependencies: 504
-- Name: COLUMN tbl_trc.dt_inc_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_trc.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9093 (class 0 OID 0)
-- Dependencies: 504
-- Name: COLUMN tbl_trc.cd_alt_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_trc.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 9094 (class 0 OID 0)
-- Dependencies: 504
-- Name: COLUMN tbl_trc.dt_alt_usr; Type: COMMENT; Schema: sc_fin; Owner: scan
--

COMMENT ON COLUMN tbl_trc.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 505 (class 1259 OID 565678)
-- Name: tbl_ttc; Type: TABLE; Schema: sc_fin; Owner: scan
--

CREATE TABLE tbl_ttc (
    cd_ttc numeric(5,0) NOT NULL,
    nm_ttc character varying(40) NOT NULL,
    rot_prc_ttc character varying,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    fg_sis_emp_ttc character(1) NOT NULL,
    cd_tlc numeric(10,0)
);


ALTER TABLE tbl_ttc OWNER TO scan;

--
-- TOC entry 506 (class 1259 OID 565684)
-- Name: vw_ccr; Type: VIEW; Schema: sc_fin; Owner: scan
--

CREATE VIEW vw_ccr AS
SELECT cnt.cd_cnt AS conta, ccr.cd_ccr AS codigo, cnt.nm_cnt AS nome FROM (tbl_ccr ccr JOIN sc_cnt.tbl_cnt cnt ON ((cnt.cd_cnt = ccr.cd_cnt))) WHERE ((ccr.fg_atv_ccr)::text = 'S'::text);


ALTER TABLE vw_ccr OWNER TO scan;

SET search_path = sc_fsc, pg_catalog;

--
-- TOC entry 507 (class 1259 OID 565689)
-- Name: sq_isr; Type: SEQUENCE; Schema: sc_fsc; Owner: scan
--

CREATE SEQUENCE sq_isr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_isr OWNER TO scan;

--
-- TOC entry 508 (class 1259 OID 565691)
-- Name: sq_lcm; Type: SEQUENCE; Schema: sc_fsc; Owner: scan
--

CREATE SEQUENCE sq_lcm
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_lcm OWNER TO scan;

--
-- TOC entry 509 (class 1259 OID 565693)
-- Name: sq_lte; Type: SEQUENCE; Schema: sc_fsc; Owner: scan
--

CREATE SEQUENCE sq_lte
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_lte OWNER TO scan;

--
-- TOC entry 510 (class 1259 OID 565695)
-- Name: sq_nrl; Type: SEQUENCE; Schema: sc_fsc; Owner: scan
--

CREATE SEQUENCE sq_nrl
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_nrl OWNER TO scan;

--
-- TOC entry 511 (class 1259 OID 565697)
-- Name: sq_rps; Type: SEQUENCE; Schema: sc_fsc; Owner: scan
--

CREATE SEQUENCE sq_rps
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rps OWNER TO scan;

--
-- TOC entry 512 (class 1259 OID 565699)
-- Name: sq_srv; Type: SEQUENCE; Schema: sc_fsc; Owner: scan
--

CREATE SEQUENCE sq_srv
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_srv OWNER TO scan;

--
-- TOC entry 513 (class 1259 OID 565701)
-- Name: tbl_cnae; Type: TABLE; Schema: sc_fsc; Owner: scan
--

CREATE TABLE tbl_cnae (
    cd_cnae numeric(10,0) NOT NULL,
    ds_cnae character varying(200) NOT NULL,
    alq_cnae numeric(2,1) NOT NULL,
    fg_srv_cnae character varying(1) NOT NULL,
    cd_itm_lst_cnae numeric(4,0) NOT NULL,
    fg_trb_cnae character varying(1) NOT NULL,
    lcl_inc_cnae numeric(2,0) NOT NULL,
    fg_sbs_trb_cnae character varying(1) NOT NULL,
    rgm_esp_cnae numeric(2,0),
    CONSTRAINT ck_sbs_trb_cnae CHECK (((fg_sbs_trb_cnae)::text = ANY (ARRAY[('N'::"char")::text, ('S'::"char")::text]))),
    CONSTRAINT ck_srv_cnae CHECK (((fg_srv_cnae)::text = ANY (ARRAY[('N'::"char")::text, ('S'::"char")::text]))),
    CONSTRAINT ck_trb_cnae CHECK (((fg_trb_cnae)::text = ANY (ARRAY[('N'::"char")::text, ('S'::"char")::text])))
);


ALTER TABLE tbl_cnae OWNER TO scan;

--
-- TOC entry 9095 (class 0 OID 0)
-- Dependencies: 513
-- Name: TABLE tbl_cnae; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON TABLE tbl_cnae IS 'TABELA DE CNAE';


--
-- TOC entry 9096 (class 0 OID 0)
-- Dependencies: 513
-- Name: COLUMN tbl_cnae.cd_cnae; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_cnae.cd_cnae IS 'código';


--
-- TOC entry 9097 (class 0 OID 0)
-- Dependencies: 513
-- Name: COLUMN tbl_cnae.ds_cnae; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_cnae.ds_cnae IS 'Descrição';


--
-- TOC entry 9098 (class 0 OID 0)
-- Dependencies: 513
-- Name: COLUMN tbl_cnae.alq_cnae; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_cnae.alq_cnae IS 'Alíquota';


--
-- TOC entry 9099 (class 0 OID 0)
-- Dependencies: 513
-- Name: COLUMN tbl_cnae.fg_srv_cnae; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_cnae.fg_srv_cnae IS 'Flag de serviço';


--
-- TOC entry 9100 (class 0 OID 0)
-- Dependencies: 513
-- Name: COLUMN tbl_cnae.cd_itm_lst_cnae; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_cnae.cd_itm_lst_cnae IS 'Ítem da lista';


--
-- TOC entry 9101 (class 0 OID 0)
-- Dependencies: 513
-- Name: COLUMN tbl_cnae.fg_trb_cnae; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_cnae.fg_trb_cnae IS 'Tributável';


--
-- TOC entry 9102 (class 0 OID 0)
-- Dependencies: 513
-- Name: COLUMN tbl_cnae.lcl_inc_cnae; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_cnae.lcl_inc_cnae IS 'Local de incidência, ver domínio';


--
-- TOC entry 9103 (class 0 OID 0)
-- Dependencies: 513
-- Name: COLUMN tbl_cnae.fg_sbs_trb_cnae; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_cnae.fg_sbs_trb_cnae IS 'Substituição Tributária';


--
-- TOC entry 9104 (class 0 OID 0)
-- Dependencies: 513
-- Name: COLUMN tbl_cnae.rgm_esp_cnae; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_cnae.rgm_esp_cnae IS 'Regime Especial, ver domínio';


--
-- TOC entry 514 (class 1259 OID 565707)
-- Name: tbl_dec; Type: TABLE; Schema: sc_fsc; Owner: scan
--

CREATE TABLE tbl_dec (
    cd_obr_dec numeric(15,0) NOT NULL,
    art_dec numeric(15,0) NOT NULL
);


ALTER TABLE tbl_dec OWNER TO scan;

--
-- TOC entry 9105 (class 0 OID 0)
-- Dependencies: 514
-- Name: TABLE tbl_dec; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON TABLE tbl_dec IS 'TABELA DE DETALHAMENTO ESPECÍFICO DA CONTRUÇÃO CIVIL';


--
-- TOC entry 9106 (class 0 OID 0)
-- Dependencies: 514
-- Name: COLUMN tbl_dec.cd_obr_dec; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_dec.cd_obr_dec IS 'Numero da matricula CEI da obra ou da empresa';


--
-- TOC entry 9107 (class 0 OID 0)
-- Dependencies: 514
-- Name: COLUMN tbl_dec.art_dec; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_dec.art_dec IS 'Numero da ART';


--
-- TOC entry 515 (class 1259 OID 565710)
-- Name: tbl_ibge; Type: TABLE; Schema: sc_fsc; Owner: scan
--

CREATE TABLE tbl_ibge (
    cd_ibge numeric(10,0) NOT NULL,
    nm_ibge character varying(80) NOT NULL,
    uf_ibge character varying(2) NOT NULL,
    cep_ini_ibge numeric(8,0) NOT NULL,
    cep_fnl_ibge numeric(8,0) NOT NULL
);


ALTER TABLE tbl_ibge OWNER TO scan;

--
-- TOC entry 9108 (class 0 OID 0)
-- Dependencies: 515
-- Name: TABLE tbl_ibge; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON TABLE tbl_ibge IS 'TABELA DE IBGE';


--
-- TOC entry 9109 (class 0 OID 0)
-- Dependencies: 515
-- Name: COLUMN tbl_ibge.cd_ibge; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_ibge.cd_ibge IS 'código';


--
-- TOC entry 9110 (class 0 OID 0)
-- Dependencies: 515
-- Name: COLUMN tbl_ibge.nm_ibge; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_ibge.nm_ibge IS 'nome';


--
-- TOC entry 9111 (class 0 OID 0)
-- Dependencies: 515
-- Name: COLUMN tbl_ibge.uf_ibge; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_ibge.uf_ibge IS 'uf';


--
-- TOC entry 9112 (class 0 OID 0)
-- Dependencies: 515
-- Name: COLUMN tbl_ibge.cep_ini_ibge; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_ibge.cep_ini_ibge IS 'cep inicial';


--
-- TOC entry 9113 (class 0 OID 0)
-- Dependencies: 515
-- Name: COLUMN tbl_ibge.cep_fnl_ibge; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_ibge.cep_fnl_ibge IS 'cep final';


--
-- TOC entry 516 (class 1259 OID 565713)
-- Name: tbl_isr; Type: TABLE; Schema: sc_fsc; Owner: scan
--

CREATE TABLE tbl_isr (
    cd_isr numeric(10,0) NOT NULL,
    cnpj_isr numeric(14,0),
    ins_isr numeric(15,0),
    rz_scl_cnpj character varying(115)
);


ALTER TABLE tbl_isr OWNER TO scan;

--
-- TOC entry 9114 (class 0 OID 0)
-- Dependencies: 516
-- Name: TABLE tbl_isr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON TABLE tbl_isr IS 'TABELA IDENTIFICAÇÃO DO INTERMEDIÁRIO DO SERVIÇO';


--
-- TOC entry 9115 (class 0 OID 0)
-- Dependencies: 516
-- Name: COLUMN tbl_isr.cd_isr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_isr.cd_isr IS 'Código';


--
-- TOC entry 9116 (class 0 OID 0)
-- Dependencies: 516
-- Name: COLUMN tbl_isr.cnpj_isr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_isr.cnpj_isr IS 'CNPJ';


--
-- TOC entry 9117 (class 0 OID 0)
-- Dependencies: 516
-- Name: COLUMN tbl_isr.ins_isr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_isr.ins_isr IS 'Inscrição Municipal';


--
-- TOC entry 9118 (class 0 OID 0)
-- Dependencies: 516
-- Name: COLUMN tbl_isr.rz_scl_cnpj; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_isr.rz_scl_cnpj IS 'Nome ou Razão social';


--
-- TOC entry 517 (class 1259 OID 565716)
-- Name: tbl_lcm; Type: TABLE; Schema: sc_fsc; Owner: scan
--

CREATE TABLE tbl_lcm (
    cd_lcm numeric(10,0) NOT NULL,
    tp_lcm numeric(2,0) NOT NULL,
    nsu_lcm numeric(10,0) NOT NULL,
    env_lcm character varying NOT NULL,
    rcb_lcm character varying
);


ALTER TABLE tbl_lcm OWNER TO scan;

--
-- TOC entry 9119 (class 0 OID 0)
-- Dependencies: 517
-- Name: TABLE tbl_lcm; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON TABLE tbl_lcm IS 'TABELA DE LOG DE COMUNICAÇÃO';


--
-- TOC entry 9120 (class 0 OID 0)
-- Dependencies: 517
-- Name: COLUMN tbl_lcm.cd_lcm; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_lcm.cd_lcm IS 'código';


--
-- TOC entry 9121 (class 0 OID 0)
-- Dependencies: 517
-- Name: COLUMN tbl_lcm.tp_lcm; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_lcm.tp_lcm IS 'tipo';


--
-- TOC entry 9122 (class 0 OID 0)
-- Dependencies: 517
-- Name: COLUMN tbl_lcm.nsu_lcm; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_lcm.nsu_lcm IS 'nsu';


--
-- TOC entry 9123 (class 0 OID 0)
-- Dependencies: 517
-- Name: COLUMN tbl_lcm.env_lcm; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_lcm.env_lcm IS 'envio';


--
-- TOC entry 9124 (class 0 OID 0)
-- Dependencies: 517
-- Name: COLUMN tbl_lcm.rcb_lcm; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_lcm.rcb_lcm IS 'recebimento';


--
-- TOC entry 518 (class 1259 OID 565722)
-- Name: tbl_lte; Type: TABLE; Schema: sc_fsc; Owner: scan
--

CREATE TABLE tbl_lte (
    cd_lte numeric(10,0) NOT NULL,
    st_lte numeric(1,0) NOT NULL,
    prt_lte numeric(50,0),
    dt_inc timestamp without time zone NOT NULL,
    fg_sbs_lte character varying(1) NOT NULL
);


ALTER TABLE tbl_lte OWNER TO scan;

--
-- TOC entry 9125 (class 0 OID 0)
-- Dependencies: 518
-- Name: TABLE tbl_lte; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON TABLE tbl_lte IS 'TABELA DE LOTE';


--
-- TOC entry 9126 (class 0 OID 0)
-- Dependencies: 518
-- Name: COLUMN tbl_lte.cd_lte; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_lte.cd_lte IS 'código';


--
-- TOC entry 9127 (class 0 OID 0)
-- Dependencies: 518
-- Name: COLUMN tbl_lte.st_lte; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_lte.st_lte IS 'Situação, ver domínio';


--
-- TOC entry 9128 (class 0 OID 0)
-- Dependencies: 518
-- Name: COLUMN tbl_lte.prt_lte; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_lte.prt_lte IS 'Protocolo';


--
-- TOC entry 9129 (class 0 OID 0)
-- Dependencies: 518
-- Name: COLUMN tbl_lte.dt_inc; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_lte.dt_inc IS 'Data de Inclusão';


--
-- TOC entry 9130 (class 0 OID 0)
-- Dependencies: 518
-- Name: COLUMN tbl_lte.fg_sbs_lte; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_lte.fg_sbs_lte IS 'Flag de substituição';


--
-- TOC entry 519 (class 1259 OID 565725)
-- Name: tbl_org_grd; Type: TABLE; Schema: sc_fsc; Owner: scan
--

CREATE TABLE tbl_org_grd (
    cd_mnc_grd numeric(7,0) NOT NULL,
    uf_mnc_grd character varying(2) NOT NULL
);


ALTER TABLE tbl_org_grd OWNER TO scan;

--
-- TOC entry 9131 (class 0 OID 0)
-- Dependencies: 519
-- Name: TABLE tbl_org_grd; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON TABLE tbl_org_grd IS 'TABELA IDENTIFICAÇÃO DO ORGÃO GERADOR';


--
-- TOC entry 9132 (class 0 OID 0)
-- Dependencies: 519
-- Name: COLUMN tbl_org_grd.cd_mnc_grd; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_org_grd.cd_mnc_grd IS 'Código do município gerador';


--
-- TOC entry 9133 (class 0 OID 0)
-- Dependencies: 519
-- Name: COLUMN tbl_org_grd.uf_mnc_grd; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_org_grd.uf_mnc_grd IS 'UF do município gerador';


--
-- TOC entry 520 (class 1259 OID 565728)
-- Name: tbl_psr; Type: TABLE; Schema: sc_fsc; Owner: scan
--

CREATE TABLE tbl_psr (
    cnpj_psr numeric(14,0) NOT NULL,
    ins_psr numeric(15,0),
    rz_scl_psr character varying(115) NOT NULL,
    nm_fnt_psr character varying(60),
    end_psr character varying(125) NOT NULL,
    nr_end_psr numeric(5,0) NOT NULL,
    cmp_end_psr character varying(60),
    brr_end_psr character varying(60) NOT NULL,
    cdd_end_psr numeric(7,0) NOT NULL,
    uf_end_psr character varying(2) NOT NULL,
    cep_end_psr numeric(8,0) NOT NULL,
    eml_psr character varying(80),
    tlf_psr numeric(11,0)
);


ALTER TABLE tbl_psr OWNER TO scan;

--
-- TOC entry 9134 (class 0 OID 0)
-- Dependencies: 520
-- Name: TABLE tbl_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON TABLE tbl_psr IS 'TABELA IDENTIFICAÇÃO DO PRESTADOR DE SERVIÇO';


--
-- TOC entry 9135 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.cnpj_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.cnpj_psr IS 'CNPJ';


--
-- TOC entry 9136 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.ins_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.ins_psr IS 'Inscrição municipal';


--
-- TOC entry 9137 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.rz_scl_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.rz_scl_psr IS 'Razão social';


--
-- TOC entry 9138 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.nm_fnt_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.nm_fnt_psr IS 'Nome fantasia';


--
-- TOC entry 9139 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.end_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.end_psr IS 'Endereço';


--
-- TOC entry 9140 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.nr_end_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.nr_end_psr IS 'Número';


--
-- TOC entry 9141 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.cmp_end_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.cmp_end_psr IS 'Complemento';


--
-- TOC entry 9142 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.brr_end_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.brr_end_psr IS 'Bairro';


--
-- TOC entry 9143 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.cdd_end_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.cdd_end_psr IS 'Cidade';


--
-- TOC entry 9144 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.uf_end_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.uf_end_psr IS 'UF';


--
-- TOC entry 9145 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.cep_end_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.cep_end_psr IS 'CEP';


--
-- TOC entry 9146 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.eml_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.eml_psr IS 'Email';


--
-- TOC entry 9147 (class 0 OID 0)
-- Dependencies: 520
-- Name: COLUMN tbl_psr.tlf_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_psr.tlf_psr IS 'Telefone';


--
-- TOC entry 521 (class 1259 OID 565734)
-- Name: tbl_rps; Type: TABLE; Schema: sc_fsc; Owner: scan
--

CREATE TABLE tbl_rps (
    cd_rps numeric(10,0) NOT NULL,
    nsu_org_rps numeric(10,0) NOT NULL,
    tp_org_rps numeric(3,0) NOT NULL,
    nr_nfse numeric(10,0),
    cd_vrf_nfse numeric(10,0),
    nr_rps numeric(15,0) NOT NULL,
    dt_cmp_rps date,
    cd_lte numeric(10,0) NOT NULL,
    cd_srv numeric(10,0) NOT NULL,
    ntr_opr_nfse numeric(2,0) NOT NULL,
    rgm_esp_trb_nfse numeric(2,0),
    opt_smp_ncn_nfse numeric(1,0) NOT NULL,
    inc_clt_rps numeric(1,0) NOT NULL,
    sre_rps character varying(5) NOT NULL,
    tp_rps_nfse numeric(1,0) NOT NULL,
    dt_ems_rps timestamp without time zone NOT NULL,
    stt_rps numeric(1,0) NOT NULL,
    nr_rps_sbt numeric(15,0),
    sre_rps_sbt character varying(5),
    fg_sbt_rps character varying(1) NOT NULL,
    fg_atv_rps character varying(1) NOT NULL
);


ALTER TABLE tbl_rps OWNER TO scan;

--
-- TOC entry 9148 (class 0 OID 0)
-- Dependencies: 521
-- Name: TABLE tbl_rps; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON TABLE tbl_rps IS 'TABELA DE RPS (RECIBO PROVISÓRIO DE SERVIÇO)';


--
-- TOC entry 9149 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.cd_rps; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.cd_rps IS 'Código';


--
-- TOC entry 9150 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.nsu_org_rps; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.nsu_org_rps IS 'NSU de origem.';


--
-- TOC entry 9151 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.tp_org_rps; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.tp_org_rps IS 'Tipo de origem.';


--
-- TOC entry 9152 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.nr_nfse; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.nr_nfse IS 'Número da NFSE.';


--
-- TOC entry 9153 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.cd_vrf_nfse; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.cd_vrf_nfse IS 'Código de verificação da NFSE.';


--
-- TOC entry 9154 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.nr_rps; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.nr_rps IS 'Número do RPS.';


--
-- TOC entry 9155 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.cd_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.cd_srv IS 'Código da Prestação de Serviços';


--
-- TOC entry 9156 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.ntr_opr_nfse; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.ntr_opr_nfse IS 'Natureza da operação, verificar domínio.';


--
-- TOC entry 9157 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.rgm_esp_trb_nfse; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.rgm_esp_trb_nfse IS 'Regime especial tributacao, verificar domínio';


--
-- TOC entry 9158 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.opt_smp_ncn_nfse; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.opt_smp_ncn_nfse IS 'Optante simples Nacional. 1 – Sim;  2 – Não';


--
-- TOC entry 9159 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.inc_clt_rps; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.inc_clt_rps IS 'Incentivador cultural, 1 = SIM; 2 = NÃO.';


--
-- TOC entry 9160 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.sre_rps; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.sre_rps IS 'Número do equipamento emissor do RPS ou série do RPS. ';


--
-- TOC entry 9161 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.tp_rps_nfse; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.tp_rps_nfse IS 'Tipo de RPS, ver domínio.';


--
-- TOC entry 9162 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.dt_ems_rps; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.dt_ems_rps IS 'Data da emissão do RPS (AAAA-MM-DD).';


--
-- TOC entry 9163 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.stt_rps; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.stt_rps IS 'Status do RPS. 1 – Normal; 2 – Cancelado';


--
-- TOC entry 9164 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.nr_rps_sbt; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.nr_rps_sbt IS 'Número do RPS substituído.';


--
-- TOC entry 9165 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.sre_rps_sbt; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.sre_rps_sbt IS 'Número do equipamento emissor do RPS ou série do RPS substituído.';


--
-- TOC entry 9166 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.fg_sbt_rps; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.fg_sbt_rps IS 'Flag de substituição.';


--
-- TOC entry 9167 (class 0 OID 0)
-- Dependencies: 521
-- Name: COLUMN tbl_rps.fg_atv_rps; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_rps.fg_atv_rps IS 'Flag de ativo.';


--
-- TOC entry 522 (class 1259 OID 565737)
-- Name: tbl_srv; Type: TABLE; Schema: sc_fsc; Owner: scan
--

CREATE TABLE tbl_srv (
    cd_srv numeric(10,0) NOT NULL,
    cnpj_psr numeric(14,0) NOT NULL,
    cpj_tsr numeric(14,0) NOT NULL,
    vlr_srv numeric(15,2) NOT NULL,
    vlr_ddc_srv numeric(15,2),
    vlr_pis_srv numeric(15,2),
    vlr_cofins_srv numeric(15,2),
    vlr_inss_srv numeric(15,2),
    vlr_ir_srv numeric(15,2),
    vlr_csll_srv numeric(15,2),
    cd_itm_lst_cnae numeric(4,0) NOT NULL,
    cd_cnae numeric(10,0),
    cd_trb_mnc_srv numeric(20,0),
    vlr_bs_clc_srv numeric(15,2),
    alq_srv numeric(5,2),
    vlr_iss_srv numeric(15,2),
    vlr_lqd_nfse_srv numeric(15,2),
    otr_rtn_srv numeric(15,2),
    vlr_crd_srv numeric(15,2),
    iss_rtd_srv numeric(1,0) NOT NULL,
    vlr_iss_rtd_srv numeric(15,2),
    vlr_dsc_inc_srv numeric(15,2),
    vlr_dsc_cnd_srv numeric(15,2),
    dsc_srv character varying(2000) NOT NULL,
    mnc_srv numeric(7,0) NOT NULL
);


ALTER TABLE tbl_srv OWNER TO scan;

--
-- TOC entry 9168 (class 0 OID 0)
-- Dependencies: 522
-- Name: TABLE tbl_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON TABLE tbl_srv IS 'TABELA DE PRESTAÇÃO DE SERVIÇOS';


--
-- TOC entry 9169 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.cd_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.cd_srv IS 'código';


--
-- TOC entry 9170 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.cnpj_psr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.cnpj_psr IS 'Número do cnpj do prestador do serviço';


--
-- TOC entry 9171 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.cpj_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.cpj_tsr IS 'Número do cpf/cnpj do tomador do serviço';


--
-- TOC entry 9172 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.vlr_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.vlr_srv IS 'Valor dos serviços em R$.';


--
-- TOC entry 9173 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.vlr_ddc_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.vlr_ddc_srv IS 'Valor das deduções para Redução da Base de Cálculo em R$.';


--
-- TOC entry 9174 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.vlr_cofins_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.vlr_cofins_srv IS 'Valor da retenção do COFINS em R$. Informação declaratória.';


--
-- TOC entry 9175 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.vlr_inss_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.vlr_inss_srv IS 'Valor da retenção do INSS em R$. Informação declaratória.';


--
-- TOC entry 9176 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.vlr_ir_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.vlr_ir_srv IS 'Valor da retenção do IR em R$. Informação declaratória.';


--
-- TOC entry 9177 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.vlr_csll_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.vlr_csll_srv IS 'Valor da retenção do CSLL em R$. Informação declaratória.';


--
-- TOC entry 9178 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.cd_itm_lst_cnae; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.cd_itm_lst_cnae IS 'Código do serviço prestado. Item da LC 116/2003.';


--
-- TOC entry 9179 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.cd_cnae; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.cd_cnae IS 'CNAE 2.0.';


--
-- TOC entry 9180 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.cd_trb_mnc_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.cd_trb_mnc_srv IS 'Código do serviço prestado próprio do município.';


--
-- TOC entry 9181 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.vlr_bs_clc_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.vlr_bs_clc_srv IS 'Valor da base de cálculo: (Valor dos serviços - Valor das deduções – descontos incondicionados).';


--
-- TOC entry 9182 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.alq_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.alq_srv IS 'Alíquota do serviço prestado.';


--
-- TOC entry 9183 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.vlr_iss_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.vlr_iss_srv IS 'Valor do ISS em R$.';


--
-- TOC entry 9184 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.vlr_lqd_nfse_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.vlr_lqd_nfse_srv IS 'Valor líquido da nfse: (ValorServicos - ValorPIS - ValorCOFINS - ValorINSS - ValorIR - ValorCSLL - OutrasRetençoes - ValorISSRetido -  DescontoIncondicionado -  DescontoCondicionado)';


--
-- TOC entry 9185 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.otr_rtn_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.otr_rtn_srv IS 'Outras retenções na Fonte. Informação Declaratória';


--
-- TOC entry 9186 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.iss_rtd_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.iss_rtd_srv IS 'ISS Retido: 1 - Sim  2 – Não';


--
-- TOC entry 9187 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.vlr_iss_rtd_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.vlr_iss_rtd_srv IS 'Valor do ISS a ser retido.';


--
-- TOC entry 9188 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.vlr_dsc_inc_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.vlr_dsc_inc_srv IS 'Valor do desconto incondicionado';


--
-- TOC entry 9189 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.vlr_dsc_cnd_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.vlr_dsc_cnd_srv IS 'Valor do desconto condicionado';


--
-- TOC entry 9190 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.dsc_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.dsc_srv IS 'Discriminação dos serviços prestados';


--
-- TOC entry 9191 (class 0 OID 0)
-- Dependencies: 522
-- Name: COLUMN tbl_srv.mnc_srv; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_srv.mnc_srv IS 'Código do município onde o serviço foi prestado (tabela do IBGE), se exterior colocar 9999999';


--
-- TOC entry 523 (class 1259 OID 565743)
-- Name: tbl_tsr; Type: TABLE; Schema: sc_fsc; Owner: scan
--

CREATE TABLE tbl_tsr (
    cpj_tsr numeric(14,0) NOT NULL,
    ind_cpj numeric(1,0) NOT NULL,
    ins_tsr numeric(15,0),
    rz_scl_tsr character varying(115),
    nm_fnt_tsr character varying(60),
    end_tsr character varying(125),
    nr_end_tsr numeric(5,0),
    cmp_end_tsr character varying(60),
    brr_end_tsr character varying(60),
    cdd_end_tsr numeric(7,0),
    uf_end_tsr character varying(2),
    cep_end_tsr numeric(8,0),
    eml_tsr character varying(80),
    tlf_tsr numeric(11,0)
);


ALTER TABLE tbl_tsr OWNER TO scan;

--
-- TOC entry 9192 (class 0 OID 0)
-- Dependencies: 523
-- Name: TABLE tbl_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON TABLE tbl_tsr IS 'TABELA IDENTIFICAÇÃO DO TOMADOR DO SERVIÇO';


--
-- TOC entry 9193 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.cpj_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.cpj_tsr IS 'CPF/CNPJ';


--
-- TOC entry 9194 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.ind_cpj; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.ind_cpj IS 'Indicador CPF/CNPJ: 1 = CNPJ, 2 = CPF, 3 = Não Informado';


--
-- TOC entry 9195 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.ins_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.ins_tsr IS 'Inscrição municipal';


--
-- TOC entry 9196 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.rz_scl_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.rz_scl_tsr IS 'Razão social';


--
-- TOC entry 9197 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.nm_fnt_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.nm_fnt_tsr IS 'Nome fantasia';


--
-- TOC entry 9198 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.end_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.end_tsr IS 'Endereço';


--
-- TOC entry 9199 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.nr_end_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.nr_end_tsr IS 'Número';


--
-- TOC entry 9200 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.cmp_end_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.cmp_end_tsr IS 'Complemento';


--
-- TOC entry 9201 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.brr_end_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.brr_end_tsr IS 'Bairro';


--
-- TOC entry 9202 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.cdd_end_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.cdd_end_tsr IS 'Cidade';


--
-- TOC entry 9203 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.uf_end_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.uf_end_tsr IS 'UF';


--
-- TOC entry 9204 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.cep_end_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.cep_end_tsr IS 'CEP';


--
-- TOC entry 9205 (class 0 OID 0)
-- Dependencies: 523
-- Name: COLUMN tbl_tsr.eml_tsr; Type: COMMENT; Schema: sc_fsc; Owner: scan
--

COMMENT ON COLUMN tbl_tsr.eml_tsr IS 'Email';


SET search_path = sc_grl, pg_catalog;

--
-- TOC entry 524 (class 1259 OID 565749)
-- Name: tbl_msg; Type: TABLE; Schema: sc_grl; Owner: scan
--

CREATE TABLE tbl_msg (
    cd_msg character varying(50) NOT NULL,
    tp_pjt_msg numeric(5,0) NOT NULL,
    nm_msg character varying(400) NOT NULL,
    fg_atv_msg character(1) NOT NULL
);


ALTER TABLE tbl_msg OWNER TO scan;

SET search_path = sc_hlt, pg_catalog;

--
-- TOC entry 796 (class 1259 OID 873244)
-- Name: sq_ahl; Type: SEQUENCE; Schema: sc_hlt; Owner: scan
--

CREATE SEQUENCE sq_ahl
    START WITH 10
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ahl OWNER TO scan;

--
-- TOC entry 797 (class 1259 OID 873246)
-- Name: sq_dhl; Type: SEQUENCE; Schema: sc_hlt; Owner: scan
--

CREATE SEQUENCE sq_dhl
    START WITH 358
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dhl OWNER TO scan;

--
-- TOC entry 798 (class 1259 OID 873248)
-- Name: sq_dhl_arq; Type: SEQUENCE; Schema: sc_hlt; Owner: scan
--

CREATE SEQUENCE sq_dhl_arq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dhl_arq OWNER TO scan;

--
-- TOC entry 799 (class 1259 OID 873250)
-- Name: sq_hlt; Type: SEQUENCE; Schema: sc_hlt; Owner: scan
--

CREATE SEQUENCE sq_hlt
    START WITH 73
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hlt OWNER TO scan;

--
-- TOC entry 800 (class 1259 OID 873252)
-- Name: sq_hlt_arq; Type: SEQUENCE; Schema: sc_hlt; Owner: scan
--

CREATE SEQUENCE sq_hlt_arq
    START WITH 73
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hlt_arq OWNER TO scan;

--
-- TOC entry 801 (class 1259 OID 873254)
-- Name: tbl_ahl; Type: TABLE; Schema: sc_hlt; Owner: scan
--

CREATE TABLE tbl_ahl (
    cd_ahl numeric(10,0) NOT NULL,
    cnpj_ahl numeric(14,0) NOT NULL,
    dt_grc_ahl timestamp without time zone NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    nm_emp_ahl character varying(30),
    st_ahl numeric(1,0) DEFAULT 1 NOT NULL,
    cd_cun numeric(10,0)
);


ALTER TABLE tbl_ahl OWNER TO scan;

--
-- TOC entry 802 (class 1259 OID 873260)
-- Name: tbl_dhl; Type: TABLE; Schema: sc_hlt; Owner: scan
--

CREATE TABLE tbl_dhl (
    cd_dhl numeric(10,0) NOT NULL,
    ds_dhl character varying(30) NOT NULL,
    vl_dhl numeric(13,2) NOT NULL,
    fg_dcr_dhl character(1) NOT NULL,
    cd_hlt numeric(10,0) NOT NULL
);


ALTER TABLE tbl_dhl OWNER TO scan;

--
-- TOC entry 803 (class 1259 OID 873265)
-- Name: tbl_dhl_arq; Type: TABLE; Schema: sc_hlt; Owner: scan
--

CREATE TABLE tbl_dhl_arq (
    cd_dhl_arq numeric(10,0) NOT NULL,
    cd_hlt numeric(10,0) NOT NULL,
    ds1_dhl_arq character varying(30),
    vl1_dhl_arq numeric(13,2),
    ds2_dhl_arq character varying(30),
    vl2_dhl_arq numeric(13,2),
    ds3_dhl_arq character varying(30),
    vl3_dhl_arq numeric(13,2),
    ds4_dhl_arq character varying(30),
    vl4_dhl_arq numeric(13,2)
);


ALTER TABLE tbl_dhl_arq OWNER TO scan;

--
-- TOC entry 804 (class 1259 OID 873271)
-- Name: tbl_hlt; Type: TABLE; Schema: sc_hlt; Owner: scan
--

CREATE TABLE tbl_hlt (
    cd_hlt numeric(10,0) NOT NULL,
    cd_ahl numeric(10,0) NOT NULL,
    vl_prv_pgt_hlt numeric(13,2),
    dt_pgt_hlt timestamp without time zone,
    vl_eft_pgt_hlt numeric(13,2),
    nr_cpf_hlt numeric(11,0),
    cd_cun numeric(10,0),
    cd_fnc_hlt numeric(15,0),
    mes_hlt character varying(6) NOT NULL,
    crg_hlt character varying(30) NOT NULL,
    vl_sal_hlt numeric(13,2),
    vl_fgts_hlt numeric(13,2),
    vl_dbt_hlt numeric(13,2),
    vl_crd_hlt numeric(13,2),
    vl_bse_ir_hlt numeric(13,2),
    vl_bse_fgts_hlt numeric(13,2),
    st_hlt numeric(1,0) DEFAULT 1 NOT NULL,
    cnpj_emp_hlt numeric(14,0),
    nm_emp_hlt character varying(80),
    nm_fnc_hlt character varying(100)
);


ALTER TABLE tbl_hlt OWNER TO scan;

--
-- TOC entry 805 (class 1259 OID 873277)
-- Name: tbl_hlt_arq; Type: TABLE; Schema: sc_hlt; Owner: scan
--

CREATE TABLE tbl_hlt_arq (
    cd_hlt_arq numeric(10,0) NOT NULL,
    cd_hlt numeric(10,0) NOT NULL,
    nr_cpf_hlt_arq numeric(11,0),
    dt_pgt_hlt_arq timestamp without time zone NOT NULL,
    nm_fnc_hlt_arq character varying(30)
);


ALTER TABLE tbl_hlt_arq OWNER TO scan;

SET search_path = sc_ind, pg_catalog;

--
-- TOC entry 525 (class 1259 OID 565752)
-- Name: tbl_alt_ind; Type: TABLE; Schema: sc_ind; Owner: scan
--

CREATE TABLE tbl_alt_ind (
    cd_alt_ind numeric(10,0) NOT NULL,
    cd_emp numeric(10,0) NOT NULL,
    dt_alt_ind timestamp without time zone NOT NULL
);


ALTER TABLE tbl_alt_ind OWNER TO scan;

--
-- TOC entry 526 (class 1259 OID 565755)
-- Name: tbl_ind; Type: TABLE; Schema: sc_ind; Owner: scan
--

CREATE TABLE tbl_ind (
    cd_fcr numeric(10,0) NOT NULL,
    cd_grt numeric(10,0) NOT NULL,
    nm_grt character varying(80),
    cd_ast numeric(10,0),
    nm_ast character varying(80),
    cd_emp numeric(10,0) NOT NULL,
    nm_emp character varying(80) NOT NULL,
    cd_fem numeric(10,0) NOT NULL,
    nm_fem character varying(80) NOT NULL,
    cd_gem numeric(10,0) NOT NULL,
    nm_gem character varying(80) NOT NULL,
    vl_ttl_opr numeric(13,2),
    vl_pcp_ttl_opr numeric(13,2),
    vl_sld_dvd_fcr numeric(13,2),
    vl_pcp_ind numeric(13,2),
    dt_vnc_fcr date NOT NULL,
    mes_ref character(7) NOT NULL,
    nm_cun character varying(100) NOT NULL,
    cd_crt numeric(14,0) NOT NULL
);


ALTER TABLE tbl_ind OWNER TO scan;

--
-- TOC entry 527 (class 1259 OID 565761)
-- Name: vw_ind; Type: VIEW; Schema: sc_ind; Owner: scan
--

CREATE VIEW vw_ind AS
SELECT i.cd_crt AS cartao, i.nm_cun AS nm_cartao, CASE WHEN (CASE WHEN (i.vl_pcp_ttl_opr > (0)::numeric) THEN CASE WHEN (i.vl_pcp_ind > i.vl_pcp_ttl_opr) THEN i.vl_pcp_ttl_opr ELSE i.vl_pcp_ind END ELSE (0)::numeric END > (0)::numeric) THEN 1 ELSE 0 END AS fg_sld_dvd, ('now'::text)::date AS dt_ini_atraso, 0 AS dias_atraso, i.cd_grt AS cd_gerente, i.nm_grt AS nm_gerente, i.cd_ast AS cd_assistente, i.nm_ast AS nm_assistente, i.cd_emp AS cd_empresa, i.nm_emp AS nm_empresa, i.cd_fem AS cd_filial, i.nm_fem AS nm_filial, i.cd_gem AS cd_grupo_emp, i.nm_gem AS nm_grupo_emp, i.vl_sld_dvd_fcr AS saldo_devedor, i.vl_pcp_ind AS valor_principal_ind, i.vl_pcp_ttl_opr AS valor_principal_total, i.vl_ttl_opr AS valor_total, i.dt_vnc_fcr AS dt_vencimento, i.mes_ref, to_char((i.dt_vnc_fcr)::timestamp with time zone, 'yyyymm'::text) AS mes_ref_order, fcr.vl_sld_dvd_fcr AS saldo_dvd_atual FROM ((tbl_ind i JOIN sc_opr.tbl_crt crt ON ((crt.cd_crt = i.cd_crt))) JOIN sc_fcr.tbl_fcr fcr ON ((fcr.cd_fcr = crt.cd_fcr))) WHERE (i.dt_vnc_fcr < ('now'::text)::date);


ALTER TABLE vw_ind OWNER TO scan;

--
-- TOC entry 528 (class 1259 OID 565766)
-- Name: vw_indOld; Type: VIEW; Schema: sc_ind; Owner: scan
--

CREATE VIEW "vw_indOld" AS
SELECT crt.cd_crt AS cartao, ((crt.cd_crt || ' - '::text) || (cun.nm_cun)::text) AS nm_cartao, CASE WHEN (CASE WHEN (se.vl_se > (0)::numeric) THEN CASE WHEN (tlt.principal_ind > se.vl_se) THEN se.vl_se ELSE tlt.principal_ind END ELSE (0)::numeric END > (0)::numeric) THEN 1 ELSE 0 END AS fg_sld_dvd, ('now'::text)::date AS dt_ini_atraso, 0 AS dias_atraso, grt.cd_grt AS cd_gerente, grt.nm_grt AS nm_gerente, ast.cd_ast AS cd_assistente, ast.nm_ast AS nm_assistente, emp.cd_emp AS cd_empresa, emp.nm_emp AS nm_empresa, fem.cd_fem AS cd_filial, fem.nm_fem AS nm_filial, gem.cd_gem AS cd_grupo_emp, gem.nm_gem AS nm_grupo_emp, se.vl_total AS valor_total, se.vl_se AS valor_principal_total, CASE WHEN (fcr.vl_sld_dvd_fcr > se.vl_total) THEN se.vl_total ELSE fcr.vl_sld_dvd_fcr END AS saldo_devedor, CASE WHEN (se.vl_se > (0)::numeric) THEN CASE WHEN (tlt.principal_ind > se.vl_se) THEN se.vl_se ELSE tlt.principal_ind END ELSE (0)::numeric END AS valor_principal_ind, fcr.dt_vnc_fcr AS dt_vencimento, to_char((fcr.dt_vnc_fcr)::timestamp with time zone, 'mm/yyyy'::text) AS mes_ref, to_char((fcr.dt_vnc_fcr)::timestamp with time zone, 'yyyymm'::text) AS mes_ref_order FROM (((((((((((sc_fcr.tbl_fcr fcr JOIN sc_opr.tbl_crt crt ON ((fcr.cd_crt = crt.cd_crt))) LEFT JOIN (SELECT fcr_tlt.cd_fcr, sum(fcr_tlt.vl_rst_fcr_tlt) AS principal_ind, sum(fcr_tlt.vl_ttl_fcr_tlt) AS principal_total FROM sc_fcr.tbl_fcr_tlt fcr_tlt WHERE (fcr_tlt.cd_tlt = (1)::numeric) GROUP BY fcr_tlt.cd_fcr) tlt ON ((tlt.cd_fcr = fcr.cd_fcr))) JOIN sc_cad.tbl_ctr ctr ON ((ctr.cd_ctr = crt.cd_ctr))) JOIN sc_cad.tbl_grt grt ON ((grt.cd_grt = ctr.cd_grt))) LEFT JOIN sc_cad.tbl_ast ast ON ((ast.cd_ast = ctr.cd_ast))) JOIN sc_cad.tbl_fnc fnc ON ((fnc.cd_fnc = crt.cd_fnc))) JOIN sc_cad.tbl_cun cun ON ((cun.cd_cun = fnc.cd_cun))) JOIN sc_cad.tbl_emp emp ON ((emp.cd_emp = fnc.cd_emp))) JOIN sc_cad.tbl_fem fem ON (((fem.cd_emp = fnc.cd_emp) AND (fem.cd_fem = fnc.cd_fem)))) JOIN sc_cad.tbl_gem gem ON ((gem.cd_gem = emp.cd_gem))) LEFT JOIN (SELECT sum(CASE WHEN (opr.cd_top = (5)::numeric) THEN opr.vl_opr ELSE (0)::numeric END) AS vl_se, sum(opr.vl_opr) AS vl_total, prc.cd_fcr FROM (sc_opr.tbl_opr opr JOIN sc_fcr.tbl_prc prc ON ((prc.cd_opr = opr.cd_opr))) GROUP BY prc.cd_fcr) se ON ((se.cd_fcr = fcr.cd_fcr))) WHERE (fcr.cd_fcr = (SELECT max(fcr2.cd_fcr) AS max FROM sc_fcr.tbl_fcr fcr2 WHERE ((to_char((fcr2.dt_vnc_fcr)::timestamp with time zone, 'mm/yyyy'::text) = to_char((fcr.dt_vnc_fcr)::timestamp with time zone, 'mm/yyyy'::text)) AND (fcr2.cd_crt = fcr.cd_crt))));


ALTER TABLE "vw_indOld" OWNER TO scan;

SET search_path = sc_iso8583, pg_catalog;

--
-- TOC entry 922 (class 1259 OID 1011004)
-- Name: sq_msg8583; Type: SEQUENCE; Schema: sc_iso8583; Owner: scan
--

CREATE SEQUENCE sq_msg8583
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_msg8583 OWNER TO scan;

--
-- TOC entry 979 (class 1259 OID 1652828)
-- Name: tbl_msg8583_exp; Type: TABLE; Schema: sc_iso8583; Owner: postgres
--

CREATE TABLE tbl_msg8583_exp (
    cd_msg bigint,
    bit001 character varying(60),
    bit002 character varying(60),
    bit003 character varying(60),
    bit004 character varying(60),
    bit005 character varying(60),
    bit006 character varying(60),
    bit007 character varying(60),
    bit008 character varying(60),
    bit009 character varying(60),
    bit010 character varying(60),
    bit011 character varying(60),
    bit012 character varying(60),
    bit013 character varying(60),
    bit014 character varying(60),
    bit015 character varying(60),
    bit016 character varying(60),
    bit017 character varying(60),
    bit018 character varying(60),
    bit019 character varying(60),
    bit020 character varying(60),
    bit021 character varying(60),
    bit022 character varying(60),
    bit023 character varying(60),
    bit024 character varying(60),
    bit025 character varying(60),
    bit026 character varying(60),
    bit027 character varying(60),
    bit028 character varying(60),
    bit029 character varying(60),
    bit030 character varying(60),
    bit031 character varying(60),
    bit032 character varying(60),
    bit033 character varying(60),
    bit034 character varying(60),
    bit035 character varying(60),
    bit036 character varying(60),
    bit037 character varying(60),
    bit038 character varying(60),
    bit039 character varying(60),
    bit040 character varying(60),
    bit041 character varying(60),
    bit042 character varying(60),
    bit043 character varying(60),
    bit044 character varying(60),
    bit045 character varying(60),
    bit046 character varying(60),
    bit047 character varying(60),
    bit048 character varying(60),
    bit049 character varying(60),
    bit050 character varying(60),
    bit051 character varying(60),
    bit052 character varying(60),
    bit053 character varying(60),
    bit054 character varying(60),
    bit055 character varying(60),
    bit056 character varying(60),
    bit057 character varying(60),
    bit058 character varying(60),
    bit059 character varying(60),
    bit060 character varying(60),
    bit061 character varying(60),
    bit062 character varying(1000),
    bit063 character varying(1000),
    bit064 character varying(60),
    bit065 character varying(60),
    bit066 character varying(60),
    bit067 character varying(60),
    bit068 character varying(60),
    bit069 character varying(60),
    bit070 character varying(60),
    bit071 character varying(60),
    bit072 character varying(60),
    bit073 character varying(60),
    bit074 character varying(60),
    bit075 character varying(60),
    bit076 character varying(60),
    bit077 character varying(60),
    bit078 character varying(60),
    bit079 character varying(60),
    bit080 character varying(60),
    bit081 character varying(60),
    bit082 character varying(60),
    bit083 character varying(60),
    bit084 character varying(60),
    bit085 character varying(60),
    bit086 character varying(60),
    bit087 character varying(60),
    bit088 character varying(60),
    bit089 character varying(60),
    bit090 character varying(60),
    bit091 character varying(60),
    bit092 character varying(60),
    bit093 character varying(60),
    bit094 character varying(60),
    bit095 character varying(60),
    bit096 character varying(60),
    bit097 character varying(60),
    bit098 character varying(60),
    bit099 character varying(60),
    bit100 character varying(60),
    bit101 character varying(60),
    bit102 character varying(60),
    bit103 character varying(60),
    bit104 character varying(60),
    bit105 character varying(60),
    bit106 character varying(60),
    bit107 character varying(60),
    bit108 character varying(60),
    bit109 character varying(60),
    bit110 character varying(60),
    bit111 character varying(60),
    bit112 character varying(60),
    bit113 character varying(60),
    bit114 character varying(60),
    bit115 character varying(60),
    bit116 character varying(60),
    bit117 character varying(60),
    bit118 character varying(60),
    bit119 character varying(60),
    bit120 character varying(60),
    bit121 character varying(60),
    bit122 character varying(60),
    bit123 character varying(60),
    bit124 character varying(60),
    bit125 character varying(60),
    bit126 character varying(60),
    bit127 character varying(60),
    bit128 character varying(60),
    cd_pai_msg numeric(10,0),
    dt_msg timestamp without time zone
);


ALTER TABLE tbl_msg8583_exp OWNER TO postgres;

--
-- TOC entry 921 (class 1259 OID 1010980)
-- Name: tbl_wkey; Type: TABLE; Schema: sc_iso8583; Owner: scan
--

CREATE TABLE tbl_wkey (
    cd_wkey numeric(5,0) NOT NULL,
    vrs_wkey numeric(5,0) NOT NULL,
    idc_wkey numeric(5,0) NOT NULL,
    open_wkey character varying(48) NOT NULL
);


ALTER TABLE tbl_wkey OWNER TO scan;

SET search_path = sc_job, pg_catalog;

--
-- TOC entry 529 (class 1259 OID 565771)
-- Name: sq_job; Type: SEQUENCE; Schema: sc_job; Owner: scan
--

CREATE SEQUENCE sq_job
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE sq_job OWNER TO scan;

--
-- TOC entry 9206 (class 0 OID 0)
-- Dependencies: 529
-- Name: SEQUENCE sq_job; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON SEQUENCE sq_job IS 'SEQUENCE DE JOB';


--
-- TOC entry 530 (class 1259 OID 565773)
-- Name: sq_ljb; Type: SEQUENCE; Schema: sc_job; Owner: scan
--

CREATE SEQUENCE sq_ljb
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE sq_ljb OWNER TO scan;

--
-- TOC entry 9207 (class 0 OID 0)
-- Dependencies: 530
-- Name: SEQUENCE sq_ljb; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON SEQUENCE sq_ljb IS 'SEQUENCE DE LOG DE JOB';


--
-- TOC entry 883 (class 1259 OID 975771)
-- Name: sq_lpj; Type: SEQUENCE; Schema: sc_job; Owner: scan
--

CREATE SEQUENCE sq_lpj
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_lpj OWNER TO scan;

--
-- TOC entry 882 (class 1259 OID 975769)
-- Name: sq_plj; Type: SEQUENCE; Schema: sc_job; Owner: scan
--

CREATE SEQUENCE sq_plj
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_plj OWNER TO scan;

--
-- TOC entry 531 (class 1259 OID 565775)
-- Name: tbl_job; Type: TABLE; Schema: sc_job; Owner: scan
--

CREATE TABLE tbl_job (
    cd_job numeric(3,0) NOT NULL,
    ds_job character varying(100) NOT NULL,
    cmd_job character varying(100) NOT NULL,
    tp_job numeric(3,0) NOT NULL,
    nm_job character varying(50),
    dt_vig_ini_job date NOT NULL,
    dt_vig_fim_job date,
    nr_ord_job numeric(3,0) NOT NULL,
    fg_atv_job character(1) DEFAULT 'S'::bpchar NOT NULL,
    cd_inc_usr numeric(5,0) DEFAULT 1 NOT NULL,
    cd_alt_usr numeric(5,0),
    dt_inc_usr timestamp without time zone DEFAULT now() NOT NULL,
    dt_alt_usr timestamp without time zone,
    CONSTRAINT "CK_FG_ATV_JOB" CHECK ((fg_atv_job = ANY (ARRAY['S'::bpchar, 'N'::bpchar])))
);


ALTER TABLE tbl_job OWNER TO scan;

--
-- TOC entry 9208 (class 0 OID 0)
-- Dependencies: 531
-- Name: TABLE tbl_job; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON TABLE tbl_job IS 'TABELA DE JOBS';


--
-- TOC entry 9209 (class 0 OID 0)
-- Dependencies: 531
-- Name: COLUMN tbl_job.cd_job; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_job.cd_job IS 'CODIGO DO JOB';


--
-- TOC entry 9210 (class 0 OID 0)
-- Dependencies: 531
-- Name: COLUMN tbl_job.ds_job; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_job.ds_job IS 'DESCRICAO DO JOB';


--
-- TOC entry 9211 (class 0 OID 0)
-- Dependencies: 531
-- Name: COLUMN tbl_job.cmd_job; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_job.cmd_job IS 'COMANDO SQL';


--
-- TOC entry 9212 (class 0 OID 0)
-- Dependencies: 531
-- Name: COLUMN tbl_job.tp_job; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_job.tp_job IS 'TIPO DO JOB';


--
-- TOC entry 9213 (class 0 OID 0)
-- Dependencies: 531
-- Name: COLUMN tbl_job.nm_job; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_job.nm_job IS 'NOME DO JOB';


--
-- TOC entry 9214 (class 0 OID 0)
-- Dependencies: 531
-- Name: COLUMN tbl_job.dt_vig_ini_job; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_job.dt_vig_ini_job IS 'DATA DE VIGENCIA INICIAL';


--
-- TOC entry 9215 (class 0 OID 0)
-- Dependencies: 531
-- Name: COLUMN tbl_job.dt_vig_fim_job; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_job.dt_vig_fim_job IS 'DATA DE VIGENCIA FINAL';


--
-- TOC entry 9216 (class 0 OID 0)
-- Dependencies: 531
-- Name: COLUMN tbl_job.nr_ord_job; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_job.nr_ord_job IS 'NUMERO DA ORDEM DE EXECUCAO DO JOB';


--
-- TOC entry 9217 (class 0 OID 0)
-- Dependencies: 531
-- Name: COLUMN tbl_job.fg_atv_job; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_job.fg_atv_job IS 'FLAG DE ATIVO';


--
-- TOC entry 532 (class 1259 OID 565782)
-- Name: tbl_ljb; Type: TABLE; Schema: sc_job; Owner: scan
--

CREATE TABLE tbl_ljb (
    cd_ljb numeric(10,0) NOT NULL,
    cd_job numeric(3,0) NOT NULL,
    st_ljb numeric(2,0) NOT NULL,
    dt_ini_ljb timestamp without time zone NOT NULL,
    dt_fim_ljb timestamp without time zone,
    ds_err_ljb character varying(4000)
);


ALTER TABLE tbl_ljb OWNER TO scan;

--
-- TOC entry 9218 (class 0 OID 0)
-- Dependencies: 532
-- Name: TABLE tbl_ljb; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON TABLE tbl_ljb IS 'TABELA DE LOG DE JOB';


--
-- TOC entry 9219 (class 0 OID 0)
-- Dependencies: 532
-- Name: COLUMN tbl_ljb.cd_ljb; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_ljb.cd_ljb IS 'CODIGO DO LOG DE JOB';


--
-- TOC entry 9220 (class 0 OID 0)
-- Dependencies: 532
-- Name: COLUMN tbl_ljb.cd_job; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_ljb.cd_job IS 'CODIGO DO JOB';


--
-- TOC entry 9221 (class 0 OID 0)
-- Dependencies: 532
-- Name: COLUMN tbl_ljb.st_ljb; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_ljb.st_ljb IS 'SITUACAO';


--
-- TOC entry 9222 (class 0 OID 0)
-- Dependencies: 532
-- Name: COLUMN tbl_ljb.dt_ini_ljb; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_ljb.dt_ini_ljb IS 'DATA DO INICIO DO JOB';


--
-- TOC entry 9223 (class 0 OID 0)
-- Dependencies: 532
-- Name: COLUMN tbl_ljb.dt_fim_ljb; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_ljb.dt_fim_ljb IS 'DATA FINAL DE EXECUCAO DO JOB';


--
-- TOC entry 9224 (class 0 OID 0)
-- Dependencies: 532
-- Name: COLUMN tbl_ljb.ds_err_ljb; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON COLUMN tbl_ljb.ds_err_ljb IS 'DESCRICAO DO ERRO';


--
-- TOC entry 881 (class 1259 OID 975756)
-- Name: tbl_lpj; Type: TABLE; Schema: sc_job; Owner: scan
--

CREATE TABLE tbl_lpj (
    cd_lpj numeric(10,0) NOT NULL,
    cd_plj numeric(3,0) NOT NULL,
    st_lpj numeric(2,0) NOT NULL,
    dt_ini_lpj timestamp without time zone NOT NULL,
    dt_fim_lpj timestamp without time zone,
    ds_err_lpj character varying(4000)
);


ALTER TABLE tbl_lpj OWNER TO scan;

--
-- TOC entry 880 (class 1259 OID 975741)
-- Name: tbl_plj; Type: TABLE; Schema: sc_job; Owner: scan
--

CREATE TABLE tbl_plj (
    cd_plj numeric(10,0) NOT NULL,
    nm_plj character varying(40) NOT NULL,
    ds_plj character varying(100) NOT NULL,
    cls_plj character varying(100) NOT NULL,
    mtd_plj character varying(50) NOT NULL,
    obj_plj character varying(100) NOT NULL,
    fg_atv_plj character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_plj OWNER TO scan;

--
-- TOC entry 9225 (class 0 OID 0)
-- Dependencies: 880
-- Name: TABLE tbl_plj; Type: COMMENT; Schema: sc_job; Owner: scan
--

COMMENT ON TABLE tbl_plj IS 'Tabela de jobs a serem executados via chamada PlJava oriundas do banco de dados';


--
-- TOC entry 843 (class 1259 OID 893189)
-- Name: tbl_teste; Type: TABLE; Schema: sc_job; Owner: postgres
--

CREATE TABLE tbl_teste (
    cd_teste numeric(10,0) NOT NULL,
    ds_teste character varying(90) NOT NULL
);


ALTER TABLE tbl_teste OWNER TO postgres;

SET search_path = sc_meta, pg_catalog;

--
-- TOC entry 533 (class 1259 OID 565788)
-- Name: sq_2015; Type: SEQUENCE; Schema: sc_meta; Owner: scan
--

CREATE SEQUENCE sq_2015
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_2015 OWNER TO scan;

--
-- TOC entry 534 (class 1259 OID 565790)
-- Name: tbl_2015; Type: TABLE; Schema: sc_meta; Owner: scan
--

CREATE TABLE tbl_2015 (
    codigo numeric(10,0) NOT NULL,
    mes_referencia date NOT NULL,
    tipo numeric(2,0) NOT NULL,
    valor numeric(10,2) NOT NULL,
    ativo character varying(1) NOT NULL
);


ALTER TABLE tbl_2015 OWNER TO scan;

--
-- TOC entry 9226 (class 0 OID 0)
-- Dependencies: 534
-- Name: TABLE tbl_2015; Type: COMMENT; Schema: sc_meta; Owner: scan
--

COMMENT ON TABLE tbl_2015 IS 'TABELA QUE IRÁ ARMAZENAR AS INFORMAÇÕES REFERENTE AOS VALORES DA META 2015';


--
-- TOC entry 9227 (class 0 OID 0)
-- Dependencies: 534
-- Name: COLUMN tbl_2015.tipo; Type: COMMENT; Schema: sc_meta; Owner: scan
--

COMMENT ON COLUMN tbl_2015.tipo IS '1 - SAQUE EXTRA UTILIZADO 2 - CARTOES ATIVO 3 - INADIMPLENCIA';


SET search_path = sc_mgr, pg_catalog;

--
-- TOC entry 535 (class 1259 OID 565793)
-- Name: sq_dvd; Type: SEQUENCE; Schema: sc_mgr; Owner: scan
--

CREATE SEQUENCE sq_dvd
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dvd OWNER TO scan;

--
-- TOC entry 536 (class 1259 OID 565795)
-- Name: sq_pdv; Type: SEQUENCE; Schema: sc_mgr; Owner: scan
--

CREATE SEQUENCE sq_pdv
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_pdv OWNER TO scan;

--
-- TOC entry 537 (class 1259 OID 565797)
-- Name: tbl_dvd; Type: TABLE; Schema: sc_mgr; Owner: scan
--

CREATE TABLE tbl_dvd (
    cd_dvd numeric(10,0) NOT NULL,
    tp_dvd numeric(1,0) NOT NULL,
    nr_nsu_dvd numeric(12,0) NOT NULL,
    dt_dvd timestamp without time zone NOT NULL,
    crt_sc_dvd numeric(14,0) NOT NULL,
    nr_cpf_dvd numeric(14,0) NOT NULL,
    dt_atu_dvd timestamp without time zone NOT NULL,
    vl_dvd numeric(13,2) NOT NULL,
    vl_pg_dvd numeric(13,2),
    vl_rps_dvd numeric(13,2),
    st_dvd numeric(1,0) DEFAULT 1 NOT NULL,
    nr_dia_atr_crt_dvd numeric(5,0),
    vl_org_dvd numeric(13,2)
);


ALTER TABLE tbl_dvd OWNER TO scan;

--
-- TOC entry 538 (class 1259 OID 565801)
-- Name: tbl_lmt; Type: TABLE; Schema: sc_mgr; Owner: scan
--

CREATE TABLE tbl_lmt (
    cd_crt numeric(14,0) NOT NULL,
    cd_crt_sc_lmt numeric(14,0) NOT NULL,
    fg_ind_lmt character(1) DEFAULT 'N'::bpchar NOT NULL,
    vl_cnc_lmt numeric(13,2) DEFAULT 0 NOT NULL,
    vl_utl_lmt numeric(13,2) DEFAULT 0 NOT NULL,
    nr_cpf_lmt numeric(11,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_lmt OWNER TO scan;

--
-- TOC entry 539 (class 1259 OID 565807)
-- Name: tbl_pdv; Type: TABLE; Schema: sc_mgr; Owner: scan
--

CREATE TABLE tbl_pdv (
    cd_pdv numeric(10,0) NOT NULL,
    cd_dvd numeric(10,0) NOT NULL,
    vl_pdv numeric(13,2) NOT NULL,
    dt_pdv timestamp without time zone NOT NULL,
    st_pdv numeric(1,0) DEFAULT 1 NOT NULL,
    dt_rps_pdv timestamp without time zone,
    cd_cnt numeric(10,0),
    dt_cnc_pdv timestamp without time zone,
    dt_prc_cnc_pdv timestamp without time zone,
    vl_rst_lmt_pdv numeric(13,2)
);


ALTER TABLE tbl_pdv OWNER TO scan;

SET search_path = sc_mnt, pg_catalog;

--
-- TOC entry 814 (class 1259 OID 880691)
-- Name: sq_ads; Type: SEQUENCE; Schema: sc_mnt; Owner: scan
--

CREATE SEQUENCE sq_ads
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ads OWNER TO scan;

--
-- TOC entry 812 (class 1259 OID 878858)
-- Name: sq_arm; Type: SEQUENCE; Schema: sc_mnt; Owner: scan
--

CREATE SEQUENCE sq_arm
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_arm OWNER TO scan;

--
-- TOC entry 813 (class 1259 OID 878860)
-- Name: sq_dar; Type: SEQUENCE; Schema: sc_mnt; Owner: scan
--

CREATE SEQUENCE sq_dar
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dar OWNER TO scan;

--
-- TOC entry 808 (class 1259 OID 875724)
-- Name: sq_mnt; Type: SEQUENCE; Schema: sc_mnt; Owner: scan
--

CREATE SEQUENCE sq_mnt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_mnt OWNER TO scan;

--
-- TOC entry 868 (class 1259 OID 955678)
-- Name: sq_rmt; Type: SEQUENCE; Schema: sc_mnt; Owner: scan
--

CREATE SEQUENCE sq_rmt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rmt OWNER TO scan;

--
-- TOC entry 811 (class 1259 OID 877670)
-- Name: tbl_ads; Type: TABLE; Schema: sc_mnt; Owner: scan
--

CREATE TABLE tbl_ads (
    cd_ads numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    cd_dsp numeric(2,0),
    nsu_dsp character varying(40),
    dt_ads timestamp without time zone NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_alt_usr numeric(10,0),
    cd_pct numeric(2,0) NOT NULL,
    st_ads numeric(1,0) DEFAULT 1 NOT NULL
);


ALTER TABLE tbl_ads OWNER TO scan;

--
-- TOC entry 859 (class 1259 OID 927708)
-- Name: tbl_arm; Type: TABLE; Schema: sc_mnt; Owner: scan
--

CREATE TABLE tbl_arm (
    cd_arm numeric(10,0) NOT NULL,
    nm_arm character varying(70) NOT NULL,
    dt_grc_arm timestamp without time zone NOT NULL,
    dt_env_arm timestamp without time zone,
    dt_pgto_arm date NOT NULL,
    st_arm numeric(1,0) DEFAULT 1 NOT NULL,
    qtd_reg_arm numeric(4,0) NOT NULL,
    vl_ttl_arm numeric(13,2) NOT NULL
);


ALTER TABLE tbl_arm OWNER TO scan;

--
-- TOC entry 9228 (class 0 OID 0)
-- Dependencies: 859
-- Name: TABLE tbl_arm; Type: COMMENT; Schema: sc_mnt; Owner: scan
--

COMMENT ON TABLE tbl_arm IS 'Tabela de arquivo de remessa minutrade';


--
-- TOC entry 860 (class 1259 OID 927714)
-- Name: tbl_dar; Type: TABLE; Schema: sc_mnt; Owner: scan
--

CREATE TABLE tbl_dar (
    cd_dar numeric(10,0) NOT NULL,
    cd_arm numeric(10,0) NOT NULL,
    tp_org_dar numeric(1,0) DEFAULT 1 NOT NULL,
    nsu_org_dar numeric(14,0) NOT NULL,
    id_evt_dar numeric(10,0) NOT NULL,
    nr_ddd_tlf_dar numeric(2,0) NOT NULL,
    nr_tlf_dar numeric(9,0) NOT NULL,
    id_dar character varying(40) NOT NULL,
    nm_dar character varying(80) NOT NULL,
    eml_dar character varying(50),
    st_dar numeric(1,0) DEFAULT 1 NOT NULL,
    vl_dar numeric(13,2) NOT NULL
);


ALTER TABLE tbl_dar OWNER TO scan;

--
-- TOC entry 9229 (class 0 OID 0)
-- Dependencies: 860
-- Name: TABLE tbl_dar; Type: COMMENT; Schema: sc_mnt; Owner: scan
--

COMMENT ON TABLE tbl_dar IS 'Tabela de detalhe do arquivo da minutrade';


--
-- TOC entry 807 (class 1259 OID 875711)
-- Name: tbl_mnt; Type: TABLE; Schema: sc_mnt; Owner: scan
--

CREATE TABLE tbl_mnt (
    cd_mnt numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    vl_mnt numeric(13,2) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_alt_usr numeric(10,0),
    st_mnt numeric(1,0) NOT NULL,
    nr_ddd_tlf_mnt numeric(2,0),
    nr_tlf_mnt numeric(10,0),
    cd_pct numeric(2,0),
    cd_arm numeric(10,0),
    cd_tsc numeric(10,0),
    dt_pgt_mnt date
);


ALTER TABLE tbl_mnt OWNER TO scan;

--
-- TOC entry 809 (class 1259 OID 877427)
-- Name: tbl_pct; Type: TABLE; Schema: sc_mnt; Owner: scan
--

CREATE TABLE tbl_pct (
    cd_pct numeric(2,0) NOT NULL,
    ds_pct character varying(40) NOT NULL,
    vl_bns_pct numeric(5,2) NOT NULL,
    vl_pgt_pct numeric(5,2) NOT NULL,
    fg_atv_pct character(1) DEFAULT 'S'::bpchar NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_pct OWNER TO scan;

--
-- TOC entry 867 (class 1259 OID 954973)
-- Name: tbl_rmt; Type: TABLE; Schema: sc_mnt; Owner: scan
--

CREATE TABLE tbl_rmt (
    cd_rmt numeric(10,0) NOT NULL,
    nm_rmt character varying(200),
    eml_rmt character varying(100),
    id_evt_rmt numeric(10,0),
    dt_mtr_rmt date,
    dt_pgt_rmt date,
    amt_rmt numeric(10,0),
    trg_rmt character varying(100),
    rwr_rmt numeric(10,2),
    frw_rmt numeric(10,0),
    dlv_rmt numeric(10,0),
    cnc_rmt numeric(10,2),
    err_rmt character varying(100),
    st_rmt numeric(1,0),
    dt_inc_rmt timestamp without time zone NOT NULL,
    id_rmt numeric(14,0),
    tlf_rmt numeric(14,0)
);


ALTER TABLE tbl_rmt OWNER TO scan;

SET search_path = sc_mrk, pg_catalog;

--
-- TOC entry 889 (class 1259 OID 992915)
-- Name: sq_abn; Type: SEQUENCE; Schema: sc_mrk; Owner: scan
--

CREATE SEQUENCE sq_abn
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_abn OWNER TO scan;

--
-- TOC entry 888 (class 1259 OID 992913)
-- Name: sq_bnn; Type: SEQUENCE; Schema: sc_mrk; Owner: scan
--

CREATE SEQUENCE sq_bnn
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_bnn OWNER TO scan;

--
-- TOC entry 891 (class 1259 OID 992947)
-- Name: tbl_abn; Type: TABLE; Schema: sc_mrk; Owner: scan
--

CREATE TABLE tbl_abn (
    cd_abn numeric(10,0) NOT NULL,
    cd_bnn numeric(10,0) NOT NULL,
    sq_abn numeric(2,0) NOT NULL,
    ds_ext_abn character varying(5) NOT NULL,
    fg_atv_abn character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_abn OWNER TO scan;

--
-- TOC entry 9230 (class 0 OID 0)
-- Dependencies: 891
-- Name: TABLE tbl_abn; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON TABLE tbl_abn IS 'tabela de arquivo de banner';


--
-- TOC entry 9231 (class 0 OID 0)
-- Dependencies: 891
-- Name: COLUMN tbl_abn.cd_abn; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_abn.cd_abn IS 'codigo';


--
-- TOC entry 9232 (class 0 OID 0)
-- Dependencies: 891
-- Name: COLUMN tbl_abn.cd_bnn; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_abn.cd_bnn IS 'codigo do banner';


--
-- TOC entry 9233 (class 0 OID 0)
-- Dependencies: 891
-- Name: COLUMN tbl_abn.ds_ext_abn; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_abn.ds_ext_abn IS 'descrição extensão';


--
-- TOC entry 9234 (class 0 OID 0)
-- Dependencies: 891
-- Name: COLUMN tbl_abn.fg_atv_abn; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_abn.fg_atv_abn IS 'flag ativo';


--
-- TOC entry 9235 (class 0 OID 0)
-- Dependencies: 891
-- Name: COLUMN tbl_abn.cd_inc_usr; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_abn.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 9236 (class 0 OID 0)
-- Dependencies: 891
-- Name: COLUMN tbl_abn.dt_inc_usr; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_abn.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 9237 (class 0 OID 0)
-- Dependencies: 891
-- Name: COLUMN tbl_abn.cd_alt_usr; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_abn.cd_alt_usr IS 'codigo do usuario de alteracao';


--
-- TOC entry 9238 (class 0 OID 0)
-- Dependencies: 891
-- Name: COLUMN tbl_abn.dt_alt_usr; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_abn.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 890 (class 1259 OID 992917)
-- Name: tbl_bnn; Type: TABLE; Schema: sc_mrk; Owner: scan
--

CREATE TABLE tbl_bnn (
    cd_bnn numeric(10,0) NOT NULL,
    tp_bnn numeric(2,0) NOT NULL,
    ds_bnn character varying(200) NOT NULL,
    fg_atv_bnn character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_bnn OWNER TO scan;

--
-- TOC entry 9239 (class 0 OID 0)
-- Dependencies: 890
-- Name: TABLE tbl_bnn; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON TABLE tbl_bnn IS 'tabela de banner';


--
-- TOC entry 9240 (class 0 OID 0)
-- Dependencies: 890
-- Name: COLUMN tbl_bnn.cd_bnn; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_bnn.cd_bnn IS 'codigo';


--
-- TOC entry 9241 (class 0 OID 0)
-- Dependencies: 890
-- Name: COLUMN tbl_bnn.tp_bnn; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_bnn.tp_bnn IS 'tipo';


--
-- TOC entry 9242 (class 0 OID 0)
-- Dependencies: 890
-- Name: COLUMN tbl_bnn.ds_bnn; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_bnn.ds_bnn IS 'descrição';


--
-- TOC entry 9243 (class 0 OID 0)
-- Dependencies: 890
-- Name: COLUMN tbl_bnn.fg_atv_bnn; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_bnn.fg_atv_bnn IS 'flag ativo';


--
-- TOC entry 9244 (class 0 OID 0)
-- Dependencies: 890
-- Name: COLUMN tbl_bnn.cd_inc_usr; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_bnn.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 9245 (class 0 OID 0)
-- Dependencies: 890
-- Name: COLUMN tbl_bnn.dt_inc_usr; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_bnn.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 9246 (class 0 OID 0)
-- Dependencies: 890
-- Name: COLUMN tbl_bnn.cd_alt_usr; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_bnn.cd_alt_usr IS 'codigo do usuario de alteracao';


--
-- TOC entry 9247 (class 0 OID 0)
-- Dependencies: 890
-- Name: COLUMN tbl_bnn.dt_alt_usr; Type: COMMENT; Schema: sc_mrk; Owner: scan
--

COMMENT ON COLUMN tbl_bnn.dt_alt_usr IS 'data de alteracao';


SET search_path = sc_msg, pg_catalog;

--
-- TOC entry 790 (class 1259 OID 862141)
-- Name: sq_cvm; Type: SEQUENCE; Schema: sc_msg; Owner: scan
--

CREATE SEQUENCE sq_cvm
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_cvm OWNER TO scan;

--
-- TOC entry 540 (class 1259 OID 565811)
-- Name: sq_msg; Type: SEQUENCE; Schema: sc_msg; Owner: scan
--

CREATE SEQUENCE sq_msg
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_msg OWNER TO scan;

--
-- TOC entry 541 (class 1259 OID 565813)
-- Name: sq_tms; Type: SEQUENCE; Schema: sc_msg; Owner: scan
--

CREATE SEQUENCE sq_tms
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tms OWNER TO scan;

--
-- TOC entry 542 (class 1259 OID 565815)
-- Name: sq_tpm; Type: SEQUENCE; Schema: sc_msg; Owner: scan
--

CREATE SEQUENCE sq_tpm
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tpm OWNER TO scan;

--
-- TOC entry 789 (class 1259 OID 862135)
-- Name: tbl_cvm; Type: TABLE; Schema: sc_msg; Owner: scan
--

CREATE TABLE tbl_cvm (
    cd_cvm numeric(10,0) NOT NULL,
    tp_org_cvm numeric(5,0) NOT NULL,
    nsu_org_cvm numeric(10,0) NOT NULL,
    cd_vld_cvm character varying(10) NOT NULL,
    dt_exp_vld_cvm timestamp without time zone NOT NULL,
    st_cvm numeric(5,0) NOT NULL,
    dt_st_cvm timestamp without time zone NOT NULL,
    nr_env_cvm numeric(5,0)
);


ALTER TABLE tbl_cvm OWNER TO scan;

--
-- TOC entry 9248 (class 0 OID 0)
-- Dependencies: 789
-- Name: TABLE tbl_cvm; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON TABLE tbl_cvm IS 'tabela dos codigos de validacao atraves de SMS';


--
-- TOC entry 543 (class 1259 OID 565817)
-- Name: tbl_msg; Type: TABLE; Schema: sc_msg; Owner: scan
--

CREATE TABLE tbl_msg (
    cd_msg numeric(10,0) NOT NULL,
    cd_tms numeric(10,0) NOT NULL,
    ddd_msg numeric(2,0) NOT NULL,
    nr_msg numeric(10,0) NOT NULL,
    prm_msg character varying(500),
    fg_atv_msg character varying(1) NOT NULL,
    fg_env_msg character varying(1) NOT NULL,
    dt_env_msg timestamp without time zone,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_rtn_msg numeric(10,0),
    cd_crt numeric(14,0),
    id_push_msg character varying(200),
    tp_env_msg numeric(2,0) DEFAULT 1
);


ALTER TABLE tbl_msg OWNER TO scan;

--
-- TOC entry 9249 (class 0 OID 0)
-- Dependencies: 543
-- Name: TABLE tbl_msg; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON TABLE tbl_msg IS 'MENSAGEM';


--
-- TOC entry 9250 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.cd_msg; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.cd_msg IS 'CODIGO';


--
-- TOC entry 9251 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.cd_tms; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.cd_tms IS 'TIPO DE MENSAGEM';


--
-- TOC entry 9252 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.ddd_msg; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.ddd_msg IS 'DDD';


--
-- TOC entry 9253 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.nr_msg; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.nr_msg IS 'NUMERO';


--
-- TOC entry 9254 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.prm_msg; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.prm_msg IS 'PARAMETROS';


--
-- TOC entry 9255 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.fg_atv_msg; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.fg_atv_msg IS 'FLAG ATIVO';


--
-- TOC entry 9256 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.fg_env_msg; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.fg_env_msg IS 'FLAG ENVIADO';


--
-- TOC entry 9257 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.cd_inc_usr; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9258 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.dt_inc_usr; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9259 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.cd_alt_usr; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 9260 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.dt_alt_usr; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 9261 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.cd_rtn_msg; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.cd_rtn_msg IS 'RETORNO';


--
-- TOC entry 9262 (class 0 OID 0)
-- Dependencies: 543
-- Name: COLUMN tbl_msg.cd_crt; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_msg.cd_crt IS 'cartao';


--
-- TOC entry 544 (class 1259 OID 565823)
-- Name: tbl_tms; Type: TABLE; Schema: sc_msg; Owner: scan
--

CREATE TABLE tbl_tms (
    cd_tms numeric(10,0) NOT NULL,
    ds_tms character varying(50) NOT NULL,
    msg_tms character varying(500) NOT NULL
);


ALTER TABLE tbl_tms OWNER TO scan;

--
-- TOC entry 9263 (class 0 OID 0)
-- Dependencies: 544
-- Name: TABLE tbl_tms; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON TABLE tbl_tms IS 'TIPO DE MENSAGEM';


--
-- TOC entry 9264 (class 0 OID 0)
-- Dependencies: 544
-- Name: COLUMN tbl_tms.cd_tms; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_tms.cd_tms IS 'CODIGO';


--
-- TOC entry 9265 (class 0 OID 0)
-- Dependencies: 544
-- Name: COLUMN tbl_tms.ds_tms; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_tms.ds_tms IS 'DESCRICAO';


--
-- TOC entry 9266 (class 0 OID 0)
-- Dependencies: 544
-- Name: COLUMN tbl_tms.msg_tms; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_tms.msg_tms IS 'MENSAGEM';


--
-- TOC entry 545 (class 1259 OID 565829)
-- Name: tbl_tpm; Type: TABLE; Schema: sc_msg; Owner: scan
--

CREATE TABLE tbl_tpm (
    cd_tpm numeric(10,0) NOT NULL,
    ds_tpm character varying(50) NOT NULL,
    cmd_hql_tpm character varying(200) NOT NULL,
    tp_tpm numeric(2,0) NOT NULL
);


ALTER TABLE tbl_tpm OWNER TO scan;

--
-- TOC entry 9267 (class 0 OID 0)
-- Dependencies: 545
-- Name: TABLE tbl_tpm; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON TABLE tbl_tpm IS 'TIPO DE PARAMETRO DE MENSAGEM';


--
-- TOC entry 9268 (class 0 OID 0)
-- Dependencies: 545
-- Name: COLUMN tbl_tpm.cd_tpm; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_tpm.cd_tpm IS 'CODIGO';


--
-- TOC entry 9269 (class 0 OID 0)
-- Dependencies: 545
-- Name: COLUMN tbl_tpm.ds_tpm; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_tpm.ds_tpm IS 'DESCRICAO';


--
-- TOC entry 9270 (class 0 OID 0)
-- Dependencies: 545
-- Name: COLUMN tbl_tpm.cmd_hql_tpm; Type: COMMENT; Schema: sc_msg; Owner: scan
--

COMMENT ON COLUMN tbl_tpm.cmd_hql_tpm IS 'COMANDO HQL';


SET search_path = sc_opr, pg_catalog;

--
-- TOC entry 546 (class 1259 OID 565832)
-- Name: sc_top_tlt; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sc_top_tlt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999
    CACHE 1;


ALTER TABLE sc_top_tlt OWNER TO scan;

--
-- TOC entry 547 (class 1259 OID 565834)
-- Name: sq_ctc; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_ctc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999
    CACHE 1;


ALTER TABLE sq_ctc OWNER TO scan;

--
-- TOC entry 548 (class 1259 OID 565836)
-- Name: sq_dos; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_dos
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999999
    CACHE 1;


ALTER TABLE sq_dos OWNER TO scan;

--
-- TOC entry 549 (class 1259 OID 565838)
-- Name: sq_dtv; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_dtv
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_dtv OWNER TO scan;

--
-- TOC entry 550 (class 1259 OID 565840)
-- Name: sq_exc; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_exc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_exc OWNER TO scan;

--
-- TOC entry 551 (class 1259 OID 565842)
-- Name: sq_hlm; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_hlm
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hlm OWNER TO scan;

--
-- TOC entry 552 (class 1259 OID 565844)
-- Name: sq_ocr; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_ocr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ocr OWNER TO scan;

--
-- TOC entry 553 (class 1259 OID 565846)
-- Name: sq_opr; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_opr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_opr OWNER TO scan;

--
-- TOC entry 554 (class 1259 OID 565848)
-- Name: sq_rst; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_rst
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_rst OWNER TO scan;

--
-- TOC entry 555 (class 1259 OID 565850)
-- Name: sq_sqm; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_sqm
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_sqm OWNER TO scan;

--
-- TOC entry 556 (class 1259 OID 565852)
-- Name: sq_tbl; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_tbl
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_tbl OWNER TO scan;

--
-- TOC entry 557 (class 1259 OID 565854)
-- Name: sq_tcp; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_tcp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999
    CACHE 1;


ALTER TABLE sq_tcp OWNER TO scan;

--
-- TOC entry 558 (class 1259 OID 565856)
-- Name: sq_top; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_top
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_top OWNER TO scan;

--
-- TOC entry 559 (class 1259 OID 565858)
-- Name: sq_tvt; Type: SEQUENCE; Schema: sc_opr; Owner: scan
--

CREATE SEQUENCE sq_tvt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 999999999999999999
    CACHE 1;


ALTER TABLE sq_tvt OWNER TO scan;

--
-- TOC entry 560 (class 1259 OID 565860)
-- Name: tbl_aal_antiga; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_aal_antiga (
    cd_aal numeric(15,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    cd_tlt numeric(2,0) NOT NULL,
    nm_mtv_aal character(400) NOT NULL,
    vl_ant_aal numeric(13,2) NOT NULL,
    vl_atu_aal numeric(13,2) NOT NULL
);


ALTER TABLE tbl_aal_antiga OWNER TO scan;

--
-- TOC entry 9271 (class 0 OID 0)
-- Dependencies: 560
-- Name: TABLE tbl_aal_antiga; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_aal_antiga IS 'TABELA DE AUDITORIA DE ALTERACAO DE LIMITE';


--
-- TOC entry 561 (class 1259 OID 565863)
-- Name: tbl_cnt_crt; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_cnt_crt (
    cd_cnt numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    tp_cnt_crt numeric(2,0) NOT NULL,
    cd_inc_usr numeric(5,0) NOT NULL,
    dt_inc_usr time without time zone NOT NULL,
    fg_pdr_cnt_crt character(1) DEFAULT 'S'::bpchar NOT NULL,
    prp_cnt_crt numeric(5,0) NOT NULL
);


ALTER TABLE tbl_cnt_crt OWNER TO scan;

--
-- TOC entry 9272 (class 0 OID 0)
-- Dependencies: 561
-- Name: TABLE tbl_cnt_crt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_cnt_crt IS 'TABELA DE CONTAS DO CARTAO';


--
-- TOC entry 9273 (class 0 OID 0)
-- Dependencies: 561
-- Name: COLUMN tbl_cnt_crt.fg_pdr_cnt_crt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_cnt_crt.fg_pdr_cnt_crt IS 'FLAG QUE INDICA SE A CONTA EH A CONTA PADRAO';


--
-- TOC entry 562 (class 1259 OID 565867)
-- Name: tbl_crt_aux; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_crt_aux (
    cd_crt numeric(14,0) NOT NULL,
    ddd numeric(2,0),
    telefone numeric(8,0),
    tipo numeric(2,0),
    cd_pls numeric(16,0),
    data date,
    cd_ctr_old numeric(10,0),
    cd_ctr_new numeric(10,0)
);


ALTER TABLE tbl_crt_aux OWNER TO scan;

--
-- TOC entry 563 (class 1259 OID 565870)
-- Name: tbl_crt_dep; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_crt_dep (
    cartao numeric(14,0) NOT NULL,
    funcionario text,
    vl_dep1 numeric(10,2),
    vl_dep2 numeric(10,2),
    saldo numeric(10,2)
);


ALTER TABLE tbl_crt_dep OWNER TO scan;

--
-- TOC entry 916 (class 1259 OID 1010399)
-- Name: tbl_crt_exc; Type: TABLE; Schema: sc_opr; Owner: postgres
--

CREATE TABLE tbl_crt_exc (
    cd_crt numeric(14,0) NOT NULL,
    cd_fnc numeric(10,0) NOT NULL,
    fg_atv_crt "char" NOT NULL,
    fg_ind_crt "char" DEFAULT 'N'::"char" NOT NULL,
    dt_ini_atr_crt date,
    cd_inc_usr numeric(5,0) NOT NULL,
    cd_prd numeric(5,0),
    cd_ult_fcr numeric(10,0),
    dt_prx_vnc_crt date NOT NULL,
    cd_tvt numeric(5,0),
    dt_prx_apr_crt date NOT NULL,
    cd_fcr numeric(10,0),
    cd_ctr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone DEFAULT now() NOT NULL,
    dt_pri_dps_crt timestamp without time zone,
    dt_ult_dps_crt timestamp without time zone,
    dt_fim_atr_crt date,
    qtd_saq_crt numeric(5,0) DEFAULT 0,
    cd_cnt numeric(10,0) NOT NULL,
    qtd_abn_trf_crt numeric(1,0),
    cd_pcs numeric(10,0),
    dt_ads_pcs_crt timestamp without time zone,
    dt_exc_crt timestamp without time zone NOT NULL,
    cd_usr_exc_crt numeric(10,0) NOT NULL,
    mtv_exc_crt character varying(400),
    CONSTRAINT ck_fg_atv_crt CHECK ((fg_atv_crt = ANY (ARRAY['N'::"char", 'S'::"char"]))),
    CONSTRAINT ck_fg_ind_crt CHECK ((fg_ind_crt = ANY (ARRAY['N'::"char", 'S'::"char"])))
);


ALTER TABLE tbl_crt_exc OWNER TO postgres;

--
-- TOC entry 564 (class 1259 OID 565876)
-- Name: tbl_ctc; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_ctc (
    cd_ctc numeric(10,0) NOT NULL,
    cd_opr numeric(10,0) NOT NULL,
    tp_ctc numeric(2,0) NOT NULL,
    ds_mtv_ctc character varying(400) NOT NULL,
    ds_anl_ctc character varying(400),
    nm_arq_fnc_ctc character varying(100),
    nm_arq_trm_ctc character varying(100),
    vl_ctc numeric(13,2) NOT NULL,
    st_ctc numeric(2,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_cnc_usr numeric(10,0),
    dt_cnc_usr timestamp without time zone,
    cd_anl_usr numeric(10,0),
    dt_anl_usr timestamp without time zone,
    vl_trf_ctc numeric(13,2),
    mtv_abn_trf_ctc character varying(100)
);


ALTER TABLE tbl_ctc OWNER TO scan;

--
-- TOC entry 9274 (class 0 OID 0)
-- Dependencies: 564
-- Name: TABLE tbl_ctc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_ctc IS 'tabela de cadastro das contestação';


--
-- TOC entry 9275 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.cd_ctc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.cd_ctc IS 'codigo';


--
-- TOC entry 9276 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.cd_opr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.cd_opr IS 'codigo da operacao';


--
-- TOC entry 9277 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.tp_ctc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.tp_ctc IS 'tipo da contestacao (ver dominio)';


--
-- TOC entry 9278 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.ds_mtv_ctc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.ds_mtv_ctc IS 'descricao do motivo da contestacao';


--
-- TOC entry 9279 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.ds_anl_ctc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.ds_anl_ctc IS 'descricao do analise da contestacao';


--
-- TOC entry 9280 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.nm_arq_fnc_ctc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.nm_arq_fnc_ctc IS 'nome do arquivo do funcionario';


--
-- TOC entry 9281 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.nm_arq_trm_ctc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.nm_arq_trm_ctc IS 'nome do arquivo do termo do funcionario';


--
-- TOC entry 9282 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.vl_ctc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.vl_ctc IS 'valor da contestacao';


--
-- TOC entry 9283 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.st_ctc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.st_ctc IS 'situacao da contestacao (ver dominio)';


--
-- TOC entry 9284 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.cd_inc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 9285 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.dt_inc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.dt_inc_usr IS 'data do usuario de inclusao';


--
-- TOC entry 9286 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.cd_alt_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.cd_alt_usr IS 'codigo do usuario de alteracao';


--
-- TOC entry 9287 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.dt_alt_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.dt_alt_usr IS 'data do usuario de alteracao';


--
-- TOC entry 9288 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.cd_cnc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.cd_cnc_usr IS 'codigo do usuario de cancelamento';


--
-- TOC entry 9289 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.dt_cnc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.dt_cnc_usr IS 'data do usuario de cancelamento';


--
-- TOC entry 9290 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.cd_anl_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.cd_anl_usr IS 'codigo do usuario de analise';


--
-- TOC entry 9291 (class 0 OID 0)
-- Dependencies: 564
-- Name: COLUMN tbl_ctc.dt_anl_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ctc.dt_anl_usr IS 'data do usuario de analise';


--
-- TOC entry 565 (class 1259 OID 565882)
-- Name: tbl_dos; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_dos (
    cd_dos numeric(15,0) NOT NULL,
    cd_opr numeric(10,0) NOT NULL,
    nm_ltr_dos "char" NOT NULL,
    nr_cdl_dos numeric(5,0) NOT NULL,
    vl_cdl_dos numeric(13,2) NOT NULL,
    nr_ttl_cdl_dos numeric(5,0) NOT NULL,
    nr_cdl_rjt_dos numeric(5,0) DEFAULT 0 NOT NULL
);


ALTER TABLE tbl_dos OWNER TO scan;

--
-- TOC entry 9292 (class 0 OID 0)
-- Dependencies: 565
-- Name: TABLE tbl_dos; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_dos IS 'TABELA DE DETALHE DA OPERACAO DE SAQUE';


--
-- TOC entry 810 (class 1259 OID 877664)
-- Name: tbl_dsp; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_dsp (
    cd_dsp numeric(2,0) NOT NULL,
    ds_dsp character varying(50) NOT NULL
);


ALTER TABLE tbl_dsp OWNER TO scan;

--
-- TOC entry 566 (class 1259 OID 565886)
-- Name: tbl_dtv; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_dtv (
    cd_dtv numeric(10,0) NOT NULL,
    cd_tvt numeric(5,0) NOT NULL,
    cd_top numeric(5,0) NOT NULL,
    tp_cbr_dtv numeric(2,0) NOT NULL,
    tp_vlr_dtv character(1) DEFAULT 'V'::bpchar NOT NULL,
    vl_dtv numeric(13,2),
    CONSTRAINT ck_tp_vlr_dtv CHECK ((tp_vlr_dtv = ANY (ARRAY['P'::bpchar, 'V'::bpchar])))
);


ALTER TABLE tbl_dtv OWNER TO scan;

--
-- TOC entry 9293 (class 0 OID 0)
-- Dependencies: 566
-- Name: TABLE tbl_dtv; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_dtv IS 'detalhe da tabela de valores de tarifas';


--
-- TOC entry 9294 (class 0 OID 0)
-- Dependencies: 566
-- Name: COLUMN tbl_dtv.cd_dtv; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_dtv.cd_dtv IS 'codigo';


--
-- TOC entry 9295 (class 0 OID 0)
-- Dependencies: 566
-- Name: COLUMN tbl_dtv.cd_tvt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_dtv.cd_tvt IS 'codigo da tabela de valores de tarifas';


--
-- TOC entry 9296 (class 0 OID 0)
-- Dependencies: 566
-- Name: COLUMN tbl_dtv.cd_top; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_dtv.cd_top IS 'codigo do tipo de operacao';


--
-- TOC entry 9297 (class 0 OID 0)
-- Dependencies: 566
-- Name: COLUMN tbl_dtv.tp_cbr_dtv; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_dtv.tp_cbr_dtv IS 'tipo de cobranca. ver tabela de dominio';


--
-- TOC entry 9298 (class 0 OID 0)
-- Dependencies: 566
-- Name: COLUMN tbl_dtv.tp_vlr_dtv; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_dtv.tp_vlr_dtv IS 'tipo de valor. V - Valor; P - percentual';


--
-- TOC entry 9299 (class 0 OID 0)
-- Dependencies: 566
-- Name: COLUMN tbl_dtv.vl_dtv; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_dtv.vl_dtv IS 'valor';


--
-- TOC entry 567 (class 1259 OID 565891)
-- Name: tbl_eop; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_eop (
    cd_opr numeric(10,0) NOT NULL,
    nr_ctr_eop numeric(10,0),
    tx_jrs_eop numeric(10,7),
    vr_prc_eop numeric(13,2),
    vr_iof_eop numeric(13,2),
    vr_ttl_eop numeric(13,2),
    dt_vnc_eop date,
    pz_dia_eop numeric(5,0),
    vr_tac_eop numeric(13,2),
    vr_jrs_eop numeric(13,2),
    vr_spd_eop numeric(13,2)
);


ALTER TABLE tbl_eop OWNER TO scan;

--
-- TOC entry 568 (class 1259 OID 565894)
-- Name: tbl_exc; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_exc (
    cd_exc numeric(20,0) NOT NULL,
    cd_rst numeric(20,0) NOT NULL,
    tp_cli_exc numeric(2,0),
    nr_nsu_cli_exc numeric(20,0),
    nr_nsu2_cli_exc numeric(20,0),
    tp_lcl_exc numeric(2,0) NOT NULL,
    nr_nsu_lcl_exc numeric(20,0),
    nr_nsu2_lcl_exc numeric(20,0),
    dt_ini_exc timestamp without time zone NOT NULL,
    dt_fin_exc timestamp without time zone,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_exc OWNER TO scan;

--
-- TOC entry 9300 (class 0 OID 0)
-- Dependencies: 568
-- Name: TABLE tbl_exc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_exc IS 'tabela que armazena as excecoes de restricao';


--
-- TOC entry 9301 (class 0 OID 0)
-- Dependencies: 568
-- Name: COLUMN tbl_exc.cd_exc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_exc.cd_exc IS 'codigo';


--
-- TOC entry 9302 (class 0 OID 0)
-- Dependencies: 568
-- Name: COLUMN tbl_exc.cd_rst; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_exc.cd_rst IS 'codigo restricao';


--
-- TOC entry 9303 (class 0 OID 0)
-- Dependencies: 568
-- Name: COLUMN tbl_exc.tp_cli_exc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_exc.tp_cli_exc IS 'tipo de cliente que esta sofrendo a excecao. ver tabela de dominio';


--
-- TOC entry 9304 (class 0 OID 0)
-- Dependencies: 568
-- Name: COLUMN tbl_exc.nr_nsu_cli_exc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_exc.nr_nsu_cli_exc IS 'numero de identificacao do cliente que esta sofrendo a excecao';


--
-- TOC entry 9305 (class 0 OID 0)
-- Dependencies: 568
-- Name: COLUMN tbl_exc.nr_nsu2_cli_exc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_exc.nr_nsu2_cli_exc IS 'numero de identificacao do cliente 2 para caso de clientes que possuem chave composta';


--
-- TOC entry 9306 (class 0 OID 0)
-- Dependencies: 568
-- Name: COLUMN tbl_exc.tp_lcl_exc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_exc.tp_lcl_exc IS 'tipo de local da excecao. ver tabela de dominio';


--
-- TOC entry 9307 (class 0 OID 0)
-- Dependencies: 568
-- Name: COLUMN tbl_exc.nr_nsu_lcl_exc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_exc.nr_nsu_lcl_exc IS 'numero de identificacao do local da excecao';


--
-- TOC entry 9308 (class 0 OID 0)
-- Dependencies: 568
-- Name: COLUMN tbl_exc.nr_nsu2_lcl_exc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_exc.nr_nsu2_lcl_exc IS 'numero de identificacao 2 do local da excecao. utilizado para os locais que possuem chave composta';


--
-- TOC entry 9309 (class 0 OID 0)
-- Dependencies: 568
-- Name: COLUMN tbl_exc.dt_ini_exc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_exc.dt_ini_exc IS 'data de inicio da excecao';


--
-- TOC entry 9310 (class 0 OID 0)
-- Dependencies: 568
-- Name: COLUMN tbl_exc.dt_fin_exc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_exc.dt_fin_exc IS 'data final de validacao da excecao';


--
-- TOC entry 569 (class 1259 OID 565897)
-- Name: tbl_hlm; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_hlm (
    cd_hlm numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    cd_tlt numeric(10,0) NOT NULL,
    vl_cnc_lmt_ant numeric(13,2),
    vl_cnc_lmt_atl numeric(13,2) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_hlm OWNER TO scan;

--
-- TOC entry 9311 (class 0 OID 0)
-- Dependencies: 569
-- Name: TABLE tbl_hlm; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_hlm IS 'HISTORICO LIMITE';


--
-- TOC entry 9312 (class 0 OID 0)
-- Dependencies: 569
-- Name: COLUMN tbl_hlm.cd_hlm; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_hlm.cd_hlm IS 'CODIGO';


--
-- TOC entry 9313 (class 0 OID 0)
-- Dependencies: 569
-- Name: COLUMN tbl_hlm.cd_crt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_hlm.cd_crt IS 'CARTAO';


--
-- TOC entry 9314 (class 0 OID 0)
-- Dependencies: 569
-- Name: COLUMN tbl_hlm.cd_tlt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_hlm.cd_tlt IS 'TIPO DE LIMITE';


--
-- TOC entry 9315 (class 0 OID 0)
-- Dependencies: 569
-- Name: COLUMN tbl_hlm.vl_cnc_lmt_ant; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_hlm.vl_cnc_lmt_ant IS 'VALOR CONCEDIDO ANTERIOR';


--
-- TOC entry 9316 (class 0 OID 0)
-- Dependencies: 569
-- Name: COLUMN tbl_hlm.vl_cnc_lmt_atl; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_hlm.vl_cnc_lmt_atl IS 'VALOR CONCEDIDO ATUAL';


--
-- TOC entry 9317 (class 0 OID 0)
-- Dependencies: 569
-- Name: COLUMN tbl_hlm.cd_inc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_hlm.cd_inc_usr IS 'USUARIO INCLUSAO';


--
-- TOC entry 9318 (class 0 OID 0)
-- Dependencies: 569
-- Name: COLUMN tbl_hlm.dt_inc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_hlm.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 570 (class 1259 OID 565900)
-- Name: tbl_lmt; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_lmt (
    cd_crt numeric(14,0) NOT NULL,
    cd_tlt numeric(2,0) NOT NULL,
    vl_cnc_lmt numeric(13,2) NOT NULL,
    vl_utl_lmt numeric(13,2) NOT NULL,
    vl_prc_lmt numeric(13,2),
    fg_snc_ctr_lmt character(1) DEFAULT 'S'::bpchar NOT NULL,
    fg_alt_lmt character varying(1) DEFAULT 'S'::character varying NOT NULL
);


ALTER TABLE tbl_lmt OWNER TO scan;

--
-- TOC entry 9319 (class 0 OID 0)
-- Dependencies: 570
-- Name: TABLE tbl_lmt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_lmt IS 'TABELA DE LIMITE DO CARTAO';


--
-- TOC entry 571 (class 1259 OID 565905)
-- Name: tbl_ocr; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_ocr (
    cd_ocr numeric(10,0) NOT NULL,
    cd_toc numeric(5,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    cd_pls numeric(16,0),
    nm_his_ocr character varying(200) NOT NULL,
    fg_atm_ocr character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone
);


ALTER TABLE tbl_ocr OWNER TO scan;

--
-- TOC entry 9320 (class 0 OID 0)
-- Dependencies: 571
-- Name: TABLE tbl_ocr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_ocr IS 'OCORRENCIA';


--
-- TOC entry 9321 (class 0 OID 0)
-- Dependencies: 571
-- Name: COLUMN tbl_ocr.cd_ocr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ocr.cd_ocr IS 'CODIGO';


--
-- TOC entry 9322 (class 0 OID 0)
-- Dependencies: 571
-- Name: COLUMN tbl_ocr.cd_toc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ocr.cd_toc IS 'TIPO DE OCORRENCIA';


--
-- TOC entry 9323 (class 0 OID 0)
-- Dependencies: 571
-- Name: COLUMN tbl_ocr.cd_crt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ocr.cd_crt IS 'CARTAO';


--
-- TOC entry 9324 (class 0 OID 0)
-- Dependencies: 571
-- Name: COLUMN tbl_ocr.cd_pls; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ocr.cd_pls IS 'PLASTICO';


--
-- TOC entry 9325 (class 0 OID 0)
-- Dependencies: 571
-- Name: COLUMN tbl_ocr.nm_his_ocr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ocr.nm_his_ocr IS 'HISTORICO';


--
-- TOC entry 9326 (class 0 OID 0)
-- Dependencies: 571
-- Name: COLUMN tbl_ocr.fg_atm_ocr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ocr.fg_atm_ocr IS 'FLAG DE AUTOMATICO';


--
-- TOC entry 9327 (class 0 OID 0)
-- Dependencies: 571
-- Name: COLUMN tbl_ocr.cd_inc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ocr.cd_inc_usr IS 'USUARIO INCLUSAO';


--
-- TOC entry 9328 (class 0 OID 0)
-- Dependencies: 571
-- Name: COLUMN tbl_ocr.dt_inc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_ocr.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 572 (class 1259 OID 565908)
-- Name: tbl_opr_pfc; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_opr_pfc (
    cd_opr numeric(10,0) NOT NULL,
    cd_pfc numeric(10,0) NOT NULL,
    vl_utl_pfc numeric(13,2)
);


ALTER TABLE tbl_opr_pfc OWNER TO scan;

--
-- TOC entry 573 (class 1259 OID 565911)
-- Name: tbl_opr_pfc2; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_opr_pfc2 (
    cd_opr numeric(10,0) NOT NULL,
    cd_pfc numeric(10,0) NOT NULL,
    vl_utl_pfc numeric(13,2)
);


ALTER TABLE tbl_opr_pfc2 OWNER TO scan;

--
-- TOC entry 574 (class 1259 OID 565914)
-- Name: tbl_opr_rst; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_opr_rst (
    cd_opr numeric(10,0) NOT NULL,
    vl_pgt_opr numeric(13,2),
    vl_opr numeric(13,2)
);


ALTER TABLE tbl_opr_rst OWNER TO scan;

--
-- TOC entry 575 (class 1259 OID 565917)
-- Name: tbl_opr_rst2; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_opr_rst2 (
    cd_opr numeric(10,0) NOT NULL,
    vl_pgt_opr numeric(13,2),
    vl_opr numeric(13,2)
);


ALTER TABLE tbl_opr_rst2 OWNER TO scan;

--
-- TOC entry 576 (class 1259 OID 565920)
-- Name: tbl_rst; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_rst (
    cd_rst numeric(20,0) NOT NULL,
    tp_cli_rst numeric(2,0) NOT NULL,
    nr_nsu_cli_rst numeric(20,0),
    nr_nsu2_cli_rst numeric(20,0),
    cd_top numeric(5,0) NOT NULL,
    tp_lcl_rst numeric(2,0) NOT NULL,
    nr_nsu_lcl_rst numeric(20,0),
    nr_nsu2_lcl_rst numeric(20,0),
    dt_ini_rst timestamp without time zone NOT NULL,
    dt_fin_rst timestamp without time zone,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    ds_mtv_rst character varying(200)
);


ALTER TABLE tbl_rst OWNER TO scan;

--
-- TOC entry 9329 (class 0 OID 0)
-- Dependencies: 576
-- Name: TABLE tbl_rst; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_rst IS 'tabela que armazena as restricoes de realizacao de determinadas operacoes, de determinados clientes, em determinados locais num determinado período de tempo';


--
-- TOC entry 9330 (class 0 OID 0)
-- Dependencies: 576
-- Name: COLUMN tbl_rst.cd_rst; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_rst.cd_rst IS 'codigo';


--
-- TOC entry 9331 (class 0 OID 0)
-- Dependencies: 576
-- Name: COLUMN tbl_rst.tp_cli_rst; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_rst.tp_cli_rst IS 'tipo de cliente que esta sofrendo a restricao. ver tabela de dominio';


--
-- TOC entry 9332 (class 0 OID 0)
-- Dependencies: 576
-- Name: COLUMN tbl_rst.nr_nsu_cli_rst; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_rst.nr_nsu_cli_rst IS 'numero de identificacao do cliente que esta sofrendo a restricao';


--
-- TOC entry 9333 (class 0 OID 0)
-- Dependencies: 576
-- Name: COLUMN tbl_rst.nr_nsu2_cli_rst; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_rst.nr_nsu2_cli_rst IS 'numero de identificacao do cliente 2 para caso de clientes que possuem chave composta';


--
-- TOC entry 9334 (class 0 OID 0)
-- Dependencies: 576
-- Name: COLUMN tbl_rst.cd_top; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_rst.cd_top IS 'tipo de operacao';


--
-- TOC entry 9335 (class 0 OID 0)
-- Dependencies: 576
-- Name: COLUMN tbl_rst.tp_lcl_rst; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_rst.tp_lcl_rst IS 'tipo de local da restricao. ver tabela de dominio';


--
-- TOC entry 9336 (class 0 OID 0)
-- Dependencies: 576
-- Name: COLUMN tbl_rst.nr_nsu_lcl_rst; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_rst.nr_nsu_lcl_rst IS 'numero de identificacao do local da restricao';


--
-- TOC entry 9337 (class 0 OID 0)
-- Dependencies: 576
-- Name: COLUMN tbl_rst.nr_nsu2_lcl_rst; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_rst.nr_nsu2_lcl_rst IS 'numero de identificacao 2 do local da restricao. utilizado para os locais que possuem chave composta';


--
-- TOC entry 9338 (class 0 OID 0)
-- Dependencies: 576
-- Name: COLUMN tbl_rst.dt_ini_rst; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_rst.dt_ini_rst IS 'data de inicio da restricao';


--
-- TOC entry 9339 (class 0 OID 0)
-- Dependencies: 576
-- Name: COLUMN tbl_rst.dt_fin_rst; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_rst.dt_fin_rst IS 'data final de validacao da restricao';


--
-- TOC entry 9340 (class 0 OID 0)
-- Dependencies: 576
-- Name: COLUMN tbl_rst.ds_mtv_rst; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_rst.ds_mtv_rst IS 'Descrição do Motivo da Restrição';


--
-- TOC entry 577 (class 1259 OID 565923)
-- Name: tbl_sqm; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_sqm (
    cd_sqm numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    vl_sld_crt numeric(13,2) NOT NULL,
    vl_saq_sqm numeric(13,2) NOT NULL,
    st_sqm numeric(2,0) NOT NULL,
    tp_doc_sqm numeric(2,0) NOT NULL,
    cd_crt_opr numeric(14,0) NOT NULL,
    dt_ref_sqm date NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    vl_trf_sqm numeric(13,2)
);


ALTER TABLE tbl_sqm OWNER TO scan;

--
-- TOC entry 9341 (class 0 OID 0)
-- Dependencies: 577
-- Name: TABLE tbl_sqm; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_sqm IS 'TABELA DE SAQUE MANUAL';


--
-- TOC entry 9342 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.cd_sqm; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.cd_sqm IS 'CODIGO';


--
-- TOC entry 9343 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.cd_crt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.cd_crt IS 'CODIGO DO CARTAO DO CLIENTE';


--
-- TOC entry 9344 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.vl_sld_crt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.vl_sld_crt IS 'VALOR DO SALDO DO CARTAO NO ATO DO SAQUE MANUAL';


--
-- TOC entry 9345 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.vl_saq_sqm; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.vl_saq_sqm IS 'VALOR A SER SACADO NO SAQUE MANUAL';


--
-- TOC entry 9346 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.st_sqm; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.st_sqm IS 'SITUACAO DO SAQUE MANUAL (VER DOMINIO)';


--
-- TOC entry 9347 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.tp_doc_sqm; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.tp_doc_sqm IS 'TIPO DE DOCUMENTO APRESENTADO PARA REALIZAR O SAQUE MANUAL(VER DOMINIO)';


--
-- TOC entry 9348 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.cd_crt_opr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.cd_crt_opr IS 'CODIGO DO CARTAO OPERADOR QUE IRÁ REALIZAR O SAQUE MANUAL';


--
-- TOC entry 9349 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.dt_ref_sqm; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.dt_ref_sqm IS 'DATA DE REFERENCIA DO SAQUE MANUAL';


--
-- TOC entry 9350 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.cd_inc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.cd_inc_usr IS 'USUARIO INCLUSAO';


--
-- TOC entry 9351 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.dt_inc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 9352 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.cd_alt_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.cd_alt_usr IS 'USUARIO ALTERACAO';


--
-- TOC entry 9353 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.dt_alt_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.dt_alt_usr IS 'DATA ALTERACAO';


--
-- TOC entry 9354 (class 0 OID 0)
-- Dependencies: 577
-- Name: COLUMN tbl_sqm.vl_trf_sqm; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_sqm.vl_trf_sqm IS 'VALOR DA TARIFA COBRADA PARA REALIZAR O SAQUE MANUAL';


--
-- TOC entry 578 (class 1259 OID 565926)
-- Name: tbl_tbl; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_tbl (
    cd_tbl numeric(5,0) NOT NULL,
    nm_tbl character varying(50),
    fg_dfn_tbl character(1) DEFAULT 'N'::bpchar NOT NULL,
    fg_atm_tbl character(1) DEFAULT 'N'::bpchar NOT NULL,
    CONSTRAINT ck_fg_atm_tbl CHECK ((fg_atm_tbl = ANY (ARRAY['N'::bpchar, 'S'::bpchar]))),
    CONSTRAINT ck_fg_dfn_tbl CHECK ((fg_dfn_tbl = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_tbl OWNER TO scan;

--
-- TOC entry 9355 (class 0 OID 0)
-- Dependencies: 578
-- Name: TABLE tbl_tbl; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_tbl IS 'tabela de tipo de bloqueio de plastico';


--
-- TOC entry 9356 (class 0 OID 0)
-- Dependencies: 578
-- Name: COLUMN tbl_tbl.cd_tbl; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tbl.cd_tbl IS 'codigo';


--
-- TOC entry 9357 (class 0 OID 0)
-- Dependencies: 578
-- Name: COLUMN tbl_tbl.nm_tbl; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tbl.nm_tbl IS 'descricao';


--
-- TOC entry 9358 (class 0 OID 0)
-- Dependencies: 578
-- Name: COLUMN tbl_tbl.fg_dfn_tbl; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tbl.fg_dfn_tbl IS 'flag de definitivo';


--
-- TOC entry 9359 (class 0 OID 0)
-- Dependencies: 578
-- Name: COLUMN tbl_tbl.fg_atm_tbl; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tbl.fg_atm_tbl IS 'flag de desbloqueio por ATM';


--
-- TOC entry 579 (class 1259 OID 565933)
-- Name: tbl_tlt; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_tlt (
    cd_tlt numeric(2,0) NOT NULL,
    nm_tlt character varying(40),
    nr_pri_tlt numeric(2,0) NOT NULL,
    vl_var_tlt numeric(13,2)
);


ALTER TABLE tbl_tlt OWNER TO scan;

--
-- TOC entry 9360 (class 0 OID 0)
-- Dependencies: 579
-- Name: TABLE tbl_tlt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_tlt IS 'TABELA DE TIPO DE LIMITE';


--
-- TOC entry 9361 (class 0 OID 0)
-- Dependencies: 579
-- Name: COLUMN tbl_tlt.cd_tlt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tlt.cd_tlt IS 'CODIGO';


--
-- TOC entry 9362 (class 0 OID 0)
-- Dependencies: 579
-- Name: COLUMN tbl_tlt.nm_tlt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tlt.nm_tlt IS 'DESCRICAO';


--
-- TOC entry 9363 (class 0 OID 0)
-- Dependencies: 579
-- Name: COLUMN tbl_tlt.nr_pri_tlt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tlt.nr_pri_tlt IS 'Prioridade de restituicao do limite';


--
-- TOC entry 580 (class 1259 OID 565936)
-- Name: tbl_toc; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_toc (
    cd_toc numeric(5,0) NOT NULL,
    nm_toc character varying(100) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_toc OWNER TO scan;

--
-- TOC entry 9364 (class 0 OID 0)
-- Dependencies: 580
-- Name: TABLE tbl_toc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_toc IS 'TIPO DE OCORRENCIA';


--
-- TOC entry 9365 (class 0 OID 0)
-- Dependencies: 580
-- Name: COLUMN tbl_toc.cd_toc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_toc.cd_toc IS 'CODIGO';


--
-- TOC entry 9366 (class 0 OID 0)
-- Dependencies: 580
-- Name: COLUMN tbl_toc.nm_toc; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_toc.nm_toc IS 'NOME';


--
-- TOC entry 9367 (class 0 OID 0)
-- Dependencies: 580
-- Name: COLUMN tbl_toc.cd_inc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_toc.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9368 (class 0 OID 0)
-- Dependencies: 580
-- Name: COLUMN tbl_toc.dt_inc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_toc.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9369 (class 0 OID 0)
-- Dependencies: 580
-- Name: COLUMN tbl_toc.cd_alt_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_toc.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 9370 (class 0 OID 0)
-- Dependencies: 580
-- Name: COLUMN tbl_toc.dt_alt_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_toc.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 581 (class 1259 OID 565939)
-- Name: tbl_top_atm; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_top_atm (
    cd_atm numeric(5,0) NOT NULL,
    cd_top numeric(5,0) NOT NULL,
    dt_top_atm timestamp without time zone NOT NULL
)
WITH (autovacuum_enabled='false');


ALTER TABLE tbl_top_atm OWNER TO scan;

--
-- TOC entry 9371 (class 0 OID 0)
-- Dependencies: 581
-- Name: TABLE tbl_top_atm; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_top_atm IS 'TABELA DA ULTIMA OPERACAO POR ATM';


--
-- TOC entry 9372 (class 0 OID 0)
-- Dependencies: 581
-- Name: COLUMN tbl_top_atm.cd_atm; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_top_atm.cd_atm IS 'CODIGO DO ATM';


--
-- TOC entry 9373 (class 0 OID 0)
-- Dependencies: 581
-- Name: COLUMN tbl_top_atm.cd_top; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_top_atm.cd_top IS 'CODIGO DO TIPO DE OPERACAO';


--
-- TOC entry 9374 (class 0 OID 0)
-- Dependencies: 581
-- Name: COLUMN tbl_top_atm.dt_top_atm; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_top_atm.dt_top_atm IS 'DATA DA ULTIMA OPERACAO DO ATM';


--
-- TOC entry 582 (class 1259 OID 565942)
-- Name: tbl_top_tlt; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_top_tlt (
    cd_top_tlt numeric(5,0) NOT NULL,
    cd_top numeric(5,0) NOT NULL,
    cd_tlt numeric(5,0) NOT NULL,
    fg_aut_top_tlt character(1) NOT NULL,
    fg_csm_top_tlt character(1) NOT NULL,
    CONSTRAINT ck_fg_aut_top_tlt CHECK ((fg_aut_top_tlt = ANY (ARRAY['N'::bpchar, 'S'::bpchar]))),
    CONSTRAINT ck_fg_csm_top_tlt CHECK ((fg_csm_top_tlt = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_top_tlt OWNER TO scan;

--
-- TOC entry 9375 (class 0 OID 0)
-- Dependencies: 582
-- Name: TABLE tbl_top_tlt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_top_tlt IS 'tabela de relacionamento entre o tipo de operacao e o tipo de limite';


--
-- TOC entry 9376 (class 0 OID 0)
-- Dependencies: 582
-- Name: COLUMN tbl_top_tlt.cd_top_tlt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_top_tlt.cd_top_tlt IS 'codigo';


--
-- TOC entry 9377 (class 0 OID 0)
-- Dependencies: 582
-- Name: COLUMN tbl_top_tlt.cd_top; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_top_tlt.cd_top IS 'tipo de operacao';


--
-- TOC entry 9378 (class 0 OID 0)
-- Dependencies: 582
-- Name: COLUMN tbl_top_tlt.cd_tlt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_top_tlt.cd_tlt IS 'tipo de limite';


--
-- TOC entry 9379 (class 0 OID 0)
-- Dependencies: 582
-- Name: COLUMN tbl_top_tlt.fg_aut_top_tlt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_top_tlt.fg_aut_top_tlt IS 'flag de autorizacao. Indica se o cartão deve possuir determinado tipo de limite para realizar determinado tipo de operacao';


--
-- TOC entry 9380 (class 0 OID 0)
-- Dependencies: 582
-- Name: COLUMN tbl_top_tlt.fg_csm_top_tlt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_top_tlt.fg_csm_top_tlt IS 'flag de consumo. indica que no momento da autorizacao do determinado tipo de operacao deve ser consumido determinado tipo de limite';


--
-- TOC entry 583 (class 1259 OID 565947)
-- Name: tbl_tvt; Type: TABLE; Schema: sc_opr; Owner: scan
--

CREATE TABLE tbl_tvt (
    cd_tvt numeric(5,0) NOT NULL,
    nm_tvt character varying(50),
    fg_atv_tvt character(1),
    cd_inc_usr numeric(5,0),
    dt_inc_usr timestamp without time zone,
    cd_alt_usr numeric(5,0),
    dt_alt_usr timestamp without time zone,
    CONSTRAINT ck_fg_atv_tvt CHECK ((fg_atv_tvt = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_tvt OWNER TO scan;

--
-- TOC entry 9381 (class 0 OID 0)
-- Dependencies: 583
-- Name: TABLE tbl_tvt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON TABLE tbl_tvt IS 'tabela de valores de tarifas';


--
-- TOC entry 9382 (class 0 OID 0)
-- Dependencies: 583
-- Name: COLUMN tbl_tvt.cd_tvt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tvt.cd_tvt IS 'codigo';


--
-- TOC entry 9383 (class 0 OID 0)
-- Dependencies: 583
-- Name: COLUMN tbl_tvt.nm_tvt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tvt.nm_tvt IS 'descricao';


--
-- TOC entry 9384 (class 0 OID 0)
-- Dependencies: 583
-- Name: COLUMN tbl_tvt.fg_atv_tvt; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tvt.fg_atv_tvt IS 'flag de ativo';


--
-- TOC entry 9385 (class 0 OID 0)
-- Dependencies: 583
-- Name: COLUMN tbl_tvt.cd_inc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tvt.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 9386 (class 0 OID 0)
-- Dependencies: 583
-- Name: COLUMN tbl_tvt.dt_inc_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tvt.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 9387 (class 0 OID 0)
-- Dependencies: 583
-- Name: COLUMN tbl_tvt.cd_alt_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tvt.cd_alt_usr IS 'codigo do usuario que realizou a ultima alteracao';


--
-- TOC entry 9388 (class 0 OID 0)
-- Dependencies: 583
-- Name: COLUMN tbl_tvt.dt_alt_usr; Type: COMMENT; Schema: sc_opr; Owner: scan
--

COMMENT ON COLUMN tbl_tvt.dt_alt_usr IS 'data da ultima alteracao';


--
-- TOC entry 865 (class 1259 OID 942542)
-- Name: vw_consulta_milagrosa_central_atendimento; Type: VIEW; Schema: sc_opr; Owner: scan
--

CREATE VIEW vw_consulta_milagrosa_central_atendimento AS
SELECT pls.cd_pls, ((((((((((pls.cd_pls || ';'::text) || cun.nr_cpf_cnpj_cun) || ';'::text) || CASE WHEN (cun.tp_pss_cun = 'F'::bpchar) THEN replace(replace(to_char(cun.nr_cpf_cnpj_cun, '000#000#000-00'::text), '#'::text, '.'::text), ' '::text, ''::text) ELSE NULL::text END) || ';'::text) || (cun.nm_cun)::text) || ';'::text) || (emp.nm_emp)::text) || ';'::text) || (fem.nm_fem)::text) AS consulta FROM (((((tbl_pls pls JOIN sc_cad.tbl_cun cun ON ((cun.cd_cun = pls.cd_cun))) JOIN tbl_crt crt ON ((crt.cd_crt = pls.cd_crt))) JOIN sc_cad.tbl_fnc fnc ON ((fnc.cd_fnc = crt.cd_fnc))) JOIN sc_cad.tbl_emp emp ON ((emp.cd_emp = fnc.cd_emp))) JOIN sc_cad.tbl_fem fem ON (((fem.cd_emp = fnc.cd_emp) AND (fem.cd_fem = fnc.cd_fem))));


ALTER TABLE vw_consulta_milagrosa_central_atendimento OWNER TO scan;

--
-- TOC entry 584 (class 1259 OID 565951)
-- Name: vw_crt; Type: VIEW; Schema: sc_opr; Owner: scan
--

CREATE VIEW vw_crt AS
SELECT crt.cd_crt AS cartao, ((cun.nm_cun)::text || CASE WHEN (crt.fg_atv_crt = 'S'::"char") THEN ' (CARTÃO ATIVO)'::text ELSE ' (CARTÃO INATIVO)'::text END) AS nome, cun.nm_cun AS funcionario FROM ((tbl_crt crt JOIN sc_cad.tbl_fnc fnc ON ((fnc.cd_fnc = crt.cd_fnc))) JOIN sc_cad.tbl_cun cun ON ((cun.cd_cun = fnc.cd_cun)));


ALTER TABLE vw_crt OWNER TO scan;

--
-- TOC entry 585 (class 1259 OID 565956)
-- Name: vw_saldo_descontar_arquivos; Type: VIEW; Schema: sc_opr; Owner: scan
--

CREATE VIEW vw_saldo_descontar_arquivos AS
SELECT x.grupo_empresarial, x.nome_grupo_empresarial, x.situacao, x.valor FROM (SELECT g.cd_gem AS grupo_empresarial, g.nm_gem AS nome_grupo_empresarial, h.st_hfe AS situacao, COALESCE(sum(COALESCE(CASE WHEN (f.vl_sld_dvd_fcr > r.vl_dep_rdp) THEN r.vl_dep_rdp ELSE f.vl_sld_dvd_fcr END, (0)::numeric)), (0)::numeric) AS valor FROM (((((sc_adp.tbl_rdp r JOIN sc_adp.tbl_hfe h ON ((h.cd_hfe = r.cd_hfe))) JOIN sc_cad.tbl_emp e ON ((e.cd_emp = h.cd_emp))) JOIN sc_cad.tbl_gem g ON ((g.cd_gem = e.cd_gem))) JOIN tbl_crt c ON ((c.cd_crt = r.cd_crt))) JOIN sc_fcr.tbl_fcr f ON ((f.cd_fcr = c.cd_fcr))) WHERE (r.st_rdp = (2)::numeric) GROUP BY g.cd_gem, g.nm_gem, h.st_hfe) x WHERE (x.valor > (0)::numeric);


ALTER TABLE vw_saldo_descontar_arquivos OWNER TO scan;

--
-- TOC entry 586 (class 1259 OID 565961)
-- Name: vw_saldo_empresa; Type: VIEW; Schema: sc_opr; Owner: scan
--

CREATE VIEW vw_saldo_empresa AS
SELECT x.empresa, x.nome_empresa, x.filial, x.nome_filial, x.saldo FROM (SELECT gem.cd_gem AS empresa, gem.nm_gem AS nome_empresa, 1 AS filial, 'FILIAL' AS nome_filial, sum(COALESCE(cnt.vl_sld_cnt, (0)::numeric)) AS saldo FROM (((((tbl_cnt_crt cnt_crt JOIN sc_cnt.tbl_cnt cnt ON ((cnt.cd_cnt = cnt_crt.cd_cnt))) JOIN tbl_crt crt ON ((crt.cd_crt = cnt_crt.cd_crt))) JOIN sc_cad.tbl_fnc fnc ON ((fnc.cd_fnc = crt.cd_fnc))) JOIN sc_cad.tbl_emp emp ON ((emp.cd_emp = fnc.cd_emp))) JOIN sc_cad.tbl_gem gem ON ((gem.cd_gem = emp.cd_gem))) GROUP BY gem.cd_gem, gem.nm_gem) x WHERE (x.saldo > (0)::numeric);


ALTER TABLE vw_saldo_empresa OWNER TO scan;

--
-- TOC entry 587 (class 1259 OID 565966)
-- Name: vw_saldo_empresa_sem_movimentacao; Type: VIEW; Schema: sc_opr; Owner: scan
--

CREATE VIEW vw_saldo_empresa_sem_movimentacao AS
SELECT x.grupo_empresarial, x.nome_grupo_empresarial, x.saldo FROM (SELECT g.cd_gem AS grupo_empresarial, g.nm_gem AS nome_grupo_empresarial, sum(COALESCE(cnt.vl_sld_cnt, (0)::numeric)) AS saldo FROM (((((tbl_cnt_crt cnt_crt JOIN sc_cnt.tbl_cnt cnt ON ((cnt.cd_cnt = cnt_crt.cd_cnt))) JOIN tbl_crt crt ON ((crt.cd_crt = cnt_crt.cd_crt))) JOIN sc_cad.tbl_fnc fnc ON ((fnc.cd_fnc = crt.cd_fnc))) JOIN sc_cad.tbl_emp emp ON ((emp.cd_emp = fnc.cd_emp))) JOIN sc_cad.tbl_gem g ON ((g.cd_gem = emp.cd_gem))) WHERE ((NOT (EXISTS (SELECT 1 FROM sc_cnt.tbl_lcn lcn WHERE (((lcn.cd_cnt = cnt.cd_cnt) AND (lcn.dt_ref_lcn >= (('now'::text)::date - 60))) AND (lcn.cd_tlc = ANY (ARRAY[(13)::numeric, (93)::numeric])))))) AND (cnt.dt_inc_usr <= (('now'::text)::date - 60))) GROUP BY g.cd_gem, g.nm_gem) x WHERE (x.saldo > (0)::numeric);


ALTER TABLE vw_saldo_empresa_sem_movimentacao OWNER TO scan;

SET search_path = sc_opr_exp, pg_catalog;

--
-- TOC entry 927 (class 1259 OID 1040616)
-- Name: tbl_dos; Type: TABLE; Schema: sc_opr_exp; Owner: scan
--

CREATE TABLE tbl_dos (
    cd_dos numeric(15,0) NOT NULL,
    cd_opr numeric(10,0) NOT NULL,
    nm_ltr_dos "char" NOT NULL,
    nr_cdl_dos numeric(5,0) NOT NULL,
    vl_cdl_dos numeric(13,2) NOT NULL,
    nr_ttl_cdl_dos numeric(5,0) NOT NULL,
    nr_cdl_rjt_dos numeric(5,0) DEFAULT 0 NOT NULL
);


ALTER TABLE tbl_dos OWNER TO scan;

--
-- TOC entry 9389 (class 0 OID 0)
-- Dependencies: 927
-- Name: TABLE tbl_dos; Type: COMMENT; Schema: sc_opr_exp; Owner: scan
--

COMMENT ON TABLE tbl_dos IS 'TABELA DE DETALHE DA OPERACAO DE SAQUE';


SET search_path = sc_pbl, pg_catalog;

--
-- TOC entry 588 (class 1259 OID 565971)
-- Name: tbl_frd; Type: TABLE; Schema: sc_pbl; Owner: scan
--

CREATE TABLE tbl_frd (
    dt_frd date NOT NULL,
    ds_frd character varying(80) NOT NULL,
    tp_frd character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_frd OWNER TO scan;

--
-- TOC entry 9390 (class 0 OID 0)
-- Dependencies: 588
-- Name: TABLE tbl_frd; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON TABLE tbl_frd IS 'FERIADO';


--
-- TOC entry 9391 (class 0 OID 0)
-- Dependencies: 588
-- Name: COLUMN tbl_frd.dt_frd; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_frd.dt_frd IS 'DATA';


--
-- TOC entry 9392 (class 0 OID 0)
-- Dependencies: 588
-- Name: COLUMN tbl_frd.ds_frd; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_frd.ds_frd IS 'DESCRICAO';


--
-- TOC entry 9393 (class 0 OID 0)
-- Dependencies: 588
-- Name: COLUMN tbl_frd.tp_frd; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_frd.tp_frd IS 'TIPO (E-ESTADUAL,M-MUNICIPAL,F-FEDERAL)';


--
-- TOC entry 9394 (class 0 OID 0)
-- Dependencies: 588
-- Name: COLUMN tbl_frd.cd_inc_usr; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_frd.cd_inc_usr IS 'USUARIO INCLUSAO';


--
-- TOC entry 9395 (class 0 OID 0)
-- Dependencies: 588
-- Name: COLUMN tbl_frd.dt_inc_usr; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_frd.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 9396 (class 0 OID 0)
-- Dependencies: 588
-- Name: COLUMN tbl_frd.cd_alt_usr; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_frd.cd_alt_usr IS 'USUARIO ALTERACAO';


--
-- TOC entry 9397 (class 0 OID 0)
-- Dependencies: 588
-- Name: COLUMN tbl_frd.dt_alt_usr; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_frd.dt_alt_usr IS 'DATA ALTERACAO';


--
-- TOC entry 589 (class 1259 OID 565974)
-- Name: tbl_ftp; Type: TABLE; Schema: sc_pbl; Owner: scan
--

CREATE TABLE tbl_ftp (
    cd_ftp numeric(2,0) NOT NULL,
    ds_ftp character varying(50) NOT NULL,
    nm_hst_ftp character varying(50) NOT NULL,
    nm_usr_ftp character varying(30) NOT NULL,
    nm_dir_hst_ftp character varying(50),
    nr_prt_ftp numeric(5,0) NOT NULL,
    nm_eml_scs_ftp character varying(200),
    nm_eml_err_ftp character varying(200),
    nm_snh_ftp character varying(20),
    nm_ftp character varying(50) NOT NULL,
    nm_dir_hst_ltr_ftp character varying(100),
    ext_arq_hst_ltr_ftp character varying(20),
    flag_passivo character(1)
);


ALTER TABLE tbl_ftp OWNER TO scan;

--
-- TOC entry 9398 (class 0 OID 0)
-- Dependencies: 589
-- Name: COLUMN tbl_ftp.flag_passivo; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_ftp.flag_passivo IS 'Modo de conexao ao servidor FTP. Se for nulo ou igual a ''S'' o modo de conexão será passivo, caso contrário será ativo.';


--
-- TOC entry 590 (class 1259 OID 565980)
-- Name: tbl_upl; Type: TABLE; Schema: sc_pbl; Owner: scan
--

CREATE TABLE tbl_upl (
    cd_upl numeric(10,0) NOT NULL,
    nm_arq_ajl_upl character varying(100) NOT NULL,
    nm_lbl_upl character varying(50),
    nm_dir_arq_upl character varying(100) NOT NULL,
    nm_class_vld_upl character varying(200),
    fg_prc_upl character varying(1) NOT NULL
);


ALTER TABLE tbl_upl OWNER TO scan;

--
-- TOC entry 9399 (class 0 OID 0)
-- Dependencies: 590
-- Name: TABLE tbl_upl; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON TABLE tbl_upl IS 'Tabela de Uploads';


--
-- TOC entry 9400 (class 0 OID 0)
-- Dependencies: 590
-- Name: COLUMN tbl_upl.cd_upl; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_upl.cd_upl IS 'CODIGO';


--
-- TOC entry 9401 (class 0 OID 0)
-- Dependencies: 590
-- Name: COLUMN tbl_upl.nm_arq_ajl_upl; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_upl.nm_arq_ajl_upl IS 'NOME DO ARQUIVO DO AJL';


--
-- TOC entry 9402 (class 0 OID 0)
-- Dependencies: 590
-- Name: COLUMN tbl_upl.nm_lbl_upl; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_upl.nm_lbl_upl IS 'NOME DA TELA DE UPLOAD';


--
-- TOC entry 9403 (class 0 OID 0)
-- Dependencies: 590
-- Name: COLUMN tbl_upl.nm_dir_arq_upl; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_upl.nm_dir_arq_upl IS 'DIRETORIO DE ONDE SE ENCONTRA O ARQUIVO DO AJL';


--
-- TOC entry 9404 (class 0 OID 0)
-- Dependencies: 590
-- Name: COLUMN tbl_upl.nm_class_vld_upl; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_upl.nm_class_vld_upl IS 'CAMINHO DA CLASSE DE VALIDACAO DO ARQUIVO';


--
-- TOC entry 9405 (class 0 OID 0)
-- Dependencies: 590
-- Name: COLUMN tbl_upl.fg_prc_upl; Type: COMMENT; Schema: sc_pbl; Owner: scan
--

COMMENT ON COLUMN tbl_upl.fg_prc_upl IS 'FLAG DE PROCESSAR O ARQUIVO';


SET search_path = sc_pgc, pg_catalog;

--
-- TOC entry 833 (class 1259 OID 889067)
-- Name: sq_cnc; Type: SEQUENCE; Schema: sc_pgc; Owner: scan
--

CREATE SEQUENCE sq_cnc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_cnc OWNER TO scan;

--
-- TOC entry 827 (class 1259 OID 889036)
-- Name: sq_crr; Type: SEQUENCE; Schema: sc_pgc; Owner: scan
--

CREATE SEQUENCE sq_crr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_crr OWNER TO scan;

--
-- TOC entry 906 (class 1259 OID 1004321)
-- Name: sq_lgt; Type: SEQUENCE; Schema: sc_pgc; Owner: scan
--

CREATE SEQUENCE sq_lgt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_lgt OWNER TO scan;

--
-- TOC entry 925 (class 1259 OID 1034210)
-- Name: sq_pga; Type: SEQUENCE; Schema: sc_pgc; Owner: scan
--

CREATE SEQUENCE sq_pga
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_pga OWNER TO scan;

--
-- TOC entry 829 (class 1259 OID 889048)
-- Name: sq_pgt; Type: SEQUENCE; Schema: sc_pgc; Owner: scan
--

CREATE SEQUENCE sq_pgt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_pgt OWNER TO scan;

--
-- TOC entry 831 (class 1259 OID 889055)
-- Name: sq_sgt; Type: SEQUENCE; Schema: sc_pgc; Owner: scan
--

CREATE SEQUENCE sq_sgt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_sgt OWNER TO scan;

--
-- TOC entry 832 (class 1259 OID 889057)
-- Name: tbl_cnc; Type: TABLE; Schema: sc_pgc; Owner: scan
--

CREATE TABLE tbl_cnc (
    cd_cnc numeric(10,0) NOT NULL,
    cd_sgt numeric(10,0) NOT NULL,
    nm_cnc character varying(200) NOT NULL,
    fg_atv_cnc character varying(1) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_cnc OWNER TO scan;

--
-- TOC entry 9406 (class 0 OID 0)
-- Dependencies: 832
-- Name: TABLE tbl_cnc; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON TABLE tbl_cnc IS 'CONCESSIONARIA';


--
-- TOC entry 9407 (class 0 OID 0)
-- Dependencies: 832
-- Name: COLUMN tbl_cnc.cd_cnc; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_cnc.cd_cnc IS 'CODIGO';


--
-- TOC entry 9408 (class 0 OID 0)
-- Dependencies: 832
-- Name: COLUMN tbl_cnc.cd_sgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_cnc.cd_sgt IS 'SEGMENTO';


--
-- TOC entry 9409 (class 0 OID 0)
-- Dependencies: 832
-- Name: COLUMN tbl_cnc.nm_cnc; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_cnc.nm_cnc IS 'NOME';


--
-- TOC entry 9410 (class 0 OID 0)
-- Dependencies: 832
-- Name: COLUMN tbl_cnc.fg_atv_cnc; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_cnc.fg_atv_cnc IS 'FLAG ATIVO';


--
-- TOC entry 9411 (class 0 OID 0)
-- Dependencies: 832
-- Name: COLUMN tbl_cnc.dt_inc_usr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_cnc.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9412 (class 0 OID 0)
-- Dependencies: 832
-- Name: COLUMN tbl_cnc.dt_alt_usr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_cnc.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 826 (class 1259 OID 889031)
-- Name: tbl_crr; Type: TABLE; Schema: sc_pgc; Owner: scan
--

CREATE TABLE tbl_crr (
    cd_crr numeric(5,0) NOT NULL,
    ds_crr character varying(50) NOT NULL,
    fg_atv_crr character varying(1) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_cnt numeric(10,0) NOT NULL,
    vl_lmt_dia_crr numeric(13,2),
    cd_frn numeric(10,0)
);


ALTER TABLE tbl_crr OWNER TO scan;

--
-- TOC entry 9413 (class 0 OID 0)
-- Dependencies: 826
-- Name: TABLE tbl_crr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON TABLE tbl_crr IS 'CORRESPONDENTE BANCARIO';


--
-- TOC entry 9414 (class 0 OID 0)
-- Dependencies: 826
-- Name: COLUMN tbl_crr.cd_crr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_crr.cd_crr IS 'CODIGO';


--
-- TOC entry 9415 (class 0 OID 0)
-- Dependencies: 826
-- Name: COLUMN tbl_crr.ds_crr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_crr.ds_crr IS 'DESCRICAO';


--
-- TOC entry 9416 (class 0 OID 0)
-- Dependencies: 826
-- Name: COLUMN tbl_crr.fg_atv_crr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_crr.fg_atv_crr IS 'FLAG ATIVO';


--
-- TOC entry 9417 (class 0 OID 0)
-- Dependencies: 826
-- Name: COLUMN tbl_crr.dt_inc_usr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_crr.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 9418 (class 0 OID 0)
-- Dependencies: 826
-- Name: COLUMN tbl_crr.dt_alt_usr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_crr.dt_alt_usr IS 'DATA ALTERACAO';


--
-- TOC entry 9419 (class 0 OID 0)
-- Dependencies: 826
-- Name: COLUMN tbl_crr.cd_cnt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_crr.cd_cnt IS 'código da conta de contabilização';


--
-- TOC entry 9420 (class 0 OID 0)
-- Dependencies: 826
-- Name: COLUMN tbl_crr.vl_lmt_dia_crr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_crr.vl_lmt_dia_crr IS 'valor do limite diário de pagamento do correspondente, se não houver limite, este campo deve ser nulo ou zero';


--
-- TOC entry 9421 (class 0 OID 0)
-- Dependencies: 826
-- Name: COLUMN tbl_crr.cd_frn; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_crr.cd_frn IS 'código do fornecedor';


--
-- TOC entry 905 (class 1259 OID 1004304)
-- Name: tbl_lgt; Type: TABLE; Schema: sc_pgc; Owner: scan
--

CREATE TABLE tbl_lgt (
    cd_lgt numeric(10,0) NOT NULL,
    cd_pgt numeric(10,0),
    tp_tsc_lgt numeric(5,0),
    dt_env_lgt timestamp without time zone,
    dt_ret_lgt timestamp without time zone,
    xml_env_lgt character varying(8000),
    xml_ret_lgt character varying(8000)
);


ALTER TABLE tbl_lgt OWNER TO scan;

--
-- TOC entry 9422 (class 0 OID 0)
-- Dependencies: 905
-- Name: TABLE tbl_lgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON TABLE tbl_lgt IS 'tabela de log de transacao de pagamento de contas';


--
-- TOC entry 9423 (class 0 OID 0)
-- Dependencies: 905
-- Name: COLUMN tbl_lgt.cd_lgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_lgt.cd_lgt IS 'codigo';


--
-- TOC entry 9424 (class 0 OID 0)
-- Dependencies: 905
-- Name: COLUMN tbl_lgt.cd_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_lgt.cd_pgt IS 'codigo do pagamento';


--
-- TOC entry 9425 (class 0 OID 0)
-- Dependencies: 905
-- Name: COLUMN tbl_lgt.tp_tsc_lgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_lgt.tp_tsc_lgt IS 'tipo de transacao';


--
-- TOC entry 9426 (class 0 OID 0)
-- Dependencies: 905
-- Name: COLUMN tbl_lgt.dt_env_lgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_lgt.dt_env_lgt IS 'data do envio';


--
-- TOC entry 9427 (class 0 OID 0)
-- Dependencies: 905
-- Name: COLUMN tbl_lgt.dt_ret_lgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_lgt.dt_ret_lgt IS 'data do retorno';


--
-- TOC entry 9428 (class 0 OID 0)
-- Dependencies: 905
-- Name: COLUMN tbl_lgt.xml_env_lgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_lgt.xml_env_lgt IS 'dados de envio';


--
-- TOC entry 926 (class 1259 OID 1034212)
-- Name: tbl_pga; Type: TABLE; Schema: sc_pgc; Owner: scan
--

CREATE TABLE tbl_pga (
    cd_pga numeric(10,0) NOT NULL,
    cd_pgt numeric(10,0),
    cd_crr numeric(5,0) NOT NULL,
    tp_org_pgt numeric(2,0) NOT NULL,
    nsu_org_pga character varying(50) NOT NULL,
    tp_dsp_pgt numeric(2,0) NOT NULL,
    nsu_dsp_pga character varying(100) NOT NULL,
    lnh_dgt_pga character varying(48),
    cd_brr_pga character varying(48),
    dt_vnc_pga date,
    dt_pga date NOT NULL,
    vl_pga numeric(13,2) NOT NULL,
    vl_dcm_pga numeric(13,2) NOT NULL,
    tp_pgt numeric(2,0) NOT NULL,
    st_pgt numeric(2,0) NOT NULL,
    obs_pga character varying(200),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    nm_ret_pga text
);


ALTER TABLE tbl_pga OWNER TO scan;

--
-- TOC entry 828 (class 1259 OID 889038)
-- Name: tbl_pgt; Type: TABLE; Schema: sc_pgc; Owner: scan
--

CREATE TABLE tbl_pgt (
    cd_pgt numeric(10,0) NOT NULL,
    cd_crr numeric(5,0) NOT NULL,
    tp_org_pgt numeric(2,0) NOT NULL,
    nsu_org_pgt character varying(50) NOT NULL,
    tp_dsp_pgt numeric(2,0) NOT NULL,
    nsu_dsp_pgt character varying(100) NOT NULL,
    cd_brr_pgt character varying(48),
    lnh_dgt_pgt character varying(48),
    dt_vnc_pgt date,
    dt_pgt date NOT NULL,
    vl_pgt numeric(13,2) NOT NULL,
    vl_dcm_pgt numeric(13,2) NOT NULL,
    tp_pgt numeric(2,0) NOT NULL,
    st_pgt numeric(2,0) NOT NULL,
    obs_pgt character varying(200),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_rtn_cnc_pgt character varying(20),
    msg_rtn_cnc_pgt character varying(2000),
    cd_rtn_aut_pgt character varying(100),
    cd_aut_pgt character varying(100),
    dt_ctb_pgt timestamp without time zone,
    dt_efv_rtn_pgt date,
    nsu_rtn_pgt character varying(80),
    rcb_rtn_pgt character varying(4000),
    vl_jrs_pgt numeric(13,2),
    vl_mlt_pgt numeric(13,2),
    vl_dsc_pgt numeric(13,2),
    cd_bnc numeric(5,0),
    nm_cnc_pgt character varying(200),
    nm_bnf_pgt character varying(200),
    nm_pgd_pgt character varying(200),
    nr_doc_pgd_pgt character varying(20),
    nr_doc_bnf_pgt character varying(20),
    dt_ctb_cnc_pgt timestamp without time zone
);


ALTER TABLE tbl_pgt OWNER TO scan;

--
-- TOC entry 9429 (class 0 OID 0)
-- Dependencies: 828
-- Name: TABLE tbl_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON TABLE tbl_pgt IS 'CORRESPONDENTE BANCARIO';


--
-- TOC entry 9430 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.cd_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.cd_pgt IS 'CODIGO';


--
-- TOC entry 9431 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.cd_crr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.cd_crr IS 'CORRESPONDENTE';


--
-- TOC entry 9432 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.tp_org_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.tp_org_pgt IS 'TIPO DE ORIGEM';


--
-- TOC entry 9433 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.nsu_org_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.nsu_org_pgt IS 'NSU DE ORIGEM';


--
-- TOC entry 9434 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.tp_dsp_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.tp_dsp_pgt IS 'TIPO DE DISPOSITIVO';


--
-- TOC entry 9435 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.nsu_dsp_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.nsu_dsp_pgt IS 'NSU DE DISPOSITIVO';


--
-- TOC entry 9436 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.cd_brr_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.cd_brr_pgt IS 'CODIGO DE BARRAS';


--
-- TOC entry 9437 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.dt_vnc_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.dt_vnc_pgt IS 'DATA DE VENCIMENTO';


--
-- TOC entry 9438 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.dt_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.dt_pgt IS 'DATA DO PAGAMENTO';


--
-- TOC entry 9439 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.vl_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.vl_pgt IS 'VALOR DO PAGAMENTO';


--
-- TOC entry 9440 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.vl_dcm_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.vl_dcm_pgt IS 'VALOR DO DOCUMENTO';


--
-- TOC entry 9441 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.tp_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.tp_pgt IS 'TIPO DE PAGAMENTO';


--
-- TOC entry 9442 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.st_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.st_pgt IS 'SITUACAO';


--
-- TOC entry 9443 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.obs_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.obs_pgt IS 'OBSERVACAO';


--
-- TOC entry 9444 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.dt_inc_usr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 9445 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.dt_alt_usr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.dt_alt_usr IS 'DATA ALTERACAO';


--
-- TOC entry 9446 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.cd_rtn_cnc_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.cd_rtn_cnc_pgt IS 'CODIGO DE RETORNO DA CONCESSIONARIA';


--
-- TOC entry 9447 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.msg_rtn_cnc_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.msg_rtn_cnc_pgt IS 'MENSAGEM DE RETORNO DA CONCESSIONARIA';


--
-- TOC entry 9448 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.cd_rtn_aut_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.cd_rtn_aut_pgt IS 'CODIGO DE RETORNO DE AUTORIZACAO';


--
-- TOC entry 9449 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.cd_aut_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.cd_aut_pgt IS 'CODIGO DA AUTORIZACAO';


--
-- TOC entry 9450 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.dt_efv_rtn_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.dt_efv_rtn_pgt IS 'data efetiva do pagamento';


--
-- TOC entry 9451 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.vl_jrs_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.vl_jrs_pgt IS 'valor de juros cobrado no pagamento';


--
-- TOC entry 9452 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.vl_mlt_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.vl_mlt_pgt IS 'valor de multa cobrado no pagamento';


--
-- TOC entry 9453 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.vl_dsc_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.vl_dsc_pgt IS 'valor de desconto concedido no pagamento';


--
-- TOC entry 9454 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.cd_bnc; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.cd_bnc IS 'codigo do banco emissor da ficha de compensação (sc_fin.tbl_bnc)';


--
-- TOC entry 9455 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.nm_cnc_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.nm_cnc_pgt IS 'nome da concessionaria da conta';


--
-- TOC entry 9456 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.nm_bnf_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.nm_bnf_pgt IS 'nome do beneficiário da ficha de compensação';


--
-- TOC entry 9457 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.nm_pgd_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.nm_pgd_pgt IS 'nome do pagador da ficha de compensação';


--
-- TOC entry 9458 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.nr_doc_pgd_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.nr_doc_pgd_pgt IS 'número do documento do pagador da ficha de compensação';


--
-- TOC entry 9459 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.nr_doc_bnf_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.nr_doc_bnf_pgt IS 'número do documento do beneficiário da ficha de compensação';


--
-- TOC entry 9460 (class 0 OID 0)
-- Dependencies: 828
-- Name: COLUMN tbl_pgt.dt_ctb_cnc_pgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_pgt.dt_ctb_cnc_pgt IS 'data de contabilizacao do cancelamento';


--
-- TOC entry 830 (class 1259 OID 889050)
-- Name: tbl_sgt; Type: TABLE; Schema: sc_pgc; Owner: scan
--

CREATE TABLE tbl_sgt (
    cd_sgt numeric(10,0) NOT NULL,
    nm_sgt character varying(100) NOT NULL,
    fg_atv_sgt character varying(1) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_sgt OWNER TO scan;

--
-- TOC entry 9461 (class 0 OID 0)
-- Dependencies: 830
-- Name: TABLE tbl_sgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON TABLE tbl_sgt IS 'SEGMENTO DA CONCESSIONARIA';


--
-- TOC entry 9462 (class 0 OID 0)
-- Dependencies: 830
-- Name: COLUMN tbl_sgt.cd_sgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_sgt.cd_sgt IS 'CODIGO';


--
-- TOC entry 9463 (class 0 OID 0)
-- Dependencies: 830
-- Name: COLUMN tbl_sgt.nm_sgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_sgt.nm_sgt IS 'NOME';


--
-- TOC entry 9464 (class 0 OID 0)
-- Dependencies: 830
-- Name: COLUMN tbl_sgt.fg_atv_sgt; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_sgt.fg_atv_sgt IS 'FLAG ATIVO';


--
-- TOC entry 9465 (class 0 OID 0)
-- Dependencies: 830
-- Name: COLUMN tbl_sgt.dt_inc_usr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_sgt.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9466 (class 0 OID 0)
-- Dependencies: 830
-- Name: COLUMN tbl_sgt.dt_alt_usr; Type: COMMENT; Schema: sc_pgc; Owner: scan
--

COMMENT ON COLUMN tbl_sgt.dt_alt_usr IS 'DATA DE ALTERACAO';


SET search_path = sc_ppr, pg_catalog;

--
-- TOC entry 911 (class 1259 OID 1007350)
-- Name: sq_ctr_ppr; Type: SEQUENCE; Schema: sc_ppr; Owner: scan
--

CREATE SEQUENCE sq_ctr_ppr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ctr_ppr OWNER TO scan;

--
-- TOC entry 910 (class 1259 OID 1007306)
-- Name: sq_dppr; Type: SEQUENCE; Schema: sc_ppr; Owner: scan
--

CREATE SEQUENCE sq_dppr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dppr OWNER TO scan;

--
-- TOC entry 908 (class 1259 OID 1007289)
-- Name: sq_ppr; Type: SEQUENCE; Schema: sc_ppr; Owner: scan
--

CREATE SEQUENCE sq_ppr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ppr OWNER TO scan;

--
-- TOC entry 912 (class 1259 OID 1007352)
-- Name: tbl_ctr_ppr; Type: TABLE; Schema: sc_ppr; Owner: scan
--

CREATE TABLE tbl_ctr_ppr (
    cd_ctr_ppr numeric(10,0) NOT NULL,
    cd_emp numeric(10,0) NOT NULL,
    cd_fem numeric(10,0) NOT NULL,
    vl_txa_ctr_ppr numeric(14,2) NOT NULL,
    fg_atv_ctr_ppr character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    vl_txa_srv_ctr_ppr numeric(14,2) NOT NULL
);


ALTER TABLE tbl_ctr_ppr OWNER TO scan;

--
-- TOC entry 9467 (class 0 OID 0)
-- Dependencies: 912
-- Name: TABLE tbl_ctr_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON TABLE tbl_ctr_ppr IS 'tabela de contrato de programa de participação de resultados';


--
-- TOC entry 9468 (class 0 OID 0)
-- Dependencies: 912
-- Name: COLUMN tbl_ctr_ppr.cd_ctr_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_ppr.cd_ctr_ppr IS 'codigo';


--
-- TOC entry 9469 (class 0 OID 0)
-- Dependencies: 912
-- Name: COLUMN tbl_ctr_ppr.cd_emp; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_ppr.cd_emp IS 'código da empresa';


--
-- TOC entry 9470 (class 0 OID 0)
-- Dependencies: 912
-- Name: COLUMN tbl_ctr_ppr.cd_fem; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_ppr.cd_fem IS 'código da filial de empresa';


--
-- TOC entry 9471 (class 0 OID 0)
-- Dependencies: 912
-- Name: COLUMN tbl_ctr_ppr.vl_txa_ctr_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_ppr.vl_txa_ctr_ppr IS 'valor da taxa';


--
-- TOC entry 9472 (class 0 OID 0)
-- Dependencies: 912
-- Name: COLUMN tbl_ctr_ppr.fg_atv_ctr_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_ppr.fg_atv_ctr_ppr IS 'flag ativo';


--
-- TOC entry 9473 (class 0 OID 0)
-- Dependencies: 912
-- Name: COLUMN tbl_ctr_ppr.cd_inc_usr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_ppr.cd_inc_usr IS 'código do usuário de inclusão';


--
-- TOC entry 9474 (class 0 OID 0)
-- Dependencies: 912
-- Name: COLUMN tbl_ctr_ppr.dt_inc_usr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_ppr.dt_inc_usr IS 'data de inclusão';


--
-- TOC entry 9475 (class 0 OID 0)
-- Dependencies: 912
-- Name: COLUMN tbl_ctr_ppr.cd_alt_usr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_ppr.cd_alt_usr IS 'código do usuário de alteração';


--
-- TOC entry 9476 (class 0 OID 0)
-- Dependencies: 912
-- Name: COLUMN tbl_ctr_ppr.dt_alt_usr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ctr_ppr.dt_alt_usr IS 'data de alteração';


--
-- TOC entry 913 (class 1259 OID 1007372)
-- Name: tbl_dppr; Type: TABLE; Schema: sc_ppr; Owner: scan
--

CREATE TABLE tbl_dppr (
    cd_dppr numeric(10,0) NOT NULL,
    cd_ppr numeric(10,0) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    mt_dppr character varying(14) NOT NULL,
    vl_dppr numeric(14,2) NOT NULL,
    fg_ant_dppr character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    vl_ant_dppr numeric(14,2)
);


ALTER TABLE tbl_dppr OWNER TO scan;

--
-- TOC entry 9477 (class 0 OID 0)
-- Dependencies: 913
-- Name: TABLE tbl_dppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON TABLE tbl_dppr IS 'tabela de detalhe de programa de participação de resultados';


--
-- TOC entry 9478 (class 0 OID 0)
-- Dependencies: 913
-- Name: COLUMN tbl_dppr.cd_dppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_dppr.cd_dppr IS 'codigo';


--
-- TOC entry 9479 (class 0 OID 0)
-- Dependencies: 913
-- Name: COLUMN tbl_dppr.cd_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_dppr.cd_ppr IS 'codigo do ppr';


--
-- TOC entry 9480 (class 0 OID 0)
-- Dependencies: 913
-- Name: COLUMN tbl_dppr.cd_cun; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_dppr.cd_cun IS 'codigo do cun';


--
-- TOC entry 9481 (class 0 OID 0)
-- Dependencies: 913
-- Name: COLUMN tbl_dppr.mt_dppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_dppr.mt_dppr IS 'matrícula';


--
-- TOC entry 9482 (class 0 OID 0)
-- Dependencies: 913
-- Name: COLUMN tbl_dppr.vl_dppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_dppr.vl_dppr IS 'valor';


--
-- TOC entry 9483 (class 0 OID 0)
-- Dependencies: 913
-- Name: COLUMN tbl_dppr.fg_ant_dppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_dppr.fg_ant_dppr IS 'flag antecipado';


--
-- TOC entry 9484 (class 0 OID 0)
-- Dependencies: 913
-- Name: COLUMN tbl_dppr.cd_inc_usr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_dppr.cd_inc_usr IS 'código do usuário de inclusão';


--
-- TOC entry 9485 (class 0 OID 0)
-- Dependencies: 913
-- Name: COLUMN tbl_dppr.dt_inc_usr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_dppr.dt_inc_usr IS 'data de inclusão';


--
-- TOC entry 9486 (class 0 OID 0)
-- Dependencies: 913
-- Name: COLUMN tbl_dppr.cd_alt_usr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_dppr.cd_alt_usr IS 'código do usuário de alteração';


--
-- TOC entry 9487 (class 0 OID 0)
-- Dependencies: 913
-- Name: COLUMN tbl_dppr.dt_alt_usr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_dppr.dt_alt_usr IS 'data de alteração';


--
-- TOC entry 909 (class 1259 OID 1007291)
-- Name: tbl_ppr; Type: TABLE; Schema: sc_ppr; Owner: scan
--

CREATE TABLE tbl_ppr (
    cd_ppr numeric(10,0) NOT NULL,
    cd_emp numeric(10,0) NOT NULL,
    cd_fem numeric(10,0) NOT NULL,
    st_ppr numeric(2,0) NOT NULL,
    vl_ppr numeric(14,2) NOT NULL,
    dt_prv_ppr timestamp without time zone NOT NULL,
    mes_cmp_ppr character varying(7) NOT NULL,
    dt_lbr_ppr timestamp without time zone,
    fg_atv_ppr character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_ppr OWNER TO scan;

--
-- TOC entry 9488 (class 0 OID 0)
-- Dependencies: 909
-- Name: TABLE tbl_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON TABLE tbl_ppr IS 'tabela de programa de participação de resultados';


--
-- TOC entry 9489 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.cd_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.cd_ppr IS 'codigo';


--
-- TOC entry 9490 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.cd_emp; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.cd_emp IS 'código da empresa';


--
-- TOC entry 9491 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.cd_fem; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.cd_fem IS 'código da filial de empresa';


--
-- TOC entry 9492 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.st_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.st_ppr IS 'situação (ver domínio)';


--
-- TOC entry 9493 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.vl_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.vl_ppr IS 'valor';


--
-- TOC entry 9494 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.dt_prv_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.dt_prv_ppr IS 'data de previsão';


--
-- TOC entry 9495 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.mes_cmp_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.mes_cmp_ppr IS 'competência';


--
-- TOC entry 9496 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.dt_lbr_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.dt_lbr_ppr IS 'data de liberação';


--
-- TOC entry 9497 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.fg_atv_ppr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.fg_atv_ppr IS 'flag ativo';


--
-- TOC entry 9498 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.cd_inc_usr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.cd_inc_usr IS 'código do usuário de inclusão';


--
-- TOC entry 9499 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.dt_inc_usr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.dt_inc_usr IS 'data de inclusão';


--
-- TOC entry 9500 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.cd_alt_usr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.cd_alt_usr IS 'código do usuário de alteração';


--
-- TOC entry 9501 (class 0 OID 0)
-- Dependencies: 909
-- Name: COLUMN tbl_ppr.dt_alt_usr; Type: COMMENT; Schema: sc_ppr; Owner: scan
--

COMMENT ON COLUMN tbl_ppr.dt_alt_usr IS 'data de alteração';


SET search_path = sc_rcg, pg_catalog;

--
-- TOC entry 591 (class 1259 OID 565983)
-- Name: sq_opr; Type: SEQUENCE; Schema: sc_rcg; Owner: scan
--

CREATE SEQUENCE sq_opr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_opr OWNER TO scan;

--
-- TOC entry 592 (class 1259 OID 565985)
-- Name: sq_prd; Type: SEQUENCE; Schema: sc_rcg; Owner: scan
--

CREATE SEQUENCE sq_prd
    START WITH 358
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_prd OWNER TO scan;

--
-- TOC entry 593 (class 1259 OID 565987)
-- Name: sq_rcg; Type: SEQUENCE; Schema: sc_rcg; Owner: scan
--

CREATE SEQUENCE sq_rcg
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rcg OWNER TO scan;

--
-- TOC entry 594 (class 1259 OID 565989)
-- Name: tbl_opr; Type: TABLE; Schema: sc_rcg; Owner: scan
--

CREATE TABLE tbl_opr (
    cd_opr numeric(5,0) NOT NULL,
    nm_opr character varying(100) NOT NULL,
    id_opr_rcg character varying(20) NOT NULL,
    fg_atv_opr character varying(1) DEFAULT 'S'::character varying NOT NULL,
    fg_atm_opr character varying(1),
    tp_rcg_opr numeric(2,0),
    cat_rcg_opr numeric(2,0),
    url_img_opr character varying(200),
    url_aju_opr character varying(200),
    ord_opr numeric(3,0),
    ds_opr text,
    id_opr_celcoin numeric(10,0)
);


ALTER TABLE tbl_opr OWNER TO scan;

--
-- TOC entry 9502 (class 0 OID 0)
-- Dependencies: 594
-- Name: TABLE tbl_opr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON TABLE tbl_opr IS 'OPERADORA';


--
-- TOC entry 9503 (class 0 OID 0)
-- Dependencies: 594
-- Name: COLUMN tbl_opr.cd_opr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_opr.cd_opr IS 'CODIGO';


--
-- TOC entry 9504 (class 0 OID 0)
-- Dependencies: 594
-- Name: COLUMN tbl_opr.nm_opr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_opr.nm_opr IS 'NOME';


--
-- TOC entry 9505 (class 0 OID 0)
-- Dependencies: 594
-- Name: COLUMN tbl_opr.id_opr_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_opr.id_opr_rcg IS 'IDENTIFICADOR DA RECARGA';


--
-- TOC entry 9506 (class 0 OID 0)
-- Dependencies: 594
-- Name: COLUMN tbl_opr.fg_atv_opr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_opr.fg_atv_opr IS 'FLAG ATIVO';


--
-- TOC entry 9507 (class 0 OID 0)
-- Dependencies: 594
-- Name: COLUMN tbl_opr.tp_rcg_opr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_opr.tp_rcg_opr IS 'TIPO DE RECARGA (VER TABELA DE DOMINIO)';


--
-- TOC entry 9508 (class 0 OID 0)
-- Dependencies: 594
-- Name: COLUMN tbl_opr.cat_rcg_opr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_opr.cat_rcg_opr IS 'CATEGORIA DA RECARGA (VER TABELA DE DOMINIO)';


--
-- TOC entry 9509 (class 0 OID 0)
-- Dependencies: 594
-- Name: COLUMN tbl_opr.url_img_opr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_opr.url_img_opr IS 'URL DA IMAGEM DA OPERADORA';


--
-- TOC entry 9510 (class 0 OID 0)
-- Dependencies: 594
-- Name: COLUMN tbl_opr.url_aju_opr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_opr.url_aju_opr IS 'URL DE AJUDA DA OPERADORA';


--
-- TOC entry 9511 (class 0 OID 0)
-- Dependencies: 594
-- Name: COLUMN tbl_opr.ord_opr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_opr.ord_opr IS 'ORDEM DE EXIBIÇÃO DAS OPERADORAS NA TELA';


--
-- TOC entry 9512 (class 0 OID 0)
-- Dependencies: 594
-- Name: COLUMN tbl_opr.ds_opr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_opr.ds_opr IS 'DESCRICAO COMERCIAL DA OPERADORA PARA SER EXIBIDA AO USUARIO NO MOMENTO DA RECARGA';


--
-- TOC entry 9513 (class 0 OID 0)
-- Dependencies: 594
-- Name: COLUMN tbl_opr.id_opr_celcoin; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_opr.id_opr_celcoin IS 'identificador da operadora na celcoin';


--
-- TOC entry 595 (class 1259 OID 565993)
-- Name: tbl_prd; Type: TABLE; Schema: sc_rcg; Owner: scan
--

CREATE TABLE tbl_prd (
    cd_prd numeric(10,0) NOT NULL,
    cd_opr numeric(5,0) NOT NULL,
    cd_prd_emp_prd character varying(4) NOT NULL,
    nm_prd character varying(50) NOT NULL,
    vl_prc_cmp_prd numeric(13,2) NOT NULL,
    vl_prc_vnd_prd numeric(13,2) NOT NULL,
    vl_prc_vrv_prd numeric(13,2) NOT NULL,
    vl_mnm_prd numeric(13,2) NOT NULL,
    vl_max_prd numeric(13,2) NOT NULL,
    vl_inc_prd numeric(13,2) NOT NULL,
    val_prd numeric(20,0) NOT NULL,
    mdl_rcg_prd numeric(2,0) NOT NULL,
    dt_ult_atl_prd timestamp without time zone NOT NULL,
    fg_atv_prd character varying(1) DEFAULT 'S'::character varying NOT NULL,
    ds_prd text
);


ALTER TABLE tbl_prd OWNER TO scan;

--
-- TOC entry 9514 (class 0 OID 0)
-- Dependencies: 595
-- Name: TABLE tbl_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON TABLE tbl_prd IS 'PRODUTO';


--
-- TOC entry 9515 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.cd_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.cd_prd IS 'CODIGO';


--
-- TOC entry 9516 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.cd_opr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.cd_opr IS 'OPERADORA';


--
-- TOC entry 9517 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.cd_prd_emp_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.cd_prd_emp_prd IS 'CODIGO DO PRODUTO NA EMPRESA DE RECARGA';


--
-- TOC entry 9518 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.nm_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.nm_prd IS 'NOME DO PRODUTO';


--
-- TOC entry 9519 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.vl_prc_cmp_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.vl_prc_cmp_prd IS 'PRECO DE COMPRA';


--
-- TOC entry 9520 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.vl_prc_vnd_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.vl_prc_vnd_prd IS 'PRECO DE VENDA';


--
-- TOC entry 9521 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.vl_prc_vrv_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.vl_prc_vrv_prd IS 'PRECO VARIAVEL';


--
-- TOC entry 9522 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.vl_mnm_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.vl_mnm_prd IS 'VALOR MINIMO DO PRODUTO';


--
-- TOC entry 9523 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.vl_max_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.vl_max_prd IS 'VALOR MAXIMO DO PRODUTO';


--
-- TOC entry 9524 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.vl_inc_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.vl_inc_prd IS 'VALOR INCREMENTAL DO PRODUTO';


--
-- TOC entry 9525 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.val_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.val_prd IS 'VALIDADE DO PRODUTO (APOS BOTAR CREDITO, DIAS)';


--
-- TOC entry 9526 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.mdl_rcg_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.mdl_rcg_prd IS 'MODELO DE RECAGA (DOMINIO)';


--
-- TOC entry 9527 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.dt_ult_atl_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.dt_ult_atl_prd IS 'DATA DA ULTIMA ATUALIZACAO DO PRODUTO';


--
-- TOC entry 9528 (class 0 OID 0)
-- Dependencies: 595
-- Name: COLUMN tbl_prd.ds_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_prd.ds_prd IS 'DESCRICAO COMERCIAL DO PRODUTO PARA SER EXIBIDA AO USUARIO NO MOMENTO DA RECARGA';


--
-- TOC entry 596 (class 1259 OID 565997)
-- Name: tbl_rcg; Type: TABLE; Schema: sc_rcg; Owner: scan
--

CREATE TABLE tbl_rcg (
    cd_rcg numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    cd_usr numeric(10,0),
    cd_prd numeric(10,0),
    vl_rcg numeric(13,2),
    ddd_cel_rcg numeric(2,0),
    nr_cel_rcg numeric(9,0),
    id_trm_rcg numeric(20,0),
    dt_rcg timestamp without time zone NOT NULL,
    cd_rtn_rcg character varying(30),
    vl_msg_rtn_rcg character varying(4000),
    nsu_rcg numeric(10,0),
    nsu_opr_rcg character varying(200),
    vl_prc_rcg numeric(13,2),
    cd_opr numeric(10,0),
    dt_ctb_rcg timestamp without time zone,
    cd_rqs numeric(10,0),
    cd_cnt numeric(10,0),
    frm_pgt_rcg numeric(5,0),
    st_rcg numeric(5,0),
    cd_crr numeric(5,0),
    dt_prc_rsp_rcg timestamp without time zone,
    tp_dsp_pgt numeric(2,0),
    cd_ass_rcg character varying(30)
);


ALTER TABLE tbl_rcg OWNER TO scan;

--
-- TOC entry 9529 (class 0 OID 0)
-- Dependencies: 596
-- Name: TABLE tbl_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON TABLE tbl_rcg IS 'RECARGA';


--
-- TOC entry 9530 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.cd_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.cd_rcg IS 'CODIGO';


--
-- TOC entry 9531 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.cd_crt; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.cd_crt IS 'CARTAO';


--
-- TOC entry 9532 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.cd_usr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.cd_usr IS 'USUARIO DA RECARGA';


--
-- TOC entry 9533 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.cd_prd; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.cd_prd IS 'PRODUTO';


--
-- TOC entry 9534 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.vl_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.vl_rcg IS 'VALOR DA RECARGA, OPCIONAL, FORNECIDO QND A RECARGA FOR VARIAVEL';


--
-- TOC entry 9535 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.ddd_cel_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.ddd_cel_rcg IS 'DDD';


--
-- TOC entry 9536 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.nr_cel_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.nr_cel_rcg IS 'NUMERO';


--
-- TOC entry 9537 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.id_trm_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.id_trm_rcg IS 'PODE SER O CODIGO DO CLIENTE NO NOSSO SISTEMA';


--
-- TOC entry 9538 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.cd_rtn_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.cd_rtn_rcg IS 'CODIGO DE RETORNO DA RECARGA';


--
-- TOC entry 9539 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.vl_msg_rtn_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.vl_msg_rtn_rcg IS 'MENSAGEM IMPRESSA NO COMPROVANTE';


--
-- TOC entry 9540 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.nsu_opr_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.nsu_opr_rcg IS 'NSU OPERADORA';


--
-- TOC entry 9541 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.vl_prc_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.vl_prc_rcg IS 'VALOR DO PRECO';


--
-- TOC entry 9542 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.cd_opr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.cd_opr IS 'código da operação de recarga (tabela sc_opr.tbl_opr)';


--
-- TOC entry 9543 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.cd_crr; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.cd_crr IS 'CODIGO DO CORRESPONDENTE (SC_PGC.TBL_CRR)';


--
-- TOC entry 9544 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.dt_prc_rsp_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.dt_prc_rsp_rcg IS 'DATA DE PROCESSAMENTO DA RESPOSTA DA AUTORIZACAO DA RECARGA';


--
-- TOC entry 9545 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.tp_dsp_pgt; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.tp_dsp_pgt IS 'TIPO DE DISPOSITIVO (VER TABELA DE DOMINIO)';


--
-- TOC entry 9546 (class 0 OID 0)
-- Dependencies: 596
-- Name: COLUMN tbl_rcg.cd_ass_rcg; Type: COMMENT; Schema: sc_rcg; Owner: scan
--

COMMENT ON COLUMN tbl_rcg.cd_ass_rcg IS 'CODIGO ASSINANTE (UTILIZADO PARA AS RECARGAS DE TV)';


SET search_path = sc_rct, pg_catalog;

--
-- TOC entry 597 (class 1259 OID 566000)
-- Name: sq_rct; Type: SEQUENCE; Schema: sc_rct; Owner: scan
--

CREATE SEQUENCE sq_rct
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rct OWNER TO scan;

--
-- TOC entry 598 (class 1259 OID 566002)
-- Name: sq_trt_top; Type: SEQUENCE; Schema: sc_rct; Owner: scan
--

CREATE SEQUENCE sq_trt_top
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_trt_top OWNER TO scan;

--
-- TOC entry 599 (class 1259 OID 566004)
-- Name: sq_vrc; Type: SEQUENCE; Schema: sc_rct; Owner: scan
--

CREATE SEQUENCE sq_vrc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_vrc OWNER TO scan;

--
-- TOC entry 600 (class 1259 OID 566006)
-- Name: tbl_mtp; Type: TABLE; Schema: sc_rct; Owner: scan
--

CREATE TABLE tbl_mtp (
    cd_cli numeric(10,0),
    sg_mod character varying(40),
    dt_sml date,
    nr_seq numeric(10,0),
    nr_ctr numeric(10,0),
    dt_ems_ope date,
    tx_jur numeric(10,7),
    nm_sac character varying(100),
    vr_prc numeric(13,2),
    vr_iof_clc numeric(13,2),
    cot_id_lib numeric(10,7),
    vr_tot_cld numeric(13,2),
    vr_tac numeric(13,2),
    tx_aa_dc numeric(10,7),
    tx_jur_2 numeric(10,7),
    mocr_dt_rsp timestamp without time zone,
    pz_do_ctr numeric(5,0),
    pz_dc_ctr numeric(5,0),
    cd_cli_cvn numeric(5,0),
    nm_cli character varying(100),
    dt_ven date,
    sd_pcp_flx numeric(13,2),
    vr_pcp_pcl numeric(13,2),
    vr_jur_pcl numeric(13,2),
    vr_tot_pcl numeric(13,2),
    vr_iof_pcl numeric(13,2),
    id_rpc character varying(1),
    id_jur character varying(1),
    id_car character varying(1),
    id_ioc_fnc character varying(1),
    dt_ori_arrend timestamp without time zone,
    dt_ori_credit timestamp without time zone,
    dt_ini_vig_segur timestamp without time zone,
    dt_vct_vig_segur timestamp without time zone,
    dt_ini_exg_gar timestamp without time zone,
    dt_fim_exg_gar timestamp without time zone,
    sd_pcp_ope_sac numeric(13,2),
    id_crt_iof character varying(1),
    nr_dc_ems numeric(5,0),
    nr_dc_pcl numeric(5,0),
    nr_cvn numeric(5,0),
    vr_pcp numeric(13,2),
    dt_ven_ogar timestamp without time zone,
    ds_nm_ope character varying(100),
    tx_cet numeric(10,7),
    nr_prp numeric(10,0)
);


ALTER TABLE tbl_mtp OWNER TO scan;

--
-- TOC entry 601 (class 1259 OID 566009)
-- Name: tbl_mtp_ctr; Type: TABLE; Schema: sc_rct; Owner: scan
--

CREATE TABLE tbl_mtp_ctr (
    nr_ctr_old numeric(10,0) NOT NULL,
    nr_ctr_new numeric(10,0) NOT NULL,
    vl_ctr_old numeric(13,2) NOT NULL
);


ALTER TABLE tbl_mtp_ctr OWNER TO scan;

--
-- TOC entry 602 (class 1259 OID 566012)
-- Name: tbl_rct; Type: TABLE; Schema: sc_rct; Owner: scan
--

CREATE TABLE tbl_rct (
    cd_rct numeric(10,0) NOT NULL,
    cd_trt numeric(10,0) NOT NULL,
    tp_org_rct numeric(2,0) NOT NULL,
    cd_sst numeric(10,0) NOT NULL,
    nsu_org_rct numeric(10,0) NOT NULL,
    dt_ctb_rct timestamp without time zone NOT NULL,
    usr_dt_inc timestamp without time zone NOT NULL,
    vl_rct numeric(10,2) NOT NULL
);


ALTER TABLE tbl_rct OWNER TO scan;

--
-- TOC entry 9547 (class 0 OID 0)
-- Dependencies: 602
-- Name: COLUMN tbl_rct.cd_sst; Type: COMMENT; Schema: sc_rct; Owner: scan
--

COMMENT ON COLUMN tbl_rct.cd_sst IS 'SISTEMA DE ORIGEM';


--
-- TOC entry 603 (class 1259 OID 566015)
-- Name: tbl_trt; Type: TABLE; Schema: sc_rct; Owner: scan
--

CREATE TABLE tbl_trt (
    cd_trt numeric(10,0) NOT NULL,
    ds_trt character varying(50) NOT NULL,
    cnt_ctb_trt character varying(40)
);


ALTER TABLE tbl_trt OWNER TO scan;

--
-- TOC entry 9548 (class 0 OID 0)
-- Dependencies: 603
-- Name: COLUMN tbl_trt.cnt_ctb_trt; Type: COMMENT; Schema: sc_rct; Owner: scan
--

COMMENT ON COLUMN tbl_trt.cnt_ctb_trt IS 'conta contabil, utilizado no momento de exportacao das informacoes contabeis';


--
-- TOC entry 604 (class 1259 OID 566018)
-- Name: tbl_trt_sfe; Type: TABLE; Schema: sc_rct; Owner: scan
--

CREATE TABLE tbl_trt_sfe (
    cd_trt_sfe numeric(10,0) NOT NULL,
    cd_sfe numeric(10,0) NOT NULL,
    cd_trt numeric(10,0) NOT NULL
);


ALTER TABLE tbl_trt_sfe OWNER TO scan;

--
-- TOC entry 605 (class 1259 OID 566021)
-- Name: tbl_trt_srv; Type: TABLE; Schema: sc_rct; Owner: scan
--

CREATE TABLE tbl_trt_srv (
    cd_trt_srv numeric(10,0) NOT NULL,
    cd_srv numeric(10,0) NOT NULL,
    cd_trt numeric(10,0) NOT NULL
);


ALTER TABLE tbl_trt_srv OWNER TO scan;

--
-- TOC entry 606 (class 1259 OID 566024)
-- Name: tbl_trt_top; Type: TABLE; Schema: sc_rct; Owner: scan
--

CREATE TABLE tbl_trt_top (
    cd_trt_top numeric(10,0) NOT NULL,
    cd_top numeric(10,0),
    cd_trt numeric(10,0),
    cd_sst numeric(5,0),
    nr_prp_trt_top numeric(2,0)
);


ALTER TABLE tbl_trt_top OWNER TO scan;

--
-- TOC entry 9549 (class 0 OID 0)
-- Dependencies: 606
-- Name: TABLE tbl_trt_top; Type: COMMENT; Schema: sc_rct; Owner: scan
--

COMMENT ON TABLE tbl_trt_top IS 'tabela de tipo de receita por operacao';


--
-- TOC entry 607 (class 1259 OID 566027)
-- Name: tbl_vrc; Type: TABLE; Schema: sc_rct; Owner: scan
--

CREATE TABLE tbl_vrc (
    cd_vrc numeric(10,0) NOT NULL,
    cd_fcr numeric(10,0) NOT NULL,
    cd_top numeric(10,0) NOT NULL,
    dt_vrc date NOT NULL,
    vl_vrc numeric(13,2) NOT NULL
);


ALTER TABLE tbl_vrc OWNER TO scan;

SET search_path = sc_rdc, pg_catalog;

--
-- TOC entry 962 (class 1259 OID 1633052)
-- Name: sq_ahp; Type: SEQUENCE; Schema: sc_rdc; Owner: scan
--

CREATE SEQUENCE sq_ahp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ahp OWNER TO scan;

--
-- TOC entry 963 (class 1259 OID 1633054)
-- Name: sq_dah; Type: SEQUENCE; Schema: sc_rdc; Owner: scan
--

CREATE SEQUENCE sq_dah
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dah OWNER TO scan;

--
-- TOC entry 919 (class 1259 OID 1010679)
-- Name: sq_etb; Type: SEQUENCE; Schema: sc_rdc; Owner: scan
--

CREATE SEQUENCE sq_etb
    START WITH 2
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_etb OWNER TO scan;

--
-- TOC entry 918 (class 1259 OID 1010676)
-- Name: sq_fet; Type: SEQUENCE; Schema: sc_rdc; Owner: scan
--

CREATE SEQUENCE sq_fet
    START WITH 2
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_fet OWNER TO scan;

--
-- TOC entry 971 (class 1259 OID 1639064)
-- Name: sq_oet; Type: SEQUENCE; Schema: sc_rdc; Owner: scan
--

CREATE SEQUENCE sq_oet
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_oet OWNER TO scan;

--
-- TOC entry 923 (class 1259 OID 1023452)
-- Name: sq_pet; Type: SEQUENCE; Schema: sc_rdc; Owner: scan
--

CREATE SEQUENCE sq_pet
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_pet OWNER TO scan;

--
-- TOC entry 973 (class 1259 OID 1648899)
-- Name: sq_rahp; Type: SEQUENCE; Schema: sc_rdc; Owner: scan
--

CREATE SEQUENCE sq_rahp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rahp OWNER TO scan;

--
-- TOC entry 974 (class 1259 OID 1648901)
-- Name: sq_rdah; Type: SEQUENCE; Schema: sc_rdc; Owner: scan
--

CREATE SEQUENCE sq_rdah
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rdah OWNER TO scan;

--
-- TOC entry 924 (class 1259 OID 1023458)
-- Name: sq_rps; Type: SEQUENCE; Schema: sc_rdc; Owner: scan
--

CREATE SEQUENCE sq_rps
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rps OWNER TO scan;

--
-- TOC entry 608 (class 1259 OID 566030)
-- Name: sq_rqs; Type: SEQUENCE; Schema: sc_rdc; Owner: scan
--

CREATE SEQUENCE sq_rqs
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rqs OWNER TO scan;

--
-- TOC entry 960 (class 1259 OID 1633040)
-- Name: tbl_ahp; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_ahp (
    cd_ahp numeric(10,0) NOT NULL,
    dt_grc_ahp timestamp without time zone NOT NULL,
    dt_env_ahp timestamp without time zone,
    st_ahp numeric(1,0) NOT NULL,
    lcl_arq_ahp character varying(200)
);


ALTER TABLE tbl_ahp OWNER TO scan;

--
-- TOC entry 9550 (class 0 OID 0)
-- Dependencies: 960
-- Name: TABLE tbl_ahp; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON TABLE tbl_ahp IS 'Tabela de arquivo de habilitacao de produto';


--
-- TOC entry 961 (class 1259 OID 1633045)
-- Name: tbl_dah; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_dah (
    cd_dah numeric(10,0) NOT NULL,
    prd_dah numeric(4,0),
    nr_cpf_cnpj_dah numeric(14,0),
    nm_dah character varying(80),
    tlf1_dah numeric(11,0),
    tlf2_dah numeric(11,0),
    nm_ctt_dah character varying(30),
    edr_dah character varying(50),
    brr_dah character varying(30),
    cdd_dah character varying(30),
    uf_dah character varying(2),
    cep_dah numeric(8,0),
    cd_fet numeric(10,0),
    cd_ahp numeric(10,0) NOT NULL,
    nr_lgc_cel_dah character varying(15)
);


ALTER TABLE tbl_dah OWNER TO scan;

--
-- TOC entry 609 (class 1259 OID 566032)
-- Name: tbl_eqp; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_eqp (
    cd_eqp numeric(10,0) NOT NULL,
    ds_eqp character varying(50) NOT NULL,
    nsu_eqp character varying(30) NOT NULL,
    tp_eqp numeric(2,0) NOT NULL
);


ALTER TABLE tbl_eqp OWNER TO scan;

--
-- TOC entry 9551 (class 0 OID 0)
-- Dependencies: 609
-- Name: TABLE tbl_eqp; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON TABLE tbl_eqp IS 'TABELA DE EQUIPAMENTO';


--
-- TOC entry 610 (class 1259 OID 566035)
-- Name: tbl_etb; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_etb (
    cd_etb numeric(10,0) NOT NULL,
    nm_etb character varying(50) NOT NULL,
    tx_adm_etb numeric(5,4) NOT NULL,
    qtd_dia_rps numeric(2,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    cd_cnt numeric(10,0) NOT NULL,
    cd_rat numeric(10,0),
    fg_atv_etb character(1) DEFAULT 'S'::bpchar NOT NULL,
    vl_tx_ant_etb numeric(13,2),
    vl_trf_ant_etb numeric(13,2),
    fg_dbc_mtz_etb character varying(1) DEFAULT 'S'::character varying NOT NULL
);


ALTER TABLE tbl_etb OWNER TO scan;

--
-- TOC entry 9552 (class 0 OID 0)
-- Dependencies: 610
-- Name: TABLE tbl_etb; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON TABLE tbl_etb IS 'TABELA DE ESTABELECIMENTO';


--
-- TOC entry 9553 (class 0 OID 0)
-- Dependencies: 610
-- Name: COLUMN tbl_etb.fg_dbc_mtz_etb; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_etb.fg_dbc_mtz_etb IS 'FLAG QUE INDICA SE AS FILIAIS UTILIZARAO ODOMICIO BANCARIO DA MATRIZ.';


--
-- TOC entry 611 (class 1259 OID 566038)
-- Name: tbl_fet; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_fet (
    cd_fet numeric(10,0) NOT NULL,
    cd_etb numeric(10,0) NOT NULL,
    cd_cnt numeric(10,0) NOT NULL,
    nm_fet character varying(50) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    cd_bnc_fet numeric(3,0) NOT NULL,
    cd_agn_fet numeric(10,0) NOT NULL,
    nr_cc_fet numeric(8,0) NOT NULL,
    dg_cc_fet character(1) NOT NULL,
    dg_agn_fet character(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    fg_atv_fet character(1) DEFAULT 'S'::bpchar NOT NULL,
    nr_lgc_fet character varying(15),
    fg_mtz_fet character(1),
    eml_env_rps_fet character varying(2000),
    nr_lgc_cel_fet numeric(15,0),
    fg_trs_dgt_fet character(1) DEFAULT 'N'::bpchar NOT NULL,
    fg_env_hpc_fet character(1) DEFAULT 'S'::bpchar NOT NULL,
    st_hpc_fet numeric(2,0) NOT NULL,
    ds_hpc_fet character varying(80),
    fg_saq_fet character varying(1),
    nr_ltd_fet numeric(10,8),
    nr_lgt_fet numeric(10,8),
    fg_exb_fet_app character(1)
);


ALTER TABLE tbl_fet OWNER TO scan;

--
-- TOC entry 9554 (class 0 OID 0)
-- Dependencies: 611
-- Name: TABLE tbl_fet; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON TABLE tbl_fet IS 'TABELA DE FILIAL DE ESTABELECIMENTO';


--
-- TOC entry 969 (class 1259 OID 1639031)
-- Name: tbl_oet; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_oet (
    cd_oet numeric(10,0) NOT NULL,
    cd_toe numeric(10,0) NOT NULL,
    ds_oet text,
    cd_fet numeric(10,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_oet OWNER TO scan;

--
-- TOC entry 612 (class 1259 OID 566041)
-- Name: tbl_pet; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_pet (
    cd_pet numeric(10,0) NOT NULL,
    cd_fet numeric(10,0) NOT NULL,
    vl_tx_adm_pet numeric(13,2) NOT NULL,
    vl_rps_pet numeric(13,2) NOT NULL,
    dt_grc_pet timestamp without time zone NOT NULL,
    dt_prv_rps_pet timestamp without time zone NOT NULL,
    dt_rps_pet timestamp without time zone,
    st_pet numeric(2,0) NOT NULL,
    fg_dcr_pet character(1) NOT NULL,
    cd_rps numeric(10,0),
    cd_opr numeric(10,0) NOT NULL
);


ALTER TABLE tbl_pet OWNER TO scan;

--
-- TOC entry 613 (class 1259 OID 566044)
-- Name: tbl_rae; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_rae (
    cd_rae numeric(10,0) NOT NULL,
    ds_rae character varying(50) NOT NULL
);


ALTER TABLE tbl_rae OWNER TO scan;

--
-- TOC entry 975 (class 1259 OID 1648903)
-- Name: tbl_rahp; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_rahp (
    cd_rahp numeric(10,0) NOT NULL,
    cd_idt_rahp numeric(1,0) NOT NULL,
    cd_idt_bnd_rahp numeric(2,0) NOT NULL,
    st_rahp numeric(2,0) NOT NULL,
    nr_vrs_rahp numeric(9,0) NOT NULL,
    nr_vrs_ent_rahp numeric(9,0) NOT NULL,
    cd_ret_rahp numeric(1,0),
    cd_rsp_rahp numeric(2,0),
    msg_rsp_rahp character varying(58),
    dt_env_rahp date NOT NULL,
    dt_prc_rahp timestamp without time zone NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_rahp OWNER TO scan;

--
-- TOC entry 9555 (class 0 OID 0)
-- Dependencies: 975
-- Name: TABLE tbl_rahp; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON TABLE tbl_rahp IS 'tabela de retorno header arquivo habilitacao produto';


--
-- TOC entry 9556 (class 0 OID 0)
-- Dependencies: 975
-- Name: COLUMN tbl_rahp.cd_rahp; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rahp.cd_rahp IS 'codigo';


--
-- TOC entry 9557 (class 0 OID 0)
-- Dependencies: 975
-- Name: COLUMN tbl_rahp.nr_vrs_rahp; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rahp.nr_vrs_rahp IS 'numero da versao';


--
-- TOC entry 9558 (class 0 OID 0)
-- Dependencies: 975
-- Name: COLUMN tbl_rahp.nr_vrs_ent_rahp; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rahp.nr_vrs_ent_rahp IS 'numero da versao de entrada';


--
-- TOC entry 9559 (class 0 OID 0)
-- Dependencies: 975
-- Name: COLUMN tbl_rahp.cd_ret_rahp; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rahp.cd_ret_rahp IS 'codigo do retorno';


--
-- TOC entry 9560 (class 0 OID 0)
-- Dependencies: 975
-- Name: COLUMN tbl_rahp.cd_rsp_rahp; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rahp.cd_rsp_rahp IS 'codigo da resposta';


--
-- TOC entry 9561 (class 0 OID 0)
-- Dependencies: 975
-- Name: COLUMN tbl_rahp.msg_rsp_rahp; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rahp.msg_rsp_rahp IS 'mensagem da resposta';


--
-- TOC entry 9562 (class 0 OID 0)
-- Dependencies: 975
-- Name: COLUMN tbl_rahp.dt_env_rahp; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rahp.dt_env_rahp IS 'data do envio';


--
-- TOC entry 9563 (class 0 OID 0)
-- Dependencies: 975
-- Name: COLUMN tbl_rahp.dt_prc_rahp; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rahp.dt_prc_rahp IS 'data do processamento';


--
-- TOC entry 9564 (class 0 OID 0)
-- Dependencies: 975
-- Name: COLUMN tbl_rahp.dt_inc_usr; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rahp.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 976 (class 1259 OID 1648908)
-- Name: tbl_rdah; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_rdah (
    cd_rdah numeric(10,0) NOT NULL,
    cd_rahp numeric(10,0) NOT NULL,
    cd_idt_rdah numeric(1,0) NOT NULL,
    cd_idt_bnd_rdah numeric(2,0) NOT NULL,
    cd_prd numeric(4,0) NOT NULL,
    tp_prc_rdah numeric(1,0) NOT NULL,
    nr_slt_prc_rdah numeric(2,0) NOT NULL,
    nr_slt_dsb_rdah numeric(2,0),
    nr_etb_cmr_rdah numeric(15,0) NOT NULL,
    nr_etb_cmr_emp_prc_rdah numeric(15,0),
    nr_cpf_cnpj_rdah numeric(14,0) NOT NULL,
    nr_vrs_rdah numeric(9,0) NOT NULL,
    nr_vrs_ent_rdah numeric(9,0) NOT NULL,
    cd_ret_rdah numeric(1,0) NOT NULL,
    cd_rsp_rdah numeric(2,0) NOT NULL,
    msg_rsp_rdah character varying(58),
    dt_env_rdah date NOT NULL,
    dt_prc_rdah timestamp without time zone NOT NULL
);


ALTER TABLE tbl_rdah OWNER TO scan;

--
-- TOC entry 9565 (class 0 OID 0)
-- Dependencies: 976
-- Name: TABLE tbl_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON TABLE tbl_rdah IS 'tabela de retorno detalhe arquivo habilitacao produto';


--
-- TOC entry 9566 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.cd_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.cd_rdah IS 'codigo';


--
-- TOC entry 9567 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.cd_rahp; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.cd_rahp IS 'codigo retorno';


--
-- TOC entry 9568 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.cd_prd; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.cd_prd IS 'codigo do produto';


--
-- TOC entry 9569 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.tp_prc_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.tp_prc_rdah IS 'tipo processo (ver domínio)';


--
-- TOC entry 9570 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.nr_slt_prc_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.nr_slt_prc_rdah IS 'numero do solicitante do processo';


--
-- TOC entry 9571 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.nr_slt_dsb_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.nr_slt_dsb_rdah IS 'numero do solicitante de desabilitacao';


--
-- TOC entry 9572 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.nr_etb_cmr_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.nr_etb_cmr_rdah IS 'numero do estabelecimento comercial';


--
-- TOC entry 9573 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.nr_etb_cmr_emp_prc_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.nr_etb_cmr_emp_prc_rdah IS 'numero do estabelecimento comercial da empresa do processo';


--
-- TOC entry 9574 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.nr_cpf_cnpj_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.nr_cpf_cnpj_rdah IS 'numero do cpf/cnpj';


--
-- TOC entry 9575 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.nr_vrs_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.nr_vrs_rdah IS 'numero da versao';


--
-- TOC entry 9576 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.nr_vrs_ent_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.nr_vrs_ent_rdah IS 'numero da versao de entrada';


--
-- TOC entry 9577 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.cd_ret_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.cd_ret_rdah IS 'codigo do retorno';


--
-- TOC entry 9578 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.cd_rsp_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.cd_rsp_rdah IS 'codigo da resposta';


--
-- TOC entry 9579 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.msg_rsp_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.msg_rsp_rdah IS 'mensagem de resposta';


--
-- TOC entry 9580 (class 0 OID 0)
-- Dependencies: 976
-- Name: COLUMN tbl_rdah.dt_env_rdah; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_rdah.dt_env_rdah IS 'data de envio';


--
-- TOC entry 614 (class 1259 OID 566047)
-- Name: tbl_rps; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_rps (
    cd_rps numeric(10,0) NOT NULL,
    cd_fet numeric(10,0) NOT NULL,
    dt_rps date NOT NULL,
    st_rps numeric(2,0) DEFAULT 1 NOT NULL,
    vl_rps numeric(13,2) NOT NULL,
    dt_ctb_rps timestamp without time zone,
    vl_tx_adm_rps numeric(13,2) NOT NULL,
    dt_eml_env_rps timestamp without time zone,
    fg_eml_env_rps character varying(1) DEFAULT 'N'::character varying,
    dt_inc_rps timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE tbl_rps OWNER TO scan;

--
-- TOC entry 9581 (class 0 OID 0)
-- Dependencies: 614
-- Name: TABLE tbl_rps; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON TABLE tbl_rps IS 'TABELA DE REPASSE';


--
-- TOC entry 615 (class 1259 OID 566051)
-- Name: tbl_rqs; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_rqs (
    cd_rqs numeric(10,0) NOT NULL,
    nr_nsu_org numeric(10,0),
    dt_rqs timestamp without time zone NOT NULL,
    tp_rqs numeric(2,0) NOT NULL,
    cd_pls numeric(16,0),
    cd_fet numeric(15,0),
    vl_rqs numeric(13,2),
    nr_prc_rqs numeric(2,0),
    cd_ret_rqs numeric(2,0),
    nsu_eqp_rqs character varying(30),
    cd_eqp numeric(10,0),
    cd_opr numeric(10,0),
    dt_vld_pls_rqs character varying(6),
    nr_scc_pls_rqs character varying(3),
    nr_lgc_fet_rqs character varying(50),
    nsu_rede_rqs numeric(10,0)
);


ALTER TABLE tbl_rqs OWNER TO scan;

--
-- TOC entry 9582 (class 0 OID 0)
-- Dependencies: 615
-- Name: TABLE tbl_rqs; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON TABLE tbl_rqs IS 'TABELA DE REQUISICAO';


--
-- TOC entry 970 (class 1259 OID 1639049)
-- Name: tbl_toe; Type: TABLE; Schema: sc_rdc; Owner: scan
--

CREATE TABLE tbl_toe (
    cd_toe numeric(10,0) NOT NULL,
    nm_toe character varying(50) NOT NULL,
    fg_vsv_toe character varying(1) DEFAULT 'S'::character varying NOT NULL
);


ALTER TABLE tbl_toe OWNER TO scan;

--
-- TOC entry 9583 (class 0 OID 0)
-- Dependencies: 970
-- Name: TABLE tbl_toe; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON TABLE tbl_toe IS 'TABELA DE TIPO DE OCORRÊNCIA DE ESTABELECIMENTO';


--
-- TOC entry 9584 (class 0 OID 0)
-- Dependencies: 970
-- Name: COLUMN tbl_toe.cd_toe; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_toe.cd_toe IS 'codigo';


--
-- TOC entry 9585 (class 0 OID 0)
-- Dependencies: 970
-- Name: COLUMN tbl_toe.nm_toe; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_toe.nm_toe IS 'descrição';


--
-- TOC entry 9586 (class 0 OID 0)
-- Dependencies: 970
-- Name: COLUMN tbl_toe.fg_vsv_toe; Type: COMMENT; Schema: sc_rdc; Owner: scan
--

COMMENT ON COLUMN tbl_toe.fg_vsv_toe IS 'flag visível';


--
-- TOC entry 934 (class 1259 OID 1084024)
-- Name: vw_compras; Type: VIEW; Schema: sc_rdc; Owner: postgres
--

CREATE VIEW vw_compras AS
SELECT opr.dt_opr AS data_operacao, top.nm_top AS tipo_operacao, opr.vl_opr AS valor_operacao, opr.vl_crd_opr AS valor_credito, (opr.vl_opr - COALESCE(opr.vl_crd_opr, (0)::numeric)) AS valor_debito, etb.nm_etb AS estabelecimento, fet.nm_fet AS filial FROM (((((sc_opr.tbl_opr opr JOIN tbl_fet fet ON ((fet.cd_fet = opr.cd_fet))) JOIN tbl_etb etb ON ((etb.cd_etb = fet.cd_etb))) JOIN tbl_pet pet ON ((pet.cd_opr = opr.cd_opr))) JOIN sc_cad.vw_edr edr ON ((edr.cd_cun = fet.cd_cun))) JOIN sc_opr.tbl_top top ON ((top.cd_top = opr.cd_top))) WHERE (top.cd_top = ANY (ARRAY[(27)::numeric, (4)::numeric]));


ALTER TABLE vw_compras OWNER TO postgres;

--
-- TOC entry 942 (class 1259 OID 1624239)
-- Name: vw_compras2; Type: VIEW; Schema: sc_rdc; Owner: postgres
--

CREATE VIEW vw_compras2 AS
SELECT etb.nm_etb AS estabelecimento, fet.nm_fet AS nome_filial_estabelecimento, opr.cd_opr AS codigo_operacao, emp.nm_emp AS nome_empresa, fem.nm_fem AS nome_filial, gem.nm_gem AS grupo_empresarial, opr.vl_opr AS valor_total, opr.vl_crd_opr AS valor_credito, (opr.vl_opr - COALESCE(opr.vl_crd_opr, (0)::numeric)) AS valor_debito, (pet.dt_prv_rps_pet)::date AS data_prevista_repasse, pet.vl_tx_adm_pet AS valor_desconto_comercial, (opr.vl_opr - COALESCE(pet.vl_tx_adm_pet, (0)::numeric)) AS valor_liquido, pet.vl_rps_pet AS valor_repasse, (opr.dt_opr)::date AS data_operacao, to_char(opr.dt_opr, 'MM/YYYY'::text) AS mes_operacao, to_char(pet.dt_prv_rps_pet, 'MM/YYYY'::text) AS mes_previsao_repasse, top.nm_top AS tipo_operacao, e.localidade, e.bairro FROM ((((((((((((sc_opr.tbl_opr opr JOIN sc_opr.tbl_pls pls ON ((pls.cd_pls = opr.cd_pls))) JOIN sc_opr.tbl_crt crt ON ((crt.cd_crt = pls.cd_crt))) JOIN sc_cad.tbl_fnc fnc ON ((fnc.cd_fnc = crt.cd_fnc))) JOIN sc_cad.tbl_emp emp ON ((emp.cd_emp = fnc.cd_emp))) JOIN sc_cad.tbl_fem fem ON (((fem.cd_emp = emp.cd_emp) AND (fem.cd_fem = fnc.cd_fem)))) JOIN sc_cad.tbl_gem gem ON ((gem.cd_gem = emp.cd_gem))) LEFT JOIN tbl_pet pet ON ((pet.cd_opr = opr.cd_opr))) JOIN tbl_fet fet ON ((fet.cd_fet = opr.cd_fet))) JOIN sc_cad.tbl_cun cun ON ((cun.cd_cun = fet.cd_cun))) JOIN tbl_etb etb ON ((etb.cd_etb = fet.cd_etb))) JOIN sc_opr.tbl_top top ON ((top.cd_top = opr.cd_top))) LEFT JOIN sc_cad.vw_edr e ON ((e.cd_cun = fet.cd_cun))) WHERE ((opr.cd_top = ANY (ARRAY[(27)::numeric, (4)::numeric])) AND ((e.cd_edr IS NULL) OR (e.cd_edr = (SELECT max(ee.cd_edr) AS max FROM sc_cad.tbl_edr ee WHERE ((fet.cd_cun = ee.cd_cun) AND (ee.fg_atv_edr = 'S'::bpchar))))));


ALTER TABLE vw_compras2 OWNER TO postgres;

SET search_path = sc_rds, pg_catalog;

--
-- TOC entry 616 (class 1259 OID 566054)
-- Name: sq_abs; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_abs
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_abs OWNER TO scan;

--
-- TOC entry 617 (class 1259 OID 566056)
-- Name: sq_aea; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_aea
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_aea OWNER TO scan;

--
-- TOC entry 618 (class 1259 OID 566058)
-- Name: sq_alt; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_alt
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_alt OWNER TO scan;

--
-- TOC entry 619 (class 1259 OID 566060)
-- Name: sq_atm; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_atm
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_atm OWNER TO scan;

--
-- TOC entry 620 (class 1259 OID 566062)
-- Name: sq_cda; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_cda
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_cda OWNER TO scan;

--
-- TOC entry 621 (class 1259 OID 566064)
-- Name: sq_dab; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_dab
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dab OWNER TO scan;

--
-- TOC entry 622 (class 1259 OID 566066)
-- Name: sq_drqa; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_drqa
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_drqa OWNER TO scan;

--
-- TOC entry 623 (class 1259 OID 566068)
-- Name: sq_dsp; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_dsp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_dsp OWNER TO scan;

--
-- TOC entry 624 (class 1259 OID 566070)
-- Name: sq_eda; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_eda
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_eda OWNER TO scan;

--
-- TOC entry 625 (class 1259 OID 566072)
-- Name: sq_eda_aap; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_eda_aap
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_eda_aap OWNER TO scan;

--
-- TOC entry 626 (class 1259 OID 566074)
-- Name: sq_eda_aop; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_eda_aop
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_eda_aop OWNER TO scan;

--
-- TOC entry 627 (class 1259 OID 566076)
-- Name: sq_fca; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_fca
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_fca OWNER TO scan;

--
-- TOC entry 628 (class 1259 OID 566078)
-- Name: sq_fva; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_fva
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_fva OWNER TO scan;

--
-- TOC entry 629 (class 1259 OID 566080)
-- Name: sq_led; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_led
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_led OWNER TO scan;

--
-- TOC entry 630 (class 1259 OID 566082)
-- Name: sq_oca; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_oca
    START WITH 1
    INCREMENT BY 1
    MINVALUE 0
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_oca OWNER TO scan;

--
-- TOC entry 631 (class 1259 OID 566084)
-- Name: sq_pop; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_pop
    START WITH 5
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 9
    CACHE 1
    CYCLE;


ALTER TABLE sq_pop OWNER TO scan;

--
-- TOC entry 632 (class 1259 OID 566086)
-- Name: sq_rqa; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_rqa
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rqa OWNER TO scan;

--
-- TOC entry 791 (class 1259 OID 862145)
-- Name: sq_sfc; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_sfc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_sfc OWNER TO scan;

--
-- TOC entry 633 (class 1259 OID 566088)
-- Name: sq_tal; Type: SEQUENCE; Schema: sc_rds; Owner: scan
--

CREATE SEQUENCE sq_tal
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tal OWNER TO scan;

--
-- TOC entry 634 (class 1259 OID 566090)
-- Name: tbl_aap; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_aap (
    cd_aap numeric(10,0) NOT NULL,
    ds_aap character varying(50) NOT NULL,
    fg_atv_aap character varying(1) DEFAULT 'S'::character varying NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    CONSTRAINT ck_fg_atv_aap CHECK (((fg_atv_aap)::text = ANY (ARRAY[('N'::character varying)::text, ('S'::character varying)::text])))
);


ALTER TABLE tbl_aap OWNER TO scan;

--
-- TOC entry 9587 (class 0 OID 0)
-- Dependencies: 634
-- Name: TABLE tbl_aap; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_aap IS 'TABELA DE ACAO DE APLICATIVO';


--
-- TOC entry 9588 (class 0 OID 0)
-- Dependencies: 634
-- Name: COLUMN tbl_aap.cd_aap; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aap.cd_aap IS 'CODIGO';


--
-- TOC entry 9589 (class 0 OID 0)
-- Dependencies: 634
-- Name: COLUMN tbl_aap.ds_aap; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aap.ds_aap IS 'DESCRICAO';


--
-- TOC entry 9590 (class 0 OID 0)
-- Dependencies: 634
-- Name: COLUMN tbl_aap.fg_atv_aap; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aap.fg_atv_aap IS 'FLAG DE ATIVO';


--
-- TOC entry 9591 (class 0 OID 0)
-- Dependencies: 634
-- Name: COLUMN tbl_aap.cd_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aap.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9592 (class 0 OID 0)
-- Dependencies: 634
-- Name: COLUMN tbl_aap.dt_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aap.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9593 (class 0 OID 0)
-- Dependencies: 634
-- Name: COLUMN tbl_aap.cd_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aap.cd_alt_usr IS 'USUARIO QUE REALIZOU A ULTIMA ALTERACAO';


--
-- TOC entry 9594 (class 0 OID 0)
-- Dependencies: 634
-- Name: COLUMN tbl_aap.dt_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aap.dt_alt_usr IS 'DATA DA ULTIMA ALTERACAO';


--
-- TOC entry 635 (class 1259 OID 566095)
-- Name: tbl_abs; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_abs (
    cd_abs numeric(10,0) NOT NULL,
    cd_atm numeric(5,0) NOT NULL,
    cd_cnt numeric(10,0) NOT NULL,
    vl_abs numeric(13,2) NOT NULL,
    vl_ret_prc_abs numeric(13,2) NOT NULL,
    st_abs numeric(2,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_alt_usr timestamp without time zone,
    dt_prc_abs timestamp without time zone,
    dt_apr_abs timestamp without time zone,
    cd_apr_usr numeric(10,0),
    vl_ret_fnl_abs numeric(13,2),
    dt_prv_abs date,
    cd_pop numeric(16,0),
    dt_cnc_abs timestamp without time zone,
    cd_cnc_usr numeric(10,0),
    dt_fnz_abs timestamp without time zone,
    cd_fnz_usr numeric(10,0),
    vl_ret_abs numeric(13,2),
    dt_ret_abs timestamp without time zone,
    cd_ret_usr numeric(10,0),
    obs_ret_abs character varying(400)
);


ALTER TABLE tbl_abs OWNER TO scan;

--
-- TOC entry 9595 (class 0 OID 0)
-- Dependencies: 635
-- Name: TABLE tbl_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_abs IS 'TABELA DE ABASTECIMENTO';


--
-- TOC entry 9596 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.cd_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.cd_abs IS 'CODIGO DO ABASTECIMENTO';


--
-- TOC entry 9597 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.cd_atm; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.cd_atm IS 'CODIGO DO ATM';


--
-- TOC entry 9598 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.cd_cnt; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.cd_cnt IS 'CODIGO DA CONTA';


--
-- TOC entry 9599 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.vl_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.vl_abs IS 'VALOR DO ABASTECIMENTO';


--
-- TOC entry 9600 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.vl_ret_prc_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.vl_ret_prc_abs IS 'VALOR RETIRADO NO PROCESSAMENTO';


--
-- TOC entry 9601 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.st_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.st_abs IS 'SITUACAO DO ABASTECIMENTO (VER DOMINIO)';


--
-- TOC entry 9602 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.cd_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9603 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.cd_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 9604 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.dt_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9605 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.dt_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 9606 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.dt_prc_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.dt_prc_abs IS 'DATA DO PROCESSAMENTO DO ABASTECIMENTO';


--
-- TOC entry 9607 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.dt_apr_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.dt_apr_abs IS 'DATA DA APROVACAO DO ABASTECIMENTO';


--
-- TOC entry 9608 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.cd_apr_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.cd_apr_usr IS 'CODIGO DO USUARIO DA APROVACAO';


--
-- TOC entry 9609 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.vl_ret_fnl_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.vl_ret_fnl_abs IS 'VALOR RETIRADO NA FINALIZACAO DO ABASTECIMENTO';


--
-- TOC entry 9610 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.dt_prv_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.dt_prv_abs IS 'DATA PREVISTA DO ABASTECIMENTO';


--
-- TOC entry 9611 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.dt_cnc_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.dt_cnc_abs IS 'DATA DO CANCELAMENTO';


--
-- TOC entry 9612 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.cd_cnc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.cd_cnc_usr IS 'CODIGO DO USUARIO DE CANCELAMENTO';


--
-- TOC entry 9613 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.dt_fnz_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.dt_fnz_abs IS 'DATA DA FINALIZACAO';


--
-- TOC entry 9614 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.cd_fnz_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.cd_fnz_usr IS 'CODIGO DO USUARIO DE FINALIZACAO';


--
-- TOC entry 9615 (class 0 OID 0)
-- Dependencies: 635
-- Name: COLUMN tbl_abs.obs_ret_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_abs.obs_ret_abs IS 'OBSERVACAO DE RETORNO DO ABASTECIMENTO';


--
-- TOC entry 636 (class 1259 OID 566098)
-- Name: tbl_aea; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_aea (
    cd_aea numeric(10,0) NOT NULL,
    cd_atm numeric(5,0),
    est_ant_atm numeric(1,0),
    est_atu_atm numeric(1,0),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_aea OWNER TO scan;

--
-- TOC entry 9616 (class 0 OID 0)
-- Dependencies: 636
-- Name: TABLE tbl_aea; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_aea IS 'TABELA DE AUDITORIA DE ESTADO DO ATM';


--
-- TOC entry 9617 (class 0 OID 0)
-- Dependencies: 636
-- Name: COLUMN tbl_aea.cd_aea; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aea.cd_aea IS 'CODIGO';


--
-- TOC entry 9618 (class 0 OID 0)
-- Dependencies: 636
-- Name: COLUMN tbl_aea.cd_atm; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aea.cd_atm IS 'CODIGO DO ATM';


--
-- TOC entry 9619 (class 0 OID 0)
-- Dependencies: 636
-- Name: COLUMN tbl_aea.est_ant_atm; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aea.est_ant_atm IS 'ESTADO ANTERIOR DO ATM';


--
-- TOC entry 9620 (class 0 OID 0)
-- Dependencies: 636
-- Name: COLUMN tbl_aea.est_atu_atm; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aea.est_atu_atm IS 'ESTADO ATUAL DO ATM';


--
-- TOC entry 637 (class 1259 OID 566101)
-- Name: tbl_alt; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_alt (
    cd_alt numeric(10,0) NOT NULL,
    cd_tal numeric(10,0) NOT NULL,
    cd_atm numeric(10,0) NOT NULL,
    st_alt numeric(2,0) NOT NULL,
    mtv_fch_alt numeric(2,0),
    obs_fch_alt character varying(200),
    cd_fch_usr numeric(10,0),
    dt_fch_usr timestamp without time zone,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    dt_st_alt timestamp without time zone
);


ALTER TABLE tbl_alt OWNER TO scan;

--
-- TOC entry 9621 (class 0 OID 0)
-- Dependencies: 637
-- Name: TABLE tbl_alt; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_alt IS 'ALERTA';


--
-- TOC entry 9622 (class 0 OID 0)
-- Dependencies: 637
-- Name: COLUMN tbl_alt.cd_alt; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_alt.cd_alt IS 'CODIGO';


--
-- TOC entry 9623 (class 0 OID 0)
-- Dependencies: 637
-- Name: COLUMN tbl_alt.cd_tal; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_alt.cd_tal IS 'CODIGO TIPO DE ALERTA';


--
-- TOC entry 9624 (class 0 OID 0)
-- Dependencies: 637
-- Name: COLUMN tbl_alt.cd_atm; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_alt.cd_atm IS 'CODIGO ATM';


--
-- TOC entry 9625 (class 0 OID 0)
-- Dependencies: 637
-- Name: COLUMN tbl_alt.st_alt; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_alt.st_alt IS 'SITUACAO';


--
-- TOC entry 9626 (class 0 OID 0)
-- Dependencies: 637
-- Name: COLUMN tbl_alt.mtv_fch_alt; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_alt.mtv_fch_alt IS 'CODIGO DO FECHAMENTO';


--
-- TOC entry 9627 (class 0 OID 0)
-- Dependencies: 637
-- Name: COLUMN tbl_alt.obs_fch_alt; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_alt.obs_fch_alt IS 'OBSERVACAO DO FECHAMENTO';


--
-- TOC entry 9628 (class 0 OID 0)
-- Dependencies: 637
-- Name: COLUMN tbl_alt.cd_fch_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_alt.cd_fch_usr IS 'USUARIO DO FECHAMENTO';


--
-- TOC entry 9629 (class 0 OID 0)
-- Dependencies: 637
-- Name: COLUMN tbl_alt.dt_fch_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_alt.dt_fch_usr IS 'DATA DO FECHAMENTO';


--
-- TOC entry 9630 (class 0 OID 0)
-- Dependencies: 637
-- Name: COLUMN tbl_alt.cd_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_alt.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9631 (class 0 OID 0)
-- Dependencies: 637
-- Name: COLUMN tbl_alt.dt_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_alt.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9632 (class 0 OID 0)
-- Dependencies: 637
-- Name: COLUMN tbl_alt.cd_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_alt.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 9633 (class 0 OID 0)
-- Dependencies: 637
-- Name: COLUMN tbl_alt.dt_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_alt.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 638 (class 1259 OID 566104)
-- Name: tbl_aop; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_aop (
    cd_aop numeric(10,0) NOT NULL,
    ds_aop character varying(50) NOT NULL,
    fg_atv_aop character varying(1) DEFAULT 'S'::character varying NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    CONSTRAINT ck_fg_atv_aop CHECK (((fg_atv_aop)::text = ANY (ARRAY[('N'::character varying)::text, ('S'::character varying)::text])))
);


ALTER TABLE tbl_aop OWNER TO scan;

--
-- TOC entry 9634 (class 0 OID 0)
-- Dependencies: 638
-- Name: TABLE tbl_aop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_aop IS 'TABELA DE ACAO DE OPERADOR';


--
-- TOC entry 9635 (class 0 OID 0)
-- Dependencies: 638
-- Name: COLUMN tbl_aop.cd_aop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aop.cd_aop IS 'CODIGO';


--
-- TOC entry 9636 (class 0 OID 0)
-- Dependencies: 638
-- Name: COLUMN tbl_aop.ds_aop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aop.ds_aop IS 'DESCRICAO';


--
-- TOC entry 9637 (class 0 OID 0)
-- Dependencies: 638
-- Name: COLUMN tbl_aop.fg_atv_aop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aop.fg_atv_aop IS 'FLAG DE ATIVO';


--
-- TOC entry 9638 (class 0 OID 0)
-- Dependencies: 638
-- Name: COLUMN tbl_aop.cd_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aop.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9639 (class 0 OID 0)
-- Dependencies: 638
-- Name: COLUMN tbl_aop.dt_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aop.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9640 (class 0 OID 0)
-- Dependencies: 638
-- Name: COLUMN tbl_aop.cd_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aop.cd_alt_usr IS 'USUARIO QUE REALIZOU A ULTIMA ALTERACAO';


--
-- TOC entry 9641 (class 0 OID 0)
-- Dependencies: 638
-- Name: COLUMN tbl_aop.dt_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_aop.dt_alt_usr IS 'DATA DA ULTIMA ALTERACAO';


--
-- TOC entry 639 (class 1259 OID 566109)
-- Name: tbl_atm; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_atm (
    cd_atm numeric(5,0) NOT NULL,
    cd_cnt numeric(10,0) NOT NULL,
    nm_atm character varying(50) NOT NULL,
    nr_hd_atm character varying(40) NOT NULL,
    hr_abr_atm timestamp without time zone NOT NULL,
    hr_fch_atm timestamp without time zone NOT NULL,
    est_atm numeric(1,0) NOT NULL,
    nr_ping_abr_atm integer,
    nr_ping_fch_atm integer,
    dt_inc_usr timestamp without time zone,
    cd_inc_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_alt_usr numeric(10,0),
    cd_edr numeric(10,0),
    fg_atv_atm character varying(1) DEFAULT 'S'::character varying NOT NULL,
    fg_imp_atm character(1) DEFAULT 'S'::bpchar NOT NULL,
    fg_lei_dip_atm character(1) DEFAULT 'S'::bpchar NOT NULL,
    fg_tcl_atm character(1) DEFAULT 'S'::bpchar NOT NULL,
    fg_mcn_atm character(1) DEFAULT 'S'::bpchar NOT NULL,
    qtd_css_atm numeric(1,0) DEFAULT 4 NOT NULL,
    cd_tsr numeric(10,0) NOT NULL,
    cd_cnt_dif_atm numeric(10,0) NOT NULL,
    dt_ult_atu_atm timestamp without time zone,
    fg_blq_atm character varying(1) DEFAULT 'N'::character varying,
    ltd_atm numeric(10,8),
    lgt_atm numeric(10,8),
    CONSTRAINT ck_fg_imp_atm CHECK ((fg_imp_atm = ANY (ARRAY['N'::bpchar, 'S'::bpchar]))),
    CONSTRAINT ck_fg_lei_dip_atm CHECK ((fg_lei_dip_atm = ANY (ARRAY['N'::bpchar, 'S'::bpchar]))),
    CONSTRAINT ck_fg_mcn_atm CHECK ((fg_mcn_atm = ANY (ARRAY['N'::bpchar, 'S'::bpchar]))),
    CONSTRAINT ck_fg_tcl_atm CHECK ((fg_tcl_atm = ANY (ARRAY['N'::bpchar, 'S'::bpchar])))
)
WITH (autovacuum_enabled='false');


ALTER TABLE tbl_atm OWNER TO scan;

--
-- TOC entry 9642 (class 0 OID 0)
-- Dependencies: 639
-- Name: TABLE tbl_atm; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_atm IS 'TABELA DE ATM';


--
-- TOC entry 9643 (class 0 OID 0)
-- Dependencies: 639
-- Name: COLUMN tbl_atm.ltd_atm; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_atm.ltd_atm IS 'latitude';


--
-- TOC entry 9644 (class 0 OID 0)
-- Dependencies: 639
-- Name: COLUMN tbl_atm.lgt_atm; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_atm.lgt_atm IS 'longitude';


--
-- TOC entry 640 (class 1259 OID 566123)
-- Name: tbl_cda; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_cda (
    cd_cda numeric(10,0) NOT NULL,
    cd_atm numeric(10,0) NOT NULL,
    nm_cda character varying(40) NOT NULL,
    url_cda character varying(100) NOT NULL,
    fg_atv_cda character(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr date NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr date
);


ALTER TABLE tbl_cda OWNER TO scan;

--
-- TOC entry 9645 (class 0 OID 0)
-- Dependencies: 640
-- Name: TABLE tbl_cda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_cda IS 'cameras do ATM';


--
-- TOC entry 641 (class 1259 OID 566126)
-- Name: tbl_css; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_css (
    cd_atm numeric(5,0) NOT NULL,
    nm_ltr_css character varying(1) NOT NULL,
    fg_atv_css character varying(1),
    vl_cdl_css numeric(13,2),
    nr_cdl_css numeric(5,0),
    nr_cdl_rej_css numeric(4,0) DEFAULT 0 NOT NULL,
    cd_tbc numeric(2,0)
);


ALTER TABLE tbl_css OWNER TO scan;

--
-- TOC entry 9646 (class 0 OID 0)
-- Dependencies: 641
-- Name: TABLE tbl_css; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_css IS 'TABELA DE CASSETES';


--
-- TOC entry 9647 (class 0 OID 0)
-- Dependencies: 641
-- Name: COLUMN tbl_css.cd_atm; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_css.cd_atm IS 'CODIGO DO ATM';


--
-- TOC entry 9648 (class 0 OID 0)
-- Dependencies: 641
-- Name: COLUMN tbl_css.nm_ltr_css; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_css.nm_ltr_css IS 'LETRA DO CASSETE';


--
-- TOC entry 9649 (class 0 OID 0)
-- Dependencies: 641
-- Name: COLUMN tbl_css.fg_atv_css; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_css.fg_atv_css IS 'FLAG DE ATIVO';


--
-- TOC entry 9650 (class 0 OID 0)
-- Dependencies: 641
-- Name: COLUMN tbl_css.vl_cdl_css; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_css.vl_cdl_css IS 'VALOR DA CEDULA';


--
-- TOC entry 9651 (class 0 OID 0)
-- Dependencies: 641
-- Name: COLUMN tbl_css.nr_cdl_css; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_css.nr_cdl_css IS 'NUMERO DE CEDULAS DO CASSETE';


--
-- TOC entry 642 (class 1259 OID 566130)
-- Name: tbl_dab; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_dab (
    cd_dab numeric(10,0) NOT NULL,
    cd_abs numeric(10,0) NOT NULL,
    nm_ltr_dab character varying(1) NOT NULL,
    vl_cdl_dab numeric(13,2) NOT NULL,
    nr_cdl_dab numeric(5,0) NOT NULL,
    nr_cdl_rej_dab numeric(4,0),
    nr_cdl_ant_dab numeric(4,0),
    vl_cdl_ant_dab numeric(13,2),
    nr_cdl_ret_dab numeric(4,0),
    vl_cdl_ret_dab numeric(13,2),
    vl_ret_dab numeric(13,2),
    fg_alt_css_dab character varying(1) NOT NULL,
    nr_cdl_ret_css_dab numeric(4,0),
    nr_cdl_ret_rej_dab numeric(4,0)
);


ALTER TABLE tbl_dab OWNER TO scan;

--
-- TOC entry 9652 (class 0 OID 0)
-- Dependencies: 642
-- Name: TABLE tbl_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_dab IS 'TABELA DE DETALHE DE ABASTECIMENTO';


--
-- TOC entry 9653 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.cd_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.cd_dab IS 'CODIGO DO DETALHE DO ABASTECIMENTO';


--
-- TOC entry 9654 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.cd_abs; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.cd_abs IS 'CODIGO DO ABASTECIMENTO';


--
-- TOC entry 9655 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.nm_ltr_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.nm_ltr_dab IS 'NOME DA LETRA DO CASSETE A SER ABASTECIDO';


--
-- TOC entry 9656 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.vl_cdl_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.vl_cdl_dab IS 'VALOR DA CEDULA A SER ABASTECIDO';


--
-- TOC entry 9657 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.nr_cdl_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.nr_cdl_dab IS 'NUMERO DE CEDULAS A SER ABASTECIDO';


--
-- TOC entry 9658 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.nr_cdl_rej_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.nr_cdl_rej_dab IS 'NUMERO DE CEDULAS REJEITADAS';


--
-- TOC entry 9659 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.nr_cdl_ant_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.nr_cdl_ant_dab IS 'NUMERO DE CEDULAS ANTERIOR AO PROCESSAMENTO DO ABASTECIMENTO';


--
-- TOC entry 9660 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.vl_cdl_ant_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.vl_cdl_ant_dab IS 'VALOR DA CEDULA ANTERIOR AO PROCESSAMENTO DO ABASTECIMENTO';


--
-- TOC entry 9661 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.nr_cdl_ret_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.nr_cdl_ret_dab IS 'NUMERO DE CEDULAS RETIRADAS NA FINALIZACAO';


--
-- TOC entry 9662 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.vl_cdl_ret_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.vl_cdl_ret_dab IS 'VALOR DA CEDULA RETIRADA NA FINALIZACAO';


--
-- TOC entry 9663 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.vl_ret_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.vl_ret_dab IS 'VALOR DO RETIRADO NA FINALIZACAO';


--
-- TOC entry 9664 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.fg_alt_css_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.fg_alt_css_dab IS 'FLAG QUE IDENTIFICA SE O CASSETE DEVE SER TROCADO OU NAO';


--
-- TOC entry 9665 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.nr_cdl_ret_css_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.nr_cdl_ret_css_dab IS 'NUMERO DE CEDULAS RETORNADAS NOS CASSETES';


--
-- TOC entry 9666 (class 0 OID 0)
-- Dependencies: 642
-- Name: COLUMN tbl_dab.nr_cdl_ret_rej_dab; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dab.nr_cdl_ret_rej_dab IS 'NUMERO DE CEDULAS RETORNADAS NA REJEICAO';


--
-- TOC entry 643 (class 1259 OID 566133)
-- Name: tbl_drqa; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_drqa (
    cd_drqa numeric(15,0) NOT NULL,
    cd_rqa numeric(10,0) NOT NULL,
    cd_opr numeric(10,0) NOT NULL,
    nm_ltr_drqa "char" NOT NULL,
    nr_cdl_drqa numeric(5,0) NOT NULL,
    vl_cdl_drqa numeric(13,2) NOT NULL,
    nr_ttl_cdl_drqa numeric(5,0) NOT NULL,
    nr_cdl_rjt_drqa numeric(5,0) DEFAULT 0 NOT NULL
);


ALTER TABLE tbl_drqa OWNER TO scan;

--
-- TOC entry 9667 (class 0 OID 0)
-- Dependencies: 643
-- Name: TABLE tbl_drqa; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_drqa IS 'TABELA DE DETALHE DA REQUISICAO DE OPERACAO DA INTEGRACAO';


--
-- TOC entry 644 (class 1259 OID 566137)
-- Name: tbl_dsp; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_dsp (
    cd_dsp numeric(10,0) NOT NULL,
    cd_tda numeric(10,0) NOT NULL,
    cd_atm numeric(5,0) NOT NULL,
    cd_ult_eda numeric(10,0),
    dt_ult_eda_dsp timestamp without time zone,
    fg_atv_dsp character varying(1) DEFAULT 'S'::character varying NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    CONSTRAINT ck_fg_atv_dsp CHECK (((fg_atv_dsp)::text = ANY (ARRAY[('N'::character varying)::text, ('S'::character varying)::text])))
);


ALTER TABLE tbl_dsp OWNER TO scan;

--
-- TOC entry 9668 (class 0 OID 0)
-- Dependencies: 644
-- Name: TABLE tbl_dsp; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_dsp IS 'TABELA DE DISPOSITIVO DE ATM';


--
-- TOC entry 9669 (class 0 OID 0)
-- Dependencies: 644
-- Name: COLUMN tbl_dsp.cd_dsp; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_dsp IS 'CODIGO';


--
-- TOC entry 9670 (class 0 OID 0)
-- Dependencies: 644
-- Name: COLUMN tbl_dsp.cd_tda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_tda IS 'CODIGO DO TIPO DE DISPOSITIVO';


--
-- TOC entry 9671 (class 0 OID 0)
-- Dependencies: 644
-- Name: COLUMN tbl_dsp.cd_atm; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_atm IS 'CODIGO DO ATM';


--
-- TOC entry 9672 (class 0 OID 0)
-- Dependencies: 644
-- Name: COLUMN tbl_dsp.cd_ult_eda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_ult_eda IS 'CODIGO DO ULTIMO ERRO DO DISPOSITIVO';


--
-- TOC entry 9673 (class 0 OID 0)
-- Dependencies: 644
-- Name: COLUMN tbl_dsp.dt_ult_eda_dsp; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.dt_ult_eda_dsp IS 'DATA DO ULTIMO ERRO DO DISPOSITIVO';


--
-- TOC entry 9674 (class 0 OID 0)
-- Dependencies: 644
-- Name: COLUMN tbl_dsp.fg_atv_dsp; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.fg_atv_dsp IS 'FLAG DE ATIVO';


--
-- TOC entry 9675 (class 0 OID 0)
-- Dependencies: 644
-- Name: COLUMN tbl_dsp.cd_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9676 (class 0 OID 0)
-- Dependencies: 644
-- Name: COLUMN tbl_dsp.dt_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9677 (class 0 OID 0)
-- Dependencies: 644
-- Name: COLUMN tbl_dsp.cd_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.cd_alt_usr IS 'USUARIO QUE REALIZOU A ULTIMA ALTERACAO';


--
-- TOC entry 9678 (class 0 OID 0)
-- Dependencies: 644
-- Name: COLUMN tbl_dsp.dt_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_dsp.dt_alt_usr IS 'DATA DA ULTIMA ALTERACAO';


--
-- TOC entry 645 (class 1259 OID 566142)
-- Name: tbl_eda; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_eda (
    cd_eda numeric(10,0) NOT NULL,
    cd_err_eda numeric(5,0) NOT NULL,
    cd_tda numeric(10,0) NOT NULL,
    ds_eda character varying(250) NOT NULL,
    fg_atv_eda character varying(1) DEFAULT 'S'::character varying NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    CONSTRAINT ck_fg_atv_eda CHECK (((fg_atv_eda)::text = ANY (ARRAY[('N'::character varying)::text, ('S'::character varying)::text])))
);


ALTER TABLE tbl_eda OWNER TO scan;

--
-- TOC entry 9679 (class 0 OID 0)
-- Dependencies: 645
-- Name: TABLE tbl_eda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_eda IS 'TABELA DE ERRO DE DISPOSITIVO DE ATM';


--
-- TOC entry 9680 (class 0 OID 0)
-- Dependencies: 645
-- Name: COLUMN tbl_eda.cd_eda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda.cd_eda IS 'CODIGO';


--
-- TOC entry 9681 (class 0 OID 0)
-- Dependencies: 645
-- Name: COLUMN tbl_eda.cd_err_eda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda.cd_err_eda IS 'CODIGO DO ERRO';


--
-- TOC entry 9682 (class 0 OID 0)
-- Dependencies: 645
-- Name: COLUMN tbl_eda.cd_tda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda.cd_tda IS 'CODIGO DO TIPO DE DISPOSITIVO';


--
-- TOC entry 9683 (class 0 OID 0)
-- Dependencies: 645
-- Name: COLUMN tbl_eda.ds_eda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda.ds_eda IS 'DESCRICAO';


--
-- TOC entry 9684 (class 0 OID 0)
-- Dependencies: 645
-- Name: COLUMN tbl_eda.fg_atv_eda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda.fg_atv_eda IS 'FLAG DE ATIVO';


--
-- TOC entry 9685 (class 0 OID 0)
-- Dependencies: 645
-- Name: COLUMN tbl_eda.cd_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9686 (class 0 OID 0)
-- Dependencies: 645
-- Name: COLUMN tbl_eda.dt_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9687 (class 0 OID 0)
-- Dependencies: 645
-- Name: COLUMN tbl_eda.cd_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda.cd_alt_usr IS 'USUARIO QUE REALIZOU A ULTIMA ALTERACAO';


--
-- TOC entry 9688 (class 0 OID 0)
-- Dependencies: 645
-- Name: COLUMN tbl_eda.dt_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda.dt_alt_usr IS 'DATA DA ULTIMA ALTERACAO';


--
-- TOC entry 646 (class 1259 OID 566147)
-- Name: tbl_eda_aap; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_eda_aap (
    cd_eda_aap numeric(10,0) NOT NULL,
    cd_eda numeric(10,0) NOT NULL,
    cd_aap numeric(10,0) NOT NULL
);


ALTER TABLE tbl_eda_aap OWNER TO scan;

--
-- TOC entry 9689 (class 0 OID 0)
-- Dependencies: 646
-- Name: TABLE tbl_eda_aap; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_eda_aap IS 'TABELA DE RELACIONAMENTO ENTRE: ERRO DE DISPOSITIVO DE ATM E ACAO APLICATIVO';


--
-- TOC entry 9690 (class 0 OID 0)
-- Dependencies: 646
-- Name: COLUMN tbl_eda_aap.cd_eda_aap; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda_aap.cd_eda_aap IS 'CODIGO';


--
-- TOC entry 9691 (class 0 OID 0)
-- Dependencies: 646
-- Name: COLUMN tbl_eda_aap.cd_eda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda_aap.cd_eda IS 'CODIGO DE ERRO DE DISPOSITIVO DE ATM';


--
-- TOC entry 9692 (class 0 OID 0)
-- Dependencies: 646
-- Name: COLUMN tbl_eda_aap.cd_aap; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda_aap.cd_aap IS 'CODIGO DE ACAO DE APLICATIVO';


--
-- TOC entry 647 (class 1259 OID 566150)
-- Name: tbl_eda_aop; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_eda_aop (
    cd_eda_aop numeric(10,0) NOT NULL,
    cd_eda numeric(10,0) NOT NULL,
    cd_aop numeric(10,0) NOT NULL
);


ALTER TABLE tbl_eda_aop OWNER TO scan;

--
-- TOC entry 9693 (class 0 OID 0)
-- Dependencies: 647
-- Name: TABLE tbl_eda_aop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_eda_aop IS 'TABELA DE RELACIONAMENTO ENTRE: ERRO DE DISPOSITIVO DE ATM E ACAO DE OPERADOR';


--
-- TOC entry 9694 (class 0 OID 0)
-- Dependencies: 647
-- Name: COLUMN tbl_eda_aop.cd_eda_aop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda_aop.cd_eda_aop IS 'CODIGO';


--
-- TOC entry 9695 (class 0 OID 0)
-- Dependencies: 647
-- Name: COLUMN tbl_eda_aop.cd_eda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda_aop.cd_eda IS 'CODIGO DE ERRO DE DISPOSITIVO DE ATM';


--
-- TOC entry 9696 (class 0 OID 0)
-- Dependencies: 647
-- Name: COLUMN tbl_eda_aop.cd_aop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_eda_aop.cd_aop IS 'CODIGO DE ACAO DE OPERADOR';


--
-- TOC entry 648 (class 1259 OID 566153)
-- Name: tbl_fca; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_fca (
    cd_fca numeric(10,0) NOT NULL,
    cd_atm numeric(5,0) NOT NULL,
    dt_ref_fca timestamp without time zone NOT NULL,
    vl_sld_ini_fca numeric(13,2),
    vl_sld_fin_fca numeric(13,2),
    vl_alv_fca numeric(13,2),
    vl_abs_fca numeric(13,2),
    nr_saq_fca numeric(5,0),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_fca OWNER TO scan;

--
-- TOC entry 9697 (class 0 OID 0)
-- Dependencies: 648
-- Name: TABLE tbl_fca; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_fca IS 'TABELA DE FECHAMENTO DO ATM';


--
-- TOC entry 9698 (class 0 OID 0)
-- Dependencies: 648
-- Name: COLUMN tbl_fca.cd_fca; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_fca.cd_fca IS 'CODIGO';


--
-- TOC entry 9699 (class 0 OID 0)
-- Dependencies: 648
-- Name: COLUMN tbl_fca.cd_atm; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_fca.cd_atm IS 'CODIGO DO ATM';


--
-- TOC entry 9700 (class 0 OID 0)
-- Dependencies: 648
-- Name: COLUMN tbl_fca.dt_ref_fca; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_fca.dt_ref_fca IS 'DATA DE REFERENCIA DO FECHAMENTO';


--
-- TOC entry 9701 (class 0 OID 0)
-- Dependencies: 648
-- Name: COLUMN tbl_fca.vl_sld_ini_fca; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_fca.vl_sld_ini_fca IS 'VALOR DO SALDO INICIAL';


--
-- TOC entry 9702 (class 0 OID 0)
-- Dependencies: 648
-- Name: COLUMN tbl_fca.vl_sld_fin_fca; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_fca.vl_sld_fin_fca IS 'VALOR DO SALDO FINAL DO FECHAMENTO';


--
-- TOC entry 9703 (class 0 OID 0)
-- Dependencies: 648
-- Name: COLUMN tbl_fca.vl_alv_fca; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_fca.vl_alv_fca IS 'VALOR DO ALIVIO DO FECHAMENTO';


--
-- TOC entry 9704 (class 0 OID 0)
-- Dependencies: 648
-- Name: COLUMN tbl_fca.vl_abs_fca; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_fca.vl_abs_fca IS 'VALOR ABASTECIMENTO DO FECHAMENTO';


--
-- TOC entry 9705 (class 0 OID 0)
-- Dependencies: 648
-- Name: COLUMN tbl_fca.nr_saq_fca; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_fca.nr_saq_fca IS 'NUMERO DE SAQUES DO FECHAMENTO';


--
-- TOC entry 9706 (class 0 OID 0)
-- Dependencies: 648
-- Name: COLUMN tbl_fca.cd_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_fca.cd_inc_usr IS 'CODIGO USUARIO DA INCLUSAO';


--
-- TOC entry 9707 (class 0 OID 0)
-- Dependencies: 648
-- Name: COLUMN tbl_fca.dt_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_fca.dt_inc_usr IS 'DATA DA INCLUSAO';


--
-- TOC entry 649 (class 1259 OID 566156)
-- Name: tbl_fva; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_fva (
    cd_fva numeric(10,0) NOT NULL,
    cd_vma numeric(10,0) NOT NULL,
    dt_fva date NOT NULL,
    vl_fva numeric(13,2)
);


ALTER TABLE tbl_fva OWNER TO scan;

--
-- TOC entry 650 (class 1259 OID 566159)
-- Name: tbl_led; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_led (
    cd_led numeric(10,0) NOT NULL,
    cd_dsp numeric(10,0) NOT NULL,
    cd_eda numeric(10,0) NOT NULL,
    dt_led timestamp without time zone NOT NULL,
    nr_nsu_org_led numeric(10,0) NOT NULL
);


ALTER TABLE tbl_led OWNER TO scan;

--
-- TOC entry 9708 (class 0 OID 0)
-- Dependencies: 650
-- Name: TABLE tbl_led; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_led IS 'TABELA DE LOG DE ERRO DE DISPOSITIVO DE ATM';


--
-- TOC entry 9709 (class 0 OID 0)
-- Dependencies: 650
-- Name: COLUMN tbl_led.cd_led; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_led.cd_led IS 'CODIGO';


--
-- TOC entry 9710 (class 0 OID 0)
-- Dependencies: 650
-- Name: COLUMN tbl_led.cd_dsp; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_led.cd_dsp IS 'CODIGO DE DISPOSITIVO DE ATM';


--
-- TOC entry 9711 (class 0 OID 0)
-- Dependencies: 650
-- Name: COLUMN tbl_led.cd_eda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_led.cd_eda IS 'CODIGO DE ERRO DE DISPOSITIVO DE ATM';


--
-- TOC entry 9712 (class 0 OID 0)
-- Dependencies: 650
-- Name: COLUMN tbl_led.dt_led; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_led.dt_led IS 'DATA';


--
-- TOC entry 651 (class 1259 OID 566162)
-- Name: tbl_oca; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_oca (
    cd_oca numeric(10,0) NOT NULL,
    cd_abs numeric(10,0) NOT NULL,
    tp_oca numeric(5,0) NOT NULL,
    his_oca character varying(400),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_oca OWNER TO scan;

--
-- TOC entry 652 (class 1259 OID 566165)
-- Name: tbl_pda; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_pda (
    cd_pda numeric(10,0) NOT NULL,
    ds_pda character varying(50) NOT NULL,
    fg_atv_pda character varying(1) DEFAULT 'S'::character varying NOT NULL,
    ds_cmd_sql_pda character varying(250) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    tam_resp_pda numeric(3,0),
    CONSTRAINT ck_fg_atv_aap CHECK (((fg_atv_pda)::text = ANY (ARRAY[('N'::character varying)::text, ('S'::character varying)::text])))
);


ALTER TABLE tbl_pda OWNER TO scan;

--
-- TOC entry 9713 (class 0 OID 0)
-- Dependencies: 652
-- Name: TABLE tbl_pda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_pda IS 'TABELA DE PERGUNTAS DE DESBLOQUEIO NO ATM';


--
-- TOC entry 9714 (class 0 OID 0)
-- Dependencies: 652
-- Name: COLUMN tbl_pda.cd_pda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pda.cd_pda IS 'CODIGO';


--
-- TOC entry 9715 (class 0 OID 0)
-- Dependencies: 652
-- Name: COLUMN tbl_pda.ds_pda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pda.ds_pda IS 'DESCRICAO';


--
-- TOC entry 9716 (class 0 OID 0)
-- Dependencies: 652
-- Name: COLUMN tbl_pda.fg_atv_pda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pda.fg_atv_pda IS 'FLAG DE ATIVO';


--
-- TOC entry 9717 (class 0 OID 0)
-- Dependencies: 652
-- Name: COLUMN tbl_pda.ds_cmd_sql_pda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pda.ds_cmd_sql_pda IS 'COMANDO SQL PARA OBTER A RESPOSTA DA PERGUNTA';


--
-- TOC entry 9718 (class 0 OID 0)
-- Dependencies: 652
-- Name: COLUMN tbl_pda.cd_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pda.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9719 (class 0 OID 0)
-- Dependencies: 652
-- Name: COLUMN tbl_pda.dt_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pda.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9720 (class 0 OID 0)
-- Dependencies: 652
-- Name: COLUMN tbl_pda.cd_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pda.cd_alt_usr IS 'USUARIO QUE REALIZOU A ULTIMA ALTERACAO';


--
-- TOC entry 9721 (class 0 OID 0)
-- Dependencies: 652
-- Name: COLUMN tbl_pda.dt_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pda.dt_alt_usr IS 'DATA DA ULTIMA ALTERACAO';


--
-- TOC entry 653 (class 1259 OID 566170)
-- Name: tbl_pop; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_pop (
    cd_pop numeric(16,0) NOT NULL,
    dt_vld_pop date NOT NULL,
    nm_snh_pop character varying(40) NOT NULL,
    nm_pop character varying(30) NOT NULL,
    ds_pop character varying(80) NOT NULL,
    nr_scc_pop numeric(3,0) NOT NULL,
    fg_blq_pop character(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    fg_ems_pop character varying(1) DEFAULT 'N'::character varying NOT NULL,
    fg_snh_pop character varying(1) DEFAULT 'N'::character varying NOT NULL,
    cd_mpl numeric(2,0) NOT NULL
);


ALTER TABLE tbl_pop OWNER TO scan;

--
-- TOC entry 9722 (class 0 OID 0)
-- Dependencies: 653
-- Name: TABLE tbl_pop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_pop IS 'tabela de plastico do operador';


--
-- TOC entry 9723 (class 0 OID 0)
-- Dependencies: 653
-- Name: COLUMN tbl_pop.cd_pop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pop.cd_pop IS 'codigo';


--
-- TOC entry 9724 (class 0 OID 0)
-- Dependencies: 653
-- Name: COLUMN tbl_pop.dt_vld_pop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pop.dt_vld_pop IS 'data de validade';


--
-- TOC entry 9725 (class 0 OID 0)
-- Dependencies: 653
-- Name: COLUMN tbl_pop.nm_snh_pop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pop.nm_snh_pop IS 'senha do plastico';


--
-- TOC entry 9726 (class 0 OID 0)
-- Dependencies: 653
-- Name: COLUMN tbl_pop.nm_pop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pop.nm_pop IS 'nome impresso no plastico';


--
-- TOC entry 9727 (class 0 OID 0)
-- Dependencies: 653
-- Name: COLUMN tbl_pop.ds_pop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pop.ds_pop IS 'descricao';


--
-- TOC entry 9728 (class 0 OID 0)
-- Dependencies: 653
-- Name: COLUMN tbl_pop.nr_scc_pop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pop.nr_scc_pop IS 'security code do plastico';


--
-- TOC entry 9729 (class 0 OID 0)
-- Dependencies: 653
-- Name: COLUMN tbl_pop.fg_blq_pop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pop.fg_blq_pop IS 'flag de bloqueado';


--
-- TOC entry 9730 (class 0 OID 0)
-- Dependencies: 653
-- Name: COLUMN tbl_pop.cd_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pop.cd_inc_usr IS 'usuario de inclusao';


--
-- TOC entry 9731 (class 0 OID 0)
-- Dependencies: 653
-- Name: COLUMN tbl_pop.dt_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pop.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 9732 (class 0 OID 0)
-- Dependencies: 653
-- Name: COLUMN tbl_pop.fg_ems_pop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pop.fg_ems_pop IS 'flag de plastico ja emitido';


--
-- TOC entry 9733 (class 0 OID 0)
-- Dependencies: 653
-- Name: COLUMN tbl_pop.fg_snh_pop; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pop.fg_snh_pop IS 'flag de senha ja emitida';


--
-- TOC entry 9734 (class 0 OID 0)
-- Dependencies: 653
-- Name: COLUMN tbl_pop.cd_mpl; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_pop.cd_mpl IS 'codigo do modelo do plastico a ser emitido';


--
-- TOC entry 654 (class 1259 OID 566175)
-- Name: tbl_rqa; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_rqa (
    cd_rqa numeric(10,0) NOT NULL,
    cd_atm numeric(5,0) NOT NULL,
    cd_pls numeric(16,0),
    ds_aca_rqa character varying(50) NOT NULL,
    cd_top numeric(10,0),
    cd_opr numeric(10,0),
    vl_sac_opr numeric(13,2),
    st_rqa numeric(5,0) NOT NULL,
    nsu_rqa numeric(10,0) NOT NULL,
    dt_rqa timestamp without time zone NOT NULL,
    xml_env_rqa text,
    xml_ret_rqa text,
    st_opr numeric(5,0)
);


ALTER TABLE tbl_rqa OWNER TO scan;

--
-- TOC entry 9735 (class 0 OID 0)
-- Dependencies: 654
-- Name: TABLE tbl_rqa; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_rqa IS 'TABELA DE REQUISICAO DE INTEGRACAO SAQCARD';


--
-- TOC entry 9736 (class 0 OID 0)
-- Dependencies: 654
-- Name: COLUMN tbl_rqa.cd_rqa; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_rqa.cd_rqa IS 'codigo da requisicao';


--
-- TOC entry 9737 (class 0 OID 0)
-- Dependencies: 654
-- Name: COLUMN tbl_rqa.cd_atm; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_rqa.cd_atm IS 'codigo do atm';


--
-- TOC entry 9738 (class 0 OID 0)
-- Dependencies: 654
-- Name: COLUMN tbl_rqa.cd_pls; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_rqa.cd_pls IS 'codigo do plastico na saqcard';


--
-- TOC entry 9739 (class 0 OID 0)
-- Dependencies: 654
-- Name: COLUMN tbl_rqa.ds_aca_rqa; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_rqa.ds_aca_rqa IS 'descricao da acao da requisicao';


--
-- TOC entry 9740 (class 0 OID 0)
-- Dependencies: 654
-- Name: COLUMN tbl_rqa.cd_top; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_rqa.cd_top IS 'codigo do tipo de operacao';


--
-- TOC entry 9741 (class 0 OID 0)
-- Dependencies: 654
-- Name: COLUMN tbl_rqa.cd_opr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_rqa.cd_opr IS 'codigo da operacao na saqcard';


--
-- TOC entry 9742 (class 0 OID 0)
-- Dependencies: 654
-- Name: COLUMN tbl_rqa.vl_sac_opr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_rqa.vl_sac_opr IS 'valor sacado da operacao saqcard no atm da soma';


--
-- TOC entry 9743 (class 0 OID 0)
-- Dependencies: 654
-- Name: COLUMN tbl_rqa.st_rqa; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_rqa.st_rqa IS 'situacao da requisicao (ver tabela de dominio)';


--
-- TOC entry 9744 (class 0 OID 0)
-- Dependencies: 654
-- Name: COLUMN tbl_rqa.nsu_rqa; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_rqa.nsu_rqa IS 'codigo da nsu de origem da requisicao';


--
-- TOC entry 9745 (class 0 OID 0)
-- Dependencies: 654
-- Name: COLUMN tbl_rqa.dt_rqa; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_rqa.dt_rqa IS 'data da requisicao';


--
-- TOC entry 9746 (class 0 OID 0)
-- Dependencies: 654
-- Name: COLUMN tbl_rqa.xml_env_rqa; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_rqa.xml_env_rqa IS 'xml de envio ao autorizador saqcard';


--
-- TOC entry 9747 (class 0 OID 0)
-- Dependencies: 654
-- Name: COLUMN tbl_rqa.xml_ret_rqa; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_rqa.xml_ret_rqa IS 'xml de retorno do autorizador saqcard';


--
-- TOC entry 782 (class 1259 OID 857778)
-- Name: tbl_sfc; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_sfc (
    cd_sfc numeric(10,0) NOT NULL,
    cd_crt numeric(16,0) NOT NULL,
    vl_sfc numeric(13,2) NOT NULL,
    st_sfc numeric(5,0) NOT NULL,
    cd_vld_sfc character varying(4),
    cd_aut_sfc character varying(6),
    dt_exp_vld_sfc timestamp without time zone,
    dt_exp_aut_sfc timestamp without time zone,
    dt_vld_sfc timestamp without time zone,
    dt_saq_sfc timestamp without time zone,
    dt_cnc_sfc timestamp without time zone,
    cd_opr numeric(10,0),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    dt_ctb_sfc timestamp without time zone
);


ALTER TABLE tbl_sfc OWNER TO scan;

--
-- TOC entry 9748 (class 0 OID 0)
-- Dependencies: 782
-- Name: TABLE tbl_sfc; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_sfc IS 'tabela dos registros de saque facil - convenio pague menos';


--
-- TOC entry 655 (class 1259 OID 566181)
-- Name: tbl_tal; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_tal (
    cd_tal numeric(10,0) NOT NULL,
    ds_tal character varying(200) NOT NULL,
    crt_tal numeric(2,0) NOT NULL,
    fg_atv_tal character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_tal OWNER TO scan;

--
-- TOC entry 9749 (class 0 OID 0)
-- Dependencies: 655
-- Name: TABLE tbl_tal; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_tal IS 'TIPO ALERTA';


--
-- TOC entry 9750 (class 0 OID 0)
-- Dependencies: 655
-- Name: COLUMN tbl_tal.cd_tal; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tal.cd_tal IS 'CODIGO';


--
-- TOC entry 9751 (class 0 OID 0)
-- Dependencies: 655
-- Name: COLUMN tbl_tal.ds_tal; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tal.ds_tal IS 'DESCRICAO';


--
-- TOC entry 9752 (class 0 OID 0)
-- Dependencies: 655
-- Name: COLUMN tbl_tal.crt_tal; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tal.crt_tal IS 'CRITICIDADE';


--
-- TOC entry 9753 (class 0 OID 0)
-- Dependencies: 655
-- Name: COLUMN tbl_tal.fg_atv_tal; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tal.fg_atv_tal IS 'FLAG ATIVO';


--
-- TOC entry 9754 (class 0 OID 0)
-- Dependencies: 655
-- Name: COLUMN tbl_tal.cd_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tal.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9755 (class 0 OID 0)
-- Dependencies: 655
-- Name: COLUMN tbl_tal.dt_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tal.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9756 (class 0 OID 0)
-- Dependencies: 655
-- Name: COLUMN tbl_tal.cd_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tal.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 9757 (class 0 OID 0)
-- Dependencies: 655
-- Name: COLUMN tbl_tal.dt_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tal.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 656 (class 1259 OID 566184)
-- Name: tbl_tbc; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_tbc (
    cd_tbc numeric(2,0) NOT NULL,
    ds_tbc character varying(40) NOT NULL,
    fg_grc_tbc character(1) NOT NULL,
    CONSTRAINT ck_fg_grc_tbc CHECK ((fg_grc_tbc = ANY (ARRAY['A'::bpchar, 'S'::bpchar])))
);


ALTER TABLE tbl_tbc OWNER TO scan;

--
-- TOC entry 9758 (class 0 OID 0)
-- Dependencies: 656
-- Name: TABLE tbl_tbc; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_tbc IS 'tabela de tipo de bloqueio de cassete';


--
-- TOC entry 9759 (class 0 OID 0)
-- Dependencies: 656
-- Name: COLUMN tbl_tbc.cd_tbc; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tbc.cd_tbc IS 'codigo';


--
-- TOC entry 9760 (class 0 OID 0)
-- Dependencies: 656
-- Name: COLUMN tbl_tbc.ds_tbc; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tbc.ds_tbc IS 'descricao';


--
-- TOC entry 9761 (class 0 OID 0)
-- Dependencies: 656
-- Name: COLUMN tbl_tbc.fg_grc_tbc; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tbc.fg_grc_tbc IS 'flag de gerencia (A - ATM, S - SERVIDOR)';


--
-- TOC entry 657 (class 1259 OID 566188)
-- Name: tbl_tda; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_tda (
    cd_tda numeric(10,0) NOT NULL,
    ds_tda character varying(50) NOT NULL,
    fg_atv_tda character varying(1) DEFAULT 'S'::character varying NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    CONSTRAINT ck_fg_atv_dsp CHECK (((fg_atv_tda)::text = ANY (ARRAY[('N'::character varying)::text, ('S'::character varying)::text])))
);


ALTER TABLE tbl_tda OWNER TO scan;

--
-- TOC entry 9762 (class 0 OID 0)
-- Dependencies: 657
-- Name: TABLE tbl_tda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_tda IS 'TABELA DE DISPOSITIVO DE ATM';


--
-- TOC entry 9763 (class 0 OID 0)
-- Dependencies: 657
-- Name: COLUMN tbl_tda.cd_tda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tda.cd_tda IS 'CODIGO';


--
-- TOC entry 9764 (class 0 OID 0)
-- Dependencies: 657
-- Name: COLUMN tbl_tda.ds_tda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tda.ds_tda IS 'DESCRICAO';


--
-- TOC entry 9765 (class 0 OID 0)
-- Dependencies: 657
-- Name: COLUMN tbl_tda.fg_atv_tda; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tda.fg_atv_tda IS 'FLAG DE ATIVO';


--
-- TOC entry 9766 (class 0 OID 0)
-- Dependencies: 657
-- Name: COLUMN tbl_tda.cd_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tda.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 9767 (class 0 OID 0)
-- Dependencies: 657
-- Name: COLUMN tbl_tda.dt_inc_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tda.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 9768 (class 0 OID 0)
-- Dependencies: 657
-- Name: COLUMN tbl_tda.cd_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tda.cd_alt_usr IS 'USUARIO QUE REALIZOU A ULTIMA ALTERACAO';


--
-- TOC entry 9769 (class 0 OID 0)
-- Dependencies: 657
-- Name: COLUMN tbl_tda.dt_alt_usr; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_tda.dt_alt_usr IS 'DATA DA ULTIMA ALTERACAO';


--
-- TOC entry 658 (class 1259 OID 566193)
-- Name: tbl_vma; Type: TABLE; Schema: sc_rds; Owner: scan
--

CREATE TABLE tbl_vma (
    cd_vma numeric(3,0) NOT NULL,
    dsc_vma character varying NOT NULL,
    vl_vma numeric(13,2) NOT NULL,
    sql_vma character varying(4000) NOT NULL,
    fg_atv_vma character varying(1) DEFAULT 'S'::character varying NOT NULL,
    dt_ult_atl_vma timestamp without time zone NOT NULL
);


ALTER TABLE tbl_vma OWNER TO scan;

--
-- TOC entry 9770 (class 0 OID 0)
-- Dependencies: 658
-- Name: TABLE tbl_vma; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON TABLE tbl_vma IS 'TABELA DE VALORES DO MONITOR ATM';


--
-- TOC entry 9771 (class 0 OID 0)
-- Dependencies: 658
-- Name: COLUMN tbl_vma.cd_vma; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_vma.cd_vma IS 'CODIGO DO VALOR';


--
-- TOC entry 9772 (class 0 OID 0)
-- Dependencies: 658
-- Name: COLUMN tbl_vma.dsc_vma; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_vma.dsc_vma IS 'DESCRICAO DO VALOR';


--
-- TOC entry 9773 (class 0 OID 0)
-- Dependencies: 658
-- Name: COLUMN tbl_vma.vl_vma; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_vma.vl_vma IS 'VALOR';


--
-- TOC entry 9774 (class 0 OID 0)
-- Dependencies: 658
-- Name: COLUMN tbl_vma.dt_ult_atl_vma; Type: COMMENT; Schema: sc_rds; Owner: scan
--

COMMENT ON COLUMN tbl_vma.dt_ult_atl_vma IS 'DATA DA ULTIMA ATUALIZACAO';


SET search_path = sc_rel, pg_catalog;

--
-- TOC entry 928 (class 1259 OID 1058829)
-- Name: vw_tarifas_filial; Type: VIEW; Schema: sc_rel; Owner: scan
--

CREATE VIEW vw_tarifas_filial AS
SELECT e.nm_emp AS empresa, f.nm_fem AS filial, (SELECT get_parametro_contrato_filial.vr_valor FROM sc_cad.get_parametro_contrato_filial((1)::numeric, c.cd_ctr, c.cd_fem) get_parametro_contrato_filial(vr_valor, vr_tipo_pagamento, vr_tipo_valor)) AS dia_vencimento, (SELECT get_parametro_contrato_filial.vr_valor FROM sc_cad.get_parametro_contrato_filial((6)::numeric, c.cd_ctr, c.cd_fem) get_parametro_contrato_filial(vr_valor, vr_tipo_pagamento, vr_tipo_valor)) AS trf_d1, (SELECT get_parametro_contrato_filial.vr_valor FROM sc_cad.get_parametro_contrato_filial((20)::numeric, c.cd_ctr, c.cd_fem) get_parametro_contrato_filial(vr_valor, vr_tipo_pagamento, vr_tipo_valor)) AS trf_d2, (SELECT get_parametro_contrato_filial.vr_valor FROM sc_cad.get_parametro_contrato_filial((8)::numeric, c.cd_ctr, c.cd_fem) get_parametro_contrato_filial(vr_valor, vr_tipo_pagamento, vr_tipo_valor)) AS pri_via, (SELECT get_parametro_contrato_filial.vr_valor FROM sc_cad.get_parametro_contrato_filial((15)::numeric, c.cd_ctr, c.cd_fem) get_parametro_contrato_filial(vr_valor, vr_tipo_pagamento, vr_tipo_valor)) AS tsm FROM ((sc_cad.tbl_fem_ctr c JOIN sc_cad.tbl_fem f ON (((f.cd_emp = c.cd_emp) AND (f.cd_fem = c.cd_fem)))) JOIN sc_cad.tbl_emp e ON ((e.cd_emp = f.cd_emp))) WHERE ((c.fg_atv_fem_ctr)::text = 'S'::text) ORDER BY e.nm_emp, f.nm_fem;


ALTER TABLE vw_tarifas_filial OWNER TO scan;

SET search_path = sc_rnc, pg_catalog;

--
-- TOC entry 659 (class 1259 OID 566200)
-- Name: sq_rnc; Type: SEQUENCE; Schema: sc_rnc; Owner: scan
--

CREATE SEQUENCE sq_rnc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999999
    CACHE 1;


ALTER TABLE sq_rnc OWNER TO scan;

--
-- TOC entry 660 (class 1259 OID 566202)
-- Name: sq_rnc_aux; Type: SEQUENCE; Schema: sc_rnc; Owner: scan
--

CREATE SEQUENCE sq_rnc_aux
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999999
    CACHE 1;


ALTER TABLE sq_rnc_aux OWNER TO scan;

--
-- TOC entry 661 (class 1259 OID 566204)
-- Name: sq_rpc; Type: SEQUENCE; Schema: sc_rnc; Owner: scan
--

CREATE SEQUENCE sq_rpc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rpc OWNER TO scan;

--
-- TOC entry 662 (class 1259 OID 566206)
-- Name: tbl_dfa; Type: TABLE; Schema: sc_rnc; Owner: scan
--

CREATE TABLE tbl_dfa (
    cd_dfa numeric(5,0) NOT NULL,
    tp_dfa numeric(5,0) NOT NULL,
    fg_atv_dfa character(1) NOT NULL,
    nr_dia_ini_dfa numeric(5,0) NOT NULL,
    nr_dia_fim_dfa numeric(5,0) NOT NULL,
    vl_ini_dfa numeric(13,2) NOT NULL,
    vl_fim_dfa numeric(13,2) NOT NULL,
    vl_dsc_ini_dfa numeric(13,2) NOT NULL,
    vl_dsc_fim_dfa numeric(13,2) NOT NULL
);


ALTER TABLE tbl_dfa OWNER TO scan;

--
-- TOC entry 9775 (class 0 OID 0)
-- Dependencies: 662
-- Name: TABLE tbl_dfa; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON TABLE tbl_dfa IS 'tabela de desconto por faixa de atraso';


--
-- TOC entry 663 (class 1259 OID 566209)
-- Name: tbl_rnc; Type: TABLE; Schema: sc_rnc; Owner: scan
--

CREATE TABLE tbl_rnc (
    cd_rnc numeric(10,0) NOT NULL,
    cd_fcr numeric(10,0) NOT NULL,
    cd_opr numeric(10,0),
    dt_grc_rnc timestamp without time zone NOT NULL,
    dt_vnc_prc_rnc date NOT NULL,
    dt_vnc_ent_rnc date,
    vl_dsc_rnc numeric(13,2) DEFAULT 0,
    vl_rnc numeric(13,2) NOT NULL,
    vl_ent_rnc numeric(13,2) DEFAULT 0,
    nr_prc_rnc numeric(5,0) NOT NULL,
    vl_prc_rnc numeric(13,2) NOT NULL,
    st_rnc numeric(5,0) NOT NULL,
    tx_jrs_rnc numeric(6,5) NOT NULL,
    vl_trf_rnc numeric(13,2) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_cfc_usr numeric(10,0),
    dt_cfc_usr timestamp without time zone,
    cd_cnc_usr numeric(10,0),
    dt_cnc_usr timestamp without time zone,
    vl_iof_rnc numeric(13,2) DEFAULT 0 NOT NULL,
    vl_prp_rnc numeric(13,2),
    pc_dsc_rnc numeric(13,2),
    vl_jrs_rnc numeric(13,2),
    nr_ctr_ext_rnc character varying(20),
    cd_emc numeric(10,0) DEFAULT 1 NOT NULL,
    cd_blt numeric(10,0)
);


ALTER TABLE tbl_rnc OWNER TO scan;

--
-- TOC entry 9776 (class 0 OID 0)
-- Dependencies: 663
-- Name: TABLE tbl_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON TABLE tbl_rnc IS 'tabela de renegociacao de fatura de cartao';


--
-- TOC entry 9777 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.cd_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.cd_rnc IS 'codigo';


--
-- TOC entry 9778 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.cd_fcr; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.cd_fcr IS 'codigo da fatura';


--
-- TOC entry 9779 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.cd_opr; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.cd_opr IS 'codigo da operacao';


--
-- TOC entry 9780 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.dt_grc_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.dt_grc_rnc IS 'data de geracao';


--
-- TOC entry 9781 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.dt_vnc_prc_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.dt_vnc_prc_rnc IS 'data vencimento parcelas';


--
-- TOC entry 9782 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.dt_vnc_ent_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.dt_vnc_ent_rnc IS 'data vencimento da entrada';


--
-- TOC entry 9783 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.vl_dsc_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.vl_dsc_rnc IS 'valor do desconto';


--
-- TOC entry 9784 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.vl_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.vl_rnc IS 'valor renegociado';


--
-- TOC entry 9785 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.nr_prc_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.nr_prc_rnc IS 'numero de parcelas';


--
-- TOC entry 9786 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.vl_prc_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.vl_prc_rnc IS 'valor da parcela';


--
-- TOC entry 9787 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.st_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.st_rnc IS 'situacao da renegociacao';


--
-- TOC entry 9788 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.tx_jrs_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.tx_jrs_rnc IS 'taxa de juros';


--
-- TOC entry 9789 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.vl_trf_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.vl_trf_rnc IS 'tarifa de renegociacao';


--
-- TOC entry 9790 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.cd_inc_usr; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.cd_inc_usr IS 'usuario de inclusao';


--
-- TOC entry 9791 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.dt_inc_usr; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 9792 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.cd_alt_usr; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.cd_alt_usr IS 'usuario de alteracao';


--
-- TOC entry 9793 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.dt_alt_usr; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 9794 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.cd_cfc_usr; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.cd_cfc_usr IS 'usuario de confirmacao';


--
-- TOC entry 9795 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.dt_cfc_usr; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.dt_cfc_usr IS 'data de confirmacao';


--
-- TOC entry 9796 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.cd_cnc_usr; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.cd_cnc_usr IS 'usuario de cancelamento';


--
-- TOC entry 9797 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.dt_cnc_usr; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.dt_cnc_usr IS 'data de cancelamento';


--
-- TOC entry 9798 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.nr_ctr_ext_rnc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.nr_ctr_ext_rnc IS 'Número contrato Externo';


--
-- TOC entry 9799 (class 0 OID 0)
-- Dependencies: 663
-- Name: COLUMN tbl_rnc.cd_emc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rnc.cd_emc IS 'Codigo da Empresa de Cobrança';


--
-- TOC entry 664 (class 1259 OID 566216)
-- Name: tbl_rnc_aux; Type: TABLE; Schema: sc_rnc; Owner: scan
--

CREATE TABLE tbl_rnc_aux (
    cd_rnc numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    vl_rnc numeric(13,2),
    vl_ent_rnc numeric(13,2),
    nr_prc_rnc numeric(5,0) NOT NULL,
    vl_prc_rnc numeric(13,2),
    dt_vnc_prc_rnc date NOT NULL,
    st_rnc numeric(5,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_emc numeric(10,0)
);


ALTER TABLE tbl_rnc_aux OWNER TO scan;

--
-- TOC entry 665 (class 1259 OID 566219)
-- Name: tbl_rpc; Type: TABLE; Schema: sc_rnc; Owner: scan
--

CREATE TABLE tbl_rpc (
    cd_rpc numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    cd_emc numeric(5,0) NOT NULL,
    vl_pgt_rpc numeric(10,2) NOT NULL,
    nr_prc_rpc numeric(2,0) NOT NULL,
    dt_pgt_rpc timestamp without time zone NOT NULL,
    st_rpc numeric(2,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_prc_rpc timestamp without time zone,
    cd_err_prc_rpc numeric(2,0)
);


ALTER TABLE tbl_rpc OWNER TO scan;

--
-- TOC entry 9800 (class 0 OID 0)
-- Dependencies: 665
-- Name: TABLE tbl_rpc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON TABLE tbl_rpc IS 'tabela de retorno dos pagamentos da cobranca tercerizada';


--
-- TOC entry 9801 (class 0 OID 0)
-- Dependencies: 665
-- Name: COLUMN tbl_rpc.cd_rpc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rpc.cd_rpc IS 'Código';


--
-- TOC entry 9802 (class 0 OID 0)
-- Dependencies: 665
-- Name: COLUMN tbl_rpc.cd_crt; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rpc.cd_crt IS 'Numero do Cartao';


--
-- TOC entry 9803 (class 0 OID 0)
-- Dependencies: 665
-- Name: COLUMN tbl_rpc.cd_emc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rpc.cd_emc IS 'Codigo da Empresa de Cobranca';


--
-- TOC entry 9804 (class 0 OID 0)
-- Dependencies: 665
-- Name: COLUMN tbl_rpc.vl_pgt_rpc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rpc.vl_pgt_rpc IS 'Valor Pagor';


--
-- TOC entry 9805 (class 0 OID 0)
-- Dependencies: 665
-- Name: COLUMN tbl_rpc.nr_prc_rpc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rpc.nr_prc_rpc IS 'Numero da Parcela Paga (Se for Zero, é o pagamento da entrada)';


--
-- TOC entry 9806 (class 0 OID 0)
-- Dependencies: 665
-- Name: COLUMN tbl_rpc.dt_pgt_rpc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rpc.dt_pgt_rpc IS 'Data do pagamento';


--
-- TOC entry 9807 (class 0 OID 0)
-- Dependencies: 665
-- Name: COLUMN tbl_rpc.st_rpc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rpc.st_rpc IS 'Situação (VER DOMINIO)';


--
-- TOC entry 9808 (class 0 OID 0)
-- Dependencies: 665
-- Name: COLUMN tbl_rpc.dt_inc_usr; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rpc.dt_inc_usr IS 'Data de Inclusao';


--
-- TOC entry 9809 (class 0 OID 0)
-- Dependencies: 665
-- Name: COLUMN tbl_rpc.cd_inc_usr; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rpc.cd_inc_usr IS 'Usuário de Inclusão ';


--
-- TOC entry 9810 (class 0 OID 0)
-- Dependencies: 665
-- Name: COLUMN tbl_rpc.dt_prc_rpc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rpc.dt_prc_rpc IS 'Data do processamento';


--
-- TOC entry 9811 (class 0 OID 0)
-- Dependencies: 665
-- Name: COLUMN tbl_rpc.cd_err_prc_rpc; Type: COMMENT; Schema: sc_rnc; Owner: scan
--

COMMENT ON COLUMN tbl_rpc.cd_err_prc_rpc IS 'Código do Erro do Processamento do Pagamento (VER DOMINIO)';


SET search_path = sc_rsc, pg_catalog;

--
-- TOC entry 666 (class 1259 OID 566222)
-- Name: sq_rsc; Type: SEQUENCE; Schema: sc_rsc; Owner: scan
--

CREATE SEQUENCE sq_rsc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999
    CACHE 1;


ALTER TABLE sq_rsc OWNER TO scan;

--
-- TOC entry 667 (class 1259 OID 566224)
-- Name: tbl_rsc; Type: TABLE; Schema: sc_rsc; Owner: scan
--

CREATE TABLE tbl_rsc (
    cd_rsc numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    dt_rsc timestamp without time zone NOT NULL,
    st_rsc numeric(2,0) DEFAULT 1 NOT NULL,
    tp_rsc numeric(2,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    vl_pgt_rsc numeric(13,2),
    obs_rsc character varying(200),
    vl_dvd_fnc_rsc numeric(13,2) NOT NULL,
    vl_dsc_rsc numeric(13,2) DEFAULT 0 NOT NULL,
    org_rsc numeric(1,0) NOT NULL
);


ALTER TABLE tbl_rsc OWNER TO scan;

--
-- TOC entry 9812 (class 0 OID 0)
-- Dependencies: 667
-- Name: TABLE tbl_rsc; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON TABLE tbl_rsc IS 'Tabela de rescisao';


--
-- TOC entry 9813 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.cd_rsc; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.cd_rsc IS 'Codigo da rescisao';


--
-- TOC entry 9814 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.cd_crt; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.cd_crt IS 'Codigo do cartao';


--
-- TOC entry 9815 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.dt_rsc; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.dt_rsc IS 'Data da demissao';


--
-- TOC entry 9816 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.st_rsc; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.st_rsc IS 'Situacao da rescisao. Ver tabela de dominio.';


--
-- TOC entry 9817 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.tp_rsc; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.tp_rsc IS 'Tipo da rescisao. Ver tabela de dominio';


--
-- TOC entry 9818 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.cd_inc_usr; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.cd_inc_usr IS 'Codigo do usuario de inclusao';


--
-- TOC entry 9819 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.dt_inc_usr; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.dt_inc_usr IS 'Data de inclusao do registro';


--
-- TOC entry 9820 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.cd_alt_usr; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.cd_alt_usr IS 'Codigo do usuario de alteracao';


--
-- TOC entry 9821 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.dt_alt_usr; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.dt_alt_usr IS 'Data da ultima alteracao do registro';


--
-- TOC entry 9822 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.vl_pgt_rsc; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.vl_pgt_rsc IS 'Valor pago da rescisao';


--
-- TOC entry 9823 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.obs_rsc; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.obs_rsc IS 'Observacao da rescisao';


--
-- TOC entry 9824 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.vl_dvd_fnc_rsc; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.vl_dvd_fnc_rsc IS 'Valor da divida do funcionario no momento da rescisao';


--
-- TOC entry 9825 (class 0 OID 0)
-- Dependencies: 667
-- Name: COLUMN tbl_rsc.vl_dsc_rsc; Type: COMMENT; Schema: sc_rsc; Owner: scan
--

COMMENT ON COLUMN tbl_rsc.vl_dsc_rsc IS 'Valor a ser descontado em rescisao';


SET search_path = sc_scan_cbe, pg_catalog;

--
-- TOC entry 886 (class 1259 OID 986064)
-- Name: tbl_dlq; Type: TABLE; Schema: sc_scan_cbe; Owner: scan
--

CREATE TABLE tbl_dlq (
    cd_dvd numeric(10,0) NOT NULL,
    dt_liq_dlq date,
    dt_inc_usr timestamp without time zone,
    cd_inc_usr numeric(10,0)
);


ALTER TABLE tbl_dlq OWNER TO scan;

SET search_path = sc_sgr, pg_catalog;

--
-- TOC entry 849 (class 1259 OID 899400)
-- Name: sq_acs; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_acs
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_acs OWNER TO scan;

--
-- TOC entry 986 (class 1259 OID 1665870)
-- Name: sq_aur; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_aur
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_aur OWNER TO scan;

--
-- TOC entry 914 (class 1259 OID 1007406)
-- Name: sq_cfv; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_cfv
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_cfv OWNER TO scan;

--
-- TOC entry 875 (class 1259 OID 973919)
-- Name: sq_epl; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_epl
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_epl OWNER TO scan;

--
-- TOC entry 668 (class 1259 OID 566229)
-- Name: sq_eus; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_eus
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_eus OWNER TO scan;

--
-- TOC entry 669 (class 1259 OID 566231)
-- Name: sq_grp; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_grp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_grp OWNER TO scan;

--
-- TOC entry 670 (class 1259 OID 566233)
-- Name: sq_grp_rol; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_grp_rol
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_grp_rol OWNER TO scan;

--
-- TOC entry 985 (class 1259 OID 1665868)
-- Name: sq_lur; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_lur
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_lur OWNER TO scan;

--
-- TOC entry 671 (class 1259 OID 566235)
-- Name: sq_menu; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_menu
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_menu OWNER TO scan;

--
-- TOC entry 672 (class 1259 OID 566237)
-- Name: sq_rol; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_rol
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rol OWNER TO scan;

--
-- TOC entry 673 (class 1259 OID 566239)
-- Name: sq_rol_sis; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_rol_sis
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rol_sis OWNER TO scan;

--
-- TOC entry 674 (class 1259 OID 566241)
-- Name: sq_sis; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_sis
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_sis OWNER TO scan;

--
-- TOC entry 675 (class 1259 OID 566243)
-- Name: sq_sis_usr; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_sis_usr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_sis_usr OWNER TO scan;

--
-- TOC entry 787 (class 1259 OID 862097)
-- Name: sq_spl; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_spl
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_spl OWNER TO scan;

--
-- TOC entry 967 (class 1259 OID 1637569)
-- Name: sq_tkn; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_tkn
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tkn OWNER TO scan;

--
-- TOC entry 824 (class 1259 OID 888995)
-- Name: sq_ucc; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_ucc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ucc OWNER TO scan;

--
-- TOC entry 676 (class 1259 OID 566245)
-- Name: sq_ucr; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_ucr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ucr OWNER TO scan;

--
-- TOC entry 677 (class 1259 OID 566247)
-- Name: sq_usr; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_usr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 99999999999
    CACHE 1;


ALTER TABLE sq_usr OWNER TO scan;

--
-- TOC entry 678 (class 1259 OID 566249)
-- Name: sq_usr_grp; Type: SEQUENCE; Schema: sc_sgr; Owner: scan
--

CREATE SEQUENCE sq_usr_grp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_usr_grp OWNER TO scan;

--
-- TOC entry 848 (class 1259 OID 899380)
-- Name: tbl_acs; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_acs (
    cd_acs numeric(10,0) NOT NULL,
    cd_usr numeric(10,0) NOT NULL,
    cd_rol numeric(10,0) NOT NULL,
    cd_sis numeric(10,0) NOT NULL,
    ip_acs character varying(40) NOT NULL,
    dt_acs timestamp without time zone NOT NULL
);


ALTER TABLE tbl_acs OWNER TO scan;

--
-- TOC entry 9826 (class 0 OID 0)
-- Dependencies: 848
-- Name: TABLE tbl_acs; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_acs IS 'TABELA ROLE SISTEMA';


--
-- TOC entry 9827 (class 0 OID 0)
-- Dependencies: 848
-- Name: COLUMN tbl_acs.cd_acs; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_acs.cd_acs IS 'CODIGO';


--
-- TOC entry 9828 (class 0 OID 0)
-- Dependencies: 848
-- Name: COLUMN tbl_acs.cd_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_acs.cd_usr IS 'CODIGO USUARIO';


--
-- TOC entry 9829 (class 0 OID 0)
-- Dependencies: 848
-- Name: COLUMN tbl_acs.cd_rol; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_acs.cd_rol IS 'ROLE';


--
-- TOC entry 9830 (class 0 OID 0)
-- Dependencies: 848
-- Name: COLUMN tbl_acs.cd_sis; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_acs.cd_sis IS 'SISTEMA';


--
-- TOC entry 9831 (class 0 OID 0)
-- Dependencies: 848
-- Name: COLUMN tbl_acs.ip_acs; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_acs.ip_acs IS 'IP REMOTO DE ACESSO';


--
-- TOC entry 9832 (class 0 OID 0)
-- Dependencies: 848
-- Name: COLUMN tbl_acs.dt_acs; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_acs.dt_acs IS 'DATA INCLUSAO';


--
-- TOC entry 984 (class 1259 OID 1665857)
-- Name: tbl_aur; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_aur (
    cd_aur numeric(10,0) NOT NULL,
    cd_lur numeric(10,0) NOT NULL,
    tp_aur numeric(2,0) NOT NULL,
    ent_aur text NOT NULL,
    sai_aur text,
    dt_inc_aur timestamp without time zone NOT NULL,
    dt_rsp_aur timestamp without time zone
);


ALTER TABLE tbl_aur OWNER TO scan;

--
-- TOC entry 9833 (class 0 OID 0)
-- Dependencies: 984
-- Name: TABLE tbl_aur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_aur IS 'tabela de atendimento da ura';


--
-- TOC entry 9834 (class 0 OID 0)
-- Dependencies: 984
-- Name: COLUMN tbl_aur.cd_aur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_aur.cd_aur IS 'código';


--
-- TOC entry 9835 (class 0 OID 0)
-- Dependencies: 984
-- Name: COLUMN tbl_aur.cd_lur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_aur.cd_lur IS 'código ligação';


--
-- TOC entry 9836 (class 0 OID 0)
-- Dependencies: 984
-- Name: COLUMN tbl_aur.tp_aur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_aur.tp_aur IS 'tipo de atendimento (ver tabela de dominio)';


--
-- TOC entry 9837 (class 0 OID 0)
-- Dependencies: 984
-- Name: COLUMN tbl_aur.ent_aur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_aur.ent_aur IS 'parâmetros de entrada';


--
-- TOC entry 9838 (class 0 OID 0)
-- Dependencies: 984
-- Name: COLUMN tbl_aur.sai_aur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_aur.sai_aur IS 'parâmetros de saída';


--
-- TOC entry 9839 (class 0 OID 0)
-- Dependencies: 984
-- Name: COLUMN tbl_aur.dt_inc_aur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_aur.dt_inc_aur IS 'data de inclusão';


--
-- TOC entry 9840 (class 0 OID 0)
-- Dependencies: 984
-- Name: COLUMN tbl_aur.dt_rsp_aur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_aur.dt_rsp_aur IS 'data da resposta';


--
-- TOC entry 915 (class 1259 OID 1007408)
-- Name: tbl_cfv; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_cfv (
    cd_cfv numeric(10,0) NOT NULL,
    cd_ucr numeric(10,0) NOT NULL,
    cd_crt_cfv numeric(14,0) NOT NULL,
    fg_atv_cfv character varying(1) NOT NULL,
    dt_inc_cfv timestamp without time zone NOT NULL
);


ALTER TABLE tbl_cfv OWNER TO scan;

--
-- TOC entry 9841 (class 0 OID 0)
-- Dependencies: 915
-- Name: TABLE tbl_cfv; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_cfv IS 'tabela de cartões favoritos';


--
-- TOC entry 9842 (class 0 OID 0)
-- Dependencies: 915
-- Name: COLUMN tbl_cfv.cd_cfv; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cfv.cd_cfv IS 'codigo';


--
-- TOC entry 9843 (class 0 OID 0)
-- Dependencies: 915
-- Name: COLUMN tbl_cfv.cd_ucr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cfv.cd_ucr IS 'código do usuário de cartão';


--
-- TOC entry 9844 (class 0 OID 0)
-- Dependencies: 915
-- Name: COLUMN tbl_cfv.cd_crt_cfv; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cfv.cd_crt_cfv IS 'código do cartão favorito';


--
-- TOC entry 9845 (class 0 OID 0)
-- Dependencies: 915
-- Name: COLUMN tbl_cfv.fg_atv_cfv; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cfv.fg_atv_cfv IS 'flag ativo';


--
-- TOC entry 9846 (class 0 OID 0)
-- Dependencies: 915
-- Name: COLUMN tbl_cfv.dt_inc_cfv; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cfv.dt_inc_cfv IS 'data de inclusão';


--
-- TOC entry 966 (class 1259 OID 1637539)
-- Name: tbl_cli; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_cli (
    cd_cli numeric(10,0) NOT NULL,
    id_cli character varying(40) NOT NULL,
    cd_sis numeric(10,0),
    pwd_cli character varying(100),
    nm_cli character varying(200),
    st_cli numeric(5,0),
    cd_inc_usr numeric(10,0),
    dt_inc_usr timestamp without time zone,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_cli OWNER TO scan;

--
-- TOC entry 9847 (class 0 OID 0)
-- Dependencies: 966
-- Name: TABLE tbl_cli; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_cli IS 'tabela de clientes de acesso a API';


--
-- TOC entry 9848 (class 0 OID 0)
-- Dependencies: 966
-- Name: COLUMN tbl_cli.cd_cli; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cli.cd_cli IS 'codigo';


--
-- TOC entry 9849 (class 0 OID 0)
-- Dependencies: 966
-- Name: COLUMN tbl_cli.id_cli; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cli.id_cli IS 'identificador';


--
-- TOC entry 9850 (class 0 OID 0)
-- Dependencies: 966
-- Name: COLUMN tbl_cli.cd_sis; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cli.cd_sis IS 'codigo do sistema';


--
-- TOC entry 9851 (class 0 OID 0)
-- Dependencies: 966
-- Name: COLUMN tbl_cli.pwd_cli; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cli.pwd_cli IS 'password';


--
-- TOC entry 9852 (class 0 OID 0)
-- Dependencies: 966
-- Name: COLUMN tbl_cli.nm_cli; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cli.nm_cli IS 'nome';


--
-- TOC entry 9853 (class 0 OID 0)
-- Dependencies: 966
-- Name: COLUMN tbl_cli.st_cli; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cli.st_cli IS 'situacao';


--
-- TOC entry 9854 (class 0 OID 0)
-- Dependencies: 966
-- Name: COLUMN tbl_cli.cd_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cli.cd_inc_usr IS 'usuario de inclusao';


--
-- TOC entry 9855 (class 0 OID 0)
-- Dependencies: 966
-- Name: COLUMN tbl_cli.dt_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cli.dt_inc_usr IS 'data de inclusao';


--
-- TOC entry 9856 (class 0 OID 0)
-- Dependencies: 966
-- Name: COLUMN tbl_cli.cd_alt_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cli.cd_alt_usr IS 'usuario de alteracao';


--
-- TOC entry 9857 (class 0 OID 0)
-- Dependencies: 966
-- Name: COLUMN tbl_cli.dt_alt_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_cli.dt_alt_usr IS 'data de alteracao';


--
-- TOC entry 876 (class 1259 OID 973921)
-- Name: tbl_epl; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_epl (
    cd_epl numeric(10,0) NOT NULL,
    tp_nsu_org_epl numeric(2,0) NOT NULL,
    nsu_org_epl numeric(16,0) NOT NULL,
    err_epl character varying(6000) NOT NULL,
    st_epl numeric(2,0) NOT NULL,
    mac_add_epl character varying(18) NOT NULL,
    sis_dsp_epl numeric(1,0) NOT NULL,
    obs_epl character varying(2000),
    vrs_sis_epl character varying(80) NOT NULL,
    vrs_app_epl character varying(6) NOT NULL,
    mrc_dsp_epl character varying(80) NOT NULL,
    mdl_dsp_epl character varying(80) NOT NULL,
    dt_inc_epl timestamp without time zone NOT NULL,
    cd_usr_alt numeric(10,0),
    dt_alt_epl timestamp without time zone
);


ALTER TABLE tbl_epl OWNER TO scan;

--
-- TOC entry 9858 (class 0 OID 0)
-- Dependencies: 876
-- Name: TABLE tbl_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_epl IS 'tabela de erros da aplicação';


--
-- TOC entry 9859 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.cd_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.cd_epl IS 'codigo';


--
-- TOC entry 9860 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.tp_nsu_org_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.tp_nsu_org_epl IS 'tipo do nsu de origem';


--
-- TOC entry 9861 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.nsu_org_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.nsu_org_epl IS 'nsu de origem';


--
-- TOC entry 9862 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.err_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.err_epl IS 'erro';


--
-- TOC entry 9863 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.st_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.st_epl IS 'situação';


--
-- TOC entry 9864 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.mac_add_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.mac_add_epl IS 'mac address dispositivo';


--
-- TOC entry 9865 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.sis_dsp_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.sis_dsp_epl IS 'sistema dispositivo';


--
-- TOC entry 9866 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.vrs_sis_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.vrs_sis_epl IS 'versão do sistema';


--
-- TOC entry 9867 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.vrs_app_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.vrs_app_epl IS 'versão do aplicativo';


--
-- TOC entry 9868 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.mrc_dsp_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.mrc_dsp_epl IS 'marca dispositivo';


--
-- TOC entry 9869 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.mdl_dsp_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.mdl_dsp_epl IS 'modelo dispositivo';


--
-- TOC entry 9870 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.dt_inc_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.dt_inc_epl IS 'data de inclusão';


--
-- TOC entry 9871 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.cd_usr_alt; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.cd_usr_alt IS 'código do usuário de alteração';


--
-- TOC entry 9872 (class 0 OID 0)
-- Dependencies: 876
-- Name: COLUMN tbl_epl.dt_alt_epl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_epl.dt_alt_epl IS 'data de inclusão';


--
-- TOC entry 679 (class 1259 OID 566251)
-- Name: tbl_grp; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_grp (
    cd_grp numeric(10,0) NOT NULL,
    ds_grp character varying(100) NOT NULL,
    fg_atv_grp character varying(1) DEFAULT 'S'::character varying NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_sis numeric(10,0) NOT NULL
);


ALTER TABLE tbl_grp OWNER TO scan;

--
-- TOC entry 9873 (class 0 OID 0)
-- Dependencies: 679
-- Name: TABLE tbl_grp; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_grp IS 'GRUPO';


--
-- TOC entry 9874 (class 0 OID 0)
-- Dependencies: 679
-- Name: COLUMN tbl_grp.cd_grp; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_grp.cd_grp IS 'CODIGO';


--
-- TOC entry 9875 (class 0 OID 0)
-- Dependencies: 679
-- Name: COLUMN tbl_grp.ds_grp; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_grp.ds_grp IS 'DESCRICAO';


--
-- TOC entry 680 (class 1259 OID 566255)
-- Name: tbl_grp_rol; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_grp_rol (
    cd_grp numeric(10,0) NOT NULL,
    cd_rol numeric(10,0) NOT NULL,
    fg_atv_grp_rol character varying(1) DEFAULT 'S'::character varying NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_grp_rol numeric(10,0) NOT NULL
);


ALTER TABLE tbl_grp_rol OWNER TO scan;

--
-- TOC entry 9876 (class 0 OID 0)
-- Dependencies: 680
-- Name: TABLE tbl_grp_rol; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_grp_rol IS 'GRUPO ROLES';


--
-- TOC entry 9877 (class 0 OID 0)
-- Dependencies: 680
-- Name: COLUMN tbl_grp_rol.cd_grp; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_grp_rol.cd_grp IS 'GRUPO';


--
-- TOC entry 9878 (class 0 OID 0)
-- Dependencies: 680
-- Name: COLUMN tbl_grp_rol.cd_rol; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_grp_rol.cd_rol IS 'ROLES';


--
-- TOC entry 983 (class 1259 OID 1665852)
-- Name: tbl_lur; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_lur (
    cd_lur numeric(10,0) NOT NULL,
    cd_pls numeric(16,0) NOT NULL,
    tkn_lur character varying(80) NOT NULL,
    nr_tlf_lur numeric(14,0),
    ip_lur character varying(20) NOT NULL,
    dt_ini_lur timestamp without time zone NOT NULL,
    dt_fim_lur timestamp without time zone,
    fg_vld_snh_lur character(1) DEFAULT 'N'::bpchar NOT NULL
);


ALTER TABLE tbl_lur OWNER TO scan;

--
-- TOC entry 9879 (class 0 OID 0)
-- Dependencies: 983
-- Name: TABLE tbl_lur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_lur IS 'tabela de ligação ura';


--
-- TOC entry 9880 (class 0 OID 0)
-- Dependencies: 983
-- Name: COLUMN tbl_lur.cd_lur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_lur.cd_lur IS 'código';


--
-- TOC entry 9881 (class 0 OID 0)
-- Dependencies: 983
-- Name: COLUMN tbl_lur.cd_pls; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_lur.cd_pls IS 'código plástico';


--
-- TOC entry 9882 (class 0 OID 0)
-- Dependencies: 983
-- Name: COLUMN tbl_lur.tkn_lur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_lur.tkn_lur IS 'token';


--
-- TOC entry 9883 (class 0 OID 0)
-- Dependencies: 983
-- Name: COLUMN tbl_lur.nr_tlf_lur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_lur.nr_tlf_lur IS 'número de telefone que originou a ligação';


--
-- TOC entry 9884 (class 0 OID 0)
-- Dependencies: 983
-- Name: COLUMN tbl_lur.ip_lur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_lur.ip_lur IS 'ip de origem';


--
-- TOC entry 9885 (class 0 OID 0)
-- Dependencies: 983
-- Name: COLUMN tbl_lur.dt_ini_lur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_lur.dt_ini_lur IS 'data de início da ligação';


--
-- TOC entry 9886 (class 0 OID 0)
-- Dependencies: 983
-- Name: COLUMN tbl_lur.dt_fim_lur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_lur.dt_fim_lur IS 'data de término da ligação';


--
-- TOC entry 9887 (class 0 OID 0)
-- Dependencies: 983
-- Name: COLUMN tbl_lur.fg_vld_snh_lur; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_lur.fg_vld_snh_lur IS 'flag de validacao de senha (S - senha foi validada; N - senha não foi validada)';


--
-- TOC entry 681 (class 1259 OID 566259)
-- Name: tbl_menu; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_menu (
    cd_menu numeric(10,0) NOT NULL,
    cd_sis numeric(10,0) NOT NULL,
    cd_rol numeric(10,0),
    cd_pai_menu numeric(10,0),
    fg_flh_menu character varying(1) NOT NULL,
    fg_atv_menu character varying(1) NOT NULL,
    nvl_menu numeric(2,0) NOT NULL,
    id_dsc_menu character varying(100) NOT NULL,
    dsc_menu character varying(100) NOT NULL,
    act_menu character varying(100) NOT NULL,
    cmp_menu character varying(100),
    trg_menu character varying(100),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_menu OWNER TO scan;

--
-- TOC entry 9888 (class 0 OID 0)
-- Dependencies: 681
-- Name: TABLE tbl_menu; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_menu IS 'MENU';


--
-- TOC entry 9889 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.cd_menu; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.cd_menu IS 'CODIGO';


--
-- TOC entry 9890 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.cd_sis; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.cd_sis IS 'SISTEMA';


--
-- TOC entry 9891 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.cd_rol; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.cd_rol IS 'ACESSO';


--
-- TOC entry 9892 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.cd_pai_menu; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.cd_pai_menu IS 'MENU PAI';


--
-- TOC entry 9893 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.fg_flh_menu; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.fg_flh_menu IS 'FLAG FOLHA';


--
-- TOC entry 9894 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.fg_atv_menu; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.fg_atv_menu IS 'FLAG ATIVO';


--
-- TOC entry 9895 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.nvl_menu; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.nvl_menu IS 'NIVEL';


--
-- TOC entry 9896 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.id_dsc_menu; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.id_dsc_menu IS 'ID DESCRICAO';


--
-- TOC entry 9897 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.dsc_menu; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.dsc_menu IS 'DESCRICAO';


--
-- TOC entry 9898 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.act_menu; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.act_menu IS 'ACTION';


--
-- TOC entry 9899 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.cmp_menu; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.cmp_menu IS 'COMPLEMENTO';


--
-- TOC entry 9900 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.trg_menu; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.trg_menu IS 'TARGETS';


--
-- TOC entry 9901 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.cd_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.cd_inc_usr IS 'USUARIO INCLUSAO';


--
-- TOC entry 9902 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.dt_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 9903 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.cd_alt_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.cd_alt_usr IS 'USUARIO ALTERACAO';


--
-- TOC entry 9904 (class 0 OID 0)
-- Dependencies: 681
-- Name: COLUMN tbl_menu.dt_alt_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_menu.dt_alt_usr IS 'DATA ALTERACAO';


--
-- TOC entry 682 (class 1259 OID 566265)
-- Name: tbl_rol; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_rol (
    cd_rol numeric(10,0) NOT NULL,
    nm_rol character varying(100) NOT NULL,
    fg_atv_rol character varying(1) DEFAULT 'S'::character varying NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_rol OWNER TO scan;

--
-- TOC entry 683 (class 1259 OID 566269)
-- Name: tbl_rol_sis; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_rol_sis (
    cd_rol_sis numeric(10,0) NOT NULL,
    cd_rol numeric(10,0) NOT NULL,
    cd_sis numeric(10,0) NOT NULL,
    fg_atv_rol_sis character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_rol_sis OWNER TO scan;

--
-- TOC entry 9905 (class 0 OID 0)
-- Dependencies: 683
-- Name: TABLE tbl_rol_sis; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_rol_sis IS 'TABELA ROLE SISTEMA';


--
-- TOC entry 9906 (class 0 OID 0)
-- Dependencies: 683
-- Name: COLUMN tbl_rol_sis.cd_rol_sis; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_rol_sis.cd_rol_sis IS 'CODIGO';


--
-- TOC entry 9907 (class 0 OID 0)
-- Dependencies: 683
-- Name: COLUMN tbl_rol_sis.cd_rol; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_rol_sis.cd_rol IS 'ROLE';


--
-- TOC entry 9908 (class 0 OID 0)
-- Dependencies: 683
-- Name: COLUMN tbl_rol_sis.cd_sis; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_rol_sis.cd_sis IS 'SISTEMA';


--
-- TOC entry 9909 (class 0 OID 0)
-- Dependencies: 683
-- Name: COLUMN tbl_rol_sis.fg_atv_rol_sis; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_rol_sis.fg_atv_rol_sis IS 'FLAG ATIVO';


--
-- TOC entry 9910 (class 0 OID 0)
-- Dependencies: 683
-- Name: COLUMN tbl_rol_sis.cd_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_rol_sis.cd_inc_usr IS 'USUARIO INCLUSAO';


--
-- TOC entry 9911 (class 0 OID 0)
-- Dependencies: 683
-- Name: COLUMN tbl_rol_sis.dt_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_rol_sis.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 9912 (class 0 OID 0)
-- Dependencies: 683
-- Name: COLUMN tbl_rol_sis.cd_alt_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_rol_sis.cd_alt_usr IS 'USUARIO ALTERACAO';


--
-- TOC entry 9913 (class 0 OID 0)
-- Dependencies: 683
-- Name: COLUMN tbl_rol_sis.dt_alt_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_rol_sis.dt_alt_usr IS 'DATA ALTERACAO';


--
-- TOC entry 684 (class 1259 OID 566272)
-- Name: tbl_sis; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_sis (
    cd_sis numeric(10,0) NOT NULL,
    nm_sis character varying(50) NOT NULL,
    fg_atv_sis character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_sis OWNER TO scan;

--
-- TOC entry 9914 (class 0 OID 0)
-- Dependencies: 684
-- Name: TABLE tbl_sis; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_sis IS 'SISTEMA';


--
-- TOC entry 9915 (class 0 OID 0)
-- Dependencies: 684
-- Name: COLUMN tbl_sis.cd_sis; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis.cd_sis IS 'CODIGO';


--
-- TOC entry 9916 (class 0 OID 0)
-- Dependencies: 684
-- Name: COLUMN tbl_sis.nm_sis; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis.nm_sis IS 'NOME';


--
-- TOC entry 9917 (class 0 OID 0)
-- Dependencies: 684
-- Name: COLUMN tbl_sis.fg_atv_sis; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis.fg_atv_sis IS 'FLAG ATIVO';


--
-- TOC entry 9918 (class 0 OID 0)
-- Dependencies: 684
-- Name: COLUMN tbl_sis.cd_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis.cd_inc_usr IS 'USUARIO INCLUSAO';


--
-- TOC entry 9919 (class 0 OID 0)
-- Dependencies: 684
-- Name: COLUMN tbl_sis.dt_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 9920 (class 0 OID 0)
-- Dependencies: 684
-- Name: COLUMN tbl_sis.cd_alt_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis.cd_alt_usr IS 'USUARIO ALTERACAO';


--
-- TOC entry 9921 (class 0 OID 0)
-- Dependencies: 684
-- Name: COLUMN tbl_sis.dt_alt_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis.dt_alt_usr IS 'DATA ALTERACAO';


--
-- TOC entry 685 (class 1259 OID 566275)
-- Name: tbl_sis_usr; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_sis_usr (
    cd_sis_usr numeric(10,0) NOT NULL,
    cd_sis numeric(10,0) NOT NULL,
    cd_usr numeric(10,0) NOT NULL,
    fg_atv_sis_usr character varying(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    fg_aud_sis_usr character varying(1)
);


ALTER TABLE tbl_sis_usr OWNER TO scan;

--
-- TOC entry 9922 (class 0 OID 0)
-- Dependencies: 685
-- Name: TABLE tbl_sis_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_sis_usr IS 'SISTEMA USUÁRIO';


--
-- TOC entry 9923 (class 0 OID 0)
-- Dependencies: 685
-- Name: COLUMN tbl_sis_usr.cd_sis_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis_usr.cd_sis_usr IS 'CODIGO';


--
-- TOC entry 9924 (class 0 OID 0)
-- Dependencies: 685
-- Name: COLUMN tbl_sis_usr.cd_sis; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis_usr.cd_sis IS 'SISTEMA';


--
-- TOC entry 9925 (class 0 OID 0)
-- Dependencies: 685
-- Name: COLUMN tbl_sis_usr.cd_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis_usr.cd_usr IS 'USUARIO';


--
-- TOC entry 9926 (class 0 OID 0)
-- Dependencies: 685
-- Name: COLUMN tbl_sis_usr.fg_atv_sis_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis_usr.fg_atv_sis_usr IS 'FLAG ATIVO';


--
-- TOC entry 9927 (class 0 OID 0)
-- Dependencies: 685
-- Name: COLUMN tbl_sis_usr.cd_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis_usr.cd_inc_usr IS 'USUARIO INCLUSAO';


--
-- TOC entry 9928 (class 0 OID 0)
-- Dependencies: 685
-- Name: COLUMN tbl_sis_usr.dt_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis_usr.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 9929 (class 0 OID 0)
-- Dependencies: 685
-- Name: COLUMN tbl_sis_usr.cd_alt_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis_usr.cd_alt_usr IS 'USUARIO ALTERACAO';


--
-- TOC entry 9930 (class 0 OID 0)
-- Dependencies: 685
-- Name: COLUMN tbl_sis_usr.dt_alt_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_sis_usr.dt_alt_usr IS 'DATA ALTERACAO';


--
-- TOC entry 788 (class 1259 OID 862099)
-- Name: tbl_spl; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_spl (
    cd_spl numeric(10,0) NOT NULL,
    tp_nsu_org_spl numeric(2,0) NOT NULL,
    nsu_org_spl numeric(14,0) NOT NULL,
    mac_add_spl character varying(40) NOT NULL,
    sis_dsp_spl numeric(1,0) NOT NULL,
    vrs_sis_spl character varying(80) NOT NULL,
    mrc_dsp_spl character varying(80) NOT NULL,
    mdl_dsp_spl character varying(80) NOT NULL,
    dt_inc_spl timestamp without time zone NOT NULL,
    dt_exp_spl timestamp without time zone,
    fg_atv_spl character varying(1) NOT NULL,
    ip_spl character varying(1000),
    vrs_app_spl character varying(6)
);


ALTER TABLE tbl_spl OWNER TO scan;

--
-- TOC entry 9931 (class 0 OID 0)
-- Dependencies: 788
-- Name: TABLE tbl_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_spl IS 'tabela de sessão da aplicação';


--
-- TOC entry 9932 (class 0 OID 0)
-- Dependencies: 788
-- Name: COLUMN tbl_spl.cd_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_spl.cd_spl IS 'codigo';


--
-- TOC entry 9933 (class 0 OID 0)
-- Dependencies: 788
-- Name: COLUMN tbl_spl.tp_nsu_org_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_spl.tp_nsu_org_spl IS 'tipo do nsu de origem';


--
-- TOC entry 9934 (class 0 OID 0)
-- Dependencies: 788
-- Name: COLUMN tbl_spl.nsu_org_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_spl.nsu_org_spl IS 'nsu de origem';


--
-- TOC entry 9935 (class 0 OID 0)
-- Dependencies: 788
-- Name: COLUMN tbl_spl.mac_add_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_spl.mac_add_spl IS 'mac address dispositivo';


--
-- TOC entry 9936 (class 0 OID 0)
-- Dependencies: 788
-- Name: COLUMN tbl_spl.sis_dsp_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_spl.sis_dsp_spl IS 'sistema dispositivo';


--
-- TOC entry 9937 (class 0 OID 0)
-- Dependencies: 788
-- Name: COLUMN tbl_spl.vrs_sis_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_spl.vrs_sis_spl IS 'versão do sistema';


--
-- TOC entry 9938 (class 0 OID 0)
-- Dependencies: 788
-- Name: COLUMN tbl_spl.mrc_dsp_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_spl.mrc_dsp_spl IS 'marca dispositivo';


--
-- TOC entry 9939 (class 0 OID 0)
-- Dependencies: 788
-- Name: COLUMN tbl_spl.mdl_dsp_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_spl.mdl_dsp_spl IS 'modelo dispositivo';


--
-- TOC entry 9940 (class 0 OID 0)
-- Dependencies: 788
-- Name: COLUMN tbl_spl.dt_inc_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_spl.dt_inc_spl IS 'data de inclusão';


--
-- TOC entry 9941 (class 0 OID 0)
-- Dependencies: 788
-- Name: COLUMN tbl_spl.dt_exp_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_spl.dt_exp_spl IS 'data de expiração';


--
-- TOC entry 9942 (class 0 OID 0)
-- Dependencies: 788
-- Name: COLUMN tbl_spl.fg_atv_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_spl.fg_atv_spl IS 'flag ativo';


--
-- TOC entry 9943 (class 0 OID 0)
-- Dependencies: 788
-- Name: COLUMN tbl_spl.ip_spl; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_spl.ip_spl IS 'ip';


--
-- TOC entry 965 (class 1259 OID 1637525)
-- Name: tbl_tkn; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_tkn (
    cd_tkn numeric(10,0) NOT NULL,
    id_tkn character varying(1000),
    dt_exp_tkn timestamp without time zone,
    cd_usr numeric(10,0)
);


ALTER TABLE tbl_tkn OWNER TO scan;

--
-- TOC entry 9944 (class 0 OID 0)
-- Dependencies: 965
-- Name: TABLE tbl_tkn; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_tkn IS 'tabela de controle dos tokens de acesso a API';


--
-- TOC entry 825 (class 1259 OID 888997)
-- Name: tbl_ucc; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_ucc (
    cd_ucc numeric(10,0) NOT NULL,
    cd_ucr numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    cd_pls numeric(16,0),
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_ucc OWNER TO scan;

--
-- TOC entry 9945 (class 0 OID 0)
-- Dependencies: 825
-- Name: TABLE tbl_ucc; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_ucc IS 'usuario cartao cartao';


--
-- TOC entry 9946 (class 0 OID 0)
-- Dependencies: 825
-- Name: COLUMN tbl_ucc.cd_ucc; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucc.cd_ucc IS 'codigo';


--
-- TOC entry 9947 (class 0 OID 0)
-- Dependencies: 825
-- Name: COLUMN tbl_ucc.cd_ucr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucc.cd_ucr IS 'codigo usuario cartao';


--
-- TOC entry 9948 (class 0 OID 0)
-- Dependencies: 825
-- Name: COLUMN tbl_ucc.cd_crt; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucc.cd_crt IS 'cartao';


--
-- TOC entry 9949 (class 0 OID 0)
-- Dependencies: 825
-- Name: COLUMN tbl_ucc.dt_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucc.dt_inc_usr IS 'data de inclusão';


--
-- TOC entry 835 (class 1259 OID 889173)
-- Name: tbl_ucc_old; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_ucc_old (
    cd_ucc numeric(10,0) NOT NULL,
    cd_ucr numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    cd_pls numeric(16,0),
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_ucc_old OWNER TO scan;

--
-- TOC entry 9950 (class 0 OID 0)
-- Dependencies: 835
-- Name: TABLE tbl_ucc_old; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_ucc_old IS 'usuario cartao cartao exlcuido';


--
-- TOC entry 9951 (class 0 OID 0)
-- Dependencies: 835
-- Name: COLUMN tbl_ucc_old.cd_ucc; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucc_old.cd_ucc IS 'codigo';


--
-- TOC entry 9952 (class 0 OID 0)
-- Dependencies: 835
-- Name: COLUMN tbl_ucc_old.cd_ucr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucc_old.cd_ucr IS 'codigo usuario cartao';


--
-- TOC entry 9953 (class 0 OID 0)
-- Dependencies: 835
-- Name: COLUMN tbl_ucc_old.cd_crt; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucc_old.cd_crt IS 'cartao';


--
-- TOC entry 9954 (class 0 OID 0)
-- Dependencies: 835
-- Name: COLUMN tbl_ucc_old.dt_inc_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucc_old.dt_inc_usr IS 'data de inclusão';


--
-- TOC entry 686 (class 1259 OID 566278)
-- Name: tbl_ucr; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_ucr (
    cd_ucr numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    lgn_ucr character varying(20) NOT NULL,
    snh_ucr character varying(50) NOT NULL,
    st_ucr numeric(2,0) NOT NULL,
    tp_rgs_ucr numeric(1,0),
    dt_inc_ucr timestamp without time zone DEFAULT now(),
    nr_err_snh_ucr numeric(5,0),
    id_push_msg character varying(200)
);


ALTER TABLE tbl_ucr OWNER TO scan;

--
-- TOC entry 9955 (class 0 OID 0)
-- Dependencies: 686
-- Name: TABLE tbl_ucr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_ucr IS 'EXTENSAO DE CARTAO';


--
-- TOC entry 9956 (class 0 OID 0)
-- Dependencies: 686
-- Name: COLUMN tbl_ucr.cd_ucr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucr.cd_ucr IS 'CODIGO';


--
-- TOC entry 9957 (class 0 OID 0)
-- Dependencies: 686
-- Name: COLUMN tbl_ucr.cd_crt; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucr.cd_crt IS 'CARTAO';


--
-- TOC entry 9958 (class 0 OID 0)
-- Dependencies: 686
-- Name: COLUMN tbl_ucr.lgn_ucr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucr.lgn_ucr IS 'LOGIN';


--
-- TOC entry 9959 (class 0 OID 0)
-- Dependencies: 686
-- Name: COLUMN tbl_ucr.snh_ucr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucr.snh_ucr IS 'SENHA';


--
-- TOC entry 9960 (class 0 OID 0)
-- Dependencies: 686
-- Name: COLUMN tbl_ucr.st_ucr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_ucr.st_ucr IS 'SITUACAO';


--
-- TOC entry 834 (class 1259 OID 889147)
-- Name: tbl_ucr_old; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_ucr_old (
    cd_ucr numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    lgn_ucr character varying(20) NOT NULL,
    snh_ucr character varying(50) NOT NULL,
    st_ucr numeric(2,0) NOT NULL,
    tp_rgs_ucr numeric(1,0),
    dt_inc_ucr timestamp without time zone,
    nr_err_snh_ucr numeric(1,0),
    dt_exc_ucr timestamp without time zone DEFAULT now(),
    usr_exc_ucr numeric(10,0),
    id_push_msg character varying(200)
);


ALTER TABLE tbl_ucr_old OWNER TO scan;

--
-- TOC entry 9961 (class 0 OID 0)
-- Dependencies: 834
-- Name: TABLE tbl_ucr_old; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_ucr_old IS 'USUARIO DE CARTAO EXCLUIDOS';


--
-- TOC entry 687 (class 1259 OID 566281)
-- Name: tbl_usr; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_usr (
    cd_usr numeric(10,0) NOT NULL,
    nm_usr character varying(80) NOT NULL,
    lgn_usr character varying(20) NOT NULL,
    snh_usr character varying(50) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    st_usr numeric(3,0) DEFAULT 1 NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    fg_adm_usr character varying(1) DEFAULT 'S'::character varying NOT NULL,
    CONSTRAINT ck_adm_usr CHECK (((fg_adm_usr)::text = ANY (ARRAY[('S'::character varying)::text, ('N'::character varying)::text])))
);


ALTER TABLE tbl_usr OWNER TO scan;

--
-- TOC entry 9962 (class 0 OID 0)
-- Dependencies: 687
-- Name: COLUMN tbl_usr.fg_adm_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_usr.fg_adm_usr IS 'ADMINISTRADOR';


--
-- TOC entry 688 (class 1259 OID 566287)
-- Name: tbl_usr_aux; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_usr_aux (
    cd_usr numeric(10,0) NOT NULL
);


ALTER TABLE tbl_usr_aux OWNER TO scan;

--
-- TOC entry 9963 (class 0 OID 0)
-- Dependencies: 688
-- Name: TABLE tbl_usr_aux; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_usr_aux IS 'tabela de usuario auxiliar';


--
-- TOC entry 689 (class 1259 OID 566290)
-- Name: tbl_usr_grp; Type: TABLE; Schema: sc_sgr; Owner: scan
--

CREATE TABLE tbl_usr_grp (
    cd_usr numeric(10,0) NOT NULL,
    cd_grp numeric(10,0) NOT NULL,
    fg_atv_usr_grp character varying(1) DEFAULT 'S'::character varying NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_usr_grp numeric(10,0) NOT NULL
);


ALTER TABLE tbl_usr_grp OWNER TO scan;

--
-- TOC entry 9964 (class 0 OID 0)
-- Dependencies: 689
-- Name: TABLE tbl_usr_grp; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON TABLE tbl_usr_grp IS 'USUARIO GRUPO';


--
-- TOC entry 9965 (class 0 OID 0)
-- Dependencies: 689
-- Name: COLUMN tbl_usr_grp.cd_usr; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_usr_grp.cd_usr IS 'USUARIO';


--
-- TOC entry 9966 (class 0 OID 0)
-- Dependencies: 689
-- Name: COLUMN tbl_usr_grp.cd_grp; Type: COMMENT; Schema: sc_sgr; Owner: scan
--

COMMENT ON COLUMN tbl_usr_grp.cd_grp IS 'GRUPO';


--
-- TOC entry 690 (class 1259 OID 566294)
-- Name: vw_eus_nsu; Type: VIEW; Schema: sc_sgr; Owner: scan
--

CREATE VIEW vw_eus_nsu AS
SELECT eus.cd_eus, eus.nsu_eus, eus.cmp_eus, CASE WHEN (eus.tp_eus = (1)::numeric) THEN emp.nm_emp ELSE NULL::character varying END AS nm_nsu_eus, CASE WHEN (eus.tp_eus = (1)::numeric) THEN fem.nm_fem ELSE NULL::character varying END AS nm_cmp_eus, eus.cd_usr FROM ((tbl_eus eus LEFT JOIN sc_cad.tbl_emp emp ON (((emp.cd_emp = eus.nsu_eus) AND (eus.tp_eus = (1)::numeric)))) LEFT JOIN sc_cad.tbl_fem fem ON ((((fem.cd_emp = emp.cd_emp) AND (eus.cd_eus = fem.cd_fem)) AND (eus.tp_eus = (1)::numeric))));


ALTER TABLE vw_eus_nsu OWNER TO scan;

--
-- TOC entry 691 (class 1259 OID 566299)
-- Name: vw_menu; Type: VIEW; Schema: sc_sgr; Owner: scan
--

CREATE VIEW vw_menu AS
SELECT menu.fg_atv_menu, menu.cd_menu, menu.cd_sis, (((((((menu.dsc_menu)::text || '(SISTEMA: '::text) || (sis.nm_sis)::text) || CASE WHEN (menu.cd_pai_menu IS NOT NULL) THEN (', MENU PAI: '::text || (pai.dsc_menu)::text) ELSE ''::text END) || ', NIVEL: '::text) || menu.nvl_menu) || ')'::text) AS dsc_menu FROM ((tbl_menu menu LEFT JOIN tbl_menu pai ON ((pai.cd_menu = menu.cd_pai_menu))) JOIN tbl_sis sis ON ((sis.cd_sis = menu.cd_sis))) WHERE ((menu.fg_atv_menu)::text = 'S'::text);


ALTER TABLE vw_menu OWNER TO scan;

--
-- TOC entry 692 (class 1259 OID 566304)
-- Name: vw_rol; Type: VIEW; Schema: sc_sgr; Owner: scan
--

CREATE VIEW vw_rol AS
SELECT rol.cd_rol, rol_sis.cd_sis, rol.fg_atv_rol, ((("substring"((rol.nm_rol)::text, 7) || ' (SISTEMA: '::text) || (sis.nm_sis)::text) || ')'::text) AS nm_rol FROM ((tbl_rol rol JOIN tbl_rol_sis rol_sis ON ((rol_sis.cd_rol = rol.cd_rol))) JOIN tbl_sis sis ON ((sis.cd_sis = rol_sis.cd_sis)));


ALTER TABLE vw_rol OWNER TO scan;

--
-- TOC entry 693 (class 1259 OID 566308)
-- Name: vw_rol_usr; Type: VIEW; Schema: sc_sgr; Owner: scan
--

CREATE VIEW vw_rol_usr AS
SELECT DISTINCT grp.cd_grp, grp.ds_grp, usr.cd_usr, usr.nm_usr, usr.lgn_usr, usr.st_usr, usr.fg_adm_usr, rol.cd_rol, rol.nm_rol, rs.cd_sis FROM (((((tbl_rol rol JOIN tbl_rol_sis rs ON ((rs.cd_rol = rol.cd_rol))) JOIN tbl_grp_rol gr ON ((gr.cd_rol = rol.cd_rol))) LEFT JOIN tbl_grp grp ON ((grp.cd_grp = gr.cd_grp))) LEFT JOIN tbl_usr_grp ug ON ((ug.cd_grp = gr.cd_grp))) LEFT JOIN tbl_usr usr ON ((usr.cd_usr = ug.cd_usr))) WHERE (((gr.fg_atv_grp_rol)::text = 'S'::text) AND ((rs.fg_atv_rol_sis)::text = 'S'::text));


ALTER TABLE vw_rol_usr OWNER TO scan;

--
-- TOC entry 694 (class 1259 OID 566313)
-- Name: vw_sis_grp; Type: VIEW; Schema: sc_sgr; Owner: scan
--

CREATE VIEW vw_sis_grp AS
SELECT grp.cd_grp, ((((grp.ds_grp)::text || '('::text) || (sis.nm_sis)::text) || ')'::text) AS ds_grp FROM (tbl_sis sis JOIN tbl_grp grp ON ((grp.cd_sis = sis.cd_sis))) WHERE ((grp.fg_atv_grp)::text = 'S'::text);


ALTER TABLE vw_sis_grp OWNER TO scan;

--
-- TOC entry 695 (class 1259 OID 566317)
-- Name: vw_usr_gem; Type: VIEW; Schema: sc_sgr; Owner: scan
--

CREATE VIEW vw_usr_gem AS
SELECT DISTINCT usr.cd_usr, usr.nm_usr, gem.cd_gem, gem.nm_gem FROM (((tbl_usr usr JOIN tbl_eus eus ON (((eus.cd_usr = usr.cd_usr) AND (eus.tp_eus = (1)::numeric)))) JOIN sc_cad.tbl_emp emp ON ((emp.cd_emp = eus.nsu_eus))) JOIN sc_cad.tbl_gem gem ON ((gem.cd_gem = emp.cd_gem))) WHERE ((eus.fg_atv_eus)::text = 'S'::text);


ALTER TABLE vw_usr_gem OWNER TO scan;

SET search_path = sc_spc, pg_catalog;

--
-- TOC entry 696 (class 1259 OID 566322)
-- Name: sq_det; Type: SEQUENCE; Schema: sc_spc; Owner: scan
--

CREATE SEQUENCE sq_det
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_det OWNER TO scan;

--
-- TOC entry 697 (class 1259 OID 566324)
-- Name: sq_drcs; Type: SEQUENCE; Schema: sc_spc; Owner: scan
--

CREATE SEQUENCE sq_drcs
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_drcs OWNER TO scan;

--
-- TOC entry 698 (class 1259 OID 566326)
-- Name: sq_drss; Type: SEQUENCE; Schema: sc_spc; Owner: scan
--

CREATE SEQUENCE sq_drss
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_drss OWNER TO scan;

--
-- TOC entry 699 (class 1259 OID 566328)
-- Name: sq_hdr; Type: SEQUENCE; Schema: sc_spc; Owner: scan
--

CREATE SEQUENCE sq_hdr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hdr OWNER TO scan;

--
-- TOC entry 700 (class 1259 OID 566330)
-- Name: sq_hrs; Type: SEQUENCE; Schema: sc_spc; Owner: scan
--

CREATE SEQUENCE sq_hrs
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hrs OWNER TO scan;

--
-- TOC entry 701 (class 1259 OID 566332)
-- Name: sq_mtv; Type: SEQUENCE; Schema: sc_spc; Owner: scan
--

CREATE SEQUENCE sq_mtv
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_mtv OWNER TO scan;

--
-- TOC entry 794 (class 1259 OID 868067)
-- Name: tbl_aux; Type: TABLE; Schema: sc_spc; Owner: scan
--

CREATE TABLE tbl_aux (
    cpf numeric(14,0) NOT NULL,
    dt_venc date NOT NULL,
    dt_registro date NOT NULL,
    contrato character varying(20) NOT NULL,
    valor numeric(13,2) NOT NULL,
    cartao numeric(14,0)
);


ALTER TABLE tbl_aux OWNER TO scan;

--
-- TOC entry 9967 (class 0 OID 0)
-- Dependencies: 794
-- Name: TABLE tbl_aux; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON TABLE tbl_aux IS 'TABELA AUXILIAR PARA REGISTRAR OS CLIENTES DO SPC INSERINDO MANUALMENTE';


--
-- TOC entry 702 (class 1259 OID 566334)
-- Name: tbl_det; Type: TABLE; Schema: sc_spc; Owner: scan
--

CREATE TABLE tbl_det (
    cd_det numeric(10,0) NOT NULL,
    cd_hdr numeric(10,0) NOT NULL,
    st_det numeric(2,0) NOT NULL,
    nr_cep_prc_cnc_det numeric(8,0),
    tp_opr_det character varying(1) NOT NULL,
    tp_pss_det numeric(2,0) NOT NULL,
    nr_cpf_cnpj_det numeric(14,0) NOT NULL,
    nm_cli_det character varying(45) NOT NULL,
    dt_vnc_det date NOT NULL,
    dt_reg_det date NOT NULL,
    vl_dvd_det numeric(10,2) NOT NULL,
    cd_mtv_inc_det numeric(2,0),
    cd_mtv_exc_det numeric(2,0),
    nr_rg_det numeric(20,0),
    dt_nsc_det date,
    nm_mae_det character varying(45),
    ds_end_det character varying(50) NOT NULL,
    nr_end_det numeric(5,0) NOT NULL,
    ds_cmp_det character varying(30),
    ds_brr_det character varying(25) NOT NULL,
    ds_lcl_det character varying(30) NOT NULL,
    uf_det character varying(2) NOT NULL,
    nr_cep_det numeric(8,0) NOT NULL,
    nr_ddd_det numeric(2,0),
    nr_tel_det numeric(8,0),
    cd_ret_cns_det numeric(5,0),
    cd_ret_spc_det numeric(5,0),
    dt_mvm_det date NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    nr_ctr_det character varying(30) NOT NULL,
    st_prc_det numeric(2,0)
);


ALTER TABLE tbl_det OWNER TO scan;

--
-- TOC entry 9968 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.cd_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.cd_det IS 'Codigo';


--
-- TOC entry 9969 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.cd_hdr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.cd_hdr IS 'Codigo do Header';


--
-- TOC entry 9970 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.st_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.st_det IS 'Situacao (1 - CADASTRADA / 2 - ENVIADA / 3 - CANCELADA)';


--
-- TOC entry 9971 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.nr_cep_prc_cnc_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.nr_cep_prc_cnc_det IS 'Numero do CEP da Praça da Concessão';


--
-- TOC entry 9972 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.tp_opr_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.tp_opr_det IS 'Tipo da Operacao (I-INCLUSAO / E-EXCLUSAO)';


--
-- TOC entry 9973 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.tp_pss_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.tp_pss_det IS 'Tipo de Pessoa';


--
-- TOC entry 9974 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.nr_cpf_cnpj_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.nr_cpf_cnpj_det IS 'CPF/CNPJ do Cliente';


--
-- TOC entry 9975 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.nm_cli_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.nm_cli_det IS 'Nome do Cliente';


--
-- TOC entry 9976 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.dt_vnc_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.dt_vnc_det IS 'Data de Vencimento';


--
-- TOC entry 9977 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.dt_reg_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.dt_reg_det IS 'Data do Registro';


--
-- TOC entry 9978 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.vl_dvd_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.vl_dvd_det IS 'Valor da Dívida';


--
-- TOC entry 9979 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.cd_mtv_inc_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.cd_mtv_inc_det IS 'Codigo do Motivo de Inclusao';


--
-- TOC entry 9980 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.cd_mtv_exc_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.cd_mtv_exc_det IS 'Codigo do Motivo de Exclusao';


--
-- TOC entry 9981 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.nr_rg_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.nr_rg_det IS 'Numero do RG';


--
-- TOC entry 9982 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.dt_nsc_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.dt_nsc_det IS 'Data de Nascimento';


--
-- TOC entry 9983 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.nm_mae_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.nm_mae_det IS 'Nome da Mae';


--
-- TOC entry 9984 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.ds_end_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.ds_end_det IS 'Descrição do Endereço';


--
-- TOC entry 9985 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.nr_end_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.nr_end_det IS 'Numero do Endereço';


--
-- TOC entry 9986 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.ds_cmp_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.ds_cmp_det IS 'Complemento do Endereço';


--
-- TOC entry 9987 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.ds_brr_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.ds_brr_det IS 'Descrição do Bairro';


--
-- TOC entry 9988 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.ds_lcl_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.ds_lcl_det IS 'Descrição da Localidade (Cidade)';


--
-- TOC entry 9989 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.uf_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.uf_det IS 'UF';


--
-- TOC entry 9990 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.nr_cep_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.nr_cep_det IS 'Numero do CEP';


--
-- TOC entry 9991 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.nr_ddd_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.nr_ddd_det IS 'DDD';


--
-- TOC entry 9992 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.nr_tel_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.nr_tel_det IS 'Telefone';


--
-- TOC entry 9993 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.cd_ret_cns_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.cd_ret_cns_det IS 'Codigo de Retorno dos dados do Consumidor';


--
-- TOC entry 9994 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.cd_ret_spc_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.cd_ret_spc_det IS 'Codigo de Retorno dos dados do SPC';


--
-- TOC entry 9995 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.dt_mvm_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.dt_mvm_det IS 'Data do Movimento';


--
-- TOC entry 9996 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.dt_inc_usr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.dt_inc_usr IS 'Data de Inclusao';


--
-- TOC entry 9997 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.nr_ctr_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.nr_ctr_det IS 'Numero do Contrato (Utilizar o campo CPF do cliente)';


--
-- TOC entry 9998 (class 0 OID 0)
-- Dependencies: 702
-- Name: COLUMN tbl_det.st_prc_det; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_det.st_prc_det IS 'Situação do Processamento';


--
-- TOC entry 703 (class 1259 OID 566337)
-- Name: tbl_drcs; Type: TABLE; Schema: sc_spc; Owner: scan
--

CREATE TABLE tbl_drcs (
    cd_drcs numeric(10,0) NOT NULL,
    cd_hrs numeric(10,0) NOT NULL,
    nr_prc_cnc_drcs numeric(8,0) NOT NULL,
    nm_cli_drcs character varying(45) NOT NULL,
    tp_pss_drcs numeric(1,0) NOT NULL,
    nr_cpf_cnpj_drcs numeric(15,0) NOT NULL,
    nr_rg_drcs numeric(20,0),
    dt_nsc_drcs date,
    nm_mae_drcs character varying(45),
    ds_end_drcs character varying(50),
    nr_end_drcs numeric(5,0),
    cmp_end_drcs character varying(30),
    ds_brr_drcs character varying(25),
    nr_cep_drcs numeric(8,0),
    ds_lcl_drcs character varying(30),
    uf_drcs character varying(30),
    nr_ddd_drcs numeric(2,0),
    nr_tel_drcs numeric(8,0),
    cd_ret_drcs numeric(10,0),
    dt_inc_drcs timestamp without time zone
);


ALTER TABLE tbl_drcs OWNER TO scan;

--
-- TOC entry 9999 (class 0 OID 0)
-- Dependencies: 703
-- Name: TABLE tbl_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON TABLE tbl_drcs IS 'tabela de detalhe do consumidor de retorno do SPC';


--
-- TOC entry 10000 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.cd_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.cd_drcs IS 'Codigo';


--
-- TOC entry 10001 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.cd_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.cd_hrs IS 'Codigo do Header';


--
-- TOC entry 10002 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.nr_prc_cnc_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.nr_prc_cnc_drcs IS 'Numero da Praca de Concessao';


--
-- TOC entry 10003 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.nm_cli_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.nm_cli_drcs IS 'Nome do Cliente';


--
-- TOC entry 10004 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.tp_pss_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.tp_pss_drcs IS 'Tipo de Pessoa';


--
-- TOC entry 10005 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.nr_cpf_cnpj_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.nr_cpf_cnpj_drcs IS 'Cpf/Cnpj do Cliente';


--
-- TOC entry 10006 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.nr_rg_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.nr_rg_drcs IS 'Numero do RG';


--
-- TOC entry 10007 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.dt_nsc_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.dt_nsc_drcs IS 'Data de Nascimento';


--
-- TOC entry 10008 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.nm_mae_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.nm_mae_drcs IS 'Nome da Mae';


--
-- TOC entry 10009 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.ds_end_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.ds_end_drcs IS 'Descriçaõ do Endereço (Logradouro)';


--
-- TOC entry 10010 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.nr_end_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.nr_end_drcs IS 'Número do Endereço';


--
-- TOC entry 10011 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.cmp_end_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.cmp_end_drcs IS 'Complemento do Endereço';


--
-- TOC entry 10012 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.ds_brr_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.ds_brr_drcs IS 'Bairro';


--
-- TOC entry 10013 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.nr_cep_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.nr_cep_drcs IS 'CEP';


--
-- TOC entry 10014 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.ds_lcl_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.ds_lcl_drcs IS 'Localidade';


--
-- TOC entry 10015 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.uf_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.uf_drcs IS 'UF';


--
-- TOC entry 10016 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.nr_ddd_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.nr_ddd_drcs IS 'DDD do telefone';


--
-- TOC entry 10017 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.nr_tel_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.nr_tel_drcs IS 'Número do Telefone';


--
-- TOC entry 10018 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.cd_ret_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.cd_ret_drcs IS 'Codigo do Retorno';


--
-- TOC entry 10019 (class 0 OID 0)
-- Dependencies: 703
-- Name: COLUMN tbl_drcs.dt_inc_drcs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drcs.dt_inc_drcs IS 'Data de Inclusão';


--
-- TOC entry 704 (class 1259 OID 566340)
-- Name: tbl_drss; Type: TABLE; Schema: sc_spc; Owner: scan
--

CREATE TABLE tbl_drss (
    cd_drss numeric(10,0) NOT NULL,
    cd_hrs numeric(10,0) NOT NULL,
    tp_pss_drss numeric(1,0) NOT NULL,
    nr_cpf_cnpj_drss numeric(15,0) NOT NULL,
    tp_opr_drss character varying(1) NOT NULL,
    dt_vnc_drss date NOT NULL,
    dt_rgt_drss date NOT NULL,
    vl_dvd_drss numeric(15,2) NOT NULL,
    nr_ctr_drss character varying(30) NOT NULL,
    nr_ass_drss numeric(8,0),
    cd_mtv_inc_drss numeric(2,0),
    cd_mtv_exc_drss numeric(2,0),
    cd_ret_drss numeric(10,0),
    dt_inc_drss timestamp without time zone
);


ALTER TABLE tbl_drss OWNER TO scan;

--
-- TOC entry 10020 (class 0 OID 0)
-- Dependencies: 704
-- Name: TABLE tbl_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON TABLE tbl_drss IS 'tabela de detalhe do dados do SPC';


--
-- TOC entry 10021 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.cd_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.cd_drss IS 'Codigo';


--
-- TOC entry 10022 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.cd_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.cd_hrs IS 'Codigo do Header';


--
-- TOC entry 10023 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.tp_pss_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.tp_pss_drss IS 'Tipo de Pessoa';


--
-- TOC entry 10024 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.nr_cpf_cnpj_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.nr_cpf_cnpj_drss IS 'Cpf/Cnpj do Cliente';


--
-- TOC entry 10025 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.tp_opr_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.tp_opr_drss IS 'Tipo de Operação';


--
-- TOC entry 10026 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.dt_vnc_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.dt_vnc_drss IS 'Data de Vencimento';


--
-- TOC entry 10027 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.dt_rgt_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.dt_rgt_drss IS 'Data do Registro';


--
-- TOC entry 10028 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.vl_dvd_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.vl_dvd_drss IS 'Valor da Dívida';


--
-- TOC entry 10029 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.nr_ctr_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.nr_ctr_drss IS 'Numero do Contrato';


--
-- TOC entry 10030 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.nr_ass_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.nr_ass_drss IS 'Numero do Associado';


--
-- TOC entry 10031 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.cd_mtv_inc_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.cd_mtv_inc_drss IS 'Codigo do Motivo da Inclusão (Ver tabela sc_spc.tbl_mtv)';


--
-- TOC entry 10032 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.cd_mtv_exc_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.cd_mtv_exc_drss IS 'Codigo do Motivo da Exclusão (Ver tabela sc_spc.tbl_mtv)';


--
-- TOC entry 10033 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.cd_ret_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.cd_ret_drss IS 'Codigo do Retorno';


--
-- TOC entry 10034 (class 0 OID 0)
-- Dependencies: 704
-- Name: COLUMN tbl_drss.dt_inc_drss; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_drss.dt_inc_drss IS 'Data de Inclusão';


--
-- TOC entry 705 (class 1259 OID 566343)
-- Name: tbl_hdr; Type: TABLE; Schema: sc_spc; Owner: scan
--

CREATE TABLE tbl_hdr (
    cd_hdr numeric(10,0) NOT NULL,
    nr_seq_hdr numeric(5,0) NOT NULL,
    nr_vrs_hdr numeric(2,0) NOT NULL,
    st_hdr numeric(2,0) NOT NULL,
    ds_uni_neg_hdr character varying(5) NOT NULL,
    dt_mvm_hdr date NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    dt_env_hdr timestamp without time zone,
    nr_rms_hdr numeric(5,0)
);


ALTER TABLE tbl_hdr OWNER TO scan;

--
-- TOC entry 10035 (class 0 OID 0)
-- Dependencies: 705
-- Name: TABLE tbl_hdr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON TABLE tbl_hdr IS 'tabela de detalhe do arquivo de remessa do spc';


--
-- TOC entry 10036 (class 0 OID 0)
-- Dependencies: 705
-- Name: COLUMN tbl_hdr.cd_hdr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.cd_hdr IS 'Codigo';


--
-- TOC entry 10037 (class 0 OID 0)
-- Dependencies: 705
-- Name: COLUMN tbl_hdr.nr_seq_hdr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.nr_seq_hdr IS 'Numero Sequencial do Arquivo';


--
-- TOC entry 10038 (class 0 OID 0)
-- Dependencies: 705
-- Name: COLUMN tbl_hdr.nr_vrs_hdr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.nr_vrs_hdr IS 'Numero da Versao';


--
-- TOC entry 10039 (class 0 OID 0)
-- Dependencies: 705
-- Name: COLUMN tbl_hdr.st_hdr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.st_hdr IS 'Situacao (1 - CADASTRADA / 2 - ENVIADA / 3 - CANCELADA)';


--
-- TOC entry 10040 (class 0 OID 0)
-- Dependencies: 705
-- Name: COLUMN tbl_hdr.ds_uni_neg_hdr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.ds_uni_neg_hdr IS 'Descricao da Unidade de Negocio (SPC, CHQ)';


--
-- TOC entry 10041 (class 0 OID 0)
-- Dependencies: 705
-- Name: COLUMN tbl_hdr.dt_mvm_hdr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.dt_mvm_hdr IS 'Data do Movimento';


--
-- TOC entry 10042 (class 0 OID 0)
-- Dependencies: 705
-- Name: COLUMN tbl_hdr.dt_inc_usr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.dt_inc_usr IS 'Data de Inclusao';


--
-- TOC entry 10043 (class 0 OID 0)
-- Dependencies: 705
-- Name: COLUMN tbl_hdr.dt_env_hdr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.dt_env_hdr IS 'Data do Envio';


--
-- TOC entry 10044 (class 0 OID 0)
-- Dependencies: 705
-- Name: COLUMN tbl_hdr.nr_rms_hdr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hdr.nr_rms_hdr IS 'Numero da remessa enviada ao SPC';


--
-- TOC entry 706 (class 1259 OID 566346)
-- Name: tbl_hrs; Type: TABLE; Schema: sc_spc; Owner: scan
--

CREATE TABLE tbl_hrs (
    cd_hrs numeric(10,0) NOT NULL,
    tp_opr_hrs character varying(15) NOT NULL,
    nr_rms_hrs numeric(5,0) NOT NULL,
    nr_ent_hrs numeric(5,0) NOT NULL,
    nr_ass_hrs numeric(8,0) NOT NULL,
    nr_vrs_hrs numeric(2,0) NOT NULL,
    st_hrs numeric(2,0) NOT NULL,
    ds_uni_neg_hrs character varying(5) NOT NULL,
    dt_mvm_hrs date NOT NULL,
    dt_rcb_hrs timestamp without time zone NOT NULL,
    cd_ret_hrs numeric(10,0),
    dt_prc_hrs timestamp without time zone
);


ALTER TABLE tbl_hrs OWNER TO scan;

--
-- TOC entry 10045 (class 0 OID 0)
-- Dependencies: 706
-- Name: TABLE tbl_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON TABLE tbl_hrs IS 'tabela de header de retorno do SPC';


--
-- TOC entry 10046 (class 0 OID 0)
-- Dependencies: 706
-- Name: COLUMN tbl_hrs.cd_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hrs.cd_hrs IS 'Codigo';


--
-- TOC entry 10047 (class 0 OID 0)
-- Dependencies: 706
-- Name: COLUMN tbl_hrs.tp_opr_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hrs.tp_opr_hrs IS 'Tipo de Operação do Arquivo';


--
-- TOC entry 10048 (class 0 OID 0)
-- Dependencies: 706
-- Name: COLUMN tbl_hrs.nr_rms_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hrs.nr_rms_hrs IS 'Numero da Remessa do Arquivo';


--
-- TOC entry 10049 (class 0 OID 0)
-- Dependencies: 706
-- Name: COLUMN tbl_hrs.nr_ent_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hrs.nr_ent_hrs IS 'Numero da Entidade';


--
-- TOC entry 10050 (class 0 OID 0)
-- Dependencies: 706
-- Name: COLUMN tbl_hrs.nr_ass_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hrs.nr_ass_hrs IS 'Numero da Associada';


--
-- TOC entry 10051 (class 0 OID 0)
-- Dependencies: 706
-- Name: COLUMN tbl_hrs.nr_vrs_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hrs.nr_vrs_hrs IS 'Numero da Versao';


--
-- TOC entry 10052 (class 0 OID 0)
-- Dependencies: 706
-- Name: COLUMN tbl_hrs.st_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hrs.st_hrs IS 'Situacao (1 - RECEBIDO / 2 - PROCESSADO / 3 - CANCELADO / 4 - PROCESSADO COM ERRO)';


--
-- TOC entry 10053 (class 0 OID 0)
-- Dependencies: 706
-- Name: COLUMN tbl_hrs.ds_uni_neg_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hrs.ds_uni_neg_hrs IS 'Descricao da Unidade de Negocio (SPC, CHQ)';


--
-- TOC entry 10054 (class 0 OID 0)
-- Dependencies: 706
-- Name: COLUMN tbl_hrs.dt_mvm_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hrs.dt_mvm_hrs IS 'Data do Movimento';


--
-- TOC entry 10055 (class 0 OID 0)
-- Dependencies: 706
-- Name: COLUMN tbl_hrs.dt_rcb_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hrs.dt_rcb_hrs IS 'Data de Recebimento';


--
-- TOC entry 10056 (class 0 OID 0)
-- Dependencies: 706
-- Name: COLUMN tbl_hrs.cd_ret_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hrs.cd_ret_hrs IS 'Codigo do Retorno';


--
-- TOC entry 10057 (class 0 OID 0)
-- Dependencies: 706
-- Name: COLUMN tbl_hrs.dt_prc_hrs; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_hrs.dt_prc_hrs IS 'Data do Processamento';


--
-- TOC entry 707 (class 1259 OID 566349)
-- Name: tbl_mtv; Type: TABLE; Schema: sc_spc; Owner: scan
--

CREATE TABLE tbl_mtv (
    cd_mtv numeric(10,0) NOT NULL,
    tp_mtv character varying(1) NOT NULL,
    cd_ref_mtv numeric(3,0) NOT NULL,
    ds_mtv character varying(80) NOT NULL,
    fg_atv_mtv character varying(1) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_mtv OWNER TO scan;

--
-- TOC entry 10058 (class 0 OID 0)
-- Dependencies: 707
-- Name: TABLE tbl_mtv; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON TABLE tbl_mtv IS 'tabela de motivos de inclusao e exclusao do SPC';


--
-- TOC entry 10059 (class 0 OID 0)
-- Dependencies: 707
-- Name: COLUMN tbl_mtv.tp_mtv; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_mtv.tp_mtv IS 'Tipo de Motivo (I - INCLUSAO / E - EXCLUSAO)';


--
-- TOC entry 10060 (class 0 OID 0)
-- Dependencies: 707
-- Name: COLUMN tbl_mtv.cd_ref_mtv; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_mtv.cd_ref_mtv IS 'Numero de Referencia';


--
-- TOC entry 10061 (class 0 OID 0)
-- Dependencies: 707
-- Name: COLUMN tbl_mtv.ds_mtv; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_mtv.ds_mtv IS 'Descricao do Motivo';


--
-- TOC entry 10062 (class 0 OID 0)
-- Dependencies: 707
-- Name: COLUMN tbl_mtv.fg_atv_mtv; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_mtv.fg_atv_mtv IS 'Flag de Ativo';


--
-- TOC entry 10063 (class 0 OID 0)
-- Dependencies: 707
-- Name: COLUMN tbl_mtv.dt_inc_usr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_mtv.dt_inc_usr IS 'Data de Inclusao';


--
-- TOC entry 708 (class 1259 OID 566352)
-- Name: tbl_ret; Type: TABLE; Schema: sc_spc; Owner: scan
--

CREATE TABLE tbl_ret (
    cd_ret numeric(10,0) NOT NULL,
    ds_ret character varying(80) NOT NULL,
    fg_atv_ret character varying(1) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_ret OWNER TO scan;

--
-- TOC entry 10064 (class 0 OID 0)
-- Dependencies: 708
-- Name: TABLE tbl_ret; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON TABLE tbl_ret IS 'tabela de retorno do SPC';


--
-- TOC entry 10065 (class 0 OID 0)
-- Dependencies: 708
-- Name: COLUMN tbl_ret.cd_ret; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_ret.cd_ret IS 'Codigo';


--
-- TOC entry 10066 (class 0 OID 0)
-- Dependencies: 708
-- Name: COLUMN tbl_ret.ds_ret; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_ret.ds_ret IS 'Descricao';


--
-- TOC entry 10067 (class 0 OID 0)
-- Dependencies: 708
-- Name: COLUMN tbl_ret.fg_atv_ret; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_ret.fg_atv_ret IS 'Flag de Ativo';


--
-- TOC entry 10068 (class 0 OID 0)
-- Dependencies: 708
-- Name: COLUMN tbl_ret.dt_inc_usr; Type: COMMENT; Schema: sc_spc; Owner: scan
--

COMMENT ON COLUMN tbl_ret.dt_inc_usr IS 'Data de Inclusao';


SET search_path = sc_srs, pg_catalog;

--
-- TOC entry 852 (class 1259 OID 899518)
-- Name: tbl_ott; Type: TABLE; Schema: sc_srs; Owner: scan
--

CREATE TABLE tbl_ott (
    cd_ott numeric(10,0) NOT NULL,
    cd_ttl numeric(10,0) NOT NULL,
    dt_ott timestamp without time zone NOT NULL,
    ds_ott character varying(100),
    tp_ott numeric(1,0) NOT NULL
);


ALTER TABLE tbl_ott OWNER TO scan;

--
-- TOC entry 851 (class 1259 OID 899511)
-- Name: tbl_rms; Type: TABLE; Schema: sc_srs; Owner: scan
--

CREATE TABLE tbl_rms (
    cd_rms numeric(10,0) NOT NULL,
    dt_rms date NOT NULL,
    st_rms numeric(1,0) DEFAULT 1 NOT NULL,
    qtd_ttl_rms numeric(3,0) NOT NULL
);


ALTER TABLE tbl_rms OWNER TO scan;

--
-- TOC entry 850 (class 1259 OID 899499)
-- Name: tbl_ttl; Type: TABLE; Schema: sc_srs; Owner: scan
--

CREATE TABLE tbl_ttl (
    cd_ttl numeric(10,0) NOT NULL,
    st_ttl numeric(1,0) DEFAULT 1 NOT NULL,
    vl_ttl numeric(13,2) NOT NULL,
    cd_rms numeric(10,0),
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    nr_cnpj_ttl numeric(14,0) NOT NULL,
    tp_org_ttl numeric(1,0) NOT NULL,
    nsu_org_ttl numeric(10,0) NOT NULL,
    dt_vnc_ttl date NOT NULL,
    dt_pgt_ttl date
);


ALTER TABLE tbl_ttl OWNER TO scan;

--
-- TOC entry 10069 (class 0 OID 0)
-- Dependencies: 850
-- Name: TABLE tbl_ttl; Type: COMMENT; Schema: sc_srs; Owner: scan
--

COMMENT ON TABLE tbl_ttl IS 'Tabela de títulos';


SET search_path = sc_srv, pg_catalog;

--
-- TOC entry 709 (class 1259 OID 566355)
-- Name: sq_cap; Type: SEQUENCE; Schema: sc_srv; Owner: scan
--

CREATE SEQUENCE sq_cap
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_cap OWNER TO scan;

--
-- TOC entry 710 (class 1259 OID 566357)
-- Name: sq_drc; Type: SEQUENCE; Schema: sc_srv; Owner: scan
--

CREATE SEQUENCE sq_drc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_drc OWNER TO scan;

--
-- TOC entry 711 (class 1259 OID 566359)
-- Name: sq_has; Type: SEQUENCE; Schema: sc_srv; Owner: scan
--

CREATE SEQUENCE sq_has
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_has OWNER TO scan;

--
-- TOC entry 712 (class 1259 OID 566361)
-- Name: sq_hrc; Type: SEQUENCE; Schema: sc_srv; Owner: scan
--

CREATE SEQUENCE sq_hrc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_hrc OWNER TO scan;

--
-- TOC entry 713 (class 1259 OID 566363)
-- Name: sq_scr; Type: SEQUENCE; Schema: sc_srv; Owner: scan
--

CREATE SEQUENCE sq_scr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_scr OWNER TO scan;

--
-- TOC entry 982 (class 1259 OID 1665579)
-- Name: sq_sga; Type: SEQUENCE; Schema: sc_srv; Owner: scan
--

CREATE SEQUENCE sq_sga
    START WITH 9
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_sga OWNER TO scan;

--
-- TOC entry 714 (class 1259 OID 566367)
-- Name: sq_sgr; Type: SEQUENCE; Schema: sc_srv; Owner: scan
--

CREATE SEQUENCE sq_sgr
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_sgr OWNER TO scan;

--
-- TOC entry 715 (class 1259 OID 566369)
-- Name: sq_srv; Type: SEQUENCE; Schema: sc_srv; Owner: scan
--

CREATE SEQUENCE sq_srv
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_srv OWNER TO scan;

--
-- TOC entry 716 (class 1259 OID 566371)
-- Name: sq_trc; Type: SEQUENCE; Schema: sc_srv; Owner: scan
--

CREATE SEQUENCE sq_trc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_trc OWNER TO scan;

--
-- TOC entry 717 (class 1259 OID 566373)
-- Name: sq_tsc; Type: SEQUENCE; Schema: sc_srv; Owner: scan
--

CREATE SEQUENCE sq_tsc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_tsc OWNER TO scan;

--
-- TOC entry 718 (class 1259 OID 566375)
-- Name: tbl_cap; Type: TABLE; Schema: sc_srv; Owner: scan
--

CREATE TABLE tbl_cap (
    cd_cap numeric(10,0) NOT NULL,
    cd_sgr numeric(10,0) NOT NULL,
    cd_new_has numeric(10,0) NOT NULL,
    cd_pag_has numeric(10,0),
    nr_srt_cap character varying(10),
    dt_inc_usr timestamp without time zone NOT NULL
);


ALTER TABLE tbl_cap OWNER TO scan;

--
-- TOC entry 10070 (class 0 OID 0)
-- Dependencies: 718
-- Name: TABLE tbl_cap; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON TABLE tbl_cap IS 'extensa do seguro';


--
-- TOC entry 10071 (class 0 OID 0)
-- Dependencies: 718
-- Name: COLUMN tbl_cap.cd_sgr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_cap.cd_sgr IS 'codigo do srguro';


--
-- TOC entry 10072 (class 0 OID 0)
-- Dependencies: 718
-- Name: COLUMN tbl_cap.cd_new_has; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_cap.cd_new_has IS 'codigo do header do tipo new da capitalizacao';


--
-- TOC entry 10073 (class 0 OID 0)
-- Dependencies: 718
-- Name: COLUMN tbl_cap.cd_pag_has; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_cap.cd_pag_has IS 'codigo do header do tipo pag da capitalizacao';


--
-- TOC entry 10074 (class 0 OID 0)
-- Dependencies: 718
-- Name: COLUMN tbl_cap.nr_srt_cap; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_cap.nr_srt_cap IS 'numero da sorte';


--
-- TOC entry 719 (class 1259 OID 566378)
-- Name: tbl_drc; Type: TABLE; Schema: sc_srv; Owner: scan
--

CREATE TABLE tbl_drc (
    cd_drc numeric(10,0) NOT NULL,
    cd_hrc numeric(10,0) NOT NULL,
    sr_crt_sgr_drc numeric(6,0),
    lt_dst_drc numeric(3,0),
    nr_srt_drc numeric(8,0),
    nr_sqn_drc numeric(9,0)
);


ALTER TABLE tbl_drc OWNER TO scan;

--
-- TOC entry 10075 (class 0 OID 0)
-- Dependencies: 719
-- Name: TABLE tbl_drc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON TABLE tbl_drc IS 'DETALHE RETORNO CAPITALIZACAO';


--
-- TOC entry 10076 (class 0 OID 0)
-- Dependencies: 719
-- Name: COLUMN tbl_drc.cd_drc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_drc.cd_drc IS 'CODIGO';


--
-- TOC entry 10077 (class 0 OID 0)
-- Dependencies: 719
-- Name: COLUMN tbl_drc.cd_hrc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_drc.cd_hrc IS 'HEADER';


--
-- TOC entry 10078 (class 0 OID 0)
-- Dependencies: 719
-- Name: COLUMN tbl_drc.sr_crt_sgr_drc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_drc.sr_crt_sgr_drc IS 'SERIE DO CERTIFICADO DO SEGURO';


--
-- TOC entry 10079 (class 0 OID 0)
-- Dependencies: 719
-- Name: COLUMN tbl_drc.lt_dst_drc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_drc.lt_dst_drc IS 'LOTE DE DISTRIBUICAO';


--
-- TOC entry 10080 (class 0 OID 0)
-- Dependencies: 719
-- Name: COLUMN tbl_drc.nr_srt_drc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_drc.nr_srt_drc IS 'NUMERO DA SORTE';


--
-- TOC entry 10081 (class 0 OID 0)
-- Dependencies: 719
-- Name: COLUMN tbl_drc.nr_sqn_drc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_drc.nr_sqn_drc IS 'NUMERO SEQUENCIAL DOS REGISTROS';


--
-- TOC entry 720 (class 1259 OID 566381)
-- Name: tbl_has; Type: TABLE; Schema: sc_srv; Owner: scan
--

CREATE TABLE tbl_has (
    cd_has numeric(10,0) NOT NULL,
    dt_grc_has timestamp without time zone NOT NULL,
    dt_env_has timestamp without time zone,
    nr_sqn_rms_has character varying(10)
);


ALTER TABLE tbl_has OWNER TO scan;

--
-- TOC entry 10082 (class 0 OID 0)
-- Dependencies: 720
-- Name: TABLE tbl_has; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON TABLE tbl_has IS 'HEADER ARQUIVO DE SEGURO';


--
-- TOC entry 10083 (class 0 OID 0)
-- Dependencies: 720
-- Name: COLUMN tbl_has.cd_has; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_has.cd_has IS 'CODIGO';


--
-- TOC entry 10084 (class 0 OID 0)
-- Dependencies: 720
-- Name: COLUMN tbl_has.dt_grc_has; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_has.dt_grc_has IS 'DATA DE GERAÇÃO';


--
-- TOC entry 10085 (class 0 OID 0)
-- Dependencies: 720
-- Name: COLUMN tbl_has.dt_env_has; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_has.dt_env_has IS 'DATA DE ENVIO';


--
-- TOC entry 721 (class 1259 OID 566384)
-- Name: tbl_hrc; Type: TABLE; Schema: sc_srv; Owner: scan
--

CREATE TABLE tbl_hrc (
    cd_hrc numeric(10,0) NOT NULL,
    cd_cli_hrc numeric(4,0),
    cd_pln_hrc numeric(4,0),
    dt_grc_hrc date,
    nr_rms_hrc character varying(10),
    dt_inc_usr timestamp without time zone DEFAULT now() NOT NULL,
    dt_prc_hrc timestamp without time zone
);


ALTER TABLE tbl_hrc OWNER TO scan;

--
-- TOC entry 10086 (class 0 OID 0)
-- Dependencies: 721
-- Name: TABLE tbl_hrc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON TABLE tbl_hrc IS 'HEADER RETORNO CAPITALIZACAO';


--
-- TOC entry 10087 (class 0 OID 0)
-- Dependencies: 721
-- Name: COLUMN tbl_hrc.cd_hrc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_hrc.cd_hrc IS 'CODIGO';


--
-- TOC entry 10088 (class 0 OID 0)
-- Dependencies: 721
-- Name: COLUMN tbl_hrc.cd_cli_hrc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_hrc.cd_cli_hrc IS 'CLIENTE';


--
-- TOC entry 10089 (class 0 OID 0)
-- Dependencies: 721
-- Name: COLUMN tbl_hrc.cd_pln_hrc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_hrc.cd_pln_hrc IS 'PLANO';


--
-- TOC entry 10090 (class 0 OID 0)
-- Dependencies: 721
-- Name: COLUMN tbl_hrc.dt_grc_hrc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_hrc.dt_grc_hrc IS 'DATA DE GERACAO';


--
-- TOC entry 10091 (class 0 OID 0)
-- Dependencies: 721
-- Name: COLUMN tbl_hrc.nr_rms_hrc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_hrc.nr_rms_hrc IS 'NUMERO DA REMESA';


--
-- TOC entry 722 (class 1259 OID 566388)
-- Name: tbl_scr; Type: TABLE; Schema: sc_srv; Owner: scan
--

CREATE TABLE tbl_scr (
    cd_scr numeric(10,0) NOT NULL,
    cd_srv numeric(5,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    st_scr numeric(2,0) NOT NULL,
    tp_ads_scr numeric(2,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_scr OWNER TO scan;

--
-- TOC entry 10092 (class 0 OID 0)
-- Dependencies: 722
-- Name: TABLE tbl_scr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON TABLE tbl_scr IS 'SERVICO CARTAO';


--
-- TOC entry 10093 (class 0 OID 0)
-- Dependencies: 722
-- Name: COLUMN tbl_scr.cd_scr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_scr.cd_scr IS 'CODIGO';


--
-- TOC entry 10094 (class 0 OID 0)
-- Dependencies: 722
-- Name: COLUMN tbl_scr.cd_srv; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_scr.cd_srv IS 'SERVICO';


--
-- TOC entry 10095 (class 0 OID 0)
-- Dependencies: 722
-- Name: COLUMN tbl_scr.cd_crt; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_scr.cd_crt IS 'CARTAO';


--
-- TOC entry 10096 (class 0 OID 0)
-- Dependencies: 722
-- Name: COLUMN tbl_scr.st_scr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_scr.st_scr IS 'SITUACAO';


--
-- TOC entry 10097 (class 0 OID 0)
-- Dependencies: 722
-- Name: COLUMN tbl_scr.cd_inc_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_scr.cd_inc_usr IS 'USUARIO INCLUSAO';


--
-- TOC entry 10098 (class 0 OID 0)
-- Dependencies: 722
-- Name: COLUMN tbl_scr.dt_inc_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_scr.dt_inc_usr IS 'DATA INCLUSAO';


--
-- TOC entry 10099 (class 0 OID 0)
-- Dependencies: 722
-- Name: COLUMN tbl_scr.cd_alt_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_scr.cd_alt_usr IS 'USUARIO ALTERACAO';


--
-- TOC entry 10100 (class 0 OID 0)
-- Dependencies: 722
-- Name: COLUMN tbl_scr.dt_alt_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_scr.dt_alt_usr IS 'DATA ALTERACAO';


--
-- TOC entry 723 (class 1259 OID 566391)
-- Name: tbl_sga; Type: TABLE; Schema: sc_srv; Owner: scan
--

CREATE TABLE tbl_sga (
    cd_sga numeric(10,0) NOT NULL,
    ds_sga character varying(100) NOT NULL,
    cd_emp_sga_aff numeric(10,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_emp_pr_sga numeric(10,0),
    cd_emp_cap_sga numeric(10,0),
    cd_cnt numeric(10,0),
    nr_apl_sga character varying(20)
);


ALTER TABLE tbl_sga OWNER TO scan;

--
-- TOC entry 10101 (class 0 OID 0)
-- Dependencies: 723
-- Name: TABLE tbl_sga; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON TABLE tbl_sga IS 'CODIGO DA SEGURADORA';


--
-- TOC entry 10102 (class 0 OID 0)
-- Dependencies: 723
-- Name: COLUMN tbl_sga.cd_sga; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sga.cd_sga IS 'CODIGO';


--
-- TOC entry 10103 (class 0 OID 0)
-- Dependencies: 723
-- Name: COLUMN tbl_sga.ds_sga; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sga.ds_sga IS 'DESCRICAO';


--
-- TOC entry 10104 (class 0 OID 0)
-- Dependencies: 723
-- Name: COLUMN tbl_sga.cd_emp_sga_aff; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sga.cd_emp_sga_aff IS 'CODIGO DA EMPRESA NA SEGURADORA';


--
-- TOC entry 10105 (class 0 OID 0)
-- Dependencies: 723
-- Name: COLUMN tbl_sga.cd_inc_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sga.cd_inc_usr IS 'CODIGO DO USUARIO DE INCLUSAO';


--
-- TOC entry 10106 (class 0 OID 0)
-- Dependencies: 723
-- Name: COLUMN tbl_sga.dt_inc_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sga.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 10107 (class 0 OID 0)
-- Dependencies: 723
-- Name: COLUMN tbl_sga.cd_alt_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sga.cd_alt_usr IS 'CODIGO DO USUARIO DE ALTERACAO';


--
-- TOC entry 10108 (class 0 OID 0)
-- Dependencies: 723
-- Name: COLUMN tbl_sga.dt_alt_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sga.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 10109 (class 0 OID 0)
-- Dependencies: 723
-- Name: COLUMN tbl_sga.cd_cnt; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sga.cd_cnt IS 'CODIGO DA CONTA DA SEGURADORA ONDE VAI CAIR OS RECURSOS DESCONTADOS DOS FUNCIONARIOS';


--
-- TOC entry 724 (class 1259 OID 566394)
-- Name: tbl_sgr; Type: TABLE; Schema: sc_srv; Owner: scan
--

CREATE TABLE tbl_sgr (
    cd_sgr numeric(10,0) NOT NULL,
    cd_sga numeric(10,0) NOT NULL,
    cd_scr numeric(14,0),
    vl_sgr numeric(13,2) NOT NULL,
    vl_prs_sgr numeric(13,2) NOT NULL,
    qt_prs_sgr numeric(3,0),
    dt_vnc_sgr date,
    vl_fin_sgr numeric(13,2),
    tp_cnc_sgr numeric(3,0),
    cd_cnc_usr numeric(10,0),
    dt_cnc_sgr date,
    ds_mtv_cnc_sgr character varying(200),
    cd_has numeric(10,0),
    cd_cnc_has numeric(10,0),
    st_sgr numeric(1,0) DEFAULT 1 NOT NULL,
    cd_csg numeric(10,0),
    cd_fnc numeric(10,0) NOT NULL,
    dt_vig_ini_sgr timestamp without time zone,
    dt_vig_fim_sgr timestamp without time zone,
    nr_srt_sgr numeric(10,0),
    dt_prc_sgr timestamp without time zone,
    vl_rnd_mes_sgr numeric(13,2),
    ds_pfs_sgr character varying(100)
);


ALTER TABLE tbl_sgr OWNER TO scan;

--
-- TOC entry 10110 (class 0 OID 0)
-- Dependencies: 724
-- Name: TABLE tbl_sgr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON TABLE tbl_sgr IS 'CODIGO DO SEGURO';


--
-- TOC entry 10111 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.cd_sgr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.cd_sgr IS 'CODIGO';


--
-- TOC entry 10112 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.cd_sga; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.cd_sga IS 'CODIGO DA SEGURADORA';


--
-- TOC entry 10113 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.cd_scr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.cd_scr IS 'CODIGO DO SERVICO DO CARTAO';


--
-- TOC entry 10114 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.vl_sgr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.vl_sgr IS 'VALOR DO SEGURO';


--
-- TOC entry 10115 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.vl_prs_sgr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.vl_prs_sgr IS 'VALOR DA PRESTACAO';


--
-- TOC entry 10116 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.qt_prs_sgr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.qt_prs_sgr IS 'QUANTIDADE DE PRESTACOES';


--
-- TOC entry 10117 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.dt_vnc_sgr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.dt_vnc_sgr IS 'DATA DE VENCIMENTO DA PRIMEIRA';


--
-- TOC entry 10118 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.vl_fin_sgr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.vl_fin_sgr IS 'VALOR DO FINANCIAMENTO';


--
-- TOC entry 10119 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.tp_cnc_sgr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.tp_cnc_sgr IS 'TIPO DO CANCELAMENTO';


--
-- TOC entry 10120 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.cd_cnc_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.cd_cnc_usr IS 'CODIGO DO USUARIO DE CANCELAMENTO';


--
-- TOC entry 10121 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.dt_cnc_sgr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.dt_cnc_sgr IS 'DATA DO CANCELAMENTO';


--
-- TOC entry 10122 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.ds_mtv_cnc_sgr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.ds_mtv_cnc_sgr IS 'DESCRICAO DO MOTIVO DO CANCELAMENTO';


--
-- TOC entry 10123 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.cd_has; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.cd_has IS 'CODIGO DO ARQUIVO DE ADESAO DO SEGURO';


--
-- TOC entry 10124 (class 0 OID 0)
-- Dependencies: 724
-- Name: COLUMN tbl_sgr.cd_cnc_has; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_sgr.cd_cnc_has IS 'CODIGO DO ARQUIVO DE CANCELAMENTO DO SEGURO';


--
-- TOC entry 725 (class 1259 OID 566398)
-- Name: tbl_srv; Type: TABLE; Schema: sc_srv; Owner: scan
--

CREATE TABLE tbl_srv (
    cd_srv numeric(5,0) NOT NULL,
    ds_srv character varying(200) NOT NULL,
    fg_atv_srv character varying(1) NOT NULL,
    cd_prd numeric(10,0),
    cd_cnt numeric(10,0),
    cd_tlc numeric(10,0)
);


ALTER TABLE tbl_srv OWNER TO scan;

--
-- TOC entry 10125 (class 0 OID 0)
-- Dependencies: 725
-- Name: TABLE tbl_srv; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON TABLE tbl_srv IS 'SERVICO';


--
-- TOC entry 10126 (class 0 OID 0)
-- Dependencies: 725
-- Name: COLUMN tbl_srv.cd_srv; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_srv.cd_srv IS 'CODIGO';


--
-- TOC entry 10127 (class 0 OID 0)
-- Dependencies: 725
-- Name: COLUMN tbl_srv.ds_srv; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_srv.ds_srv IS 'DESCRICAO';


--
-- TOC entry 10128 (class 0 OID 0)
-- Dependencies: 725
-- Name: COLUMN tbl_srv.fg_atv_srv; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_srv.fg_atv_srv IS 'FLAG ATIVO';


--
-- TOC entry 10129 (class 0 OID 0)
-- Dependencies: 725
-- Name: COLUMN tbl_srv.cd_cnt; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_srv.cd_cnt IS 'CODIGO DA CONTA';


--
-- TOC entry 10130 (class 0 OID 0)
-- Dependencies: 725
-- Name: COLUMN tbl_srv.cd_tlc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_srv.cd_tlc IS 'CODIGO DO TIPO DE LANCAMENTO';


--
-- TOC entry 726 (class 1259 OID 566401)
-- Name: tbl_trc; Type: TABLE; Schema: sc_srv; Owner: scan
--

CREATE TABLE tbl_trc (
    cd_trc numeric(10,0) NOT NULL,
    cd_hrc numeric(10,0) NOT NULL,
    nr_ttl_rg_trc numeric(9,0)
);


ALTER TABLE tbl_trc OWNER TO scan;

--
-- TOC entry 10131 (class 0 OID 0)
-- Dependencies: 726
-- Name: TABLE tbl_trc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON TABLE tbl_trc IS 'TRAILLER RETORNO CAPITALIZACAO';


--
-- TOC entry 10132 (class 0 OID 0)
-- Dependencies: 726
-- Name: COLUMN tbl_trc.cd_trc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_trc.cd_trc IS 'CODIGO';


--
-- TOC entry 10133 (class 0 OID 0)
-- Dependencies: 726
-- Name: COLUMN tbl_trc.cd_hrc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_trc.cd_hrc IS 'HEADER';


--
-- TOC entry 10134 (class 0 OID 0)
-- Dependencies: 726
-- Name: COLUMN tbl_trc.nr_ttl_rg_trc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_trc.nr_ttl_rg_trc IS 'NUMERO TOTAL DE REGISTRO';


--
-- TOC entry 727 (class 1259 OID 566404)
-- Name: tbl_tsc; Type: TABLE; Schema: sc_srv; Owner: scan
--

CREATE TABLE tbl_tsc (
    cd_tsc numeric(10,0) NOT NULL,
    cd_srv numeric(5,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    vl_tsc numeric(13,2) NOT NULL,
    st_tsc numeric(2,0) NOT NULL,
    dt_vnc_tsc date NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    cd_opr numeric(10,0),
    cd_cnt numeric(10,0),
    his_lcn_tsc character varying(400),
    dt_pgto_tsc date,
    dt_grc_rps_tsc timestamp without time zone,
    cd_fep_sfe numeric(10,0)
);


ALTER TABLE tbl_tsc OWNER TO scan;

--
-- TOC entry 10135 (class 0 OID 0)
-- Dependencies: 727
-- Name: TABLE tbl_tsc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON TABLE tbl_tsc IS 'TARIFA DE SERVICO DE CARTAO';


--
-- TOC entry 10136 (class 0 OID 0)
-- Dependencies: 727
-- Name: COLUMN tbl_tsc.cd_tsc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_tsc.cd_tsc IS 'CODIGO';


--
-- TOC entry 10137 (class 0 OID 0)
-- Dependencies: 727
-- Name: COLUMN tbl_tsc.cd_srv; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_tsc.cd_srv IS 'SERVICO';


--
-- TOC entry 10138 (class 0 OID 0)
-- Dependencies: 727
-- Name: COLUMN tbl_tsc.cd_crt; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_tsc.cd_crt IS 'CARTAO';


--
-- TOC entry 10139 (class 0 OID 0)
-- Dependencies: 727
-- Name: COLUMN tbl_tsc.vl_tsc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_tsc.vl_tsc IS 'VALOR';


--
-- TOC entry 10140 (class 0 OID 0)
-- Dependencies: 727
-- Name: COLUMN tbl_tsc.st_tsc; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_tsc.st_tsc IS 'SITUACAO';


--
-- TOC entry 10141 (class 0 OID 0)
-- Dependencies: 727
-- Name: COLUMN tbl_tsc.cd_inc_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_tsc.cd_inc_usr IS 'USUARIO DE INCLUSAO';


--
-- TOC entry 10142 (class 0 OID 0)
-- Dependencies: 727
-- Name: COLUMN tbl_tsc.dt_inc_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_tsc.dt_inc_usr IS 'DATA DE INCLUSAO';


--
-- TOC entry 10143 (class 0 OID 0)
-- Dependencies: 727
-- Name: COLUMN tbl_tsc.cd_alt_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_tsc.cd_alt_usr IS 'USUARIO DE ALTERACAO';


--
-- TOC entry 10144 (class 0 OID 0)
-- Dependencies: 727
-- Name: COLUMN tbl_tsc.dt_alt_usr; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_tsc.dt_alt_usr IS 'DATA DE ALTERACAO';


--
-- TOC entry 10145 (class 0 OID 0)
-- Dependencies: 727
-- Name: COLUMN tbl_tsc.cd_fep_sfe; Type: COMMENT; Schema: sc_srv; Owner: scan
--

COMMENT ON COLUMN tbl_tsc.cd_fep_sfe IS 'codigo do servico de fatura de empresa que a TSM esta sendo cobrada';


SET search_path = sc_ssp, pg_catalog;

--
-- TOC entry 728 (class 1259 OID 566407)
-- Name: sq_caep; Type: SEQUENCE; Schema: sc_ssp; Owner: scan
--

CREATE SEQUENCE sq_caep
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE sq_caep OWNER TO scan;

--
-- TOC entry 729 (class 1259 OID 566409)
-- Name: sq_daep; Type: SEQUENCE; Schema: sc_ssp; Owner: scan
--

CREATE SEQUENCE sq_daep
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE sq_daep OWNER TO scan;

--
-- TOC entry 730 (class 1259 OID 566411)
-- Name: sq_faep; Type: SEQUENCE; Schema: sc_ssp; Owner: scan
--

CREATE SEQUENCE sq_faep
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE sq_faep OWNER TO scan;

--
-- TOC entry 731 (class 1259 OID 566413)
-- Name: sq_haep; Type: SEQUENCE; Schema: sc_ssp; Owner: scan
--

CREATE SEQUENCE sq_haep
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE sq_haep OWNER TO scan;

--
-- TOC entry 732 (class 1259 OID 566415)
-- Name: sq_ssp; Type: SEQUENCE; Schema: sc_ssp; Owner: scan
--

CREATE SEQUENCE sq_ssp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE sq_ssp OWNER TO scan;

--
-- TOC entry 733 (class 1259 OID 566417)
-- Name: tbl_caep; Type: TABLE; Schema: sc_ssp; Owner: scan
--

CREATE TABLE tbl_caep (
    cd_caep numeric(10,0) NOT NULL,
    cd_haep numeric(10,0) NOT NULL,
    cd_ctr numeric(10,0) NOT NULL,
    cd_emp numeric(10,0) NOT NULL,
    ds_emp character varying(50) NOT NULL,
    cd_mpl numeric(2,0) NOT NULL
);


ALTER TABLE tbl_caep OWNER TO scan;

--
-- TOC entry 734 (class 1259 OID 566420)
-- Name: tbl_daep; Type: TABLE; Schema: sc_ssp; Owner: scan
--

CREATE TABLE tbl_daep (
    cd_daep numeric(10,0) NOT NULL,
    nm_func_daep character varying(80) NOT NULL,
    nm_pls_daep character varying(40) NOT NULL,
    cd_pls numeric(16,0),
    dt_vld_daep character varying(7) NOT NULL,
    trl1_daep character varying(76) NOT NULL,
    trl2_daep character varying(37) NOT NULL,
    msg_crt_daep character varying(40),
    cd_haep numeric(10,0) NOT NULL,
    cd_caep numeric(10,0) NOT NULL,
    cd_faep numeric(10,0) NOT NULL,
    scc_daep character varying(3) NOT NULL,
    cd_ssp numeric(10,0) NOT NULL,
    cd_pop numeric(16,0),
    tp_etr_daep character(1)
);


ALTER TABLE tbl_daep OWNER TO scan;

--
-- TOC entry 735 (class 1259 OID 566423)
-- Name: tbl_faep; Type: TABLE; Schema: sc_ssp; Owner: scan
--

CREATE TABLE tbl_faep (
    cd_faep numeric(10,0) NOT NULL,
    cd_caep numeric(10,0) NOT NULL,
    cd_fem numeric(8,0) NOT NULL,
    ds_fem character varying(60) NOT NULL,
    cnpj_faep numeric(14,0) NOT NULL,
    cep_faep numeric(8,0) NOT NULL,
    log_faep character varying(60) NOT NULL,
    nr_end_faep character varying(5) NOT NULL,
    cpl_edr_faep character varying(60),
    brr_edr_faep character varying(60) NOT NULL,
    loc_edr_faep character varying(60) NOT NULL,
    uf_edr_faep character(2) NOT NULL,
    cd_emp numeric(8,0) NOT NULL
);


ALTER TABLE tbl_faep OWNER TO scan;

--
-- TOC entry 736 (class 1259 OID 566426)
-- Name: tbl_haep; Type: TABLE; Schema: sc_ssp; Owner: scan
--

CREATE TABLE tbl_haep (
    cd_haep numeric(10,0) NOT NULL,
    vrs_haep character varying(5) NOT NULL,
    dt_grc_haep timestamp without time zone NOT NULL,
    nm_arq_haep character varying(100) NOT NULL,
    pri_haep character(1) DEFAULT 'N'::bpchar NOT NULL,
    st_haep numeric(2,0) DEFAULT 1 NOT NULL,
    nm_dir_arq_haep character varying(100) NOT NULL,
    qtd_pls_haep numeric(5,0),
    dt_env_haep timestamp without time zone,
    nm_ftp_imp_haep character varying(50)
);


ALTER TABLE tbl_haep OWNER TO scan;

--
-- TOC entry 10146 (class 0 OID 0)
-- Dependencies: 736
-- Name: TABLE tbl_haep; Type: COMMENT; Schema: sc_ssp; Owner: scan
--

COMMENT ON TABLE tbl_haep IS 'Tabela de Header de Arquivo de Emissao de Plastico';


--
-- TOC entry 10147 (class 0 OID 0)
-- Dependencies: 736
-- Name: COLUMN tbl_haep.qtd_pls_haep; Type: COMMENT; Schema: sc_ssp; Owner: scan
--

COMMENT ON COLUMN tbl_haep.qtd_pls_haep IS 'QUANTIDADE DE PLASTICO DENTRO DO ARQUIVO';


--
-- TOC entry 10148 (class 0 OID 0)
-- Dependencies: 736
-- Name: COLUMN tbl_haep.dt_env_haep; Type: COMMENT; Schema: sc_ssp; Owner: scan
--

COMMENT ON COLUMN tbl_haep.dt_env_haep IS 'DATA DO ENVIO DO ARQUIVO';


--
-- TOC entry 737 (class 1259 OID 566431)
-- Name: tbl_mpl; Type: TABLE; Schema: sc_ssp; Owner: scan
--

CREATE TABLE tbl_mpl (
    cd_mpl numeric(2,0) NOT NULL,
    ds_mpl character varying(50) NOT NULL,
    fg_snh_mpl character(1) DEFAULT 'N'::bpchar NOT NULL
);


ALTER TABLE tbl_mpl OWNER TO scan;

--
-- TOC entry 10149 (class 0 OID 0)
-- Dependencies: 737
-- Name: COLUMN tbl_mpl.fg_snh_mpl; Type: COMMENT; Schema: sc_ssp; Owner: scan
--

COMMENT ON COLUMN tbl_mpl.fg_snh_mpl IS 'S - Emite senha junto com o cartao;N - Emite senha senha separado do cartao';


--
-- TOC entry 738 (class 1259 OID 566435)
-- Name: tbl_ssp; Type: TABLE; Schema: sc_ssp; Owner: scan
--

CREATE TABLE tbl_ssp (
    cd_ssp numeric(10,0) NOT NULL,
    cd_pls numeric(16,0),
    tp_ssp numeric(2,0) NOT NULL,
    st_ssp numeric(2,0) DEFAULT 1 NOT NULL,
    cd_mpl numeric(2,0) NOT NULL,
    msg_crt_ssp character varying(40),
    dt_prv_grc_ssp timestamp without time zone NOT NULL,
    dt_grc_ssp timestamp without time zone,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_pop numeric(16,0),
    dt_cnc_ssp timestamp without time zone,
    cd_usr_cnc_ssp numeric(10,0),
    mtv_cnc_ssp character varying(100),
    cd_fep numeric(10,0),
    cd_inc_usr numeric(10,0) DEFAULT 1,
    fg_cbr_emi_ssp character varying DEFAULT 'S'::character varying NOT NULL
);


ALTER TABLE tbl_ssp OWNER TO scan;

--
-- TOC entry 10150 (class 0 OID 0)
-- Dependencies: 738
-- Name: COLUMN tbl_ssp.cd_fep; Type: COMMENT; Schema: sc_ssp; Owner: scan
--

COMMENT ON COLUMN tbl_ssp.cd_fep IS 'CODIGO DA FATURA DE EMPRESA QUE FOI COBRADA A VIA DE CARTAO';


--
-- TOC entry 10151 (class 0 OID 0)
-- Dependencies: 738
-- Name: COLUMN tbl_ssp.fg_cbr_emi_ssp; Type: COMMENT; Schema: sc_ssp; Owner: scan
--

COMMENT ON COLUMN tbl_ssp.fg_cbr_emi_ssp IS 'FLAG COBRAR EMISSAO DO PLASTICO';


SET search_path = sc_svg, pg_catalog;

--
-- TOC entry 739 (class 1259 OID 566444)
-- Name: sq_ars; Type: SEQUENCE; Schema: sc_svg; Owner: scan
--

CREATE SEQUENCE sq_ars
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_ars OWNER TO scan;

--
-- TOC entry 740 (class 1259 OID 566446)
-- Name: sq_csg; Type: SEQUENCE; Schema: sc_svg; Owner: scan
--

CREATE SEQUENCE sq_csg
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_csg OWNER TO scan;

--
-- TOC entry 741 (class 1259 OID 566448)
-- Name: sq_drs; Type: SEQUENCE; Schema: sc_svg; Owner: scan
--

CREATE SEQUENCE sq_drs
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_drs OWNER TO scan;

--
-- TOC entry 742 (class 1259 OID 566450)
-- Name: sq_fem_csg; Type: SEQUENCE; Schema: sc_svg; Owner: scan
--

CREATE SEQUENCE sq_fem_csg
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_fem_csg OWNER TO scan;

--
-- TOC entry 743 (class 1259 OID 566452)
-- Name: sq_osg; Type: SEQUENCE; Schema: sc_svg; Owner: scan
--

CREATE SEQUENCE sq_osg
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_osg OWNER TO scan;

--
-- TOC entry 744 (class 1259 OID 566454)
-- Name: sq_psg; Type: SEQUENCE; Schema: sc_svg; Owner: scan
--

CREATE SEQUENCE sq_psg
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_psg OWNER TO scan;

--
-- TOC entry 745 (class 1259 OID 566456)
-- Name: tbl_ars; Type: TABLE; Schema: sc_svg; Owner: scan
--

CREATE TABLE tbl_ars (
    cd_ars numeric(10,0) NOT NULL,
    nm_ars character varying(400) NOT NULL,
    cd_csg numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    st_ars numeric(1,0) NOT NULL,
    qtd_ars numeric(3,0),
    mes_ars character varying(7) NOT NULL
);


ALTER TABLE tbl_ars OWNER TO scan;

--
-- TOC entry 10152 (class 0 OID 0)
-- Dependencies: 745
-- Name: TABLE tbl_ars; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON TABLE tbl_ars IS 'TABELA DE ARQUIVO DE REMESSA DO SEGURO';


--
-- TOC entry 747 (class 1259 OID 566463)
-- Name: tbl_drs; Type: TABLE; Schema: sc_svg; Owner: scan
--

CREATE TABLE tbl_drs (
    cd_drs numeric(10,0) NOT NULL,
    cd_sgr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    cd_ars numeric(10,0) NOT NULL
);


ALTER TABLE tbl_drs OWNER TO scan;

--
-- TOC entry 10153 (class 0 OID 0)
-- Dependencies: 747
-- Name: TABLE tbl_drs; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON TABLE tbl_drs IS 'DETALHE DO ARQUIVO DE REMESSA DO SEGURO';


--
-- TOC entry 748 (class 1259 OID 566466)
-- Name: tbl_fem_csg; Type: TABLE; Schema: sc_svg; Owner: scan
--

CREATE TABLE tbl_fem_csg (
    cd_fem_csg numeric(10,0) NOT NULL,
    cd_emp numeric(10,0) NOT NULL,
    cd_fem numeric(10,0) NOT NULL,
    cd_csg numeric(10,0) NOT NULL,
    fg_atv_fem_csg character(1) DEFAULT 'S'::bpchar NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    dg_apl_fem_csg character varying(20)
);


ALTER TABLE tbl_fem_csg OWNER TO scan;

--
-- TOC entry 10154 (class 0 OID 0)
-- Dependencies: 748
-- Name: TABLE tbl_fem_csg; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON TABLE tbl_fem_csg IS 'FILIAIS DO CONTRATO DE SEGURO EM GRUPO';


--
-- TOC entry 749 (class 1259 OID 566470)
-- Name: tbl_osg; Type: TABLE; Schema: sc_svg; Owner: scan
--

CREATE TABLE tbl_osg (
    cd_osg numeric(10,0) NOT NULL,
    cd_tos numeric(10,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    ds_osg character varying(100) NOT NULL,
    cd_sgr numeric(10,0) NOT NULL
);


ALTER TABLE tbl_osg OWNER TO scan;

--
-- TOC entry 10155 (class 0 OID 0)
-- Dependencies: 749
-- Name: TABLE tbl_osg; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON TABLE tbl_osg IS 'TABELA DE OCORRENCIA DE SEGURO';


--
-- TOC entry 750 (class 1259 OID 566473)
-- Name: tbl_psg; Type: TABLE; Schema: sc_svg; Owner: scan
--

CREATE TABLE tbl_psg (
    cd_psg numeric(10,0) NOT NULL,
    dt_grc_psg timestamp without time zone NOT NULL,
    cd_sgr numeric(10,0) NOT NULL,
    st_psg numeric(1,0) NOT NULL,
    vl_psg numeric(13,2) NOT NULL,
    dt_pgt_psg timestamp without time zone,
    dt_vnc_psg date NOT NULL
);


ALTER TABLE tbl_psg OWNER TO scan;

--
-- TOC entry 751 (class 1259 OID 566476)
-- Name: tbl_tos; Type: TABLE; Schema: sc_svg; Owner: scan
--

CREATE TABLE tbl_tos (
    cd_tos numeric(10,0) NOT NULL,
    ds_tos character varying(50) NOT NULL
);


ALTER TABLE tbl_tos OWNER TO scan;

--
-- TOC entry 10156 (class 0 OID 0)
-- Dependencies: 751
-- Name: TABLE tbl_tos; Type: COMMENT; Schema: sc_svg; Owner: scan
--

COMMENT ON TABLE tbl_tos IS 'TIPO DE OCORRENCIA DE SEGURO';


SET search_path = sc_tem, pg_catalog;

--
-- TOC entry 752 (class 1259 OID 566479)
-- Name: sq_ads; Type: SEQUENCE; Schema: sc_tem; Owner: scan
--

CREATE SEQUENCE sq_ads
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE sq_ads OWNER TO scan;

--
-- TOC entry 753 (class 1259 OID 566481)
-- Name: sq_oca; Type: SEQUENCE; Schema: sc_tem; Owner: scan
--

CREATE SEQUENCE sq_oca
    START WITH 0
    INCREMENT BY 1
    MINVALUE 0
    MAXVALUE 9999999999999
    CACHE 1;


ALTER TABLE sq_oca OWNER TO scan;

--
-- TOC entry 754 (class 1259 OID 566483)
-- Name: sq_prc; Type: SEQUENCE; Schema: sc_tem; Owner: scan
--

CREATE SEQUENCE sq_prc
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_prc OWNER TO scan;

--
-- TOC entry 755 (class 1259 OID 566485)
-- Name: sq_rqs; Type: SEQUENCE; Schema: sc_tem; Owner: scan
--

CREATE SEQUENCE sq_rqs
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE sq_rqs OWNER TO scan;

--
-- TOC entry 756 (class 1259 OID 566487)
-- Name: tbl_ads; Type: TABLE; Schema: sc_tem; Owner: scan
--

CREATE TABLE tbl_ads (
    cd_ads numeric(10,0) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    cd_crt numeric(16,0) NOT NULL,
    cd_crt_tem numeric(16,0) NOT NULL,
    cd_css numeric(5,0) NOT NULL,
    st_ads numeric(5,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone
);


ALTER TABLE tbl_ads OWNER TO scan;

--
-- TOC entry 10157 (class 0 OID 0)
-- Dependencies: 756
-- Name: TABLE tbl_ads; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON TABLE tbl_ads IS 'tabela de adesao ao produto por cpf na saqpag';


--
-- TOC entry 10158 (class 0 OID 0)
-- Dependencies: 756
-- Name: COLUMN tbl_ads.cd_ads; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_ads.cd_ads IS 'codigo';


--
-- TOC entry 10159 (class 0 OID 0)
-- Dependencies: 756
-- Name: COLUMN tbl_ads.cd_cun; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_ads.cd_cun IS 'codigo do cadastro unico';


--
-- TOC entry 10160 (class 0 OID 0)
-- Dependencies: 756
-- Name: COLUMN tbl_ads.cd_crt; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_ads.cd_crt IS 'codigo do cartao saqpag';


--
-- TOC entry 10161 (class 0 OID 0)
-- Dependencies: 756
-- Name: COLUMN tbl_ads.cd_crt_tem; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_ads.cd_crt_tem IS 'codigo do cartao tem';


--
-- TOC entry 10162 (class 0 OID 0)
-- Dependencies: 756
-- Name: COLUMN tbl_ads.cd_inc_usr; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_ads.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 10163 (class 0 OID 0)
-- Dependencies: 756
-- Name: COLUMN tbl_ads.dt_inc_usr; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_ads.dt_inc_usr IS 'data da inclusao';


--
-- TOC entry 10164 (class 0 OID 0)
-- Dependencies: 756
-- Name: COLUMN tbl_ads.cd_alt_usr; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_ads.cd_alt_usr IS 'codigo do usuario de alteracao';


--
-- TOC entry 10165 (class 0 OID 0)
-- Dependencies: 756
-- Name: COLUMN tbl_ads.dt_alt_usr; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_ads.dt_alt_usr IS 'data da alteracao';


--
-- TOC entry 836 (class 1259 OID 889630)
-- Name: tbl_chv; Type: TABLE; Schema: sc_tem; Owner: scan
--

CREATE TABLE tbl_chv (
    cd_chv numeric(10,0) NOT NULL,
    vrs_chv character varying(10) NOT NULL,
    str_chv character varying(50) NOT NULL,
    nr_chv numeric(2,0)
);


ALTER TABLE tbl_chv OWNER TO scan;

--
-- TOC entry 757 (class 1259 OID 566490)
-- Name: tbl_css; Type: TABLE; Schema: sc_tem; Owner: scan
--

CREATE TABLE tbl_css (
    cd_css numeric(10,0) NOT NULL,
    cd_cun numeric(10,0) NOT NULL,
    nm_css character varying(80) NOT NULL,
    vl_prc_cms_css numeric(6,5) NOT NULL,
    fg_atv_css character(1) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    cd_alt_usr numeric(10,0),
    dt_alt_usr timestamp without time zone,
    vl_msl_css numeric(13,2)
);


ALTER TABLE tbl_css OWNER TO scan;

--
-- TOC entry 10166 (class 0 OID 0)
-- Dependencies: 757
-- Name: TABLE tbl_css; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON TABLE tbl_css IS 'tabela de contrato de servico de saude';


--
-- TOC entry 10167 (class 0 OID 0)
-- Dependencies: 757
-- Name: COLUMN tbl_css.cd_css; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_css.cd_css IS 'codigo';


--
-- TOC entry 10168 (class 0 OID 0)
-- Dependencies: 757
-- Name: COLUMN tbl_css.cd_cun; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_css.cd_cun IS 'codigo do cadastro unico';


--
-- TOC entry 10169 (class 0 OID 0)
-- Dependencies: 757
-- Name: COLUMN tbl_css.cd_inc_usr; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_css.cd_inc_usr IS 'codigo do usuario de inclusao';


--
-- TOC entry 10170 (class 0 OID 0)
-- Dependencies: 757
-- Name: COLUMN tbl_css.dt_inc_usr; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_css.dt_inc_usr IS 'data da inclusao';


--
-- TOC entry 10171 (class 0 OID 0)
-- Dependencies: 757
-- Name: COLUMN tbl_css.cd_alt_usr; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_css.cd_alt_usr IS 'codigo do usuario de alteracao';


--
-- TOC entry 10172 (class 0 OID 0)
-- Dependencies: 757
-- Name: COLUMN tbl_css.dt_alt_usr; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON COLUMN tbl_css.dt_alt_usr IS 'data da alteracao';


--
-- TOC entry 758 (class 1259 OID 566493)
-- Name: tbl_oca; Type: TABLE; Schema: sc_tem; Owner: scan
--

CREATE TABLE tbl_oca (
    cd_oca numeric(10,0) NOT NULL,
    cd_ads numeric(10,0) NOT NULL,
    tp_oca numeric(5,0) NOT NULL,
    cd_inc_usr numeric(10,0) NOT NULL,
    dt_inc_usr timestamp without time zone NOT NULL,
    ds_oca character varying(400),
    dt_prc_oca timestamp without time zone
);


ALTER TABLE tbl_oca OWNER TO scan;

--
-- TOC entry 10173 (class 0 OID 0)
-- Dependencies: 758
-- Name: TABLE tbl_oca; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON TABLE tbl_oca IS 'tabela de ocorrencias das adesoes do servico de saude';


--
-- TOC entry 759 (class 1259 OID 566496)
-- Name: tbl_prc; Type: TABLE; Schema: sc_tem; Owner: scan
--

CREATE TABLE tbl_prc (
    cd_prc numeric(10,0) NOT NULL,
    cd_ads numeric(10,0) NOT NULL,
    cd_crt numeric(14,0) NOT NULL,
    vl_prc numeric(13,2) NOT NULL,
    cd_rqs numeric(10,0) NOT NULL,
    st_prc numeric(1,0) NOT NULL,
    cd_crt_tem numeric(16,0) NOT NULL,
    dt_prc timestamp without time zone NOT NULL,
    fg_cnc_prc character(1) DEFAULT 'N'::bpchar NOT NULL
);


ALTER TABLE tbl_prc OWNER TO scan;

--
-- TOC entry 10174 (class 0 OID 0)
-- Dependencies: 759
-- Name: TABLE tbl_prc; Type: COMMENT; Schema: sc_tem; Owner: scan
--

COMMENT ON TABLE tbl_prc IS 'TABELA DE PROCEDIMENTOS REALIZADOS';


--
-- TOC entry 760 (class 1259 OID 566500)
-- Name: tbl_rqs; Type: TABLE; Schema: sc_tem; Owner: scan
--

CREATE TABLE tbl_rqs (
    cd_rqs numeric(10,0) NOT NULL,
    xml_rqs character varying(4000) NOT NULL,
    xml_rsp_rqs character varying(4000),
    dt_rqs timestamp without time zone NOT NULL,
    msg_err_rqs character varying(4000),
    id_trm_rqs character varying(50),
    nsu_trm_rqs character varying(50),
    tp_trn_rqs numeric(1,0),
    nr_aut_rqs character varying(30),
    id_prj_rqs character varying(50),
    cd_ret_rqs character varying(3)
);


ALTER TABLE tbl_rqs OWNER TO scan;

SET search_path = sqlj, pg_catalog;

--
-- TOC entry 761 (class 1259 OID 566506)
-- Name: classpath_entry; Type: TABLE; Schema: sqlj; Owner: scan
--

CREATE TABLE classpath_entry (
    schemaname character varying(30) NOT NULL,
    ordinal smallint NOT NULL,
    jarid integer NOT NULL
);


ALTER TABLE classpath_entry OWNER TO scan;

--
-- TOC entry 762 (class 1259 OID 566509)
-- Name: jar_entry; Type: TABLE; Schema: sqlj; Owner: scan
--

CREATE TABLE jar_entry (
    entryid integer NOT NULL,
    entryname character varying(200) NOT NULL,
    jarid integer NOT NULL,
    entryimage bytea NOT NULL
);


ALTER TABLE jar_entry OWNER TO scan;

--
-- TOC entry 763 (class 1259 OID 566515)
-- Name: jar_entry_entryid_seq; Type: SEQUENCE; Schema: sqlj; Owner: scan
--

CREATE SEQUENCE jar_entry_entryid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE jar_entry_entryid_seq OWNER TO scan;

--
-- TOC entry 10177 (class 0 OID 0)
-- Dependencies: 763
-- Name: jar_entry_entryid_seq; Type: SEQUENCE OWNED BY; Schema: sqlj; Owner: scan
--

ALTER SEQUENCE jar_entry_entryid_seq OWNED BY jar_entry.entryid;


--
-- TOC entry 764 (class 1259 OID 566517)
-- Name: jar_repository; Type: TABLE; Schema: sqlj; Owner: scan
--

CREATE TABLE jar_repository (
    jarid integer NOT NULL,
    jarname character varying(100) NOT NULL,
    jarorigin character varying(500) NOT NULL,
    jarowner name NOT NULL,
    jarmanifest text,
    deploymentdesc integer
);


ALTER TABLE jar_repository OWNER TO scan;

--
-- TOC entry 765 (class 1259 OID 566523)
-- Name: jar_repository_jarid_seq; Type: SEQUENCE; Schema: sqlj; Owner: scan
--

CREATE SEQUENCE jar_repository_jarid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE jar_repository_jarid_seq OWNER TO scan;

--
-- TOC entry 10179 (class 0 OID 0)
-- Dependencies: 765
-- Name: jar_repository_jarid_seq; Type: SEQUENCE OWNED BY; Schema: sqlj; Owner: scan
--

ALTER SEQUENCE jar_repository_jarid_seq OWNED BY jar_repository.jarid;


--
-- TOC entry 766 (class 1259 OID 566525)
-- Name: typemap_entry; Type: TABLE; Schema: sqlj; Owner: scan
--

CREATE TABLE typemap_entry (
    mapid integer NOT NULL,
    javaname character varying(200) NOT NULL,
    sqlname name NOT NULL
);


ALTER TABLE typemap_entry OWNER TO scan;

--
-- TOC entry 767 (class 1259 OID 566528)
-- Name: typemap_entry_mapid_seq; Type: SEQUENCE; Schema: sqlj; Owner: scan
--

CREATE SEQUENCE typemap_entry_mapid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE typemap_entry_mapid_seq OWNER TO scan;

--
-- TOC entry 10181 (class 0 OID 0)
-- Dependencies: 767
-- Name: typemap_entry_mapid_seq; Type: SEQUENCE OWNED BY; Schema: sqlj; Owner: scan
--

ALTER SEQUENCE typemap_entry_mapid_seq OWNED BY typemap_entry.mapid;


SET search_path = sc__buxo, pg_catalog;

--
-- TOC entry 5501 (class 2604 OID 1668900)
-- Name: cd_cbf_aux; Type: DEFAULT; Schema: sc__buxo; Owner: postgres
--

ALTER TABLE ONLY tbl_cbf_aux ALTER COLUMN cd_cbf_aux SET DEFAULT nextval('tbl_cbf_aux_cd_cbf_aux_seq'::regclass);


SET search_path = sc_analise, pg_catalog;

--
-- TOC entry 5525 (class 2604 OID 1667137)
-- Name: codigo; Type: DEFAULT; Schema: sc_analise; Owner: scan
--

ALTER TABLE ONLY tbl_cartoes_mes ALTER COLUMN codigo SET DEFAULT nextval('tbl_cartoes_mes_codigo_seq'::regclass);


SET search_path = sc_cbe, pg_catalog;

--
-- TOC entry 5526 (class 2604 OID 1672257)
-- Name: id; Type: DEFAULT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY acordo_funcionario_empresa ALTER COLUMN id SET DEFAULT nextval('acordo_funcionario_empresa_id_seq'::regclass);


SET search_path = sqlj, pg_catalog;

--
-- TOC entry 5469 (class 2604 OID 566530)
-- Name: entryid; Type: DEFAULT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY jar_entry ALTER COLUMN entryid SET DEFAULT nextval('jar_entry_entryid_seq'::regclass);


--
-- TOC entry 5470 (class 2604 OID 566531)
-- Name: jarid; Type: DEFAULT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY jar_repository ALTER COLUMN jarid SET DEFAULT nextval('jar_repository_jarid_seq'::regclass);


--
-- TOC entry 5471 (class 2604 OID 566532)
-- Name: mapid; Type: DEFAULT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY typemap_entry ALTER COLUMN mapid SET DEFAULT nextval('typemap_entry_mapid_seq'::regclass);


SET search_path = sc__buxo, pg_catalog;

--
-- TOC entry 6525 (class 2606 OID 1614089)
-- Name: pk_buxo_cdcnt; Type: CONSTRAINT; Schema: sc__buxo; Owner: postgres
--

ALTER TABLE ONLY tbl_conta
    ADD CONSTRAINT pk_buxo_cdcnt PRIMARY KEY (cd_cnt);


--
-- TOC entry 6350 (class 2606 OID 874388)
-- Name: pk_buxo_cpf; Type: CONSTRAINT; Schema: sc__buxo; Owner: scan
--

ALTER TABLE ONLY tbl_viper
    ADD CONSTRAINT pk_buxo_cpf PRIMARY KEY (cpf);


--
-- TOC entry 6334 (class 2606 OID 862533)
-- Name: pk_buxo_svn; Type: CONSTRAINT; Schema: sc__buxo; Owner: postgres
--

ALTER TABLE ONLY tbl_svn2_org
    ADD CONSTRAINT pk_buxo_svn PRIMARY KEY (cd_svn);


--
-- TOC entry 6457 (class 2606 OID 975179)
-- Name: pk_buxo_svn2; Type: CONSTRAINT; Schema: sc__buxo; Owner: scan
--

ALTER TABLE ONLY tbl_svn2
    ADD CONSTRAINT pk_buxo_svn2 PRIMARY KEY (cd_svn);


--
-- TOC entry 5579 (class 2606 OID 829515)
-- Name: pk_crt_aux; Type: CONSTRAINT; Schema: sc__buxo; Owner: scan
--

ALTER TABLE ONLY tbl_crt_aux
    ADD CONSTRAINT pk_crt_aux PRIMARY KEY (cd_crt);


--
-- TOC entry 6550 (class 2606 OID 1636253)
-- Name: pk_dados_matricula; Type: CONSTRAINT; Schema: sc__buxo; Owner: scan
--

ALTER TABLE ONLY tbl_dados_campanha
    ADD CONSTRAINT pk_dados_matricula PRIMARY KEY (matricula);


--
-- TOC entry 5581 (class 2606 OID 829517)
-- Name: pk_dvd; Type: CONSTRAINT; Schema: sc__buxo; Owner: scan
--

ALTER TABLE ONLY tbl_dvd
    ADD CONSTRAINT pk_dvd PRIMARY KEY (cd_dvd);


--
-- TOC entry 6325 (class 2606 OID 862035)
-- Name: pk_ltc; Type: CONSTRAINT; Schema: sc__buxo; Owner: scan
--

ALTER TABLE ONLY tbl_svn_ltc
    ADD CONSTRAINT pk_ltc PRIMARY KEY (cd_ltc);


--
-- TOC entry 5583 (class 2606 OID 829519)
-- Name: pk_pls_aux; Type: CONSTRAINT; Schema: sc__buxo; Owner: scan
--

ALTER TABLE ONLY tbl_pls_aux
    ADD CONSTRAINT pk_pls_aux PRIMARY KEY (cd_pls);


SET search_path = sc_acc, pg_catalog;

--
-- TOC entry 5530 (class 2606 OID 829521)
-- Name: fk_hfe; Type: CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT fk_hfe PRIMARY KEY (cd_hfe);


--
-- TOC entry 5585 (class 2606 OID 829523)
-- Name: pk_hdr; Type: CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_hdr
    ADD CONSTRAINT pk_hdr PRIMARY KEY (cd_hdr);


--
-- TOC entry 5528 (class 2606 OID 829525)
-- Name: pk_rct; Type: CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_rct
    ADD CONSTRAINT pk_rct PRIMARY KEY (cd_rct);


--
-- TOC entry 5587 (class 2606 OID 829527)
-- Name: pk_red; Type: CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_red
    ADD CONSTRAINT pk_red PRIMARY KEY (cd_red);


--
-- TOC entry 5589 (class 2606 OID 829529)
-- Name: pk_rtl; Type: CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_rtl
    ADD CONSTRAINT pk_rtl PRIMARY KEY (cd_rtl);


--
-- TOC entry 5591 (class 2606 OID 829531)
-- Name: pk_tfe; Type: CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_tfe
    ADD CONSTRAINT pk_tfe PRIMARY KEY (cd_tfe);


--
-- TOC entry 5593 (class 2606 OID 829533)
-- Name: pk_trl; Type: CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_trl
    ADD CONSTRAINT pk_trl PRIMARY KEY (cd_trl);


SET search_path = sc_ace, pg_catalog;

--
-- TOC entry 5532 (class 2606 OID 829535)
-- Name: pk_det_oboe; Type: CONSTRAINT; Schema: sc_ace; Owner: scan
--

ALTER TABLE ONLY tbl_det_oboe
    ADD CONSTRAINT pk_det_oboe PRIMARY KEY (cd_det_oboe);


--
-- TOC entry 5595 (class 2606 OID 829537)
-- Name: pk_hdr_oboe; Type: CONSTRAINT; Schema: sc_ace; Owner: scan
--

ALTER TABLE ONLY tbl_hdr_oboe
    ADD CONSTRAINT pk_hdr_oboe PRIMARY KEY (cd_hdr_oboe);


SET search_path = sc_adp, pg_catalog;

--
-- TOC entry 5601 (class 2606 OID 829539)
-- Name: pk_add; Type: CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_add
    ADD CONSTRAINT pk_add PRIMARY KEY (cd_add);


--
-- TOC entry 5597 (class 2606 OID 829541)
-- Name: pk_adp; Type: CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY old_tbl_adp
    ADD CONSTRAINT pk_adp PRIMARY KEY (cd_adp);


--
-- TOC entry 5599 (class 2606 OID 829543)
-- Name: pk_ddp; Type: CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY old_tbl_ddp
    ADD CONSTRAINT pk_ddp PRIMARY KEY (cd_ddp);


--
-- TOC entry 5603 (class 2606 OID 829545)
-- Name: pk_hdr; Type: CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hdr
    ADD CONSTRAINT pk_hdr PRIMARY KEY (cd_hdr);


--
-- TOC entry 5605 (class 2606 OID 829547)
-- Name: pk_hdr_tmp; Type: CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hdr_tmp
    ADD CONSTRAINT pk_hdr_tmp PRIMARY KEY (cd_hdr);


--
-- TOC entry 5607 (class 2606 OID 829549)
-- Name: pk_hfe; Type: CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT pk_hfe PRIMARY KEY (cd_hfe);


--
-- TOC entry 5612 (class 2606 OID 829551)
-- Name: pk_rdp; Type: CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_rdp
    ADD CONSTRAINT pk_rdp PRIMARY KEY (cd_rdp);


--
-- TOC entry 5614 (class 2606 OID 829553)
-- Name: pk_rdp_tmp; Type: CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_rdp_tmp
    ADD CONSTRAINT pk_rdp_tmp PRIMARY KEY (cd_rdp);


--
-- TOC entry 5616 (class 2606 OID 829555)
-- Name: pk_tdp; Type: CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_tdp
    ADD CONSTRAINT pk_tdp PRIMARY KEY (cd_tdp);


--
-- TOC entry 5620 (class 2606 OID 829557)
-- Name: pk_tfe; Type: CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_tfe
    ADD CONSTRAINT pk_tfe PRIMARY KEY (cd_tfe);


--
-- TOC entry 5623 (class 2606 OID 829559)
-- Name: pk_trl; Type: CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_trl
    ADD CONSTRAINT pk_trl PRIMARY KEY (cd_trl);


SET search_path = sc_aeo, pg_catalog;

--
-- TOC entry 5625 (class 2606 OID 829561)
-- Name: pk_aeo; Type: CONSTRAINT; Schema: sc_aeo; Owner: scan
--

ALTER TABLE ONLY tbl_aeo
    ADD CONSTRAINT pk_aeo PRIMARY KEY (cd_aeo);


--
-- TOC entry 5627 (class 2606 OID 829563)
-- Name: pk_aeop; Type: CONSTRAINT; Schema: sc_aeo; Owner: scan
--

ALTER TABLE ONLY tbl_aeop
    ADD CONSTRAINT pk_aeop PRIMARY KEY (cd_aeop);


--
-- TOC entry 5632 (class 2606 OID 829565)
-- Name: pk_eop; Type: CONSTRAINT; Schema: sc_aeo; Owner: scan
--

ALTER TABLE ONLY tbl_eop
    ADD CONSTRAINT pk_eop PRIMARY KEY (cd_eop);


--
-- TOC entry 5636 (class 2606 OID 829567)
-- Name: pk_ivt; Type: CONSTRAINT; Schema: sc_aeo; Owner: scan
--

ALTER TABLE ONLY tbl_ivt
    ADD CONSTRAINT pk_ivt PRIMARY KEY (cd_ivt);


--
-- TOC entry 5634 (class 2606 OID 891706)
-- Name: uk_eop_opr; Type: CONSTRAINT; Schema: sc_aeo; Owner: scan
--

ALTER TABLE ONLY tbl_eop
    ADD CONSTRAINT uk_eop_opr UNIQUE (cd_opr);


--
-- TOC entry 5629 (class 2606 OID 829569)
-- Name: uk_seq_dtgrc_aeop; Type: CONSTRAINT; Schema: sc_aeo; Owner: scan
--

ALTER TABLE ONLY tbl_aeop
    ADD CONSTRAINT uk_seq_dtgrc_aeop UNIQUE (seq_aeop, dt_ref_aeop);


SET search_path = sc_analise, pg_catalog;

SET default_tablespace = ts_scan_i;

--
-- TOC entry 6576 (class 2606 OID 1667139)
-- Name: pk_analise_cartao_mes; Type: CONSTRAINT; Schema: sc_analise; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_cartoes_mes
    ADD CONSTRAINT pk_analise_cartao_mes PRIMARY KEY (codigo);


--
-- TOC entry 6578 (class 2606 OID 1667143)
-- Name: uk_cartao_mes_ano; Type: CONSTRAINT; Schema: sc_analise; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_cartoes_mes
    ADD CONSTRAINT uk_cartao_mes_ano UNIQUE (cartao, mes, ano);


SET search_path = sc_atb, pg_catalog;

SET default_tablespace = '';

--
-- TOC entry 5556 (class 2606 OID 829571)
-- Name: fk_atb; Type: CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_atb
    ADD CONSTRAINT fk_atb PRIMARY KEY (cd_atb);


--
-- TOC entry 5644 (class 2606 OID 829573)
-- Name: fk_tba; Type: CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tba
    ADD CONSTRAINT fk_tba PRIMARY KEY (cd_tba);


--
-- TOC entry 5560 (class 2606 OID 829575)
-- Name: pk_art; Type: CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_art
    ADD CONSTRAINT pk_art PRIMARY KEY (cd_art);


--
-- TOC entry 5562 (class 2606 OID 829577)
-- Name: pk_drt; Type: CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_drt
    ADD CONSTRAINT pk_drt PRIMARY KEY (cd_drt);


--
-- TOC entry 5554 (class 2606 OID 829579)
-- Name: pk_dtb; Type: CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_dtb
    ADD CONSTRAINT pk_dtb PRIMARY KEY (cd_dtb);


--
-- TOC entry 5638 (class 2606 OID 829581)
-- Name: pk_etb; Type: CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_etb
    ADD CONSTRAINT pk_etb PRIMARY KEY (cd_etb);


--
-- TOC entry 5640 (class 2606 OID 829583)
-- Name: pk_hlt; Type: CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_hlt
    ADD CONSTRAINT pk_hlt PRIMARY KEY (cd_hlt);


--
-- TOC entry 5642 (class 2606 OID 829585)
-- Name: pk_ort; Type: CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_ort
    ADD CONSTRAINT pk_ort PRIMARY KEY (cd_ort);


--
-- TOC entry 5647 (class 2606 OID 829587)
-- Name: pk_tlt; Type: CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tlt
    ADD CONSTRAINT pk_tlt PRIMARY KEY (cd_hlt);


--
-- TOC entry 5649 (class 2606 OID 829589)
-- Name: pk_trt; Type: CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_trt
    ADD CONSTRAINT pk_trt PRIMARY KEY (cd_art);


SET search_path = sc_cad, pg_catalog;

--
-- TOC entry 5694 (class 2606 OID 829591)
-- Name: UQ_GEM_NOME; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_gem
    ADD CONSTRAINT "UQ_GEM_NOME" UNIQUE (nm_gem);


--
-- TOC entry 5655 (class 2606 OID 829593)
-- Name: fk_cbf; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cbf
    ADD CONSTRAINT fk_cbf PRIMARY KEY (cd_cbf);


--
-- TOC entry 5662 (class 2606 OID 829595)
-- Name: fk_crg; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_crg
    ADD CONSTRAINT fk_crg PRIMARY KEY (cd_crg);


--
-- TOC entry 5534 (class 2606 OID 829597)
-- Name: fk_edr; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_edr
    ADD CONSTRAINT fk_edr PRIMARY KEY (cd_edr);


--
-- TOC entry 5537 (class 2606 OID 829599)
-- Name: fk_eex; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_eex
    ADD CONSTRAINT fk_eex PRIMARY KEY (cd_edr);


--
-- TOC entry 5684 (class 2606 OID 829601)
-- Name: fk_fem; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fem
    ADD CONSTRAINT fk_fem PRIMARY KEY (cd_emp, cd_fem);


--
-- TOC entry 5689 (class 2606 OID 829603)
-- Name: fk_fnc; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fnc
    ADD CONSTRAINT fk_fnc PRIMARY KEY (cd_fnc);


--
-- TOC entry 5702 (class 2606 OID 829605)
-- Name: fk_ham; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ham
    ADD CONSTRAINT fk_ham PRIMARY KEY (cd_ham);


--
-- TOC entry 5713 (class 2606 OID 829607)
-- Name: fk_prd; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_prd
    ADD CONSTRAINT fk_prd PRIMARY KEY (cd_prd);


--
-- TOC entry 5719 (class 2606 OID 829609)
-- Name: fk_rat; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_rat
    ADD CONSTRAINT fk_rat PRIMARY KEY (cd_rat);


--
-- TOC entry 5550 (class 2606 OID 829611)
-- Name: fk_tlf; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_tlf
    ADD CONSTRAINT fk_tlf PRIMARY KEY (cd_tlf);


--
-- TOC entry 5651 (class 2606 OID 829613)
-- Name: pk_ast; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ast
    ADD CONSTRAINT pk_ast PRIMARY KEY (cd_ast);


--
-- TOC entry 5653 (class 2606 OID 829615)
-- Name: pk_bin; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_bin
    ADD CONSTRAINT pk_bin PRIMARY KEY (cd_bin);


--
-- TOC entry 6465 (class 2606 OID 976470)
-- Name: pk_cls; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cls
    ADD CONSTRAINT pk_cls PRIMARY KEY (cd_cls);


--
-- TOC entry 5658 (class 2606 OID 829617)
-- Name: pk_cpf; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cpf
    ADD CONSTRAINT pk_cpf PRIMARY KEY (cd_cun);


--
-- TOC entry 5660 (class 2606 OID 829619)
-- Name: pk_cpj; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cpj
    ADD CONSTRAINT pk_cpj PRIMARY KEY (cd_cun);


--
-- TOC entry 5665 (class 2606 OID 829621)
-- Name: pk_ctr; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT pk_ctr PRIMARY KEY (cd_ctr);


--
-- TOC entry 6503 (class 2606 OID 1010475)
-- Name: pk_ctr_exc; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT pk_ctr_exc PRIMARY KEY (cd_ctr);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6438 (class 2606 OID 934458)
-- Name: pk_ctr_pcs; Type: CONSTRAINT; Schema: sc_cad; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_ctr_pcs
    ADD CONSTRAINT pk_ctr_pcs PRIMARY KEY (cd_ctr_pcs);


SET default_tablespace = '';

--
-- TOC entry 5709 (class 2606 OID 829623)
-- Name: pk_ctrpce; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_ctr
    ADD CONSTRAINT pk_ctrpce PRIMARY KEY (cd_pce_ctr);


--
-- TOC entry 5667 (class 2606 OID 829625)
-- Name: pk_ctt; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctt
    ADD CONSTRAINT pk_ctt PRIMARY KEY (cd_ctt);


--
-- TOC entry 5669 (class 2606 OID 829627)
-- Name: pk_cun; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cun
    ADD CONSTRAINT pk_cun PRIMARY KEY (cd_cun);


--
-- TOC entry 5673 (class 2606 OID 829629)
-- Name: pk_dmn; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_dmn
    ADD CONSTRAINT pk_dmn PRIMARY KEY (cd_dmn);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6378 (class 2606 OID 888976)
-- Name: pk_dps; Type: CONSTRAINT; Schema: sc_cad; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_dps
    ADD CONSTRAINT pk_dps PRIMARY KEY (cd_dps);


SET default_tablespace = '';

--
-- TOC entry 5680 (class 2606 OID 829631)
-- Name: pk_edr_ctr; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_edr_ctr
    ADD CONSTRAINT pk_edr_ctr PRIMARY KEY (cd_edr_ctr);


--
-- TOC entry 5682 (class 2606 OID 829633)
-- Name: pk_emp; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_emp
    ADD CONSTRAINT pk_emp PRIMARY KEY (cd_emp);


--
-- TOC entry 5687 (class 2606 OID 829635)
-- Name: pk_femctr; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fem_ctr
    ADD CONSTRAINT pk_femctr PRIMARY KEY (cd_fem_ctr);


--
-- TOC entry 5696 (class 2606 OID 829637)
-- Name: pk_gem; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_gem
    ADD CONSTRAINT pk_gem PRIMARY KEY (cd_gem);


--
-- TOC entry 5698 (class 2606 OID 829639)
-- Name: pk_grt; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_grt
    ADD CONSTRAINT pk_grt PRIMARY KEY (cd_grt);


--
-- TOC entry 5700 (class 2606 OID 829641)
-- Name: pk_haef; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_haef
    ADD CONSTRAINT pk_haef PRIMARY KEY (cd_haef);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6513 (class 2606 OID 1076900)
-- Name: pk_luc; Type: CONSTRAINT; Schema: sc_cad; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_luc
    ADD CONSTRAINT pk_luc PRIMARY KEY (cd_luc);


SET default_tablespace = '';

--
-- TOC entry 5704 (class 2606 OID 829643)
-- Name: pk_oce; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_oce
    ADD CONSTRAINT pk_oce PRIMARY KEY (cd_oce);


--
-- TOC entry 5706 (class 2606 OID 829645)
-- Name: pk_pce; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce
    ADD CONSTRAINT pk_pce PRIMARY KEY (cd_pce);


--
-- TOC entry 6405 (class 2606 OID 892051)
-- Name: pk_pce_crt; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_crt
    ADD CONSTRAINT pk_pce_crt PRIMARY KEY (cd_pce_crt);


--
-- TOC entry 6319 (class 2606 OID 852233)
-- Name: pk_pce_fem_ctr; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_fem_ctr
    ADD CONSTRAINT pk_pce_fem_ctr PRIMARY KEY (cd_pce_fem_ctr);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6374 (class 2606 OID 888965)
-- Name: pk_pcs; Type: CONSTRAINT; Schema: sc_cad; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_pcs
    ADD CONSTRAINT pk_pcs PRIMARY KEY (cd_pcs);


--
-- TOC entry 6409 (class 2606 OID 892176)
-- Name: pk_pfe; Type: CONSTRAINT; Schema: sc_cad; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_pfe
    ADD CONSTRAINT pk_pfe PRIMARY KEY (cd_pfe);


SET default_tablespace = '';

--
-- TOC entry 6463 (class 2606 OID 976450)
-- Name: pk_ppt; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ppt
    ADD CONSTRAINT pk_ppt PRIMARY KEY (cd_ppt);


--
-- TOC entry 5715 (class 2606 OID 829647)
-- Name: pk_prm; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_prm
    ADD CONSTRAINT pk_prm PRIMARY KEY (cd_prm);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6479 (class 2606 OID 1002042)
-- Name: pk_rcf; Type: CONSTRAINT; Schema: sc_cad; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_rcf
    ADD CONSTRAINT pk_rcf PRIMARY KEY (cd_rcf);


--
-- TOC entry 6477 (class 2606 OID 1002036)
-- Name: pk_rel; Type: CONSTRAINT; Schema: sc_cad; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_rel
    ADD CONSTRAINT pk_rel PRIMARY KEY (cd_rel);


--
-- TOC entry 6481 (class 2606 OID 1002049)
-- Name: pk_rfl; Type: CONSTRAINT; Schema: sc_cad; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_rfl
    ADD CONSTRAINT pk_rfl PRIMARY KEY (cd_rfl);


--
-- TOC entry 6483 (class 2606 OID 1002060)
-- Name: pk_rrl; Type: CONSTRAINT; Schema: sc_cad; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_rrl
    ADD CONSTRAINT pk_rrl PRIMARY KEY (cd_rrl);


SET default_tablespace = '';

--
-- TOC entry 5721 (class 2606 OID 829649)
-- Name: pk_tltctr; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_tlt_ctr
    ADD CONSTRAINT pk_tltctr PRIMARY KEY (cd_tlt_ctr);


--
-- TOC entry 5725 (class 2606 OID 829651)
-- Name: pk_toe; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_toe
    ADD CONSTRAINT pk_toe PRIMARY KEY (cd_toe);


--
-- TOC entry 5671 (class 2606 OID 829653)
-- Name: uk_cpf_cnpj; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cun
    ADD CONSTRAINT uk_cpf_cnpj UNIQUE (nr_cpf_cnpj_cun);


--
-- TOC entry 5717 (class 2606 OID 829655)
-- Name: uk_nm_prm; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_prm
    ADD CONSTRAINT uk_nm_prm UNIQUE (nm_prm);


--
-- TOC entry 6407 (class 2606 OID 892053)
-- Name: uk_pce_crt; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_crt
    ADD CONSTRAINT uk_pce_crt UNIQUE (cd_crt, cd_pce);


--
-- TOC entry 5711 (class 2606 OID 961892)
-- Name: uk_pce_ctr; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_ctr
    ADD CONSTRAINT uk_pce_ctr UNIQUE (cd_ctr, cd_pce);


--
-- TOC entry 6321 (class 2606 OID 852235)
-- Name: uk_pce_fem_ctr; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_fem_ctr
    ADD CONSTRAINT uk_pce_fem_ctr UNIQUE (cd_fem_ctr, cd_pce);


--
-- TOC entry 5723 (class 2606 OID 829657)
-- Name: uk_tlt_ctr_cd_tlt; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_tlt_ctr
    ADD CONSTRAINT uk_tlt_ctr_cd_tlt UNIQUE (cd_fem_ctr, cd_tlt);


--
-- TOC entry 5675 (class 2606 OID 829659)
-- Name: uk_vl_cmp_nm_cmp_dmn; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_dmn
    ADD CONSTRAINT uk_vl_cmp_nm_cmp_dmn UNIQUE (vl_cmp_dmn, nm_cmp_dmn);


--
-- TOC entry 6380 (class 2606 OID 888978)
-- Name: uq_dps; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_dps
    ADD CONSTRAINT uq_dps UNIQUE (cd_pcs, cd_pce);


--
-- TOC entry 6376 (class 2606 OID 888994)
-- Name: uq_dsc; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pcs
    ADD CONSTRAINT uq_dsc UNIQUE (tp_pcs, dsc_pcs);


--
-- TOC entry 6411 (class 2606 OID 892178)
-- Name: uq_pfe; Type: CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pfe
    ADD CONSTRAINT uq_pfe UNIQUE (cd_pcs_emp_pfe, cd_pcs_fnc_pfe);


SET search_path = sc_cap, pg_catalog;

--
-- TOC entry 5735 (class 2606 OID 829661)
-- Name: fk_cdp; Type: CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_cdp
    ADD CONSTRAINT fk_cdp PRIMARY KEY (cd_dsp);


--
-- TOC entry 5731 (class 2606 OID 829663)
-- Name: pk_atd; Type: CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_atd
    ADD CONSTRAINT pk_atd PRIMARY KEY (cd_atd);


--
-- TOC entry 5733 (class 2606 OID 829665)
-- Name: pk_cdc; Type: CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_cdc
    ADD CONSTRAINT pk_cdc PRIMARY KEY (cd_cdc);


--
-- TOC entry 5737 (class 2606 OID 829667)
-- Name: pk_dsp; Type: CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT pk_dsp PRIMARY KEY (cd_dsp);


--
-- TOC entry 5739 (class 2606 OID 829669)
-- Name: pk_frn; Type: CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_frn
    ADD CONSTRAINT pk_frn PRIMARY KEY (cd_frn);


--
-- TOC entry 5741 (class 2606 OID 829671)
-- Name: pk_tdp; Type: CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_tdp
    ADD CONSTRAINT pk_tdp PRIMARY KEY (cd_tdp);


SET search_path = sc_cbe, pg_catalog;

SET default_tablespace = ts_scan_i;

--
-- TOC entry 6580 (class 2606 OID 1672259)
-- Name: pk_acordo_funcionario_empresa; Type: CONSTRAINT; Schema: sc_cbe; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY acordo_funcionario_empresa
    ADD CONSTRAINT pk_acordo_funcionario_empresa PRIMARY KEY (id);


SET default_tablespace = '';

--
-- TOC entry 6306 (class 2606 OID 840880)
-- Name: pk_acr; Type: CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_acr
    ADD CONSTRAINT pk_acr PRIMARY KEY (cd_acr);


--
-- TOC entry 6415 (class 2606 OID 894738)
-- Name: pk_act; Type: CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_act
    ADD CONSTRAINT pk_act PRIMARY KEY (cd_act);


--
-- TOC entry 6313 (class 2606 OID 844232)
-- Name: pk_bpr; Type: CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_bpr
    ADD CONSTRAINT pk_bpr PRIMARY KEY (cd_bpr);


--
-- TOC entry 6417 (class 2606 OID 894748)
-- Name: pk_dct; Type: CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_dct
    ADD CONSTRAINT pk_dct PRIMARY KEY (cd_dct);


--
-- TOC entry 6309 (class 2606 OID 840885)
-- Name: pk_dvd; Type: CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_dvd
    ADD CONSTRAINT pk_dvd PRIMARY KEY (cd_dvd);


--
-- TOC entry 6304 (class 2606 OID 840870)
-- Name: pk_emc; Type: CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_emc
    ADD CONSTRAINT pk_emc PRIMARY KEY (cd_emc);


--
-- TOC entry 6315 (class 2606 OID 844242)
-- Name: pk_pgp; Type: CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_pgp
    ADD CONSTRAINT pk_pgp PRIMARY KEY (cd_pgp);


--
-- TOC entry 6311 (class 2606 OID 840911)
-- Name: pk_prd; Type: CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_prd
    ADD CONSTRAINT pk_prd PRIMARY KEY (cd_prd);


--
-- TOC entry 6455 (class 2606 OID 975075)
-- Name: pk_rce; Type: CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_rce
    ADD CONSTRAINT pk_rce PRIMARY KEY (cd_rce);


SET search_path = sc_cbr, pg_catalog;

--
-- TOC entry 5743 (class 2606 OID 829673)
-- Name: pk_bac; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_bac
    ADD CONSTRAINT pk_bac PRIMARY KEY (cd_bac);


--
-- TOC entry 5745 (class 2606 OID 829675)
-- Name: pk_blt; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_blt
    ADD CONSTRAINT pk_blt PRIMARY KEY (cd_blt);


--
-- TOC entry 5566 (class 2606 OID 829677)
-- Name: pk_ccb; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_ccb
    ADD CONSTRAINT pk_ccb PRIMARY KEY (cd_ccb);


--
-- TOC entry 5775 (class 2606 OID 829679)
-- Name: pk_cd_prc; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_prc
    ADD CONSTRAINT pk_cd_prc PRIMARY KEY (cd_prc);


--
-- TOC entry 5749 (class 2606 OID 829681)
-- Name: pk_cdt; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_cdt
    ADD CONSTRAINT pk_cdt PRIMARY KEY (cd_cdt);


--
-- TOC entry 5751 (class 2606 OID 829683)
-- Name: pk_darcg; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_darcg
    ADD CONSTRAINT pk_darcg PRIMARY KEY (cd_darcg);


--
-- TOC entry 5753 (class 2606 OID 829685)
-- Name: pk_drb; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_drb
    ADD CONSTRAINT pk_drb PRIMARY KEY (cd_drb);


--
-- TOC entry 5757 (class 2606 OID 829687)
-- Name: pk_drc; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_drc_u
    ADD CONSTRAINT pk_drc PRIMARY KEY (cd_drc);


--
-- TOC entry 5759 (class 2606 OID 829689)
-- Name: pk_hadb; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_hadb
    ADD CONSTRAINT pk_hadb PRIMARY KEY (cd_hadb);


--
-- TOC entry 5761 (class 2606 OID 829691)
-- Name: pk_harc; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_harc
    ADD CONSTRAINT pk_harc PRIMARY KEY (cd_harc);


--
-- TOC entry 5765 (class 2606 OID 829693)
-- Name: pk_harcg; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_harcg
    ADD CONSTRAINT pk_harcg PRIMARY KEY (cd_harcg);


--
-- TOC entry 5769 (class 2606 OID 829695)
-- Name: pk_hlsc; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_hlsc
    ADD CONSTRAINT pk_hlsc PRIMARY KEY (cd_hlsc);


--
-- TOC entry 5771 (class 2606 OID 829697)
-- Name: pk_hrb; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_hrb
    ADD CONSTRAINT pk_hrb PRIMARY KEY (cd_hrb);


--
-- TOC entry 5773 (class 2606 OID 829699)
-- Name: pk_ocb; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_ocb
    ADD CONSTRAINT pk_ocb PRIMARY KEY (cd_ocb);


--
-- TOC entry 5777 (class 2606 OID 829701)
-- Name: pk_tarc; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_tarc
    ADD CONSTRAINT pk_tarc PRIMARY KEY (cd_harc);


--
-- TOC entry 5779 (class 2606 OID 829703)
-- Name: pk_tarcg; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_tarcg
    ADD CONSTRAINT pk_tarcg PRIMARY KEY (cd_tarcg);


--
-- TOC entry 5564 (class 2606 OID 829705)
-- Name: pk_tcb; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_tcb
    ADD CONSTRAINT pk_tcb PRIMARY KEY (cd_tcb);


--
-- TOC entry 5781 (class 2606 OID 829707)
-- Name: pk_tlsc; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_tlsc
    ADD CONSTRAINT pk_tlsc PRIMARY KEY (cd_hlsc);


--
-- TOC entry 5755 (class 2606 OID 829709)
-- Name: tbl_drc_t_pkey; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_drc_t
    ADD CONSTRAINT tbl_drc_t_pkey PRIMARY KEY (cd_drc);


--
-- TOC entry 5763 (class 2606 OID 829711)
-- Name: tbl_harc_cd_bnc_nr_seq_harc_key; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_harc
    ADD CONSTRAINT tbl_harc_cd_bnc_nr_seq_harc_key UNIQUE (cd_bnc, nr_seq_harc, nr_ctr_harc);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 5767 (class 2606 OID 884244)
-- Name: uk_bnc_cdt_abc_harcg; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_harcg
    ADD CONSTRAINT uk_bnc_cdt_abc_harcg UNIQUE (cd_bnc, nr_cdt_harcg, nr_abc_harcg);


SET default_tablespace = '';

--
-- TOC entry 5747 (class 2606 OID 829713)
-- Name: uk_ccb_nsu_tp_nnum; Type: CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_blt
    ADD CONSTRAINT uk_ccb_nsu_tp_nnum UNIQUE (cd_ccb, tp_org_blt, nr_nsu_org_blt, cd_doc_blt);


SET search_path = sc_ccb, pg_catalog;

SET default_tablespace = ts_scan_i;

--
-- TOC entry 6367 (class 2606 OID 885429)
-- Name: pk_ccb; Type: CONSTRAINT; Schema: sc_ccb; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_ccb
    ADD CONSTRAINT pk_ccb PRIMARY KEY (cd_ccb);


--
-- TOC entry 6428 (class 2606 OID 909386)
-- Name: pk_ccb_ant; Type: CONSTRAINT; Schema: sc_ccb; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_ccb_ant
    ADD CONSTRAINT pk_ccb_ant PRIMARY KEY (cd_ccb);


SET default_tablespace = '';

--
-- TOC entry 6370 (class 2606 OID 892524)
-- Name: pk_ccb_pfc; Type: CONSTRAINT; Schema: sc_ccb; Owner: scan
--

ALTER TABLE ONLY tbl_ccb_pfc
    ADD CONSTRAINT pk_ccb_pfc PRIMARY KEY (cd_ccb_pfc);


--
-- TOC entry 6430 (class 2606 OID 909404)
-- Name: pk_ccb_pfc_ant; Type: CONSTRAINT; Schema: sc_ccb; Owner: scan
--

ALTER TABLE ONLY tbl_ccb_pfc_ant
    ADD CONSTRAINT pk_ccb_pfc_ant PRIMARY KEY (cd_ccb_pfc);


--
-- TOC entry 6489 (class 2606 OID 1006380)
-- Name: pk_ccb_tmp; Type: CONSTRAINT; Schema: sc_ccb; Owner: scan
--

ALTER TABLE ONLY tbl_tmp
    ADD CONSTRAINT pk_ccb_tmp PRIMARY KEY (cd_ccb);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6362 (class 2606 OID 885399)
-- Name: pk_csn; Type: CONSTRAINT; Schema: sc_ccb; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_csn
    ADD CONSTRAINT pk_csn PRIMARY KEY (cd_csn);


SET default_tablespace = '';

--
-- TOC entry 6475 (class 2606 OID 997742)
-- Name: pk_occ; Type: CONSTRAINT; Schema: sc_ccb; Owner: scan
--

ALTER TABLE ONLY tbl_occ
    ADD CONSTRAINT pk_occ PRIMARY KEY (cd_occ);


--
-- TOC entry 6372 (class 2606 OID 888688)
-- Name: pk_rps; Type: CONSTRAINT; Schema: sc_ccb; Owner: scan
--

ALTER TABLE ONLY tbl_rps
    ADD CONSTRAINT pk_rps PRIMARY KEY (cd_rps);


--
-- TOC entry 6432 (class 2606 OID 910779)
-- Name: pk_rps_ant; Type: CONSTRAINT; Schema: sc_ccb; Owner: scan
--

ALTER TABLE ONLY tbl_rps_ant
    ADD CONSTRAINT pk_rps_ant PRIMARY KEY (cd_rps);


--
-- TOC entry 6364 (class 2606 OID 885401)
-- Name: uq_cun; Type: CONSTRAINT; Schema: sc_ccb; Owner: scan
--

ALTER TABLE ONLY tbl_csn
    ADD CONSTRAINT uq_cun UNIQUE (cd_cun);


SET search_path = sc_cce, pg_catalog;

--
-- TOC entry 6528 (class 2606 OID 1630846)
-- Name: pk_cce; Type: CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_cce
    ADD CONSTRAINT pk_cce PRIMARY KEY (cd_cce);


--
-- TOC entry 6540 (class 2606 OID 1631834)
-- Name: pk_darc; Type: CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_darc
    ADD CONSTRAINT pk_darc PRIMARY KEY (cd_darc);


--
-- TOC entry 6536 (class 2606 OID 1630922)
-- Name: pk_drb; Type: CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_drb
    ADD CONSTRAINT pk_drb PRIMARY KEY (cd_drb);


--
-- TOC entry 6566 (class 2606 OID 1656463)
-- Name: pk_fnn; Type: CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_fnn
    ADD CONSTRAINT pk_fnn PRIMARY KEY (cd_cce, nr_ini_fnn, nr_fim_fnn);


--
-- TOC entry 6538 (class 2606 OID 1631821)
-- Name: pk_harc; Type: CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_harc
    ADD CONSTRAINT pk_harc PRIMARY KEY (cd_harc);


--
-- TOC entry 6534 (class 2606 OID 1630906)
-- Name: pk_hrb; Type: CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_hrb
    ADD CONSTRAINT pk_hrb PRIMARY KEY (cd_hrb);


--
-- TOC entry 6544 (class 2606 OID 1631888)
-- Name: pk_mti; Type: CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_mti
    ADD CONSTRAINT pk_mti PRIMARY KEY (cd_mti);


--
-- TOC entry 6532 (class 2606 OID 1630887)
-- Name: pk_scd; Type: CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_scd
    ADD CONSTRAINT pk_scd PRIMARY KEY (cd_scd);


--
-- TOC entry 6542 (class 2606 OID 1631852)
-- Name: pk_tarc; Type: CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_tarc
    ADD CONSTRAINT pk_tarc PRIMARY KEY (cd_tarc);


--
-- TOC entry 6530 (class 2606 OID 1630876)
-- Name: pk_tit; Type: CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_tit
    ADD CONSTRAINT pk_tit PRIMARY KEY (cd_tit);


SET search_path = sc_cci, pg_catalog;

--
-- TOC entry 5795 (class 2606 OID 829715)
-- Name: fk_hcc; Type: CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_hcc
    ADD CONSTRAINT fk_hcc PRIMARY KEY (cd_hcc);


--
-- TOC entry 5797 (class 2606 OID 829717)
-- Name: fk_hci; Type: CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_hci
    ADD CONSTRAINT fk_hci PRIMARY KEY (cd_hci);


--
-- TOC entry 5799 (class 2606 OID 829719)
-- Name: fk_tci; Type: CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_tci
    ADD CONSTRAINT fk_tci PRIMARY KEY (cd_tci);


--
-- TOC entry 5783 (class 2606 OID 829721)
-- Name: pk_act; Type: CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_act
    ADD CONSTRAINT pk_act PRIMARY KEY (cd_act);


--
-- TOC entry 5785 (class 2606 OID 829723)
-- Name: pk_ans; Type: CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_ans
    ADD CONSTRAINT pk_ans PRIMARY KEY (cd_ans);


--
-- TOC entry 5787 (class 2606 OID 829725)
-- Name: pk_cci; Type: CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_cci
    ADD CONSTRAINT pk_cci PRIMARY KEY (cd_crt);


--
-- TOC entry 5789 (class 2606 OID 829727)
-- Name: pk_cct; Type: CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_cct
    ADD CONSTRAINT pk_cct PRIMARY KEY (cd_crt);


--
-- TOC entry 5791 (class 2606 OID 829729)
-- Name: pk_dct; Type: CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_dct
    ADD CONSTRAINT pk_dct PRIMARY KEY (cd_dct);


--
-- TOC entry 5793 (class 2606 OID 829731)
-- Name: pk_emc; Type: CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_emc
    ADD CONSTRAINT pk_emc PRIMARY KEY (cd_emc);


SET search_path = sc_cnt, pg_catalog;

--
-- TOC entry 5846 (class 2606 OID 829733)
-- Name: PK_TLC; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tlc
    ADD CONSTRAINT "PK_TLC" PRIMARY KEY (cd_tlc);


--
-- TOC entry 5802 (class 2606 OID 829735)
-- Name: pk_cnt; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_cnt
    ADD CONSTRAINT pk_cnt PRIMARY KEY (cd_cnt);


--
-- TOC entry 5804 (class 2606 OID 829737)
-- Name: pk_gcn; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_gcn
    ADD CONSTRAINT pk_gcn PRIMARY KEY (cd_gcn);


--
-- TOC entry 5811 (class 2606 OID 829739)
-- Name: pk_lcn; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lcn
    ADD CONSTRAINT pk_lcn PRIMARY KEY (cd_lcn);


--
-- TOC entry 5814 (class 2606 OID 829743)
-- Name: pk_lcn_exc; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lcn_exc
    ADD CONSTRAINT pk_lcn_exc PRIMARY KEY (cd_lcn);


--
-- TOC entry 5816 (class 2606 OID 829745)
-- Name: pk_lpd; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lpd
    ADD CONSTRAINT pk_lpd PRIMARY KEY (cd_lpd);


--
-- TOC entry 5822 (class 2606 OID 829747)
-- Name: pk_pcn; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_pcn
    ADD CONSTRAINT pk_pcn PRIMARY KEY (cd_pcn);


--
-- TOC entry 5824 (class 2606 OID 829749)
-- Name: pk_scn; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_scn
    ADD CONSTRAINT pk_scn PRIMARY KEY (cd_scn);


--
-- TOC entry 5831 (class 2606 OID 829751)
-- Name: pk_sds; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_sds
    ADD CONSTRAINT pk_sds PRIMARY KEY (cd_sds);


--
-- TOC entry 5835 (class 2606 OID 829753)
-- Name: pk_sgc; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_sgc
    ADD CONSTRAINT pk_sgc PRIMARY KEY (cd_sgc);


--
-- TOC entry 5837 (class 2606 OID 829755)
-- Name: pk_sst; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_sst
    ADD CONSTRAINT pk_sst PRIMARY KEY (cd_sst);


--
-- TOC entry 5839 (class 2606 OID 829757)
-- Name: pk_tbc; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tbc
    ADD CONSTRAINT pk_tbc PRIMARY KEY (cd_tbc);


--
-- TOC entry 5842 (class 2606 OID 829759)
-- Name: pk_tbc_cnt; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tbc_cnt
    ADD CONSTRAINT pk_tbc_cnt PRIMARY KEY (cd_tbc_cnt);


--
-- TOC entry 5844 (class 2606 OID 829761)
-- Name: pk_tcn; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tcn
    ADD CONSTRAINT pk_tcn PRIMARY KEY (cd_tcn);


--
-- TOC entry 5848 (class 2606 OID 829763)
-- Name: pk_tsr; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tsr
    ADD CONSTRAINT pk_tsr PRIMARY KEY (cd_tsr);


--
-- TOC entry 5833 (class 2606 OID 829765)
-- Name: uk_dt_sds_cd_scn; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_sds
    ADD CONSTRAINT uk_dt_sds_cd_scn UNIQUE (dt_sds, cd_scn);


--
-- TOC entry 5818 (class 2606 OID 829767)
-- Name: uk_lpd_dbt_crd_tlc; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lpd
    ADD CONSTRAINT uk_lpd_dbt_crd_tlc UNIQUE (cd_cnt_dbt_lpd, cd_cnt_crd_lpd, cd_tlc);


--
-- TOC entry 5820 (class 2606 OID 829769)
-- Name: uk_lpd_ds; Type: CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lpd
    ADD CONSTRAINT uk_lpd_ds UNIQUE (ds_lpd);


SET search_path = sc_crr, pg_catalog;

--
-- TOC entry 5541 (class 2606 OID 829771)
-- Name: pk_log_bairro; Type: CONSTRAINT; Schema: sc_crr; Owner: scan
--

ALTER TABLE ONLY log_bairro
    ADD CONSTRAINT pk_log_bairro PRIMARY KEY (bai_nu_sequencial);


--
-- TOC entry 5543 (class 2606 OID 829773)
-- Name: pk_log_localidade; Type: CONSTRAINT; Schema: sc_crr; Owner: scan
--

ALTER TABLE ONLY log_localidade
    ADD CONSTRAINT pk_log_localidade PRIMARY KEY (loc_nu_sequencial);


--
-- TOC entry 5548 (class 2606 OID 829775)
-- Name: pk_log_logradouro; Type: CONSTRAINT; Schema: sc_crr; Owner: scan
--

ALTER TABLE ONLY log_logradouro
    ADD CONSTRAINT pk_log_logradouro PRIMARY KEY (log_nu_sequencial);


SET search_path = sc_ctb, pg_catalog;

--
-- TOC entry 5570 (class 2606 OID 829777)
-- Name: pk_aec; Type: CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_aec
    ADD CONSTRAINT pk_aec PRIMARY KEY (cd_aec);


--
-- TOC entry 6440 (class 2606 OID 938432)
-- Name: pk_arq_ctb; Type: CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_arq_ctb
    ADD CONSTRAINT pk_arq_ctb PRIMARY KEY (cd_arq_ctb);


--
-- TOC entry 5850 (class 2606 OID 829779)
-- Name: pk_cte; Type: CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_cte
    ADD CONSTRAINT pk_cte PRIMARY KEY (cd_cte);


--
-- TOC entry 5852 (class 2606 OID 829781)
-- Name: pk_daec; Type: CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_daec
    ADD CONSTRAINT pk_daec PRIMARY KEY (cd_daec);


--
-- TOC entry 5574 (class 2606 OID 829783)
-- Name: pk_daec_cpl; Type: CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_daec_cpl
    ADD CONSTRAINT pk_daec_cpl PRIMARY KEY (cd_daec_cpl);


--
-- TOC entry 5577 (class 2606 OID 829785)
-- Name: pk_daec_lcn; Type: CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_daec_lcn
    ADD CONSTRAINT pk_daec_lcn PRIMARY KEY (cd_daec_lcn);


--
-- TOC entry 5854 (class 2606 OID 829787)
-- Name: pk_evt; Type: CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_evt
    ADD CONSTRAINT pk_evt PRIMARY KEY (cd_evt);


--
-- TOC entry 5858 (class 2606 OID 829789)
-- Name: pk_ext_lcn; Type: CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_ext_lcn2
    ADD CONSTRAINT pk_ext_lcn PRIMARY KEY (cd_ext_lcn);


--
-- TOC entry 6517 (class 2606 OID 1077249)
-- Name: pk_ext_lcn2; Type: CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_ext_lcn
    ADD CONSTRAINT pk_ext_lcn2 PRIMARY KEY (cd_ext_lcn);


--
-- TOC entry 5860 (class 2606 OID 829791)
-- Name: pk_tve; Type: CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_tve
    ADD CONSTRAINT pk_tve PRIMARY KEY (cd_tve);


SET search_path = sc_dgt, pg_catalog;

--
-- TOC entry 6449 (class 2606 OID 966400)
-- Name: pk_arq; Type: CONSTRAINT; Schema: sc_dgt; Owner: scan
--

ALTER TABLE ONLY tbl_arq
    ADD CONSTRAINT pk_arq PRIMARY KEY (cd_arq);


--
-- TOC entry 6444 (class 2606 OID 966393)
-- Name: pk_tar; Type: CONSTRAINT; Schema: sc_dgt; Owner: scan
--

ALTER TABLE ONLY tbl_tar
    ADD CONSTRAINT pk_tar PRIMARY KEY (cd_tar);


--
-- TOC entry 6451 (class 2606 OID 966412)
-- Name: pk_var; Type: CONSTRAINT; Schema: sc_dgt; Owner: scan
--

ALTER TABLE ONLY tbl_var
    ADD CONSTRAINT pk_var PRIMARY KEY (cd_var);


SET search_path = sc_dsp, pg_catalog;

--
-- TOC entry 5862 (class 2606 OID 829793)
-- Name: pk_dsp; Type: CONSTRAINT; Schema: sc_dsp; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT pk_dsp PRIMARY KEY (cd_dsp);


--
-- TOC entry 5864 (class 2606 OID 829795)
-- Name: pk_fdv; Type: CONSTRAINT; Schema: sc_dsp; Owner: scan
--

ALTER TABLE ONLY tbl_fvd
    ADD CONSTRAINT pk_fdv PRIMARY KEY (cd_fvd);


--
-- TOC entry 6338 (class 2606 OID 871435)
-- Name: pk_mdp; Type: CONSTRAINT; Schema: sc_dsp; Owner: scan
--

ALTER TABLE ONLY tbl_mdp
    ADD CONSTRAINT pk_mdp PRIMARY KEY (cd_mdp);


--
-- TOC entry 5866 (class 2606 OID 829797)
-- Name: pk_vds; Type: CONSTRAINT; Schema: sc_dsp; Owner: scan
--

ALTER TABLE ONLY tbl_vds
    ADD CONSTRAINT pk_vds PRIMARY KEY (cd_vds);


SET search_path = sc_dwn, pg_catalog;

--
-- TOC entry 5868 (class 2606 OID 829799)
-- Name: pk_dwn; Type: CONSTRAINT; Schema: sc_dwn; Owner: scan
--

ALTER TABLE ONLY tbl_dwa
    ADD CONSTRAINT pk_dwn PRIMARY KEY (cd_dwa);


--
-- TOC entry 5870 (class 2606 OID 829801)
-- Name: pk_tda; Type: CONSTRAINT; Schema: sc_dwn; Owner: scan
--

ALTER TABLE ONLY tbl_tda
    ADD CONSTRAINT pk_tda PRIMARY KEY (cd_tda);


SET search_path = sc_exp, pg_catalog;

--
-- TOC entry 6521 (class 2606 OID 1348526)
-- Name: pk_drqa; Type: CONSTRAINT; Schema: sc_exp; Owner: scan
--

ALTER TABLE ONLY sc_rds_tbl_drqa
    ADD CONSTRAINT pk_drqa PRIMARY KEY (cd_drqa);


--
-- TOC entry 6523 (class 2606 OID 1611258)
-- Name: pk_lgt; Type: CONSTRAINT; Schema: sc_exp; Owner: scan
--

ALTER TABLE ONLY sc_pgc_tbl_lgt
    ADD CONSTRAINT pk_lgt PRIMARY KEY (cd_lgt);


--
-- TOC entry 6519 (class 2606 OID 1085839)
-- Name: pk_rqa; Type: CONSTRAINT; Schema: sc_exp; Owner: scan
--

ALTER TABLE ONLY sc_rds_tbl_rqa
    ADD CONSTRAINT pk_rqa PRIMARY KEY (cd_rqa);


SET search_path = sc_fcr, pg_catalog;

--
-- TOC entry 5873 (class 2606 OID 829803)
-- Name: pk_fcr; Type: CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_fcr
    ADD CONSTRAINT pk_fcr PRIMARY KEY (cd_fcr);


--
-- TOC entry 6469 (class 2606 OID 989091)
-- Name: pk_fcr_exc; Type: CONSTRAINT; Schema: sc_fcr; Owner: postgres
--

ALTER TABLE ONLY tbl_fcr_exc
    ADD CONSTRAINT pk_fcr_exc PRIMARY KEY (cd_fcr);


--
-- TOC entry 5876 (class 2606 OID 829805)
-- Name: pk_fcr_tlt; Type: CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_fcr_tlt
    ADD CONSTRAINT pk_fcr_tlt PRIMARY KEY (cd_fcr, cd_tlt);


--
-- TOC entry 5878 (class 2606 OID 829807)
-- Name: pk_fcr_top; Type: CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_fcr_top
    ADD CONSTRAINT pk_fcr_top PRIMARY KEY (cd_fcr, cd_top);


--
-- TOC entry 5888 (class 2606 OID 829809)
-- Name: pk_pf_prc; Type: CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_pfc_prc
    ADD CONSTRAINT pk_pf_prc PRIMARY KEY (cd_pfc, cd_prc);


--
-- TOC entry 5885 (class 2606 OID 829811)
-- Name: pk_pfc; Type: CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_pfc
    ADD CONSTRAINT pk_pfc PRIMARY KEY (cd_pfc);


--
-- TOC entry 5890 (class 2606 OID 829813)
-- Name: pk_pfc_tlt; Type: CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_pfc_tlt
    ADD CONSTRAINT pk_pfc_tlt PRIMARY KEY (cd_pfc, cd_tlt);


--
-- TOC entry 5896 (class 2606 OID 829815)
-- Name: pk_prc; Type: CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_prc
    ADD CONSTRAINT pk_prc PRIMARY KEY (cd_prc);


--
-- TOC entry 5898 (class 2606 OID 829817)
-- Name: pk_tfc; Type: CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_tfc
    ADD CONSTRAINT pk_tfc PRIMARY KEY (cd_tfc);


--
-- TOC entry 5900 (class 2606 OID 829819)
-- Name: pk_tpc; Type: CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_tpc
    ADD CONSTRAINT pk_tpc PRIMARY KEY (cd_tpc);


SET search_path = sc_fep, pg_catalog;

--
-- TOC entry 5917 (class 2606 OID 829821)
-- Name: pk_apf; Type: CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_apf
    ADD CONSTRAINT pk_apf PRIMARY KEY (cd_apf);


--
-- TOC entry 5919 (class 2606 OID 829823)
-- Name: tbl_fep_pkey; Type: CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_fep
    ADD CONSTRAINT tbl_fep_pkey PRIMARY KEY (cd_fep);


--
-- TOC entry 5921 (class 2606 OID 829825)
-- Name: tbl_fep_sfe_pkey; Type: CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_fep_sfe
    ADD CONSTRAINT tbl_fep_sfe_pkey PRIMARY KEY (cd_fep_sfe);


--
-- TOC entry 5923 (class 2606 OID 829827)
-- Name: tbl_pfe_pkey; Type: CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_pfe
    ADD CONSTRAINT tbl_pfe_pkey PRIMARY KEY (cd_pfe);


--
-- TOC entry 5925 (class 2606 OID 829829)
-- Name: tbl_sfe_pkey; Type: CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_sfe
    ADD CONSTRAINT tbl_sfe_pkey PRIMARY KEY (cd_sfe);


--
-- TOC entry 5927 (class 2606 OID 829831)
-- Name: tbl_tpe_pkey; Type: CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_tpe
    ADD CONSTRAINT tbl_tpe_pkey PRIMARY KEY (cd_tpe);


SET search_path = sc_fin, pg_catalog;

--
-- TOC entry 5939 (class 2606 OID 829833)
-- Name: fk_drr_hfe; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_drr_hfe
    ADD CONSTRAINT fk_drr_hfe PRIMARY KEY (cd_drr_hfe);


--
-- TOC entry 5929 (class 2606 OID 829835)
-- Name: pk_alr; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_alr
    ADD CONSTRAINT pk_alr PRIMARY KEY (cd_alr);


--
-- TOC entry 5931 (class 2606 OID 829837)
-- Name: pk_bla; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_bla
    ADD CONSTRAINT pk_bla PRIMARY KEY (cd_bla);


--
-- TOC entry 5933 (class 2606 OID 829839)
-- Name: pk_bnc; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_bnc
    ADD CONSTRAINT pk_bnc PRIMARY KEY (cd_bnc);


--
-- TOC entry 5935 (class 2606 OID 829841)
-- Name: pk_cd_did; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_did
    ADD CONSTRAINT pk_cd_did PRIMARY KEY (cd_did);


--
-- TOC entry 5943 (class 2606 OID 829843)
-- Name: pk_cd_idp; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_idp
    ADD CONSTRAINT pk_cd_idp PRIMARY KEY (cd_idp);


--
-- TOC entry 5568 (class 2606 OID 829845)
-- Name: pk_cd_tec; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_tec
    ADD CONSTRAINT pk_cd_tec PRIMARY KEY (cd_tec);


--
-- TOC entry 5949 (class 2606 OID 829847)
-- Name: pk_cd_ttc; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_ttc
    ADD CONSTRAINT pk_cd_ttc PRIMARY KEY (cd_ttc);


--
-- TOC entry 5558 (class 2606 OID 829849)
-- Name: pk_crr; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_ccr
    ADD CONSTRAINT pk_crr PRIMARY KEY (cd_ccr);


--
-- TOC entry 5937 (class 2606 OID 829851)
-- Name: pk_drr; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_drr
    ADD CONSTRAINT pk_drr PRIMARY KEY (cd_drr);


--
-- TOC entry 5941 (class 2606 OID 829853)
-- Name: pk_hadr; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_hadr
    ADD CONSTRAINT pk_hadr PRIMARY KEY (cd_hadr);


--
-- TOC entry 5945 (class 2606 OID 829855)
-- Name: pk_rrc; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_rrc
    ADD CONSTRAINT pk_rrc PRIMARY KEY (cd_rrc);


--
-- TOC entry 5947 (class 2606 OID 829857)
-- Name: pk_trc; Type: CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_trc
    ADD CONSTRAINT pk_trc PRIMARY KEY (cd_trc);


SET search_path = sc_fsc, pg_catalog;

--
-- TOC entry 5951 (class 2606 OID 829859)
-- Name: pk_cnae; Type: CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_cnae
    ADD CONSTRAINT pk_cnae PRIMARY KEY (cd_cnae, cd_itm_lst_cnae);


--
-- TOC entry 5966 (class 2606 OID 829861)
-- Name: pk_cnpj_psr; Type: CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_psr
    ADD CONSTRAINT pk_cnpj_psr PRIMARY KEY (cnpj_psr);


--
-- TOC entry 5975 (class 2606 OID 829863)
-- Name: pk_cpj_tsr; Type: CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_tsr
    ADD CONSTRAINT pk_cpj_tsr PRIMARY KEY (cpj_tsr);


--
-- TOC entry 5955 (class 2606 OID 829865)
-- Name: pk_ibge; Type: CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_ibge
    ADD CONSTRAINT pk_ibge PRIMARY KEY (cd_ibge);


--
-- TOC entry 5957 (class 2606 OID 829867)
-- Name: pk_isr; Type: CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_isr
    ADD CONSTRAINT pk_isr PRIMARY KEY (cd_isr);


--
-- TOC entry 5959 (class 2606 OID 829869)
-- Name: pk_lcm; Type: CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_lcm
    ADD CONSTRAINT pk_lcm PRIMARY KEY (cd_lcm);


--
-- TOC entry 5961 (class 2606 OID 829871)
-- Name: pk_lte; Type: CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_lte
    ADD CONSTRAINT pk_lte PRIMARY KEY (cd_lte);


--
-- TOC entry 5963 (class 2606 OID 829873)
-- Name: pk_mnc_grd; Type: CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_org_grd
    ADD CONSTRAINT pk_mnc_grd PRIMARY KEY (cd_mnc_grd);


--
-- TOC entry 5953 (class 2606 OID 829875)
-- Name: pk_obr_dec; Type: CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_dec
    ADD CONSTRAINT pk_obr_dec PRIMARY KEY (cd_obr_dec);


--
-- TOC entry 5969 (class 2606 OID 829877)
-- Name: pk_rps; Type: CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_rps
    ADD CONSTRAINT pk_rps PRIMARY KEY (cd_rps);


--
-- TOC entry 5972 (class 2606 OID 829879)
-- Name: pk_srv; Type: CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_srv
    ADD CONSTRAINT pk_srv PRIMARY KEY (cd_srv);


SET search_path = sc_grl, pg_catalog;

--
-- TOC entry 5977 (class 2606 OID 892161)
-- Name: fk_msg; Type: CONSTRAINT; Schema: sc_grl; Owner: scan
--

ALTER TABLE ONLY tbl_msg
    ADD CONSTRAINT fk_msg PRIMARY KEY (cd_msg);


SET search_path = sc_hlt, pg_catalog;

--
-- TOC entry 6340 (class 2606 OID 873259)
-- Name: pk_ahl; Type: CONSTRAINT; Schema: sc_hlt; Owner: scan
--

ALTER TABLE ONLY tbl_ahl
    ADD CONSTRAINT pk_ahl PRIMARY KEY (cd_ahl);


--
-- TOC entry 6342 (class 2606 OID 873264)
-- Name: pk_dhl; Type: CONSTRAINT; Schema: sc_hlt; Owner: scan
--

ALTER TABLE ONLY tbl_dhl
    ADD CONSTRAINT pk_dhl PRIMARY KEY (cd_dhl);


--
-- TOC entry 6344 (class 2606 OID 873269)
-- Name: pk_dhl_arq; Type: CONSTRAINT; Schema: sc_hlt; Owner: scan
--

ALTER TABLE ONLY tbl_dhl_arq
    ADD CONSTRAINT pk_dhl_arq PRIMARY KEY (cd_dhl_arq);


--
-- TOC entry 6346 (class 2606 OID 873276)
-- Name: pk_hlt; Type: CONSTRAINT; Schema: sc_hlt; Owner: scan
--

ALTER TABLE ONLY tbl_hlt
    ADD CONSTRAINT pk_hlt PRIMARY KEY (cd_hlt);


--
-- TOC entry 6348 (class 2606 OID 873281)
-- Name: pk_hlt_arq; Type: CONSTRAINT; Schema: sc_hlt; Owner: scan
--

ALTER TABLE ONLY tbl_hlt_arq
    ADD CONSTRAINT pk_hlt_arq PRIMARY KEY (cd_hlt_arq);


SET search_path = sc_ind, pg_catalog;

--
-- TOC entry 5979 (class 2606 OID 829883)
-- Name: pk_alt_ind; Type: CONSTRAINT; Schema: sc_ind; Owner: scan
--

ALTER TABLE ONLY tbl_alt_ind
    ADD CONSTRAINT pk_alt_ind PRIMARY KEY (cd_alt_ind);


SET search_path = sc_iso8583, pg_catalog;

--
-- TOC entry 6505 (class 2606 OID 1010974)
-- Name: pk_msg8583; Type: CONSTRAINT; Schema: sc_iso8583; Owner: scan
--

ALTER TABLE ONLY tbl_msg8583
    ADD CONSTRAINT pk_msg8583 PRIMARY KEY (cd_msg);


--
-- TOC entry 6507 (class 2606 OID 1010984)
-- Name: pk_wkey; Type: CONSTRAINT; Schema: sc_iso8583; Owner: scan
--

ALTER TABLE ONLY tbl_wkey
    ADD CONSTRAINT pk_wkey PRIMARY KEY (cd_wkey);


SET search_path = sc_job, pg_catalog;

--
-- TOC entry 5981 (class 2606 OID 829885)
-- Name: PK_JOB; Type: CONSTRAINT; Schema: sc_job; Owner: scan
--

ALTER TABLE ONLY tbl_job
    ADD CONSTRAINT "PK_JOB" PRIMARY KEY (cd_job);


--
-- TOC entry 5985 (class 2606 OID 829887)
-- Name: PK_LJB; Type: CONSTRAINT; Schema: sc_job; Owner: scan
--

ALTER TABLE ONLY tbl_ljb
    ADD CONSTRAINT "PK_LJB" PRIMARY KEY (cd_ljb);


--
-- TOC entry 6461 (class 2606 OID 975763)
-- Name: PK_LPJ; Type: CONSTRAINT; Schema: sc_job; Owner: scan
--

ALTER TABLE ONLY tbl_lpj
    ADD CONSTRAINT "PK_LPJ" PRIMARY KEY (cd_lpj);


--
-- TOC entry 5983 (class 2606 OID 1067637)
-- Name: UK_NR_ORD_TP_JOB; Type: CONSTRAINT; Schema: sc_job; Owner: scan
--

ALTER TABLE ONLY tbl_job
    ADD CONSTRAINT "UK_NR_ORD_TP_JOB" UNIQUE (tp_job, nr_ord_job);


--
-- TOC entry 6459 (class 2606 OID 975745)
-- Name: pk_ljb; Type: CONSTRAINT; Schema: sc_job; Owner: scan
--

ALTER TABLE ONLY tbl_plj
    ADD CONSTRAINT pk_ljb PRIMARY KEY (cd_plj);


--
-- TOC entry 6413 (class 2606 OID 893193)
-- Name: pk_teste; Type: CONSTRAINT; Schema: sc_job; Owner: postgres
--

ALTER TABLE ONLY tbl_teste
    ADD CONSTRAINT pk_teste PRIMARY KEY (cd_teste);


SET search_path = sc_meta, pg_catalog;

--
-- TOC entry 5987 (class 2606 OID 829891)
-- Name: pk_2015; Type: CONSTRAINT; Schema: sc_meta; Owner: scan
--

ALTER TABLE ONLY tbl_2015
    ADD CONSTRAINT pk_2015 PRIMARY KEY (codigo);


--
-- TOC entry 5989 (class 2606 OID 829893)
-- Name: uq_2015; Type: CONSTRAINT; Schema: sc_meta; Owner: scan
--

ALTER TABLE ONLY tbl_2015
    ADD CONSTRAINT uq_2015 UNIQUE (mes_referencia, tipo, ativo);


SET search_path = sc_mgr, pg_catalog;

--
-- TOC entry 5997 (class 2606 OID 829895)
-- Name: pk_crt; Type: CONSTRAINT; Schema: sc_mgr; Owner: scan
--

ALTER TABLE ONLY tbl_lmt
    ADD CONSTRAINT pk_crt PRIMARY KEY (cd_crt);


--
-- TOC entry 5993 (class 2606 OID 829897)
-- Name: pk_dvd; Type: CONSTRAINT; Schema: sc_mgr; Owner: scan
--

ALTER TABLE ONLY tbl_dvd
    ADD CONSTRAINT pk_dvd PRIMARY KEY (cd_dvd);


--
-- TOC entry 6001 (class 2606 OID 829899)
-- Name: pk_pdv; Type: CONSTRAINT; Schema: sc_mgr; Owner: scan
--

ALTER TABLE ONLY tbl_pdv
    ADD CONSTRAINT pk_pdv PRIMARY KEY (cd_pdv);


--
-- TOC entry 5995 (class 2606 OID 829901)
-- Name: uk_dvd; Type: CONSTRAINT; Schema: sc_mgr; Owner: scan
--

ALTER TABLE ONLY tbl_dvd
    ADD CONSTRAINT uk_dvd UNIQUE (tp_dvd, nr_nsu_dvd);


--
-- TOC entry 5999 (class 2606 OID 829903)
-- Name: uk_lmt_crt_sc; Type: CONSTRAINT; Schema: sc_mgr; Owner: scan
--

ALTER TABLE ONLY tbl_lmt
    ADD CONSTRAINT uk_lmt_crt_sc UNIQUE (cd_crt_sc_lmt);


SET search_path = sc_mnt, pg_catalog;

--
-- TOC entry 6360 (class 2606 OID 877675)
-- Name: pk_ads; Type: CONSTRAINT; Schema: sc_mnt; Owner: scan
--

ALTER TABLE ONLY tbl_ads
    ADD CONSTRAINT pk_ads PRIMARY KEY (cd_ads);


--
-- TOC entry 6434 (class 2606 OID 927713)
-- Name: pk_arm; Type: CONSTRAINT; Schema: sc_mnt; Owner: scan
--

ALTER TABLE ONLY tbl_arm
    ADD CONSTRAINT pk_arm PRIMARY KEY (cd_arm);


--
-- TOC entry 6436 (class 2606 OID 927720)
-- Name: pk_dar; Type: CONSTRAINT; Schema: sc_mnt; Owner: scan
--

ALTER TABLE ONLY tbl_dar
    ADD CONSTRAINT pk_dar PRIMARY KEY (cd_dar);


--
-- TOC entry 6352 (class 2606 OID 875715)
-- Name: pk_mnt; Type: CONSTRAINT; Schema: sc_mnt; Owner: scan
--

ALTER TABLE ONLY tbl_mnt
    ADD CONSTRAINT pk_mnt PRIMARY KEY (cd_mnt);


--
-- TOC entry 6356 (class 2606 OID 877432)
-- Name: pk_pct; Type: CONSTRAINT; Schema: sc_mnt; Owner: scan
--

ALTER TABLE ONLY tbl_pct
    ADD CONSTRAINT pk_pct PRIMARY KEY (cd_pct);


--
-- TOC entry 6442 (class 2606 OID 954980)
-- Name: pk_rmt; Type: CONSTRAINT; Schema: sc_mnt; Owner: scan
--

ALTER TABLE ONLY tbl_rmt
    ADD CONSTRAINT pk_rmt PRIMARY KEY (cd_rmt);


--
-- TOC entry 6354 (class 2606 OID 969383)
-- Name: uk_mnt_tsc; Type: CONSTRAINT; Schema: sc_mnt; Owner: scan
--

ALTER TABLE ONLY tbl_mnt
    ADD CONSTRAINT uk_mnt_tsc UNIQUE (cd_tsc);


SET search_path = sc_mrk, pg_catalog;

--
-- TOC entry 6473 (class 2606 OID 992951)
-- Name: pk_abn; Type: CONSTRAINT; Schema: sc_mrk; Owner: scan
--

ALTER TABLE ONLY tbl_abn
    ADD CONSTRAINT pk_abn PRIMARY KEY (cd_abn);


--
-- TOC entry 6471 (class 2606 OID 992921)
-- Name: pk_bnn; Type: CONSTRAINT; Schema: sc_mrk; Owner: scan
--

ALTER TABLE ONLY tbl_bnn
    ADD CONSTRAINT pk_bnn PRIMARY KEY (cd_bnn);


SET search_path = sc_msg, pg_catalog;

--
-- TOC entry 6332 (class 2606 OID 862139)
-- Name: pk_cvm; Type: CONSTRAINT; Schema: sc_msg; Owner: scan
--

ALTER TABLE ONLY tbl_cvm
    ADD CONSTRAINT pk_cvm PRIMARY KEY (cd_cvm);


--
-- TOC entry 6003 (class 2606 OID 829905)
-- Name: pk_msg; Type: CONSTRAINT; Schema: sc_msg; Owner: scan
--

ALTER TABLE ONLY tbl_msg
    ADD CONSTRAINT pk_msg PRIMARY KEY (cd_msg);


--
-- TOC entry 6005 (class 2606 OID 829907)
-- Name: pk_tms; Type: CONSTRAINT; Schema: sc_msg; Owner: scan
--

ALTER TABLE ONLY tbl_tms
    ADD CONSTRAINT pk_tms PRIMARY KEY (cd_tms);


--
-- TOC entry 6007 (class 2606 OID 829909)
-- Name: pk_tpm; Type: CONSTRAINT; Schema: sc_msg; Owner: scan
--

ALTER TABLE ONLY tbl_tpm
    ADD CONSTRAINT pk_tpm PRIMARY KEY (cd_tpm);


SET search_path = sc_opr, pg_catalog;

--
-- TOC entry 6019 (class 2606 OID 829911)
-- Name: fk_dtv; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_dtv
    ADD CONSTRAINT fk_dtv PRIMARY KEY (cd_dtv);


--
-- TOC entry 6062 (class 2606 OID 829913)
-- Name: fk_tvt; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_tvt
    ADD CONSTRAINT fk_tvt PRIMARY KEY (cd_tvt);


--
-- TOC entry 6009 (class 2606 OID 829915)
-- Name: pk_aal; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_aal_antiga
    ADD CONSTRAINT pk_aal PRIMARY KEY (cd_aal);


--
-- TOC entry 6058 (class 2606 OID 829917)
-- Name: pk_atm_top; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_top_atm
    ADD CONSTRAINT pk_atm_top PRIMARY KEY (cd_atm, cd_top);


--
-- TOC entry 6012 (class 2606 OID 829919)
-- Name: pk_cnt_crt; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_cnt_crt
    ADD CONSTRAINT pk_cnt_crt PRIMARY KEY (cd_cnt);


--
-- TOC entry 5905 (class 2606 OID 829921)
-- Name: pk_crt; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_crt
    ADD CONSTRAINT pk_crt PRIMARY KEY (cd_crt);


--
-- TOC entry 6501 (class 2606 OID 1010408)
-- Name: pk_crt_exc; Type: CONSTRAINT; Schema: sc_opr; Owner: postgres
--

ALTER TABLE ONLY tbl_crt_exc
    ADD CONSTRAINT pk_crt_exc PRIMARY KEY (cd_crt);


--
-- TOC entry 6031 (class 2606 OID 829923)
-- Name: pk_crt_tlt; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_lmt
    ADD CONSTRAINT pk_crt_tlt PRIMARY KEY (cd_crt, cd_tlt);


--
-- TOC entry 6014 (class 2606 OID 829927)
-- Name: pk_ctc; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_ctc
    ADD CONSTRAINT pk_ctc PRIMARY KEY (cd_ctc);


--
-- TOC entry 6017 (class 2606 OID 829929)
-- Name: pk_dos; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_dos
    ADD CONSTRAINT pk_dos PRIMARY KEY (cd_dos);


--
-- TOC entry 6358 (class 2606 OID 877668)
-- Name: pk_dsp; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT pk_dsp PRIMARY KEY (cd_dsp);


--
-- TOC entry 6021 (class 2606 OID 829931)
-- Name: pk_eop; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_eop
    ADD CONSTRAINT pk_eop PRIMARY KEY (cd_opr);


--
-- TOC entry 6023 (class 2606 OID 829933)
-- Name: pk_exc; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_exc
    ADD CONSTRAINT pk_exc PRIMARY KEY (cd_exc);


--
-- TOC entry 6027 (class 2606 OID 829935)
-- Name: pk_hlm; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_hlm
    ADD CONSTRAINT pk_hlm PRIMARY KEY (cd_hlm);


--
-- TOC entry 6035 (class 2606 OID 829937)
-- Name: pk_ocr; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_ocr
    ADD CONSTRAINT pk_ocr PRIMARY KEY (cd_ocr);


--
-- TOC entry 5909 (class 2606 OID 829939)
-- Name: pk_opr; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_opr
    ADD CONSTRAINT pk_opr PRIMARY KEY (cd_opr);


--
-- TOC entry 6037 (class 2606 OID 829946)
-- Name: pk_opr_pfc; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_opr_pfc
    ADD CONSTRAINT pk_opr_pfc PRIMARY KEY (cd_opr, cd_pfc);


--
-- TOC entry 6039 (class 2606 OID 829948)
-- Name: pk_opr_pfc2; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_opr_pfc2
    ADD CONSTRAINT pk_opr_pfc2 PRIMARY KEY (cd_opr, cd_pfc);


--
-- TOC entry 6041 (class 2606 OID 829950)
-- Name: pk_opr_rst; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_opr_rst
    ADD CONSTRAINT pk_opr_rst PRIMARY KEY (cd_opr);


--
-- TOC entry 6043 (class 2606 OID 829953)
-- Name: pk_opr_rst2; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_opr_rst2
    ADD CONSTRAINT pk_opr_rst2 PRIMARY KEY (cd_opr);


--
-- TOC entry 5913 (class 2606 OID 829955)
-- Name: pk_pls; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_pls
    ADD CONSTRAINT pk_pls PRIMARY KEY (cd_pls);


--
-- TOC entry 6045 (class 2606 OID 829957)
-- Name: pk_rst; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_rst
    ADD CONSTRAINT pk_rst PRIMARY KEY (cd_rst);


--
-- TOC entry 6047 (class 2606 OID 829959)
-- Name: pk_sqm; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_sqm
    ADD CONSTRAINT pk_sqm PRIMARY KEY (cd_sqm);


--
-- TOC entry 6049 (class 2606 OID 829961)
-- Name: pk_tbl; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_tbl
    ADD CONSTRAINT pk_tbl PRIMARY KEY (cd_tbl);


--
-- TOC entry 6051 (class 2606 OID 829963)
-- Name: pk_tlt; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_tlt
    ADD CONSTRAINT pk_tlt PRIMARY KEY (cd_tlt);


--
-- TOC entry 6055 (class 2606 OID 829965)
-- Name: pk_toc; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_toc
    ADD CONSTRAINT pk_toc PRIMARY KEY (cd_toc);


--
-- TOC entry 5915 (class 2606 OID 829967)
-- Name: pk_top; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_top
    ADD CONSTRAINT pk_top PRIMARY KEY (cd_top);


--
-- TOC entry 6060 (class 2606 OID 829969)
-- Name: pk_top_tlt; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_top_tlt
    ADD CONSTRAINT pk_top_tlt PRIMARY KEY (cd_top_tlt);


--
-- TOC entry 6053 (class 2606 OID 829971)
-- Name: uk_tlt_nr_pri; Type: CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_tlt
    ADD CONSTRAINT uk_tlt_nr_pri UNIQUE (nr_pri_tlt);


SET search_path = sc_opr_exp, pg_catalog;

--
-- TOC entry 6511 (class 2606 OID 1040621)
-- Name: pk_dos_exp; Type: CONSTRAINT; Schema: sc_opr_exp; Owner: scan
--

ALTER TABLE ONLY tbl_dos
    ADD CONSTRAINT pk_dos_exp PRIMARY KEY (cd_dos);


SET search_path = sc_pbl, pg_catalog;

--
-- TOC entry 6064 (class 2606 OID 829973)
-- Name: pk_frd; Type: CONSTRAINT; Schema: sc_pbl; Owner: scan
--

ALTER TABLE ONLY tbl_frd
    ADD CONSTRAINT pk_frd PRIMARY KEY (dt_frd);


--
-- TOC entry 6066 (class 2606 OID 829975)
-- Name: pk_ftp; Type: CONSTRAINT; Schema: sc_pbl; Owner: scan
--

ALTER TABLE ONLY tbl_ftp
    ADD CONSTRAINT pk_ftp PRIMARY KEY (cd_ftp);


--
-- TOC entry 6070 (class 2606 OID 829977)
-- Name: pk_upl; Type: CONSTRAINT; Schema: sc_pbl; Owner: scan
--

ALTER TABLE ONLY tbl_upl
    ADD CONSTRAINT pk_upl PRIMARY KEY (cd_upl);


--
-- TOC entry 6068 (class 2606 OID 829979)
-- Name: uq_nm_ftp; Type: CONSTRAINT; Schema: sc_pbl; Owner: scan
--

ALTER TABLE ONLY tbl_ftp
    ADD CONSTRAINT uq_nm_ftp UNIQUE (nm_ftp);


SET search_path = sc_pgc, pg_catalog;

SET default_tablespace = ts_scan_i;

--
-- TOC entry 6394 (class 2606 OID 889061)
-- Name: pk_cnc; Type: CONSTRAINT; Schema: sc_pgc; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_cnc
    ADD CONSTRAINT pk_cnc PRIMARY KEY (cd_cnc);


--
-- TOC entry 6388 (class 2606 OID 889035)
-- Name: pk_crr; Type: CONSTRAINT; Schema: sc_pgc; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_crr
    ADD CONSTRAINT pk_crr PRIMARY KEY (cd_crr);


SET default_tablespace = '';

--
-- TOC entry 6487 (class 2606 OID 1004311)
-- Name: pk_lgt; Type: CONSTRAINT; Schema: sc_pgc; Owner: scan
--

ALTER TABLE ONLY tbl_lgt
    ADD CONSTRAINT pk_lgt PRIMARY KEY (cd_lgt);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6509 (class 2606 OID 1034216)
-- Name: pk_pga; Type: CONSTRAINT; Schema: sc_pgc; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_pga
    ADD CONSTRAINT pk_pga PRIMARY KEY (cd_pga);


--
-- TOC entry 6390 (class 2606 OID 889042)
-- Name: pk_pgt; Type: CONSTRAINT; Schema: sc_pgc; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_pgt
    ADD CONSTRAINT pk_pgt PRIMARY KEY (cd_pgt);


--
-- TOC entry 6392 (class 2606 OID 889054)
-- Name: pk_sgt; Type: CONSTRAINT; Schema: sc_pgc; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_sgt
    ADD CONSTRAINT pk_sgt PRIMARY KEY (cd_sgt);


SET search_path = sc_ppr, pg_catalog;

SET default_tablespace = '';

--
-- TOC entry 6493 (class 2606 OID 1007405)
-- Name: contrato_key; Type: CONSTRAINT; Schema: sc_ppr; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_ppr
    ADD CONSTRAINT contrato_key UNIQUE (cd_emp, cd_fem);


--
-- TOC entry 6495 (class 2606 OID 1007356)
-- Name: pk_ctr_ppr; Type: CONSTRAINT; Schema: sc_ppr; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_ppr
    ADD CONSTRAINT pk_ctr_ppr PRIMARY KEY (cd_ctr_ppr);


--
-- TOC entry 6497 (class 2606 OID 1007376)
-- Name: pk_dppr; Type: CONSTRAINT; Schema: sc_ppr; Owner: scan
--

ALTER TABLE ONLY tbl_dppr
    ADD CONSTRAINT pk_dppr PRIMARY KEY (cd_dppr);


--
-- TOC entry 6491 (class 2606 OID 1007295)
-- Name: pk_ppr; Type: CONSTRAINT; Schema: sc_ppr; Owner: scan
--

ALTER TABLE ONLY tbl_ppr
    ADD CONSTRAINT pk_ppr PRIMARY KEY (cd_ppr);


SET search_path = sc_rcg, pg_catalog;

--
-- TOC entry 6072 (class 2606 OID 829981)
-- Name: pk_opr; Type: CONSTRAINT; Schema: sc_rcg; Owner: scan
--

ALTER TABLE ONLY tbl_opr
    ADD CONSTRAINT pk_opr PRIMARY KEY (cd_opr);


--
-- TOC entry 6076 (class 2606 OID 829983)
-- Name: pk_prd; Type: CONSTRAINT; Schema: sc_rcg; Owner: scan
--

ALTER TABLE ONLY tbl_prd
    ADD CONSTRAINT pk_prd PRIMARY KEY (cd_prd);


--
-- TOC entry 6078 (class 2606 OID 829985)
-- Name: pk_rcg; Type: CONSTRAINT; Schema: sc_rcg; Owner: scan
--

ALTER TABLE ONLY tbl_rcg
    ADD CONSTRAINT pk_rcg PRIMARY KEY (cd_rcg);


--
-- TOC entry 6074 (class 2606 OID 1666520)
-- Name: uk_id_opr_celcoin; Type: CONSTRAINT; Schema: sc_rcg; Owner: scan
--

ALTER TABLE ONLY tbl_opr
    ADD CONSTRAINT uk_id_opr_celcoin UNIQUE (id_opr_celcoin);


SET search_path = sc_rct, pg_catalog;

--
-- TOC entry 6090 (class 2606 OID 829987)
-- Name: cd_trt_top; Type: CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_trt_top
    ADD CONSTRAINT cd_trt_top PRIMARY KEY (cd_trt_top);


--
-- TOC entry 6080 (class 2606 OID 829989)
-- Name: pk_ctr; Type: CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_mtp_ctr
    ADD CONSTRAINT pk_ctr PRIMARY KEY (nr_ctr_new);


--
-- TOC entry 6082 (class 2606 OID 829991)
-- Name: pk_rct; Type: CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_rct
    ADD CONSTRAINT pk_rct PRIMARY KEY (cd_rct);


--
-- TOC entry 6084 (class 2606 OID 829993)
-- Name: pk_trt; Type: CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_trt
    ADD CONSTRAINT pk_trt PRIMARY KEY (cd_trt);


--
-- TOC entry 6086 (class 2606 OID 829995)
-- Name: pk_trt_sfe; Type: CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_trt_sfe
    ADD CONSTRAINT pk_trt_sfe PRIMARY KEY (cd_trt_sfe);


--
-- TOC entry 6088 (class 2606 OID 829997)
-- Name: pk_trt_srv; Type: CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_trt_srv
    ADD CONSTRAINT pk_trt_srv PRIMARY KEY (cd_trt_srv);


--
-- TOC entry 6092 (class 2606 OID 829999)
-- Name: pk_vrc; Type: CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_vrc
    ADD CONSTRAINT pk_vrc PRIMARY KEY (cd_vrc);


SET search_path = sc_rdc, pg_catalog;

--
-- TOC entry 6546 (class 2606 OID 1633044)
-- Name: pk_ahp; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_ahp
    ADD CONSTRAINT pk_ahp PRIMARY KEY (cd_ahp);


--
-- TOC entry 6548 (class 2606 OID 1633049)
-- Name: pk_dah; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_dah
    ADD CONSTRAINT pk_dah PRIMARY KEY (cd_dah);


--
-- TOC entry 6094 (class 2606 OID 830001)
-- Name: pk_eqp; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_eqp
    ADD CONSTRAINT pk_eqp PRIMARY KEY (cd_eqp);


--
-- TOC entry 6096 (class 2606 OID 830003)
-- Name: pk_etb; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_etb
    ADD CONSTRAINT pk_etb PRIMARY KEY (cd_etb);


--
-- TOC entry 6100 (class 2606 OID 830005)
-- Name: pk_fet; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_fet
    ADD CONSTRAINT pk_fet PRIMARY KEY (cd_fet);


--
-- TOC entry 6558 (class 2606 OID 1639038)
-- Name: pk_oet; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_oet
    ADD CONSTRAINT pk_oet PRIMARY KEY (cd_oet);


--
-- TOC entry 6105 (class 2606 OID 830007)
-- Name: pk_pet; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_pet
    ADD CONSTRAINT pk_pet PRIMARY KEY (cd_pet);


--
-- TOC entry 6107 (class 2606 OID 830009)
-- Name: pk_rae; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_rae
    ADD CONSTRAINT pk_rae PRIMARY KEY (cd_rae);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6562 (class 2606 OID 1648907)
-- Name: pk_rahp; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_rahp
    ADD CONSTRAINT pk_rahp PRIMARY KEY (cd_rahp);


--
-- TOC entry 6564 (class 2606 OID 1648912)
-- Name: pk_rdah; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_rdah
    ADD CONSTRAINT pk_rdah PRIMARY KEY (cd_rdah);


SET default_tablespace = '';

--
-- TOC entry 6109 (class 2606 OID 830011)
-- Name: pk_rps; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_rps
    ADD CONSTRAINT pk_rps PRIMARY KEY (cd_rps);


--
-- TOC entry 6113 (class 2606 OID 830013)
-- Name: pk_rqs; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_rqs
    ADD CONSTRAINT pk_rqs PRIMARY KEY (cd_rqs);


--
-- TOC entry 6560 (class 2606 OID 1639054)
-- Name: pk_toe_rdc; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_toe
    ADD CONSTRAINT pk_toe_rdc PRIMARY KEY (cd_toe);


--
-- TOC entry 6102 (class 2606 OID 1639068)
-- Name: uk_fet_nr_lgc; Type: CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_fet
    ADD CONSTRAINT uk_fet_nr_lgc UNIQUE (nr_lgc_fet);


SET search_path = sc_rds, pg_catalog;

--
-- TOC entry 6115 (class 2606 OID 830015)
-- Name: pk_aap; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_aap
    ADD CONSTRAINT pk_aap PRIMARY KEY (cd_aap);


--
-- TOC entry 6117 (class 2606 OID 830017)
-- Name: pk_abs; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_abs
    ADD CONSTRAINT pk_abs PRIMARY KEY (cd_abs);


--
-- TOC entry 6119 (class 2606 OID 830019)
-- Name: pk_aea; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_aea
    ADD CONSTRAINT pk_aea PRIMARY KEY (cd_aea);


--
-- TOC entry 6121 (class 2606 OID 830021)
-- Name: pk_alt; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_alt
    ADD CONSTRAINT pk_alt PRIMARY KEY (cd_alt);


--
-- TOC entry 6123 (class 2606 OID 830023)
-- Name: pk_aop; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_aop
    ADD CONSTRAINT pk_aop PRIMARY KEY (cd_aop);


--
-- TOC entry 6125 (class 2606 OID 830025)
-- Name: pk_atm; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_atm
    ADD CONSTRAINT pk_atm PRIMARY KEY (cd_atm);


--
-- TOC entry 6127 (class 2606 OID 830027)
-- Name: pk_cda; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_cda
    ADD CONSTRAINT pk_cda PRIMARY KEY (cd_cda);


--
-- TOC entry 6131 (class 2606 OID 830029)
-- Name: pk_dab; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_dab
    ADD CONSTRAINT pk_dab PRIMARY KEY (cd_dab);


--
-- TOC entry 6133 (class 2606 OID 830031)
-- Name: pk_drqa; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_drqa
    ADD CONSTRAINT pk_drqa PRIMARY KEY (cd_drqa);


--
-- TOC entry 6165 (class 2606 OID 830033)
-- Name: pk_dsp; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_tda
    ADD CONSTRAINT pk_dsp PRIMARY KEY (cd_tda);


--
-- TOC entry 6135 (class 2606 OID 830040)
-- Name: pk_dsp2; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT pk_dsp2 PRIMARY KEY (cd_dsp);


--
-- TOC entry 6139 (class 2606 OID 830042)
-- Name: pk_eda; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_eda
    ADD CONSTRAINT pk_eda PRIMARY KEY (cd_eda);


--
-- TOC entry 6141 (class 2606 OID 830044)
-- Name: pk_eda_aap; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_eda_aap
    ADD CONSTRAINT pk_eda_aap PRIMARY KEY (cd_eda_aap);


--
-- TOC entry 6143 (class 2606 OID 830046)
-- Name: pk_eda_aop; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_eda_aop
    ADD CONSTRAINT pk_eda_aop PRIMARY KEY (cd_eda_aop);


--
-- TOC entry 6145 (class 2606 OID 830048)
-- Name: pk_fca; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_fca
    ADD CONSTRAINT pk_fca PRIMARY KEY (cd_fca);


--
-- TOC entry 6147 (class 2606 OID 830050)
-- Name: pk_fva; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_fva
    ADD CONSTRAINT pk_fva PRIMARY KEY (cd_fva);


--
-- TOC entry 6149 (class 2606 OID 830052)
-- Name: pk_led; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_led
    ADD CONSTRAINT pk_led PRIMARY KEY (cd_led);


--
-- TOC entry 6129 (class 2606 OID 830054)
-- Name: pk_ltr_css_atm; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_css
    ADD CONSTRAINT pk_ltr_css_atm PRIMARY KEY (cd_atm, nm_ltr_css);


--
-- TOC entry 6151 (class 2606 OID 830056)
-- Name: pk_oca; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_oca
    ADD CONSTRAINT pk_oca PRIMARY KEY (cd_oca);


--
-- TOC entry 6153 (class 2606 OID 830058)
-- Name: pk_pda; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_pda
    ADD CONSTRAINT pk_pda PRIMARY KEY (cd_pda);


--
-- TOC entry 6155 (class 2606 OID 830060)
-- Name: pk_pop; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_pop
    ADD CONSTRAINT pk_pop PRIMARY KEY (cd_pop);


--
-- TOC entry 6159 (class 2606 OID 830062)
-- Name: pk_rqa; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_rqa
    ADD CONSTRAINT pk_rqa PRIMARY KEY (cd_rqa);


--
-- TOC entry 6323 (class 2606 OID 857782)
-- Name: pk_sfc; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_sfc
    ADD CONSTRAINT pk_sfc PRIMARY KEY (cd_sfc);


--
-- TOC entry 6161 (class 2606 OID 830069)
-- Name: pk_tal; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_tal
    ADD CONSTRAINT pk_tal PRIMARY KEY (cd_tal);


--
-- TOC entry 6163 (class 2606 OID 830071)
-- Name: pk_tbc; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_tbc
    ADD CONSTRAINT pk_tbc PRIMARY KEY (cd_tbc);


--
-- TOC entry 6167 (class 2606 OID 830073)
-- Name: pk_vma; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_vma
    ADD CONSTRAINT pk_vma PRIMARY KEY (cd_vma);


--
-- TOC entry 6137 (class 2606 OID 830075)
-- Name: uk_tda_atm; Type: CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT uk_tda_atm UNIQUE (cd_tda, cd_atm);


SET search_path = sc_rnc, pg_catalog;

--
-- TOC entry 6169 (class 2606 OID 830077)
-- Name: pk_dfa; Type: CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_dfa
    ADD CONSTRAINT pk_dfa PRIMARY KEY (cd_dfa);


--
-- TOC entry 6171 (class 2606 OID 830079)
-- Name: pk_rnc; Type: CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rnc
    ADD CONSTRAINT pk_rnc PRIMARY KEY (cd_rnc);


--
-- TOC entry 6173 (class 2606 OID 830081)
-- Name: pk_rnc_aux; Type: CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rnc_aux
    ADD CONSTRAINT pk_rnc_aux PRIMARY KEY (cd_rnc);


--
-- TOC entry 6175 (class 2606 OID 830083)
-- Name: pk_rpc; Type: CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rpc
    ADD CONSTRAINT pk_rpc PRIMARY KEY (cd_rpc);


SET search_path = sc_rsc, pg_catalog;

--
-- TOC entry 6177 (class 2606 OID 830087)
-- Name: tbl_rsc_pkey; Type: CONSTRAINT; Schema: sc_rsc; Owner: scan
--

ALTER TABLE ONLY tbl_rsc
    ADD CONSTRAINT tbl_rsc_pkey PRIMARY KEY (cd_rsc);


SET search_path = sc_scan_cbe, pg_catalog;

--
-- TOC entry 6467 (class 2606 OID 986068)
-- Name: pk_dql; Type: CONSTRAINT; Schema: sc_scan_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_dlq
    ADD CONSTRAINT pk_dql PRIMARY KEY (cd_dvd);


SET search_path = sc_sgr, pg_catalog;

SET default_tablespace = ts_scan_i;

--
-- TOC entry 6197 (class 2606 OID 852560)
-- Name: UK_UCR_LGN; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_ucr
    ADD CONSTRAINT "UK_UCR_LGN" UNIQUE (lgn_ucr);


SET default_tablespace = '';

--
-- TOC entry 6419 (class 2606 OID 899384)
-- Name: pk_acs; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_acs
    ADD CONSTRAINT pk_acs PRIMARY KEY (cd_acs);


--
-- TOC entry 6573 (class 2606 OID 1665864)
-- Name: pk_aur; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_aur
    ADD CONSTRAINT pk_aur PRIMARY KEY (cd_aur);


--
-- TOC entry 6554 (class 2606 OID 1637543)
-- Name: pk_cd_cli; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_cli
    ADD CONSTRAINT pk_cd_cli PRIMARY KEY (cd_cli);


--
-- TOC entry 6203 (class 2606 OID 830089)
-- Name: pk_cd_usr; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_usr
    ADD CONSTRAINT pk_cd_usr PRIMARY KEY (cd_usr);


--
-- TOC entry 6499 (class 2606 OID 1007412)
-- Name: pk_cfv; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_cfv
    ADD CONSTRAINT pk_cfv PRIMARY KEY (cd_cfv);


--
-- TOC entry 6453 (class 2606 OID 973928)
-- Name: pk_epl; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_epl
    ADD CONSTRAINT pk_epl PRIMARY KEY (cd_epl);


--
-- TOC entry 5729 (class 2606 OID 830091)
-- Name: pk_eus; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_eus
    ADD CONSTRAINT pk_eus PRIMARY KEY (cd_eus);


--
-- TOC entry 6179 (class 2606 OID 830093)
-- Name: pk_grp; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_grp
    ADD CONSTRAINT pk_grp PRIMARY KEY (cd_grp);


--
-- TOC entry 6182 (class 2606 OID 830095)
-- Name: pk_grp_rol; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_grp_rol
    ADD CONSTRAINT pk_grp_rol PRIMARY KEY (cd_grp_rol);


--
-- TOC entry 6569 (class 2606 OID 1665856)
-- Name: pk_lur; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_lur
    ADD CONSTRAINT pk_lur PRIMARY KEY (cd_lur);


--
-- TOC entry 6184 (class 2606 OID 830097)
-- Name: pk_menu; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_menu
    ADD CONSTRAINT pk_menu PRIMARY KEY (cd_menu);


--
-- TOC entry 6186 (class 2606 OID 830099)
-- Name: pk_rol; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_rol
    ADD CONSTRAINT pk_rol PRIMARY KEY (cd_rol);


--
-- TOC entry 6191 (class 2606 OID 830101)
-- Name: pk_rol_sis; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_rol_sis
    ADD CONSTRAINT pk_rol_sis PRIMARY KEY (cd_rol_sis);


--
-- TOC entry 6193 (class 2606 OID 830103)
-- Name: pk_sis; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_sis
    ADD CONSTRAINT pk_sis PRIMARY KEY (cd_sis);


--
-- TOC entry 6195 (class 2606 OID 830105)
-- Name: pk_sis_usr; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_sis_usr
    ADD CONSTRAINT pk_sis_usr PRIMARY KEY (cd_sis_usr);


--
-- TOC entry 6329 (class 2606 OID 862103)
-- Name: pk_spl; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_spl
    ADD CONSTRAINT pk_spl PRIMARY KEY (cd_spl);


--
-- TOC entry 6552 (class 2606 OID 1637532)
-- Name: pk_tkn; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_tkn
    ADD CONSTRAINT pk_tkn PRIMARY KEY (cd_tkn);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6382 (class 2606 OID 889001)
-- Name: pk_ucc; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_ucc
    ADD CONSTRAINT pk_ucc PRIMARY KEY (cd_ucc);


--
-- TOC entry 6398 (class 2606 OID 889177)
-- Name: pk_ucc_old; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_ucc_old
    ADD CONSTRAINT pk_ucc_old PRIMARY KEY (cd_ucc);


SET default_tablespace = '';

--
-- TOC entry 6199 (class 2606 OID 830107)
-- Name: pk_ucr; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_ucr
    ADD CONSTRAINT pk_ucr PRIMARY KEY (cd_ucr);


--
-- TOC entry 6396 (class 2606 OID 889159)
-- Name: pk_ucr_old; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_ucr_old
    ADD CONSTRAINT pk_ucr_old PRIMARY KEY (cd_ucr);


--
-- TOC entry 6209 (class 2606 OID 830109)
-- Name: pk_usr_aux; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_usr_aux
    ADD CONSTRAINT pk_usr_aux PRIMARY KEY (cd_usr);


--
-- TOC entry 6212 (class 2606 OID 830111)
-- Name: pk_usr_grp; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_usr_grp
    ADD CONSTRAINT pk_usr_grp PRIMARY KEY (cd_usr_grp);


--
-- TOC entry 6556 (class 2606 OID 1637545)
-- Name: uk_id_cli; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_cli
    ADD CONSTRAINT uk_id_cli UNIQUE (id_cli);


--
-- TOC entry 6205 (class 2606 OID 830113)
-- Name: uk_lgn_usr; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_usr
    ADD CONSTRAINT uk_lgn_usr UNIQUE (lgn_usr);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6571 (class 2606 OID 1665866)
-- Name: uk_tkn_lur; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan; Tablespace: ts_scan_i
--

ALTER TABLE ONLY tbl_lur
    ADD CONSTRAINT uk_tkn_lur UNIQUE (tkn_lur);


SET default_tablespace = '';

--
-- TOC entry 6384 (class 2606 OID 1651356)
-- Name: uk_ucc_crt; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_ucc
    ADD CONSTRAINT uk_ucc_crt UNIQUE (cd_crt);


--
-- TOC entry 6201 (class 2606 OID 1651353)
-- Name: uk_ucr_crt; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_ucr
    ADD CONSTRAINT uk_ucr_crt UNIQUE (cd_crt);


--
-- TOC entry 6188 (class 2606 OID 830115)
-- Name: uq_nm_rol; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_rol
    ADD CONSTRAINT uq_nm_rol UNIQUE (nm_rol);


--
-- TOC entry 6386 (class 2606 OID 889003)
-- Name: uq_ucr_crt; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_ucc
    ADD CONSTRAINT uq_ucr_crt UNIQUE (cd_ucr, cd_crt);


--
-- TOC entry 6400 (class 2606 OID 889179)
-- Name: uq_ucr_old_crt; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_ucc_old
    ADD CONSTRAINT uq_ucr_old_crt UNIQUE (cd_ucr, cd_crt);


--
-- TOC entry 6207 (class 2606 OID 830117)
-- Name: uq_usr_cun; Type: CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_usr
    ADD CONSTRAINT uq_usr_cun UNIQUE (cd_cun);


SET search_path = sc_spc, pg_catalog;

--
-- TOC entry 6222 (class 2606 OID 830119)
-- Name: UQ_HRS_NR_RMS; Type: CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_hrs
    ADD CONSTRAINT "UQ_HRS_NR_RMS" UNIQUE (nr_rms_hrs);


--
-- TOC entry 6336 (class 2606 OID 868071)
-- Name: pk_aux; Type: CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_aux
    ADD CONSTRAINT pk_aux PRIMARY KEY (cpf);


--
-- TOC entry 6214 (class 2606 OID 830121)
-- Name: pk_det; Type: CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_det
    ADD CONSTRAINT pk_det PRIMARY KEY (cd_det);


--
-- TOC entry 6216 (class 2606 OID 830123)
-- Name: pk_drcs; Type: CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_drcs
    ADD CONSTRAINT pk_drcs PRIMARY KEY (cd_drcs);


--
-- TOC entry 6218 (class 2606 OID 830125)
-- Name: pk_drss; Type: CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_drss
    ADD CONSTRAINT pk_drss PRIMARY KEY (cd_drss);


--
-- TOC entry 6220 (class 2606 OID 830127)
-- Name: pk_hdr; Type: CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_hdr
    ADD CONSTRAINT pk_hdr PRIMARY KEY (cd_hdr);


--
-- TOC entry 6224 (class 2606 OID 830129)
-- Name: pk_hrs; Type: CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_hrs
    ADD CONSTRAINT pk_hrs PRIMARY KEY (cd_hrs);


--
-- TOC entry 6226 (class 2606 OID 830131)
-- Name: pk_mtv; Type: CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_mtv
    ADD CONSTRAINT pk_mtv PRIMARY KEY (cd_mtv);


--
-- TOC entry 6228 (class 2606 OID 830133)
-- Name: pk_ret; Type: CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_ret
    ADD CONSTRAINT pk_ret PRIMARY KEY (cd_ret);


SET search_path = sc_srs, pg_catalog;

--
-- TOC entry 6425 (class 2606 OID 899522)
-- Name: pk_ott; Type: CONSTRAINT; Schema: sc_srs; Owner: scan
--

ALTER TABLE ONLY tbl_ott
    ADD CONSTRAINT pk_ott PRIMARY KEY (cd_ott);


--
-- TOC entry 6423 (class 2606 OID 899516)
-- Name: pk_rms; Type: CONSTRAINT; Schema: sc_srs; Owner: scan
--

ALTER TABLE ONLY tbl_rms
    ADD CONSTRAINT pk_rms PRIMARY KEY (cd_rms);


--
-- TOC entry 6421 (class 2606 OID 899504)
-- Name: pk_ttl; Type: CONSTRAINT; Schema: sc_srs; Owner: scan
--

ALTER TABLE ONLY tbl_ttl
    ADD CONSTRAINT pk_ttl PRIMARY KEY (cd_ttl);


SET search_path = sc_srv, pg_catalog;

--
-- TOC entry 6230 (class 2606 OID 830135)
-- Name: pk_cap; Type: CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_cap
    ADD CONSTRAINT pk_cap PRIMARY KEY (cd_cap);


--
-- TOC entry 6232 (class 2606 OID 830137)
-- Name: pk_drc; Type: CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_drc
    ADD CONSTRAINT pk_drc PRIMARY KEY (cd_drc);


--
-- TOC entry 6234 (class 2606 OID 830139)
-- Name: pk_has; Type: CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_has
    ADD CONSTRAINT pk_has PRIMARY KEY (cd_has);


--
-- TOC entry 6236 (class 2606 OID 830141)
-- Name: pk_hrc; Type: CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_hrc
    ADD CONSTRAINT pk_hrc PRIMARY KEY (cd_hrc);


--
-- TOC entry 6239 (class 2606 OID 830143)
-- Name: pk_scr; Type: CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_scr
    ADD CONSTRAINT pk_scr PRIMARY KEY (cd_scr);


--
-- TOC entry 6241 (class 2606 OID 830145)
-- Name: pk_sga; Type: CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_sga
    ADD CONSTRAINT pk_sga PRIMARY KEY (cd_sga);


--
-- TOC entry 6243 (class 2606 OID 830147)
-- Name: pk_sgr; Type: CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_sgr
    ADD CONSTRAINT pk_sgr PRIMARY KEY (cd_sgr);


--
-- TOC entry 6245 (class 2606 OID 830149)
-- Name: pk_srv; Type: CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_srv
    ADD CONSTRAINT pk_srv PRIMARY KEY (cd_srv);


--
-- TOC entry 6247 (class 2606 OID 830151)
-- Name: pk_trc; Type: CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_trc
    ADD CONSTRAINT pk_trc PRIMARY KEY (cd_trc);


--
-- TOC entry 6251 (class 2606 OID 830153)
-- Name: pk_tsc; Type: CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_tsc
    ADD CONSTRAINT pk_tsc PRIMARY KEY (cd_tsc);


SET search_path = sc_ssp, pg_catalog;

--
-- TOC entry 6253 (class 2606 OID 830155)
-- Name: pk_caep; Type: CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_caep
    ADD CONSTRAINT pk_caep PRIMARY KEY (cd_caep);


--
-- TOC entry 6257 (class 2606 OID 830157)
-- Name: pk_daep; Type: CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_daep
    ADD CONSTRAINT pk_daep PRIMARY KEY (cd_daep);


--
-- TOC entry 6259 (class 2606 OID 830159)
-- Name: pk_faep; Type: CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_faep
    ADD CONSTRAINT pk_faep PRIMARY KEY (cd_faep);


--
-- TOC entry 6261 (class 2606 OID 830161)
-- Name: pk_haep; Type: CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_haep
    ADD CONSTRAINT pk_haep PRIMARY KEY (cd_haep);


--
-- TOC entry 6263 (class 2606 OID 830163)
-- Name: pk_mpl; Type: CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_mpl
    ADD CONSTRAINT pk_mpl PRIMARY KEY (cd_mpl);


--
-- TOC entry 6266 (class 2606 OID 830165)
-- Name: pk_ssp; Type: CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_ssp
    ADD CONSTRAINT pk_ssp PRIMARY KEY (cd_ssp);


SET search_path = sc_svg, pg_catalog;

--
-- TOC entry 6268 (class 2606 OID 830167)
-- Name: pk_ars; Type: CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_ars
    ADD CONSTRAINT pk_ars PRIMARY KEY (cd_ars);


--
-- TOC entry 6270 (class 2606 OID 830169)
-- Name: pk_csg; Type: CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_csg
    ADD CONSTRAINT pk_csg PRIMARY KEY (cd_csg);


--
-- TOC entry 6272 (class 2606 OID 830171)
-- Name: pk_drs; Type: CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_drs
    ADD CONSTRAINT pk_drs PRIMARY KEY (cd_drs);


--
-- TOC entry 6274 (class 2606 OID 830173)
-- Name: pk_fem_csg; Type: CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_fem_csg
    ADD CONSTRAINT pk_fem_csg PRIMARY KEY (cd_fem_csg);


--
-- TOC entry 6276 (class 2606 OID 830175)
-- Name: pk_osg; Type: CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_osg
    ADD CONSTRAINT pk_osg PRIMARY KEY (cd_osg);


--
-- TOC entry 6278 (class 2606 OID 830177)
-- Name: pk_psg; Type: CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_psg
    ADD CONSTRAINT pk_psg PRIMARY KEY (cd_psg);


--
-- TOC entry 6280 (class 2606 OID 830179)
-- Name: pk_tos; Type: CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_tos
    ADD CONSTRAINT pk_tos PRIMARY KEY (cd_tos);


SET search_path = sc_tem, pg_catalog;

--
-- TOC entry 6282 (class 2606 OID 830181)
-- Name: pk_ads; Type: CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_ads
    ADD CONSTRAINT pk_ads PRIMARY KEY (cd_ads);


--
-- TOC entry 6402 (class 2606 OID 889634)
-- Name: pk_chv; Type: CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_chv
    ADD CONSTRAINT pk_chv PRIMARY KEY (cd_chv);


--
-- TOC entry 6284 (class 2606 OID 830183)
-- Name: pk_css; Type: CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_css
    ADD CONSTRAINT pk_css PRIMARY KEY (cd_css);


--
-- TOC entry 6286 (class 2606 OID 830185)
-- Name: pk_oca; Type: CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_oca
    ADD CONSTRAINT pk_oca PRIMARY KEY (cd_oca);


--
-- TOC entry 6288 (class 2606 OID 830187)
-- Name: pk_prc; Type: CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_prc
    ADD CONSTRAINT pk_prc PRIMARY KEY (cd_prc);


--
-- TOC entry 6290 (class 2606 OID 830189)
-- Name: pk_rqs; Type: CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_rqs
    ADD CONSTRAINT pk_rqs PRIMARY KEY (cd_rqs);


SET search_path = sqlj, pg_catalog;

--
-- TOC entry 6292 (class 2606 OID 830191)
-- Name: classpath_entry_pkey; Type: CONSTRAINT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY classpath_entry
    ADD CONSTRAINT classpath_entry_pkey PRIMARY KEY (schemaname, ordinal);


--
-- TOC entry 6294 (class 2606 OID 830193)
-- Name: jar_entry_jarid_entryname_key; Type: CONSTRAINT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY jar_entry
    ADD CONSTRAINT jar_entry_jarid_entryname_key UNIQUE (jarid, entryname);


--
-- TOC entry 6296 (class 2606 OID 830195)
-- Name: jar_entry_pkey; Type: CONSTRAINT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY jar_entry
    ADD CONSTRAINT jar_entry_pkey PRIMARY KEY (entryid);


--
-- TOC entry 6298 (class 2606 OID 830197)
-- Name: jar_repository_jarname_key; Type: CONSTRAINT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY jar_repository
    ADD CONSTRAINT jar_repository_jarname_key UNIQUE (jarname);


--
-- TOC entry 6300 (class 2606 OID 830199)
-- Name: jar_repository_pkey; Type: CONSTRAINT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY jar_repository
    ADD CONSTRAINT jar_repository_pkey PRIMARY KEY (jarid);


--
-- TOC entry 6302 (class 2606 OID 830201)
-- Name: typemap_entry_pkey; Type: CONSTRAINT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY typemap_entry
    ADD CONSTRAINT typemap_entry_pkey PRIMARY KEY (mapid);


SET search_path = sc__buxo, pg_catalog;

--
-- TOC entry 6526 (class 1259 OID 1614102)
-- Name: ix_bx_cnt; Type: INDEX; Schema: sc__buxo; Owner: postgres
--

CREATE INDEX ix_bx_cnt ON tbl_conta_data USING btree (cd_cnt);


SET search_path = sc_adp, pg_catalog;

--
-- TOC entry 5608 (class 1259 OID 830202)
-- Name: ix_rdp_crt; Type: INDEX; Schema: sc_adp; Owner: scan
--

CREATE INDEX ix_rdp_crt ON tbl_rdp USING btree (cd_crt);


--
-- TOC entry 5609 (class 1259 OID 830203)
-- Name: ix_rdp_hdr; Type: INDEX; Schema: sc_adp; Owner: scan
--

CREATE INDEX ix_rdp_hdr ON tbl_rdp USING btree (cd_hdr);


--
-- TOC entry 5610 (class 1259 OID 830204)
-- Name: ix_rdp_hfe; Type: INDEX; Schema: sc_adp; Owner: scan
--

CREATE INDEX ix_rdp_hfe ON tbl_rdp USING btree (cd_hfe);


--
-- TOC entry 5617 (class 1259 OID 830205)
-- Name: ix_tfe_hdr; Type: INDEX; Schema: sc_adp; Owner: scan
--

CREATE INDEX ix_tfe_hdr ON tbl_tfe USING btree (cd_hdr);


--
-- TOC entry 5618 (class 1259 OID 830206)
-- Name: ix_tfe_hfe; Type: INDEX; Schema: sc_adp; Owner: scan
--

CREATE INDEX ix_tfe_hfe ON tbl_tfe USING btree (cd_hfe);


--
-- TOC entry 5621 (class 1259 OID 830207)
-- Name: ix_trl_hdr; Type: INDEX; Schema: sc_adp; Owner: scan
--

CREATE INDEX ix_trl_hdr ON tbl_trl USING btree (cd_hdr);


SET search_path = sc_aeo, pg_catalog;

--
-- TOC entry 5630 (class 1259 OID 976621)
-- Name: ix_eop_opr; Type: INDEX; Schema: sc_aeo; Owner: scan
--

CREATE INDEX ix_eop_opr ON tbl_eop USING btree (cd_opr);


SET search_path = sc_analise, pg_catalog;

SET default_tablespace = ts_scan_i;

--
-- TOC entry 6574 (class 1259 OID 1667152)
-- Name: idx_cartao_cartoes_mes; Type: INDEX; Schema: sc_analise; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX idx_cartao_cartoes_mes ON tbl_cartoes_mes USING btree (cartao);


SET search_path = sc_atb, pg_catalog;

SET default_tablespace = '';

--
-- TOC entry 5645 (class 1259 OID 952746)
-- Name: ix_tba_campos; Type: INDEX; Schema: sc_atb; Owner: scan
--

CREATE INDEX ix_tba_campos ON tbl_tba USING btree (st_tba, nr_cpf_cnpj_tba, cd_bnc, nr_agc_tba, nr_dgt_agc_tba, nr_cba_tba, nr_dgt_cba_tba);


SET search_path = sc_cad, pg_catalog;

--
-- TOC entry 5663 (class 1259 OID 830208)
-- Name: fki_ctr_mpl; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX fki_ctr_mpl ON tbl_ctr USING btree (cd_mpl);


--
-- TOC entry 5656 (class 1259 OID 952744)
-- Name: ix_cbf_cun; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_cbf_cun ON tbl_cbf USING btree (cd_cun);


--
-- TOC entry 5538 (class 1259 OID 830209)
-- Name: ix_cd_edr; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_cd_edr ON tbl_eex USING btree (cd_edr);


--
-- TOC entry 5676 (class 1259 OID 830210)
-- Name: ix_cd_edr_ctr; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_cd_edr_ctr ON tbl_edr_ctr USING btree (cd_edr);


--
-- TOC entry 5677 (class 1259 OID 830211)
-- Name: ix_edr_ctr_ctr; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_edr_ctr_ctr ON tbl_edr_ctr USING btree (cd_ctr);


--
-- TOC entry 5535 (class 1259 OID 830212)
-- Name: ix_edr_cun; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_edr_cun ON tbl_edr USING btree (cd_cun);


--
-- TOC entry 5685 (class 1259 OID 952739)
-- Name: ix_fem_ctr_ctr_fem; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_fem_ctr_ctr_fem ON tbl_fem_ctr USING btree (cd_ctr, cd_fem);


--
-- TOC entry 5690 (class 1259 OID 830215)
-- Name: ix_fnc_cun; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_fnc_cun ON tbl_fnc USING btree (cd_cun);


--
-- TOC entry 5691 (class 1259 OID 952745)
-- Name: ix_fnc_emp; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_fnc_emp ON tbl_fnc USING btree (cd_emp);


--
-- TOC entry 5692 (class 1259 OID 830216)
-- Name: ix_fnc_emp_fem; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_fnc_emp_fem ON tbl_fnc USING btree (cd_emp, cd_fem);


--
-- TOC entry 6403 (class 1259 OID 952743)
-- Name: ix_pce_crt_crt_pce; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_pce_crt_crt_pce ON tbl_pce_crt USING btree (cd_crt, cd_pce);


--
-- TOC entry 5707 (class 1259 OID 952742)
-- Name: ix_pce_ctr_pce_ctr; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_pce_ctr_pce_ctr ON tbl_pce_ctr USING btree (cd_ctr, cd_pce);


--
-- TOC entry 6316 (class 1259 OID 952741)
-- Name: ix_pce_fem_ctr_fem_ctr; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_pce_fem_ctr_fem_ctr ON tbl_pce_fem_ctr USING btree (cd_fem_ctr);


--
-- TOC entry 6317 (class 1259 OID 952740)
-- Name: ix_pce_fem_ctr_pce; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_pce_fem_ctr_pce ON tbl_pce_fem_ctr USING btree (cd_pce);


--
-- TOC entry 5678 (class 1259 OID 830218)
-- Name: ix_tp_edr_ctr; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_tp_edr_ctr ON tbl_edr_ctr USING btree (cd_ctr, tp_edr_ctr);


--
-- TOC entry 5551 (class 1259 OID 830219)
-- Name: ix_tp_org_nsu_org; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_tp_org_nsu_org ON tbl_tlf USING btree (tp_org_tlf, nsu_org_tlf);


--
-- TOC entry 5552 (class 1259 OID 999431)
-- Name: ix_tp_tp_org_nsu_org; Type: INDEX; Schema: sc_cad; Owner: scan
--

CREATE INDEX ix_tp_tp_org_nsu_org ON tbl_tlf USING btree (tp_org_tlf, nsu_org_tlf, tp_tlf);


SET search_path = sc_cbe, pg_catalog;

--
-- TOC entry 6307 (class 1259 OID 1002617)
-- Name: ix_emc_nsu_org_dvd; Type: INDEX; Schema: sc_cbe; Owner: scan
--

CREATE INDEX ix_emc_nsu_org_dvd ON tbl_dvd USING btree (nsu_org_dvd, tp_org_dvd);


SET search_path = sc_ccb, pg_catalog;

--
-- TOC entry 6426 (class 1259 OID 916154)
-- Name: ix_ccb_ant_opr; Type: INDEX; Schema: sc_ccb; Owner: scan
--

CREATE INDEX ix_ccb_ant_opr ON tbl_ccb_ant USING btree (cd_opr);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6365 (class 1259 OID 1004361)
-- Name: ix_ccb_cd_opr; Type: INDEX; Schema: sc_ccb; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_ccb_cd_opr ON tbl_ccb USING btree (cd_opr);


--
-- TOC entry 6368 (class 1259 OID 1004348)
-- Name: ix_ccb_pfc_cd_pfc; Type: INDEX; Schema: sc_ccb; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_ccb_pfc_cd_pfc ON tbl_ccb_pfc USING btree (cd_pfc);


SET search_path = sc_cnt, pg_catalog;

--
-- TOC entry 5800 (class 1259 OID 852556)
-- Name: ix_cnt_scn; Type: INDEX; Schema: sc_cnt; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_cnt_scn ON tbl_cnt USING btree (cd_scn);


SET default_tablespace = '';

--
-- TOC entry 5805 (class 1259 OID 830220)
-- Name: ix_lcn_cnt; Type: INDEX; Schema: sc_cnt; Owner: scan
--

CREATE INDEX ix_lcn_cnt ON tbl_lcn USING btree (cd_cnt);


--
-- TOC entry 5806 (class 1259 OID 830230)
-- Name: ix_lcn_ctp; Type: INDEX; Schema: sc_cnt; Owner: scan
--

CREATE INDEX ix_lcn_ctp ON tbl_lcn USING btree (cd_ctp_lcn);


--
-- TOC entry 5807 (class 1259 OID 830232)
-- Name: ix_lcn_dt_ref; Type: INDEX; Schema: sc_cnt; Owner: scan
--

CREATE INDEX ix_lcn_dt_ref ON tbl_lcn USING btree (dt_ref_lcn);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 5812 (class 1259 OID 852557)
-- Name: ix_lcn_exc_lcn; Type: INDEX; Schema: sc_cnt; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_lcn_exc_lcn ON tbl_lcn_exc USING btree (cd_lcn);


SET default_tablespace = '';

--
-- TOC entry 5808 (class 1259 OID 830233)
-- Name: ix_lcn_sst_nsu; Type: INDEX; Schema: sc_cnt; Owner: scan
--

CREATE INDEX ix_lcn_sst_nsu ON tbl_lcn USING btree (cd_sst, nsu_lcn);


--
-- TOC entry 5809 (class 1259 OID 830234)
-- Name: ix_lcn_tlc; Type: INDEX; Schema: sc_cnt; Owner: scan
--

CREATE INDEX ix_lcn_tlc ON tbl_lcn USING btree (cd_tlc);


--
-- TOC entry 5825 (class 1259 OID 830235)
-- Name: ix_sdc_cnt; Type: INDEX; Schema: sc_cnt; Owner: scan
--

CREATE INDEX ix_sdc_cnt ON tbl_sdc USING btree (cd_cnt);


--
-- TOC entry 5826 (class 1259 OID 1614083)
-- Name: ix_sdc_cnt_dt; Type: INDEX; Schema: sc_cnt; Owner: scan
--

CREATE INDEX ix_sdc_cnt_dt ON tbl_sdc USING btree (cd_cnt, dt_sdc);


--
-- TOC entry 5827 (class 1259 OID 830236)
-- Name: ix_sdc_dt; Type: INDEX; Schema: sc_cnt; Owner: scan
--

CREATE INDEX ix_sdc_dt ON tbl_sdc USING btree (dt_sdc);


--
-- TOC entry 5828 (class 1259 OID 830258)
-- Name: ix_sdc_scn; Type: INDEX; Schema: sc_cnt; Owner: scan
--

CREATE INDEX ix_sdc_scn ON tbl_sds USING btree (cd_scn);


--
-- TOC entry 5829 (class 1259 OID 830259)
-- Name: ix_sds_dt_scn; Type: INDEX; Schema: sc_cnt; Owner: scan
--

CREATE INDEX ix_sds_dt_scn ON tbl_sds USING btree (dt_sds, dt_inc_usr, cd_scn);


--
-- TOC entry 5840 (class 1259 OID 830260)
-- Name: ix_tbc_cnt_cnt; Type: INDEX; Schema: sc_cnt; Owner: scan
--

CREATE INDEX ix_tbc_cnt_cnt ON tbl_tbc_cnt USING btree (cd_cnt);


SET search_path = sc_crr, pg_catalog;

--
-- TOC entry 5544 (class 1259 OID 830261)
-- Name: ix_bairro_ini; Type: INDEX; Schema: sc_crr; Owner: scan
--

CREATE INDEX ix_bairro_ini ON log_logradouro USING hash (bai_nu_sequencial_ini);


--
-- TOC entry 5545 (class 1259 OID 830262)
-- Name: ix_cep; Type: INDEX; Schema: sc_crr; Owner: scan
--

CREATE INDEX ix_cep ON log_logradouro USING btree (cep);


--
-- TOC entry 5546 (class 1259 OID 830263)
-- Name: ix_cep_cep2; Type: INDEX; Schema: sc_crr; Owner: scan
--

CREATE INDEX ix_cep_cep2 ON log_logradouro USING btree (cep2);


--
-- TOC entry 5539 (class 1259 OID 830264)
-- Name: ix_localidade; Type: INDEX; Schema: sc_crr; Owner: scan
--

CREATE INDEX ix_localidade ON log_bairro USING btree (loc_nu_sequencial);


SET search_path = sc_ctb, pg_catalog;

SET default_tablespace = ts_scan_i;

--
-- TOC entry 5571 (class 1259 OID 852562)
-- Name: ix_dac_cpl_fg_cnt_hst; Type: INDEX; Schema: sc_ctb; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_dac_cpl_fg_cnt_hst ON tbl_daec_cpl USING btree (fg_dcr_daec_cpl, cnt_daec_cpl, cd_hst_daec_cpl);


--
-- TOC entry 5572 (class 1259 OID 852561)
-- Name: ix_daec_cpl_daec_lcn; Type: INDEX; Schema: sc_ctb; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_daec_cpl_daec_lcn ON tbl_daec_cpl USING btree (cd_daec_lcn);


SET default_tablespace = '';

--
-- TOC entry 5575 (class 1259 OID 852564)
-- Name: ix_daec_lcn_aec; Type: INDEX; Schema: sc_ctb; Owner: scan
--

CREATE INDEX ix_daec_lcn_aec ON tbl_daec_lcn USING btree (cd_aec);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 5855 (class 1259 OID 852558)
-- Name: ix_ext_lcn_lcn; Type: INDEX; Schema: sc_ctb; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_ext_lcn_lcn ON tbl_ext_lcn2 USING btree (cd_lcn);


--
-- TOC entry 6514 (class 1259 OID 1077250)
-- Name: ix_ext_lcn_lcn2; Type: INDEX; Schema: sc_ctb; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_ext_lcn_lcn2 ON tbl_ext_lcn USING btree (cd_lcn);


--
-- TOC entry 5856 (class 1259 OID 852563)
-- Name: ix_ext_lcn_sq; Type: INDEX; Schema: sc_ctb; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_ext_lcn_sq ON tbl_ext_lcn2 USING btree (nr_seq_ext_lcn);


--
-- TOC entry 6515 (class 1259 OID 1077251)
-- Name: ix_ext_lcn_sq2; Type: INDEX; Schema: sc_ctb; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_ext_lcn_sq2 ON tbl_ext_lcn USING btree (nr_seq_ext_lcn);


SET search_path = sc_dgt, pg_catalog;

SET default_tablespace = '';

--
-- TOC entry 6445 (class 1259 OID 1014975)
-- Name: ix_arq_cun; Type: INDEX; Schema: sc_dgt; Owner: scan
--

CREATE INDEX ix_arq_cun ON tbl_arq USING btree (cd_cun);


--
-- TOC entry 6446 (class 1259 OID 1014982)
-- Name: ix_arq_st; Type: INDEX; Schema: sc_dgt; Owner: scan
--

CREATE INDEX ix_arq_st ON tbl_arq USING btree (st_arq);


--
-- TOC entry 6447 (class 1259 OID 1029379)
-- Name: ix_arq_tar; Type: INDEX; Schema: sc_dgt; Owner: scan
--

CREATE INDEX ix_arq_tar ON tbl_arq USING btree (cd_tar);


SET search_path = sc_fcr, pg_catalog;

--
-- TOC entry 5871 (class 1259 OID 830265)
-- Name: ix_fcr_crt; Type: INDEX; Schema: sc_fcr; Owner: scan
--

CREATE INDEX ix_fcr_crt ON tbl_fcr USING btree (cd_crt);


--
-- TOC entry 5874 (class 1259 OID 830266)
-- Name: ix_fcr_tlt_fcr; Type: INDEX; Schema: sc_fcr; Owner: scan
--

CREATE INDEX ix_fcr_tlt_fcr ON tbl_fcr_tlt USING btree (cd_fcr);


--
-- TOC entry 5879 (class 1259 OID 1614049)
-- Name: ix_pfc_crt; Type: INDEX; Schema: sc_fcr; Owner: scan
--

CREATE INDEX ix_pfc_crt ON tbl_pfc USING btree (cd_crt);


--
-- TOC entry 5880 (class 1259 OID 1614052)
-- Name: ix_pfc_dt_pgt; Type: INDEX; Schema: sc_fcr; Owner: scan
--

CREATE INDEX ix_pfc_dt_pgt ON tbl_pfc USING btree (dt_pgt_pfc);


--
-- TOC entry 5881 (class 1259 OID 1614051)
-- Name: ix_pfc_dt_rcb; Type: INDEX; Schema: sc_fcr; Owner: scan
--

CREATE INDEX ix_pfc_dt_rcb ON tbl_pfc USING btree (dt_rcb_pfc);


--
-- TOC entry 5882 (class 1259 OID 1614050)
-- Name: ix_pfc_fcr; Type: INDEX; Schema: sc_fcr; Owner: scan
--

CREATE INDEX ix_pfc_fcr ON tbl_pfc USING btree (cd_fcr);


--
-- TOC entry 5886 (class 1259 OID 1614065)
-- Name: ix_pfc_prc_cd_pfc; Type: INDEX; Schema: sc_fcr; Owner: scan
--

CREATE INDEX ix_pfc_prc_cd_pfc ON tbl_pfc_prc USING btree (cd_pfc);


--
-- TOC entry 5891 (class 1259 OID 830267)
-- Name: ix_prc_crt; Type: INDEX; Schema: sc_fcr; Owner: scan
--

CREATE INDEX ix_prc_crt ON tbl_prc USING btree (cd_crt);


--
-- TOC entry 5892 (class 1259 OID 830268)
-- Name: ix_prc_fcr; Type: INDEX; Schema: sc_fcr; Owner: scan
--

CREATE INDEX ix_prc_fcr ON tbl_prc USING btree (cd_fcr);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 5893 (class 1259 OID 853277)
-- Name: ix_prc_fcr_atu; Type: INDEX; Schema: sc_fcr; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_prc_fcr_atu ON tbl_prc USING btree (cd_fcr_atu_prc);


SET default_tablespace = '';

--
-- TOC entry 5894 (class 1259 OID 830269)
-- Name: ix_prc_opr; Type: INDEX; Schema: sc_fcr; Owner: scan
--

CREATE INDEX ix_prc_opr ON tbl_prc USING btree (cd_opr);


--
-- TOC entry 5883 (class 1259 OID 1614055)
-- Name: ix_st_dt_rcb_pfc; Type: INDEX; Schema: sc_fcr; Owner: scan
--

CREATE INDEX ix_st_dt_rcb_pfc ON tbl_pfc USING btree (st_pfc, dt_rcb_pfc);


SET search_path = sc_fsc, pg_catalog;

--
-- TOC entry 5964 (class 1259 OID 830270)
-- Name: ix_psr; Type: INDEX; Schema: sc_fsc; Owner: scan
--

CREATE INDEX ix_psr ON tbl_psr USING btree (cnpj_psr);


--
-- TOC entry 5967 (class 1259 OID 830271)
-- Name: ix_rps; Type: INDEX; Schema: sc_fsc; Owner: scan
--

CREATE INDEX ix_rps ON tbl_rps USING btree (cd_rps);


--
-- TOC entry 5970 (class 1259 OID 830272)
-- Name: ix_srv; Type: INDEX; Schema: sc_fsc; Owner: scan
--

CREATE INDEX ix_srv ON tbl_srv USING btree (cd_srv);


--
-- TOC entry 5973 (class 1259 OID 830273)
-- Name: ix_tsr; Type: INDEX; Schema: sc_fsc; Owner: scan
--

CREATE INDEX ix_tsr ON tbl_tsr USING btree (cpj_tsr);


SET search_path = sc_mgr, pg_catalog;

--
-- TOC entry 5990 (class 1259 OID 830274)
-- Name: ix_dvd_cpf; Type: INDEX; Schema: sc_mgr; Owner: scan
--

CREATE INDEX ix_dvd_cpf ON tbl_dvd USING btree (nr_cpf_dvd);


--
-- TOC entry 5991 (class 1259 OID 830275)
-- Name: ix_dvd_nr_nsu; Type: INDEX; Schema: sc_mgr; Owner: scan
--

CREATE INDEX ix_dvd_nr_nsu ON tbl_dvd USING btree (nr_nsu_dvd);


SET search_path = sc_msg, pg_catalog;

--
-- TOC entry 6330 (class 1259 OID 1013350)
-- Name: ix_msg_cvm; Type: INDEX; Schema: sc_msg; Owner: scan
--

CREATE INDEX ix_msg_cvm ON tbl_cvm USING btree (tp_org_cvm, nsu_org_cvm);


SET search_path = sc_opr, pg_catalog;

SET default_tablespace = ts_scan_i;

--
-- TOC entry 6024 (class 1259 OID 1667742)
-- Name: idx_hlm_dt_inc; Type: INDEX; Schema: sc_opr; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX idx_hlm_dt_inc ON tbl_hlm USING btree (dt_inc_usr);


--
-- TOC entry 6025 (class 1259 OID 1667741)
-- Name: idx_tbl_hlm_cd_crt; Type: INDEX; Schema: sc_opr; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX idx_tbl_hlm_cd_crt ON tbl_hlm USING btree (cd_crt);


SET default_tablespace = '';

--
-- TOC entry 5901 (class 1259 OID 830276)
-- Name: ix_cd_ctr_tbl_crt; Type: INDEX; Schema: sc_opr; Owner: scan
--

CREATE INDEX ix_cd_ctr_tbl_crt ON tbl_crt USING btree (cd_ctr);


--
-- TOC entry 6010 (class 1259 OID 830277)
-- Name: ix_cnt_crt_crt; Type: INDEX; Schema: sc_opr; Owner: scan
--

CREATE INDEX ix_cnt_crt_crt ON tbl_cnt_crt USING btree (cd_crt);


--
-- TOC entry 5902 (class 1259 OID 830278)
-- Name: ix_crt_fcr; Type: INDEX; Schema: sc_opr; Owner: scan
--

CREATE INDEX ix_crt_fcr ON tbl_crt USING btree (cd_fcr);


--
-- TOC entry 5903 (class 1259 OID 830279)
-- Name: ix_crt_fnc; Type: INDEX; Schema: sc_opr; Owner: scan
--

CREATE INDEX ix_crt_fnc ON tbl_crt USING btree (cd_fnc);


--
-- TOC entry 6028 (class 1259 OID 830280)
-- Name: ix_crt_tlt; Type: INDEX; Schema: sc_opr; Owner: scan
--

CREATE UNIQUE INDEX ix_crt_tlt ON tbl_lmt USING btree (cd_crt, cd_tlt);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6015 (class 1259 OID 1040658)
-- Name: ix_dos_opr; Type: INDEX; Schema: sc_opr; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_dos_opr ON tbl_dos USING btree (cd_opr);


SET default_tablespace = '';

--
-- TOC entry 6029 (class 1259 OID 830281)
-- Name: ix_lmt_crt; Type: INDEX; Schema: sc_opr; Owner: scan
--

CREATE INDEX ix_lmt_crt ON tbl_lmt USING btree (cd_crt);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6032 (class 1259 OID 1029697)
-- Name: ix_ocr_crt; Type: INDEX; Schema: sc_opr; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_ocr_crt ON tbl_ocr USING btree (cd_crt);


SET default_tablespace = '';

--
-- TOC entry 5906 (class 1259 OID 830282)
-- Name: ix_opr_pls; Type: INDEX; Schema: sc_opr; Owner: scan
--

CREATE INDEX ix_opr_pls ON tbl_opr USING btree (cd_pls);


--
-- TOC entry 5907 (class 1259 OID 1614080)
-- Name: ix_opr_st_opr_top; Type: INDEX; Schema: sc_opr; Owner: scan
--

CREATE INDEX ix_opr_st_opr_top ON tbl_opr USING btree (cd_top, st_opr);


--
-- TOC entry 5910 (class 1259 OID 830283)
-- Name: ix_pls_crt; Type: INDEX; Schema: sc_opr; Owner: scan
--

CREATE INDEX ix_pls_crt ON tbl_pls USING btree (cd_crt);


--
-- TOC entry 5911 (class 1259 OID 830284)
-- Name: ix_pls_cun; Type: INDEX; Schema: sc_opr; Owner: scan
--

CREATE INDEX ix_pls_cun ON tbl_pls USING btree (cd_cun);


--
-- TOC entry 6033 (class 1259 OID 1614044)
-- Name: ix_toc_dt_inc; Type: INDEX; Schema: sc_opr; Owner: scan
--

CREATE INDEX ix_toc_dt_inc ON tbl_ocr USING btree (cd_toc, dt_inc_usr);


--
-- TOC entry 6056 (class 1259 OID 830285)
-- Name: ix_top_atm; Type: INDEX; Schema: sc_opr; Owner: scan
--

CREATE INDEX ix_top_atm ON tbl_top_atm USING btree (cd_atm, cd_top);


SET search_path = sc_pgc, pg_catalog;

SET default_tablespace = ts_scan_i;

--
-- TOC entry 6484 (class 1259 OID 1004317)
-- Name: ix_cd_pgt; Type: INDEX; Schema: sc_pgc; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_cd_pgt ON tbl_lgt USING btree (cd_pgt);


--
-- TOC entry 6485 (class 1259 OID 1073535)
-- Name: ix_pgt_dt_pgt; Type: INDEX; Schema: sc_pgc; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_pgt_dt_pgt ON tbl_lgt USING btree (dt_env_lgt);


SET search_path = sc_rdc, pg_catalog;

SET default_tablespace = '';

--
-- TOC entry 6097 (class 1259 OID 1654362)
-- Name: ix_fet_nr_lgc; Type: INDEX; Schema: sc_rdc; Owner: scan
--

CREATE INDEX ix_fet_nr_lgc ON tbl_fet USING btree (nr_lgc_fet);


--
-- TOC entry 6098 (class 1259 OID 1654363)
-- Name: ix_fet_nr_lgc_cie; Type: INDEX; Schema: sc_rdc; Owner: scan
--

CREATE INDEX ix_fet_nr_lgc_cie ON tbl_fet USING btree (nr_lgc_cel_fet);


SET default_tablespace = ts_scan_i;

--
-- TOC entry 6103 (class 1259 OID 1639151)
-- Name: ix_pet_opr; Type: INDEX; Schema: sc_rdc; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_pet_opr ON tbl_pet USING btree (cd_opr);


SET default_tablespace = '';

--
-- TOC entry 6110 (class 1259 OID 1639152)
-- Name: ix_rqs_opr; Type: INDEX; Schema: sc_rdc; Owner: scan
--

CREATE INDEX ix_rqs_opr ON tbl_rqs USING btree (cd_opr);


--
-- TOC entry 6111 (class 1259 OID 1639159)
-- Name: ix_rqs_tp_rqs; Type: INDEX; Schema: sc_rdc; Owner: scan
--

CREATE INDEX ix_rqs_tp_rqs ON tbl_rqs USING btree (tp_rqs);


SET search_path = sc_rds, pg_catalog;

--
-- TOC entry 6156 (class 1259 OID 830286)
-- Name: ix_rqa_dtrqa; Type: INDEX; Schema: sc_rds; Owner: scan
--

CREATE INDEX ix_rqa_dtrqa ON tbl_rqa USING btree (dt_rqa DESC);


--
-- TOC entry 6157 (class 1259 OID 830287)
-- Name: ix_rqa_opr_top; Type: INDEX; Schema: sc_rds; Owner: scan
--

CREATE INDEX ix_rqa_opr_top ON tbl_rqa USING btree (cd_opr, cd_top);


SET search_path = sc_sgr, pg_catalog;

SET default_tablespace = ts_scan_i;

--
-- TOC entry 6326 (class 1259 OID 1667744)
-- Name: idx_spl_dt_inc; Type: INDEX; Schema: sc_sgr; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX idx_spl_dt_inc ON tbl_spl USING btree (dt_inc_spl);


--
-- TOC entry 6567 (class 1259 OID 1665867)
-- Name: idx_tkn_lur; Type: INDEX; Schema: sc_sgr; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX idx_tkn_lur ON tbl_lur USING btree (tkn_lur);


SET default_tablespace = '';

--
-- TOC entry 5726 (class 1259 OID 932146)
-- Name: ix_eus_tp_usr; Type: INDEX; Schema: sc_sgr; Owner: scan
--

CREATE INDEX ix_eus_tp_usr ON tbl_eus USING btree (cd_usr, tp_eus);


--
-- TOC entry 6180 (class 1259 OID 932154)
-- Name: ix_grp_rol_grp; Type: INDEX; Schema: sc_sgr; Owner: scan
--

CREATE INDEX ix_grp_rol_grp ON tbl_grp_rol USING btree (cd_grp);


--
-- TOC entry 6210 (class 1259 OID 932148)
-- Name: ix_grp_usr; Type: INDEX; Schema: sc_sgr; Owner: scan
--

CREATE INDEX ix_grp_usr ON tbl_usr_grp USING btree (cd_usr);


--
-- TOC entry 5727 (class 1259 OID 932153)
-- Name: ix_nsu_eus; Type: INDEX; Schema: sc_sgr; Owner: scan
--

CREATE INDEX ix_nsu_eus ON tbl_eus USING btree (nsu_eus);


--
-- TOC entry 6189 (class 1259 OID 932159)
-- Name: ix_rol_sis; Type: INDEX; Schema: sc_sgr; Owner: scan
--

CREATE INDEX ix_rol_sis ON tbl_rol_sis USING btree (cd_sis, cd_rol);


--
-- TOC entry 6327 (class 1259 OID 1013348)
-- Name: ix_tp_org_nsu_org_spl; Type: INDEX; Schema: sc_sgr; Owner: scan
--

CREATE INDEX ix_tp_org_nsu_org_spl ON tbl_spl USING btree (tp_nsu_org_spl, nsu_org_spl, mac_add_spl);


SET search_path = sc_srv, pg_catalog;

--
-- TOC entry 6237 (class 1259 OID 877299)
-- Name: ix_scr_srv_crt; Type: INDEX; Schema: sc_srv; Owner: scan
--

CREATE INDEX ix_scr_srv_crt ON tbl_scr USING btree (cd_crt, cd_srv);


--
-- TOC entry 6248 (class 1259 OID 1614082)
-- Name: ix_tsc_opr; Type: INDEX; Schema: sc_srv; Owner: scan
--

CREATE INDEX ix_tsc_opr ON tbl_tsc USING btree (cd_opr);


--
-- TOC entry 6249 (class 1259 OID 877300)
-- Name: ix_tsc_tmc; Type: INDEX; Schema: sc_srv; Owner: scan
--

CREATE INDEX ix_tsc_tmc ON tbl_tsc USING btree (cd_srv, cd_crt, st_tsc);


SET search_path = sc_ssp, pg_catalog;

SET default_tablespace = ts_scan_i;

--
-- TOC entry 6254 (class 1259 OID 888190)
-- Name: ix_daep_pls; Type: INDEX; Schema: sc_ssp; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_daep_pls ON tbl_daep USING btree (cd_pls);


--
-- TOC entry 6255 (class 1259 OID 888189)
-- Name: ix_daep_ssp; Type: INDEX; Schema: sc_ssp; Owner: scan; Tablespace: ts_scan_i
--

CREATE INDEX ix_daep_ssp ON tbl_daep USING btree (cd_ssp);


SET default_tablespace = '';

--
-- TOC entry 6264 (class 1259 OID 1614079)
-- Name: ix_ssp_pls; Type: INDEX; Schema: sc_ssp; Owner: scan
--

CREATE INDEX ix_ssp_pls ON tbl_ssp USING btree (cd_pls);


SET search_path = sc_cad, pg_catalog;

--
-- TOC entry 7334 (class 2620 OID 830288)
-- Name: tg_ctr_update; Type: TRIGGER; Schema: sc_cad; Owner: scan
--

CREATE TRIGGER tg_ctr_update BEFORE UPDATE ON tbl_ctr FOR EACH ROW EXECUTE PROCEDURE sc_trg.tg_ctr_update();


--
-- TOC entry 7335 (class 2620 OID 830289)
-- Name: tg_fnc_update; Type: TRIGGER; Schema: sc_cad; Owner: scan
--

CREATE TRIGGER tg_fnc_update BEFORE UPDATE ON tbl_fnc FOR EACH ROW EXECUTE PROCEDURE sc_trg.tg_fnc_update();


--
-- TOC entry 7336 (class 2620 OID 830290)
-- Name: tg_pce_ctr_update; Type: TRIGGER; Schema: sc_cad; Owner: scan
--

CREATE TRIGGER tg_pce_ctr_update BEFORE UPDATE ON tbl_pce_ctr FOR EACH ROW EXECUTE PROCEDURE sc_trg.tg_pce_ctr_update();


--
-- TOC entry 7337 (class 2620 OID 830291)
-- Name: tg_tlt_ctr_update; Type: TRIGGER; Schema: sc_cad; Owner: scan
--

CREATE TRIGGER tg_tlt_ctr_update BEFORE UPDATE ON tbl_tlt_ctr FOR EACH ROW EXECUTE PROCEDURE sc_trg.tg_tlt_ctr_update();


--
-- TOC entry 7333 (class 2620 OID 1025367)
-- Name: trg_tlf; Type: TRIGGER; Schema: sc_cad; Owner: scan
--

CREATE TRIGGER trg_tlf BEFORE UPDATE ON tbl_tlf FOR EACH ROW EXECUTE PROCEDURE sc_trg.tg_tlf_update();


SET search_path = sc_rdc, pg_catalog;

--
-- TOC entry 7338 (class 2620 OID 1672241)
-- Name: tg_fet_update; Type: TRIGGER; Schema: sc_rdc; Owner: scan
--

CREATE TRIGGER tg_fet_update BEFORE UPDATE ON tbl_fet FOR EACH ROW EXECUTE PROCEDURE sc_trg.tg_fet_update();


SET search_path = sc__buxo, pg_catalog;

--
-- TOC entry 7279 (class 2606 OID 999588)
-- Name: fk_cbf_bnc; Type: FK CONSTRAINT; Schema: sc__buxo; Owner: postgres
--

ALTER TABLE ONLY tbl_cbf_aux
    ADD CONSTRAINT fk_cbf_bnc FOREIGN KEY (cd_bnc) REFERENCES sc_fin.tbl_bnc(cd_bnc);


--
-- TOC entry 6620 (class 2606 OID 830292)
-- Name: fk_dvd_crt; Type: FK CONSTRAINT; Schema: sc__buxo; Owner: scan
--

ALTER TABLE ONLY tbl_dvd
    ADD CONSTRAINT fk_dvd_crt FOREIGN KEY (cartao) REFERENCES sc_opr.tbl_crt(cd_crt);


SET search_path = sc_acc, pg_catalog;

--
-- TOC entry 6621 (class 2606 OID 830297)
-- Name: FK_HDR_USRINC; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_hdr
    ADD CONSTRAINT "FK_HDR_USRINC" FOREIGN KEY (cd_rcb_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6629 (class 2606 OID 830302)
-- Name: fk_fem_tfe; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_tfe
    ADD CONSTRAINT fk_fem_tfe FOREIGN KEY (cd_emp, cd_fem) REFERENCES sc_cad.tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 6622 (class 2606 OID 830307)
-- Name: fk_hdr_emp; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_hdr
    ADD CONSTRAINT fk_hdr_emp FOREIGN KEY (cd_emp) REFERENCES sc_cad.tbl_emp(cd_emp);


--
-- TOC entry 6585 (class 2606 OID 830312)
-- Name: fk_hfe_fem; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT fk_hfe_fem FOREIGN KEY (cd_emp, cd_fem) REFERENCES sc_cad.tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 6586 (class 2606 OID 830317)
-- Name: fk_hfe_hdr; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT fk_hfe_hdr FOREIGN KEY (cd_hdr) REFERENCES tbl_hdr(cd_hdr);


--
-- TOC entry 6587 (class 2606 OID 830322)
-- Name: fk_hfe_prd; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT fk_hfe_prd FOREIGN KEY (cd_prd) REFERENCES sc_cad.tbl_prd(cd_prd);


--
-- TOC entry 6581 (class 2606 OID 830327)
-- Name: fk_rct_crt; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_rct
    ADD CONSTRAINT fk_rct_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6582 (class 2606 OID 830332)
-- Name: fk_rct_hdr; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_rct
    ADD CONSTRAINT fk_rct_hdr FOREIGN KEY (cd_hdr) REFERENCES tbl_hdr(cd_hdr);


--
-- TOC entry 6583 (class 2606 OID 830337)
-- Name: fk_rct_hfe; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_rct
    ADD CONSTRAINT fk_rct_hfe FOREIGN KEY (cd_hfe) REFERENCES tbl_hfe(cd_hfe);


--
-- TOC entry 6584 (class 2606 OID 830342)
-- Name: fk_rct_pls; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_rct
    ADD CONSTRAINT fk_rct_pls FOREIGN KEY (cd_pls) REFERENCES sc_opr.tbl_pls(cd_pls);


--
-- TOC entry 6623 (class 2606 OID 830347)
-- Name: fk_red_edr; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_red
    ADD CONSTRAINT fk_red_edr FOREIGN KEY (cd_edr) REFERENCES sc_cad.tbl_edr(cd_edr);


--
-- TOC entry 6624 (class 2606 OID 830352)
-- Name: fk_red_hdr; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_red
    ADD CONSTRAINT fk_red_hdr FOREIGN KEY (cd_hdr) REFERENCES tbl_hdr(cd_hdr);


--
-- TOC entry 6625 (class 2606 OID 830357)
-- Name: fk_red_hfe; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_red
    ADD CONSTRAINT fk_red_hfe FOREIGN KEY (cd_hfe) REFERENCES tbl_hfe(cd_hfe);


--
-- TOC entry 6626 (class 2606 OID 830362)
-- Name: fk_rtl_hdr; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_rtl
    ADD CONSTRAINT fk_rtl_hdr FOREIGN KEY (cd_hdr) REFERENCES tbl_hdr(cd_hdr);


--
-- TOC entry 6627 (class 2606 OID 830367)
-- Name: fk_rtl_hfe; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_rtl
    ADD CONSTRAINT fk_rtl_hfe FOREIGN KEY (cd_hfe) REFERENCES tbl_hfe(cd_hfe);


--
-- TOC entry 6628 (class 2606 OID 830372)
-- Name: fk_rtl_tlf; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_rtl
    ADD CONSTRAINT fk_rtl_tlf FOREIGN KEY (cd_tlf) REFERENCES sc_cad.tbl_tlf(cd_tlf);


--
-- TOC entry 6630 (class 2606 OID 830377)
-- Name: fk_tfe_hdr; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_tfe
    ADD CONSTRAINT fk_tfe_hdr FOREIGN KEY (cd_hdr) REFERENCES tbl_hdr(cd_hdr);


--
-- TOC entry 6631 (class 2606 OID 830382)
-- Name: fk_tfe_hfe; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_tfe
    ADD CONSTRAINT fk_tfe_hfe FOREIGN KEY (cd_hfe) REFERENCES tbl_hfe(cd_hfe);


--
-- TOC entry 6632 (class 2606 OID 830387)
-- Name: fk_tfe_prd; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_tfe
    ADD CONSTRAINT fk_tfe_prd FOREIGN KEY (cd_prd) REFERENCES sc_cad.tbl_prd(cd_prd);


--
-- TOC entry 6633 (class 2606 OID 830392)
-- Name: fk_trl_emp; Type: FK CONSTRAINT; Schema: sc_acc; Owner: scan
--

ALTER TABLE ONLY tbl_trl
    ADD CONSTRAINT fk_trl_emp FOREIGN KEY (cd_emp) REFERENCES sc_cad.tbl_emp(cd_emp);


SET search_path = sc_ace, pg_catalog;

--
-- TOC entry 6634 (class 2606 OID 830397)
-- Name: FK_HDR_OBOE_USRINC; Type: FK CONSTRAINT; Schema: sc_ace; Owner: scan
--

ALTER TABLE ONLY tbl_hdr_oboe
    ADD CONSTRAINT "FK_HDR_OBOE_USRINC" FOREIGN KEY (cd_rcb_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6588 (class 2606 OID 964541)
-- Name: fk_det_oboe_hdr; Type: FK CONSTRAINT; Schema: sc_ace; Owner: scan
--

ALTER TABLE ONLY tbl_det_oboe
    ADD CONSTRAINT fk_det_oboe_hdr FOREIGN KEY (cd_hdr_oboe) REFERENCES tbl_hdr_oboe(cd_hdr_oboe);


--
-- TOC entry 6635 (class 2606 OID 830407)
-- Name: fk_hdr_oboe_emp; Type: FK CONSTRAINT; Schema: sc_ace; Owner: scan
--

ALTER TABLE ONLY tbl_hdr_oboe
    ADD CONSTRAINT fk_hdr_oboe_emp FOREIGN KEY (cd_emp) REFERENCES sc_cad.tbl_emp(cd_emp);


--
-- TOC entry 6636 (class 2606 OID 830412)
-- Name: fk_hdr_oboe_fem; Type: FK CONSTRAINT; Schema: sc_ace; Owner: scan
--

ALTER TABLE ONLY tbl_hdr_oboe
    ADD CONSTRAINT fk_hdr_oboe_fem FOREIGN KEY (cd_emp, cd_fem) REFERENCES sc_cad.tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 6637 (class 2606 OID 830417)
-- Name: fk_hdr_oboe_hdr; Type: FK CONSTRAINT; Schema: sc_ace; Owner: scan
--

ALTER TABLE ONLY tbl_hdr_oboe
    ADD CONSTRAINT fk_hdr_oboe_hdr FOREIGN KEY (cd_hdr) REFERENCES sc_acc.tbl_hdr(cd_hdr);


SET search_path = sc_adp, pg_catalog;

--
-- TOC entry 6643 (class 2606 OID 830422)
-- Name: fg_add_hfe; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_add
    ADD CONSTRAINT fg_add_hfe FOREIGN KEY (cd_hfe) REFERENCES tbl_hfe(cd_hfe);


--
-- TOC entry 6644 (class 2606 OID 830427)
-- Name: fg_add_usrinc; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_add
    ADD CONSTRAINT fg_add_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6638 (class 2606 OID 830432)
-- Name: fk_adp_prd; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY old_tbl_adp
    ADD CONSTRAINT fk_adp_prd FOREIGN KEY (cd_prd) REFERENCES sc_cad.tbl_prd(cd_prd);


--
-- TOC entry 6640 (class 2606 OID 830437)
-- Name: fk_ddp_adp; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY old_tbl_ddp
    ADD CONSTRAINT fk_ddp_adp FOREIGN KEY (cd_adp) REFERENCES old_tbl_adp(cd_adp);


--
-- TOC entry 6641 (class 2606 OID 830442)
-- Name: fk_ddp_crt; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY old_tbl_ddp
    ADD CONSTRAINT fk_ddp_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6642 (class 2606 OID 830447)
-- Name: fk_ddp_tdp; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY old_tbl_ddp
    ADD CONSTRAINT fk_ddp_tdp FOREIGN KEY (cd_tdp) REFERENCES tbl_tdp(cd_tdp);


--
-- TOC entry 6639 (class 2606 OID 830452)
-- Name: fk_fem_adp; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY old_tbl_adp
    ADD CONSTRAINT fk_fem_adp FOREIGN KEY (cd_emp, cd_fem) REFERENCES sc_cad.tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 6645 (class 2606 OID 830457)
-- Name: fk_hdr_emp; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hdr
    ADD CONSTRAINT fk_hdr_emp FOREIGN KEY (cd_emp) REFERENCES sc_cad.tbl_emp(cd_emp);


--
-- TOC entry 6649 (class 2606 OID 830462)
-- Name: fk_hdr_emp; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hdr_tmp
    ADD CONSTRAINT fk_hdr_emp FOREIGN KEY (cd_emp) REFERENCES sc_cad.tbl_emp(cd_emp);


--
-- TOC entry 6650 (class 2606 OID 830467)
-- Name: fk_hdr_fem; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hdr_tmp
    ADD CONSTRAINT fk_hdr_fem FOREIGN KEY (cd_emp, cd_fem) REFERENCES sc_cad.tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 6646 (class 2606 OID 830472)
-- Name: fk_hdr_prd; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hdr
    ADD CONSTRAINT fk_hdr_prd FOREIGN KEY (cd_prd) REFERENCES sc_cad.tbl_prd(cd_prd);


--
-- TOC entry 6647 (class 2606 OID 830477)
-- Name: fk_hdr_usrcnc; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hdr
    ADD CONSTRAINT fk_hdr_usrcnc FOREIGN KEY (cd_cnc_hdr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6648 (class 2606 OID 830482)
-- Name: fk_hdr_usrrcb; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hdr
    ADD CONSTRAINT fk_hdr_usrrcb FOREIGN KEY (cd_rcb_hdr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6651 (class 2606 OID 830487)
-- Name: fk_hfe_ctr; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT fk_hfe_ctr FOREIGN KEY (cd_ctr) REFERENCES sc_cad.tbl_ctr(cd_ctr);


--
-- TOC entry 6652 (class 2606 OID 830492)
-- Name: fk_hfe_fem; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT fk_hfe_fem FOREIGN KEY (cd_emp, cd_fem) REFERENCES sc_cad.tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 6666 (class 2606 OID 830497)
-- Name: fk_hfe_fem; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_tfe
    ADD CONSTRAINT fk_hfe_fem FOREIGN KEY (cd_emp, cd_fem) REFERENCES sc_cad.tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 6653 (class 2606 OID 830502)
-- Name: fk_hfe_hdr; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT fk_hfe_hdr FOREIGN KEY (cd_hdr) REFERENCES tbl_hdr(cd_hdr);


--
-- TOC entry 6659 (class 2606 OID 830507)
-- Name: fk_hfe_hdr; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_rdp
    ADD CONSTRAINT fk_hfe_hdr FOREIGN KEY (cd_hdr) REFERENCES tbl_hdr(cd_hdr);


--
-- TOC entry 6654 (class 2606 OID 830512)
-- Name: fk_hfe_tdp; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT fk_hfe_tdp FOREIGN KEY (cd_tdp) REFERENCES tbl_tdp(cd_tdp);


--
-- TOC entry 6655 (class 2606 OID 830517)
-- Name: fk_hfe_usr_agd; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT fk_hfe_usr_agd FOREIGN KEY (cd_usr_agd_hfe) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6656 (class 2606 OID 830522)
-- Name: fk_hfe_usr_cnc_agd; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT fk_hfe_usr_cnc_agd FOREIGN KEY (cd_cnc_agd_hfe) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6658 (class 2606 OID 861987)
-- Name: fk_hfe_usr_vld; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT fk_hfe_usr_vld FOREIGN KEY (cd_usr_vld_hfe) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6657 (class 2606 OID 830527)
-- Name: fk_hfe_usrcnc; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_hfe
    ADD CONSTRAINT fk_hfe_usrcnc FOREIGN KEY (cd_cnc_hfe) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6660 (class 2606 OID 830532)
-- Name: fk_rct_hfe; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_rdp
    ADD CONSTRAINT fk_rct_hfe FOREIGN KEY (cd_hfe) REFERENCES tbl_hfe(cd_hfe);


--
-- TOC entry 6661 (class 2606 OID 830537)
-- Name: fk_rdp_crt; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_rdp
    ADD CONSTRAINT fk_rdp_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6663 (class 2606 OID 830542)
-- Name: fk_rdp_crt; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_rdp_tmp
    ADD CONSTRAINT fk_rdp_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6662 (class 2606 OID 830547)
-- Name: fk_rdp_tdp; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_rdp
    ADD CONSTRAINT fk_rdp_tdp FOREIGN KEY (cd_tdp) REFERENCES tbl_tdp(cd_tdp);


--
-- TOC entry 6664 (class 2606 OID 830552)
-- Name: fk_rdp_tmp_hdr; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_rdp_tmp
    ADD CONSTRAINT fk_rdp_tmp_hdr FOREIGN KEY (cd_hdr) REFERENCES tbl_hdr_tmp(cd_hdr);


--
-- TOC entry 6665 (class 2606 OID 830557)
-- Name: fk_tdp_tlc; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_tdp
    ADD CONSTRAINT fk_tdp_tlc FOREIGN KEY (cd_tlc) REFERENCES sc_cnt.tbl_tlc(cd_tlc);


--
-- TOC entry 6667 (class 2606 OID 830562)
-- Name: fk_tfe_hdr; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_tfe
    ADD CONSTRAINT fk_tfe_hdr FOREIGN KEY (cd_hdr) REFERENCES tbl_hdr(cd_hdr);


--
-- TOC entry 6668 (class 2606 OID 830567)
-- Name: fk_tfe_hfe; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_tfe
    ADD CONSTRAINT fk_tfe_hfe FOREIGN KEY (cd_hfe) REFERENCES tbl_hfe(cd_hfe);


--
-- TOC entry 6669 (class 2606 OID 830572)
-- Name: fk_trl_emp; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_trl
    ADD CONSTRAINT fk_trl_emp FOREIGN KEY (cd_emp) REFERENCES sc_cad.tbl_emp(cd_emp);


--
-- TOC entry 6670 (class 2606 OID 830577)
-- Name: fk_trl_hdr; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_trl
    ADD CONSTRAINT fk_trl_hdr FOREIGN KEY (cd_hdr) REFERENCES tbl_hdr(cd_hdr);


--
-- TOC entry 6671 (class 2606 OID 830582)
-- Name: fk_trl_prd; Type: FK CONSTRAINT; Schema: sc_adp; Owner: scan
--

ALTER TABLE ONLY tbl_trl
    ADD CONSTRAINT fk_trl_prd FOREIGN KEY (cd_prd) REFERENCES sc_cad.tbl_prd(cd_prd);


SET search_path = sc_aeo, pg_catalog;

--
-- TOC entry 6672 (class 2606 OID 830587)
-- Name: fk_eop_aeop; Type: FK CONSTRAINT; Schema: sc_aeo; Owner: scan
--

ALTER TABLE ONLY tbl_eop
    ADD CONSTRAINT fk_eop_aeop FOREIGN KEY (cd_aeop) REFERENCES tbl_aeop(cd_aeop);


SET search_path = sc_atb, pg_catalog;

--
-- TOC entry 6600 (class 2606 OID 830592)
-- Name: fk_art_bnc; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_art
    ADD CONSTRAINT fk_art_bnc FOREIGN KEY (cd_bnc) REFERENCES sc_fin.tbl_bnc(cd_bnc);


--
-- TOC entry 6601 (class 2606 OID 830597)
-- Name: fk_art_usr; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_art
    ADD CONSTRAINT fk_art_usr FOREIGN KEY (cd_rcb_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6597 (class 2606 OID 830602)
-- Name: fk_atb_ccr; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_atb
    ADD CONSTRAINT fk_atb_ccr FOREIGN KEY (cd_ccr) REFERENCES sc_fin.tbl_ccr(cd_ccr);


--
-- TOC entry 6602 (class 2606 OID 830607)
-- Name: fk_drt_art; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_drt
    ADD CONSTRAINT fk_drt_art FOREIGN KEY (cd_art) REFERENCES tbl_art(cd_art);


--
-- TOC entry 6603 (class 2606 OID 830612)
-- Name: fk_drt_bnc; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_drt
    ADD CONSTRAINT fk_drt_bnc FOREIGN KEY (cd_bnc) REFERENCES sc_fin.tbl_bnc(cd_bnc);


--
-- TOC entry 6604 (class 2606 OID 830617)
-- Name: fk_drt_hlt; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_drt
    ADD CONSTRAINT fk_drt_hlt FOREIGN KEY (cd_hlt) REFERENCES tbl_hlt(cd_hlt);


--
-- TOC entry 6605 (class 2606 OID 830622)
-- Name: fk_drt_ort; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_drt
    ADD CONSTRAINT fk_drt_ort FOREIGN KEY (cd_ort) REFERENCES tbl_ort(cd_ort);


--
-- TOC entry 6595 (class 2606 OID 830627)
-- Name: fk_dtb_atb; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_dtb
    ADD CONSTRAINT fk_dtb_atb FOREIGN KEY (cd_atb) REFERENCES tbl_atb(cd_atb);


--
-- TOC entry 6596 (class 2606 OID 830632)
-- Name: fk_dtb_bnc; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_dtb
    ADD CONSTRAINT fk_dtb_bnc FOREIGN KEY (cd_bnc) REFERENCES sc_fin.tbl_bnc(cd_bnc);


--
-- TOC entry 6673 (class 2606 OID 830637)
-- Name: fk_etb_ctr; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_etb
    ADD CONSTRAINT fk_etb_ctr FOREIGN KEY (cd_ctr) REFERENCES sc_cad.tbl_ctr(cd_ctr);


--
-- TOC entry 6674 (class 2606 OID 830642)
-- Name: fk_etb_tba; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_etb
    ADD CONSTRAINT fk_etb_tba FOREIGN KEY (cd_tba) REFERENCES tbl_tba(cd_tba);


--
-- TOC entry 6675 (class 2606 OID 830647)
-- Name: fk_hlt_art; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_hlt
    ADD CONSTRAINT fk_hlt_art FOREIGN KEY (cd_art) REFERENCES tbl_art(cd_art);


--
-- TOC entry 6676 (class 2606 OID 830652)
-- Name: fk_tba_bnc; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tba
    ADD CONSTRAINT fk_tba_bnc FOREIGN KEY (cd_bnc) REFERENCES sc_fin.tbl_bnc(cd_bnc);


--
-- TOC entry 6677 (class 2606 OID 830657)
-- Name: fk_tba_ccr; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tba
    ADD CONSTRAINT fk_tba_ccr FOREIGN KEY (cd_ccr) REFERENCES sc_fin.tbl_ccr(cd_ccr);


--
-- TOC entry 6678 (class 2606 OID 830662)
-- Name: fk_tba_cnt_crd; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tba
    ADD CONSTRAINT fk_tba_cnt_crd FOREIGN KEY (cd_crd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6679 (class 2606 OID 830667)
-- Name: fk_tba_cnt_dbt; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tba
    ADD CONSTRAINT fk_tba_cnt_dbt FOREIGN KEY (cd_dbt_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6680 (class 2606 OID 830672)
-- Name: fk_tba_dtb; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tba
    ADD CONSTRAINT fk_tba_dtb FOREIGN KEY (cd_dtb) REFERENCES tbl_dtb(cd_dtb);


--
-- TOC entry 6681 (class 2606 OID 830677)
-- Name: fk_tba_fep; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tba
    ADD CONSTRAINT fk_tba_fep FOREIGN KEY (cd_fep) REFERENCES sc_fep.tbl_fep(cd_fep);


--
-- TOC entry 6682 (class 2606 OID 830682)
-- Name: fk_tba_sst; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tba
    ADD CONSTRAINT fk_tba_sst FOREIGN KEY (cd_sst) REFERENCES sc_cnt.tbl_sst(cd_sst);


--
-- TOC entry 6683 (class 2606 OID 830687)
-- Name: fk_tba_usr_aut; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tba
    ADD CONSTRAINT fk_tba_usr_aut FOREIGN KEY (cd_aut_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6684 (class 2606 OID 830692)
-- Name: fk_tba_usr_cnc; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tba
    ADD CONSTRAINT fk_tba_usr_cnc FOREIGN KEY (cd_cnc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6685 (class 2606 OID 830697)
-- Name: fk_tba_usr_inc; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tba
    ADD CONSTRAINT fk_tba_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6686 (class 2606 OID 830702)
-- Name: fk_tlt_art; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tlt
    ADD CONSTRAINT fk_tlt_art FOREIGN KEY (cd_art) REFERENCES tbl_art(cd_art);


--
-- TOC entry 6687 (class 2606 OID 830707)
-- Name: fk_tlt_hlt; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_tlt
    ADD CONSTRAINT fk_tlt_hlt FOREIGN KEY (cd_hlt) REFERENCES tbl_hlt(cd_hlt);


--
-- TOC entry 6688 (class 2606 OID 830712)
-- Name: fk_trt_art; Type: FK CONSTRAINT; Schema: sc_atb; Owner: scan
--

ALTER TABLE ONLY tbl_trt
    ADD CONSTRAINT fk_trt_art FOREIGN KEY (cd_art) REFERENCES tbl_art(cd_art);


SET search_path = sc_cad, pg_catalog;

--
-- TOC entry 6714 (class 2606 OID 830717)
-- Name: FK_CUN_USRALT; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cun
    ADD CONSTRAINT "FK_CUN_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6723 (class 2606 OID 1035050)
-- Name: FK_CUN_USRALT; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fem
    ADD CONSTRAINT "FK_CUN_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6715 (class 2606 OID 830727)
-- Name: FK_CUN_USRINC; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cun
    ADD CONSTRAINT "FK_CUN_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6724 (class 2606 OID 1035055)
-- Name: FK_CUN_USRINC; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fem
    ADD CONSTRAINT "FK_CUN_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6589 (class 2606 OID 830737)
-- Name: FK_EDR_USRALT; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_edr
    ADD CONSTRAINT "FK_EDR_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6590 (class 2606 OID 830742)
-- Name: FK_EDR_USRINC; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_edr
    ADD CONSTRAINT "FK_EDR_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6719 (class 2606 OID 830747)
-- Name: FK_EMP_USRALT; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_emp
    ADD CONSTRAINT "FK_EMP_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6720 (class 2606 OID 830752)
-- Name: FK_EMP_USRINC; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_emp
    ADD CONSTRAINT "FK_EMP_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6733 (class 2606 OID 830757)
-- Name: FK_FNC_CUN; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fnc
    ADD CONSTRAINT "FK_FNC_CUN" FOREIGN KEY (cd_cun) REFERENCES tbl_cun(cd_cun);


--
-- TOC entry 6734 (class 2606 OID 830762)
-- Name: FK_FNC_USRALT; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fnc
    ADD CONSTRAINT "FK_FNC_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6735 (class 2606 OID 830767)
-- Name: FK_FNC_USRINC; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fnc
    ADD CONSTRAINT "FK_FNC_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6737 (class 2606 OID 830772)
-- Name: FK_GEM_USRALT; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_gem
    ADD CONSTRAINT "FK_GEM_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6738 (class 2606 OID 830777)
-- Name: FK_GEM_USRINC; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_gem
    ADD CONSTRAINT "FK_GEM_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6593 (class 2606 OID 830782)
-- Name: FK_TLF_USRALT; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_tlf
    ADD CONSTRAINT "FK_TLF_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6594 (class 2606 OID 830787)
-- Name: FK_TLF_USRINC; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_tlf
    ADD CONSTRAINT "FK_TLF_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6689 (class 2606 OID 830792)
-- Name: fk_ast_cun; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ast
    ADD CONSTRAINT fk_ast_cun FOREIGN KEY (cd_cun) REFERENCES tbl_cun(cd_cun);


--
-- TOC entry 6690 (class 2606 OID 830797)
-- Name: fk_ast_usralt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ast
    ADD CONSTRAINT fk_ast_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6691 (class 2606 OID 830802)
-- Name: fk_ast_usrinc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ast
    ADD CONSTRAINT fk_ast_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6692 (class 2606 OID 830807)
-- Name: fk_cbf_bnc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cbf
    ADD CONSTRAINT fk_cbf_bnc FOREIGN KEY (cd_bnc) REFERENCES sc_fin.tbl_bnc(cd_bnc);


--
-- TOC entry 6693 (class 2606 OID 830812)
-- Name: fk_cbf_cun; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cbf
    ADD CONSTRAINT fk_cbf_cun FOREIGN KEY (cd_cun) REFERENCES tbl_cun(cd_cun);


--
-- TOC entry 6694 (class 2606 OID 830817)
-- Name: fk_cbf_usr_alt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cbf
    ADD CONSTRAINT fk_cbf_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6695 (class 2606 OID 830822)
-- Name: fk_cbf_usr_inc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cbf
    ADD CONSTRAINT fk_cbf_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7269 (class 2606 OID 976471)
-- Name: fk_cls_cun; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cls
    ADD CONSTRAINT fk_cls_cun FOREIGN KEY (cd_cun) REFERENCES tbl_cun(cd_cun);


--
-- TOC entry 7270 (class 2606 OID 976476)
-- Name: fk_cls_usralt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cls
    ADD CONSTRAINT fk_cls_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7271 (class 2606 OID 976481)
-- Name: fk_cls_usrinc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cls
    ADD CONSTRAINT fk_cls_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6696 (class 2606 OID 830827)
-- Name: fk_cpf_cun; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cpf
    ADD CONSTRAINT fk_cpf_cun FOREIGN KEY (cd_cun) REFERENCES tbl_cun(cd_cun);


--
-- TOC entry 6697 (class 2606 OID 830832)
-- Name: fk_cpj_cun; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cpj
    ADD CONSTRAINT fk_cpj_cun FOREIGN KEY (cd_cun) REFERENCES tbl_cun(cd_cun);


--
-- TOC entry 6698 (class 2606 OID 976486)
-- Name: fk_ctr_ast; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT fk_ctr_ast FOREIGN KEY (cd_ast) REFERENCES tbl_ast(cd_ast);


--
-- TOC entry 6709 (class 2606 OID 976541)
-- Name: fk_ctr_cls; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT fk_ctr_cls FOREIGN KEY (cd_cls) REFERENCES tbl_cls(cd_cls);


--
-- TOC entry 6699 (class 2606 OID 976491)
-- Name: fk_ctr_cnt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT fk_ctr_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6700 (class 2606 OID 976496)
-- Name: fk_ctr_cnt_crd_cnt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT fk_ctr_cnt_crd_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6756 (class 2606 OID 932634)
-- Name: fk_ctr_ctr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_ctr
    ADD CONSTRAINT fk_ctr_ctr FOREIGN KEY (cd_ctr) REFERENCES tbl_ctr(cd_ctr);


--
-- TOC entry 6701 (class 2606 OID 976501)
-- Name: fk_ctr_edr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT fk_ctr_edr FOREIGN KEY (cd_edr_ctr) REFERENCES tbl_edr(cd_edr);


--
-- TOC entry 6702 (class 2606 OID 976506)
-- Name: fk_ctr_emp; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT fk_ctr_emp FOREIGN KEY (cd_emp) REFERENCES tbl_emp(cd_emp);


--
-- TOC entry 7300 (class 2606 OID 1010476)
-- Name: fk_ctr_exc_ast; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT fk_ctr_exc_ast FOREIGN KEY (cd_ast) REFERENCES tbl_ast(cd_ast);


--
-- TOC entry 7301 (class 2606 OID 1010481)
-- Name: fk_ctr_exc_cls; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT fk_ctr_exc_cls FOREIGN KEY (cd_cls) REFERENCES tbl_cls(cd_cls);


--
-- TOC entry 7302 (class 2606 OID 1010486)
-- Name: fk_ctr_exc_cnt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT fk_ctr_exc_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 7303 (class 2606 OID 1010491)
-- Name: fk_ctr_exc_cnt_crd_cnt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT fk_ctr_exc_cnt_crd_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 7304 (class 2606 OID 1010496)
-- Name: fk_ctr_exc_edr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT fk_ctr_exc_edr FOREIGN KEY (cd_edr_ctr) REFERENCES tbl_edr(cd_edr);


--
-- TOC entry 7305 (class 2606 OID 1010501)
-- Name: fk_ctr_exc_emp; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT fk_ctr_exc_emp FOREIGN KEY (cd_emp) REFERENCES tbl_emp(cd_emp);


--
-- TOC entry 7306 (class 2606 OID 1010506)
-- Name: fk_ctr_exc_grt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT fk_ctr_exc_grt FOREIGN KEY (cd_grt) REFERENCES tbl_grt(cd_grt);


--
-- TOC entry 7307 (class 2606 OID 1010511)
-- Name: fk_ctr_exc_mpl; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT fk_ctr_exc_mpl FOREIGN KEY (cd_mpl) REFERENCES sc_ssp.tbl_mpl(cd_mpl);


--
-- TOC entry 7308 (class 2606 OID 1010516)
-- Name: fk_ctr_exc_ppt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT fk_ctr_exc_ppt FOREIGN KEY (cd_ppt) REFERENCES tbl_ppt(cd_ppt);


--
-- TOC entry 7309 (class 2606 OID 1010521)
-- Name: fk_ctr_exc_usralt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT fk_ctr_exc_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7310 (class 2606 OID 1010526)
-- Name: fk_ctr_exc_usrinc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT fk_ctr_exc_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6703 (class 2606 OID 976511)
-- Name: fk_ctr_grt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT fk_ctr_grt FOREIGN KEY (cd_grt) REFERENCES tbl_grt(cd_grt);


--
-- TOC entry 6704 (class 2606 OID 976516)
-- Name: fk_ctr_mpl; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT fk_ctr_mpl FOREIGN KEY (cd_mpl) REFERENCES sc_ssp.tbl_mpl(cd_mpl);


--
-- TOC entry 6755 (class 2606 OID 932629)
-- Name: fk_ctr_pce; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_ctr
    ADD CONSTRAINT fk_ctr_pce FOREIGN KEY (cd_pce) REFERENCES tbl_pce(cd_pce);


--
-- TOC entry 7254 (class 2606 OID 934461)
-- Name: fk_ctr_pcs_pcs; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_pcs
    ADD CONSTRAINT fk_ctr_pcs_pcs FOREIGN KEY (cd_pcs) REFERENCES tbl_pcs(cd_pcs);


--
-- TOC entry 6708 (class 2606 OID 976536)
-- Name: fk_ctr_ppt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT fk_ctr_ppt FOREIGN KEY (cd_ppt) REFERENCES tbl_ppt(cd_ppt);


--
-- TOC entry 6757 (class 2606 OID 830877)
-- Name: fk_ctr_prd; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_prd
    ADD CONSTRAINT fk_ctr_prd FOREIGN KEY (cd_prd) REFERENCES tbl_prd(cd_prd);


--
-- TOC entry 6705 (class 2606 OID 976521)
-- Name: fk_ctr_usralt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT fk_ctr_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6706 (class 2606 OID 976526)
-- Name: fk_ctr_usrinc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT fk_ctr_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6710 (class 2606 OID 830892)
-- Name: fk_ctt_alt_usr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctt
    ADD CONSTRAINT fk_ctt_alt_usr FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6711 (class 2606 OID 830897)
-- Name: fk_ctt_cpj; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctt
    ADD CONSTRAINT fk_ctt_cpj FOREIGN KEY (cd_cun) REFERENCES tbl_cpj(cd_cun);


--
-- TOC entry 6712 (class 2606 OID 830902)
-- Name: fk_ctt_crg; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctt
    ADD CONSTRAINT fk_ctt_crg FOREIGN KEY (cd_crg) REFERENCES tbl_crg(cd_crg);


--
-- TOC entry 6713 (class 2606 OID 830907)
-- Name: fk_ctt_inc_usr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctt
    ADD CONSTRAINT fk_ctt_inc_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6716 (class 2606 OID 830912)
-- Name: fk_cun_crt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_cun
    ADD CONSTRAINT fk_cun_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6717 (class 2606 OID 830917)
-- Name: fk_edr_ctr_ctr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_edr_ctr
    ADD CONSTRAINT fk_edr_ctr_ctr FOREIGN KEY (cd_ctr) REFERENCES tbl_ctr(cd_ctr);


--
-- TOC entry 6718 (class 2606 OID 830922)
-- Name: fk_edr_ctr_edr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_edr_ctr
    ADD CONSTRAINT fk_edr_ctr_edr FOREIGN KEY (cd_edr) REFERENCES tbl_edr(cd_edr);


--
-- TOC entry 6591 (class 2606 OID 830927)
-- Name: fk_edr_cun; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_edr
    ADD CONSTRAINT fk_edr_cun FOREIGN KEY (cd_cun) REFERENCES tbl_cun(cd_cun);


--
-- TOC entry 6592 (class 2606 OID 830932)
-- Name: fk_eex_edr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_eex
    ADD CONSTRAINT fk_eex_edr FOREIGN KEY (cd_edr) REFERENCES tbl_edr(cd_edr);


--
-- TOC entry 6721 (class 2606 OID 830937)
-- Name: fk_emp_gem; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_emp
    ADD CONSTRAINT fk_emp_gem FOREIGN KEY (cd_gem) REFERENCES tbl_gem(cd_gem);


--
-- TOC entry 6722 (class 2606 OID 830942)
-- Name: fk_emp_rat; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_emp
    ADD CONSTRAINT fk_emp_rat FOREIGN KEY (cd_rat) REFERENCES tbl_rat(cd_rat);


--
-- TOC entry 6725 (class 2606 OID 1035060)
-- Name: fk_fem_cun; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fem
    ADD CONSTRAINT fk_fem_cun FOREIGN KEY (cd_cun) REFERENCES tbl_cun(cd_cun);


--
-- TOC entry 6726 (class 2606 OID 1035065)
-- Name: fk_fem_emp; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fem
    ADD CONSTRAINT fk_fem_emp FOREIGN KEY (cd_emp) REFERENCES tbl_emp(cd_emp);


--
-- TOC entry 6727 (class 2606 OID 830957)
-- Name: fk_femctr_ctr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fem_ctr
    ADD CONSTRAINT fk_femctr_ctr FOREIGN KEY (cd_ctr) REFERENCES tbl_ctr(cd_ctr);


--
-- TOC entry 6728 (class 2606 OID 830962)
-- Name: fk_femctr_emp; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fem_ctr
    ADD CONSTRAINT fk_femctr_emp FOREIGN KEY (cd_emp) REFERENCES tbl_emp(cd_emp);


--
-- TOC entry 6729 (class 2606 OID 830967)
-- Name: fk_femctr_fem; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fem_ctr
    ADD CONSTRAINT fk_femctr_fem FOREIGN KEY (cd_emp, cd_fem) REFERENCES tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 6730 (class 2606 OID 830972)
-- Name: fk_femctr_tvt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fem_ctr
    ADD CONSTRAINT fk_femctr_tvt FOREIGN KEY (cd_tvt) REFERENCES sc_opr.tbl_tvt(cd_tvt);


--
-- TOC entry 6731 (class 2606 OID 830977)
-- Name: fk_femctr_usralt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fem_ctr
    ADD CONSTRAINT fk_femctr_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6732 (class 2606 OID 830982)
-- Name: fk_femctr_usrinc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fem_ctr
    ADD CONSTRAINT fk_femctr_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6736 (class 2606 OID 830987)
-- Name: fk_fnc_fem; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_fnc
    ADD CONSTRAINT fk_fnc_fem FOREIGN KEY (cd_emp, cd_fem) REFERENCES tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 6739 (class 2606 OID 830992)
-- Name: fk_gem_rrc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_gem
    ADD CONSTRAINT fk_gem_rrc FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6740 (class 2606 OID 830997)
-- Name: fk_grt_cun; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_grt
    ADD CONSTRAINT fk_grt_cun FOREIGN KEY (cd_cun) REFERENCES tbl_cun(cd_cun);


--
-- TOC entry 6741 (class 2606 OID 831002)
-- Name: fk_grt_usralt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_grt
    ADD CONSTRAINT fk_grt_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6742 (class 2606 OID 831007)
-- Name: fk_grt_usrinc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_grt
    ADD CONSTRAINT fk_grt_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6743 (class 2606 OID 831012)
-- Name: fk_haef_emp_ant; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_haef
    ADD CONSTRAINT fk_haef_emp_ant FOREIGN KEY (cd_emp_ant_haef) REFERENCES tbl_emp(cd_emp);


--
-- TOC entry 6744 (class 2606 OID 831017)
-- Name: fk_haef_emp_atl; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_haef
    ADD CONSTRAINT fk_haef_emp_atl FOREIGN KEY (cd_emp_atl_haef) REFERENCES tbl_emp(cd_emp);


--
-- TOC entry 6745 (class 2606 OID 831022)
-- Name: fk_haef_fem_ant; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_haef
    ADD CONSTRAINT fk_haef_fem_ant FOREIGN KEY (cd_emp_ant_haef, cd_fem_ant_haef) REFERENCES tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 6746 (class 2606 OID 831027)
-- Name: fk_haef_fem_atl; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_haef
    ADD CONSTRAINT fk_haef_fem_atl FOREIGN KEY (cd_emp_atl_haef, cd_fem_atl_haef) REFERENCES tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 6747 (class 2606 OID 831032)
-- Name: fk_haef_fnc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_haef
    ADD CONSTRAINT fk_haef_fnc FOREIGN KEY (cd_fnc) REFERENCES tbl_fnc(cd_fnc);


--
-- TOC entry 6748 (class 2606 OID 831037)
-- Name: fk_haef_usr_inc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_haef
    ADD CONSTRAINT fk_haef_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6749 (class 2606 OID 831042)
-- Name: fk_ham_fnc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ham
    ADD CONSTRAINT fk_ham_fnc FOREIGN KEY (cd_fnc) REFERENCES tbl_fnc(cd_fnc);


--
-- TOC entry 6750 (class 2606 OID 831047)
-- Name: fk_ham_usr_inc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ham
    ADD CONSTRAINT fk_ham_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6751 (class 2606 OID 901805)
-- Name: fk_oce_emp; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_oce
    ADD CONSTRAINT fk_oce_emp FOREIGN KEY (cd_emp) REFERENCES tbl_emp(cd_emp);


--
-- TOC entry 6752 (class 2606 OID 901810)
-- Name: fk_oce_usr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_oce
    ADD CONSTRAINT fk_oce_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7240 (class 2606 OID 892054)
-- Name: fk_pcc_crt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_crt
    ADD CONSTRAINT fk_pcc_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 7241 (class 2606 OID 892059)
-- Name: fk_pcc_usralt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_crt
    ADD CONSTRAINT fk_pcc_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7242 (class 2606 OID 892064)
-- Name: fk_pcc_usrinc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_crt
    ADD CONSTRAINT fk_pcc_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7234 (class 2606 OID 888979)
-- Name: fk_pce; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_dps
    ADD CONSTRAINT fk_pce FOREIGN KEY (cd_pce) REFERENCES tbl_pce(cd_pce);


--
-- TOC entry 6753 (class 2606 OID 831062)
-- Name: fk_pce_usralt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce
    ADD CONSTRAINT fk_pce_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6754 (class 2606 OID 831067)
-- Name: fk_pce_usrinc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce
    ADD CONSTRAINT fk_pce_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6707 (class 2606 OID 976531)
-- Name: fk_pcs; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr
    ADD CONSTRAINT fk_pcs FOREIGN KEY (cd_pcs) REFERENCES tbl_pcs(cd_pcs);


--
-- TOC entry 7311 (class 2606 OID 1010531)
-- Name: fk_pcs; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_exc
    ADD CONSTRAINT fk_pcs FOREIGN KEY (cd_pcs) REFERENCES tbl_pcs(cd_pcs);


--
-- TOC entry 7243 (class 2606 OID 892179)
-- Name: fk_pcs_emp_pfe; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pfe
    ADD CONSTRAINT fk_pcs_emp_pfe FOREIGN KEY (cd_pcs_emp_pfe) REFERENCES tbl_pcs(cd_pcs);


--
-- TOC entry 7244 (class 2606 OID 892184)
-- Name: fk_pcs_fnc_pfe; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pfe
    ADD CONSTRAINT fk_pcs_fnc_pfe FOREIGN KEY (cd_pcs_fnc_pfe) REFERENCES tbl_pcs(cd_pcs);


--
-- TOC entry 7221 (class 2606 OID 852236)
-- Name: fk_pfc_fem_ctr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_fem_ctr
    ADD CONSTRAINT fk_pfc_fem_ctr FOREIGN KEY (cd_fem_ctr) REFERENCES tbl_fem_ctr(cd_fem_ctr);


--
-- TOC entry 7222 (class 2606 OID 852241)
-- Name: fk_pfc_usralt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_fem_ctr
    ADD CONSTRAINT fk_pfc_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7223 (class 2606 OID 852246)
-- Name: fk_pfc_usrinc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_pce_fem_ctr
    ADD CONSTRAINT fk_pfc_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7266 (class 2606 OID 976451)
-- Name: fk_ppt_cun; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ppt
    ADD CONSTRAINT fk_ppt_cun FOREIGN KEY (cd_cun) REFERENCES tbl_cun(cd_cun);


--
-- TOC entry 7267 (class 2606 OID 976456)
-- Name: fk_ppt_usralt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ppt
    ADD CONSTRAINT fk_ppt_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7268 (class 2606 OID 976461)
-- Name: fk_ppt_usrinc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_ppt
    ADD CONSTRAINT fk_ppt_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6758 (class 2606 OID 831072)
-- Name: fk_prd_usralt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_prd
    ADD CONSTRAINT fk_prd_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6759 (class 2606 OID 831077)
-- Name: fk_prd_usrinc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_prd
    ADD CONSTRAINT fk_prd_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7280 (class 2606 OID 1002050)
-- Name: fk_rel; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_rfl
    ADD CONSTRAINT fk_rel FOREIGN KEY (cd_rel) REFERENCES tbl_rel(cd_rel);


--
-- TOC entry 7281 (class 2606 OID 1002061)
-- Name: fk_rel; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_rrl
    ADD CONSTRAINT fk_rel FOREIGN KEY (cd_rel) REFERENCES tbl_rel(cd_rel);


--
-- TOC entry 6760 (class 2606 OID 831082)
-- Name: fk_tlt_ctr_fem_ctr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_tlt_ctr
    ADD CONSTRAINT fk_tlt_ctr_fem_ctr FOREIGN KEY (cd_fem_ctr) REFERENCES tbl_fem_ctr(cd_fem_ctr);


--
-- TOC entry 6761 (class 2606 OID 831087)
-- Name: fk_tltctr_usralt; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_tlt_ctr
    ADD CONSTRAINT fk_tltctr_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6762 (class 2606 OID 831092)
-- Name: fk_tltctr_usrinc; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_tlt_ctr
    ADD CONSTRAINT fk_tltctr_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7314 (class 2606 OID 1076901)
-- Name: fk_ucr; Type: FK CONSTRAINT; Schema: sc_cad; Owner: scan
--

ALTER TABLE ONLY tbl_luc
    ADD CONSTRAINT fk_ucr FOREIGN KEY (cd_ucr) REFERENCES sc_sgr.tbl_ucr(cd_ucr);


SET search_path = sc_cap, pg_catalog;

--
-- TOC entry 6766 (class 2606 OID 831097)
-- Name: fk_cdc_cdcpai; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_cdc
    ADD CONSTRAINT fk_cdc_cdcpai FOREIGN KEY (cd_cdc_pai) REFERENCES tbl_cdc(cd_cdc);


--
-- TOC entry 6767 (class 2606 OID 831102)
-- Name: fk_cdc_usralt; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_cdc
    ADD CONSTRAINT fk_cdc_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6768 (class 2606 OID 831107)
-- Name: fk_cdc_usrinc; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_cdc
    ADD CONSTRAINT fk_cdc_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6769 (class 2606 OID 831112)
-- Name: fk_dsp_cbf; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT fk_dsp_cbf FOREIGN KEY (cd_cbf) REFERENCES sc_cad.tbl_cbf(cd_cbf);


--
-- TOC entry 6770 (class 2606 OID 831117)
-- Name: fk_dsp_cdc; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT fk_dsp_cdc FOREIGN KEY (cd_cdc) REFERENCES tbl_cdc(cd_cdc);


--
-- TOC entry 6771 (class 2606 OID 831122)
-- Name: fk_dsp_cnt; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT fk_dsp_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6772 (class 2606 OID 831127)
-- Name: fk_dsp_frn; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT fk_dsp_frn FOREIGN KEY (cd_frn) REFERENCES tbl_frn(cd_frn);


--
-- TOC entry 6773 (class 2606 OID 831132)
-- Name: fk_dsp_tdp; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT fk_dsp_tdp FOREIGN KEY (cd_tdp) REFERENCES tbl_tdp(cd_tdp);


--
-- TOC entry 6774 (class 2606 OID 831137)
-- Name: fk_dsp_usralt; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT fk_dsp_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6775 (class 2606 OID 831142)
-- Name: fk_dsp_usraut; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT fk_dsp_usraut FOREIGN KEY (cd_aut_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6776 (class 2606 OID 831147)
-- Name: fk_dsp_usrcnc; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT fk_dsp_usrcnc FOREIGN KEY (cd_cnc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6777 (class 2606 OID 831152)
-- Name: fk_dsp_usrcnf; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT fk_dsp_usrcnf FOREIGN KEY (cd_cnf_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6778 (class 2606 OID 831157)
-- Name: fk_dsp_usrinc; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT fk_dsp_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6779 (class 2606 OID 831162)
-- Name: fk_frn_cun; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_frn
    ADD CONSTRAINT fk_frn_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 6780 (class 2606 OID 831167)
-- Name: fk_frn_tdp; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_frn
    ADD CONSTRAINT fk_frn_tdp FOREIGN KEY (cd_tdp) REFERENCES tbl_tdp(cd_tdp);


--
-- TOC entry 6781 (class 2606 OID 831172)
-- Name: fk_frn_usralt; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_frn
    ADD CONSTRAINT fk_frn_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6783 (class 2606 OID 831177)
-- Name: fk_frn_usralt; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_tdp
    ADD CONSTRAINT fk_frn_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6782 (class 2606 OID 831182)
-- Name: fk_frn_usrinc; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_frn
    ADD CONSTRAINT fk_frn_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6784 (class 2606 OID 831187)
-- Name: fk_tdp_atd; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_tdp
    ADD CONSTRAINT fk_tdp_atd FOREIGN KEY (cd_atd) REFERENCES tbl_atd(cd_atd);


--
-- TOC entry 6785 (class 2606 OID 831192)
-- Name: fk_tdp_cnt; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_tdp
    ADD CONSTRAINT fk_tdp_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6786 (class 2606 OID 831197)
-- Name: fk_tdp_tlc; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_tdp
    ADD CONSTRAINT fk_tdp_tlc FOREIGN KEY (cd_tlc) REFERENCES sc_cnt.tbl_tlc(cd_tlc);


--
-- TOC entry 6787 (class 2606 OID 831202)
-- Name: fk_tdp_usrinc; Type: FK CONSTRAINT; Schema: sc_cap; Owner: scan
--

ALTER TABLE ONLY tbl_tdp
    ADD CONSTRAINT fk_tdp_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sc_cbe, pg_catalog;

--
-- TOC entry 7213 (class 2606 OID 840891)
-- Name: fk_acr; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_dvd
    ADD CONSTRAINT fk_acr FOREIGN KEY (cd_acr) REFERENCES tbl_acr(cd_acr);


--
-- TOC entry 7215 (class 2606 OID 956191)
-- Name: fk_acr; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_prd
    ADD CONSTRAINT fk_acr FOREIGN KEY (cd_acr) REFERENCES tbl_acr(cd_acr);


--
-- TOC entry 7245 (class 2606 OID 894739)
-- Name: fk_act_emc; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_act
    ADD CONSTRAINT fk_act_emc FOREIGN KEY (cd_emc) REFERENCES tbl_emc(cd_emc);


--
-- TOC entry 7219 (class 2606 OID 975123)
-- Name: fk_bpr_rce; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_bpr
    ADD CONSTRAINT fk_bpr_rce FOREIGN KEY (cd_rce) REFERENCES tbl_rce(cd_rce);


--
-- TOC entry 7216 (class 2606 OID 956196)
-- Name: fk_cbr; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_prd
    ADD CONSTRAINT fk_cbr FOREIGN KEY (cd_blt) REFERENCES sc_cbr.tbl_blt(cd_blt);


--
-- TOC entry 7214 (class 2606 OID 840896)
-- Name: fk_cun; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_dvd
    ADD CONSTRAINT fk_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 7246 (class 2606 OID 894749)
-- Name: fk_dct_act; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_dct
    ADD CONSTRAINT fk_dct_act FOREIGN KEY (cd_act) REFERENCES tbl_act(cd_act);


--
-- TOC entry 7247 (class 2606 OID 894754)
-- Name: fk_dct_dvd; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_dct
    ADD CONSTRAINT fk_dct_dvd FOREIGN KEY (cd_dvd) REFERENCES tbl_dvd(cd_dvd);


--
-- TOC entry 7210 (class 2606 OID 840901)
-- Name: fk_dvd; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_acr
    ADD CONSTRAINT fk_dvd FOREIGN KEY (cd_dvd) REFERENCES tbl_dvd(cd_dvd);


--
-- TOC entry 7212 (class 2606 OID 840886)
-- Name: fk_emc; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_dvd
    ADD CONSTRAINT fk_emc FOREIGN KEY (cd_emc) REFERENCES tbl_emc(cd_emc);


--
-- TOC entry 7209 (class 2606 OID 840871)
-- Name: fk_emc_cun; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_emc
    ADD CONSTRAINT fk_emc_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 7259 (class 2606 OID 1008658)
-- Name: fk_lrc_emc; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_rce
    ADD CONSTRAINT fk_lrc_emc FOREIGN KEY (cd_emc) REFERENCES tbl_emc(cd_emc);


--
-- TOC entry 7220 (class 2606 OID 844243)
-- Name: fk_prd; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_pgp
    ADD CONSTRAINT fk_prd FOREIGN KEY (cd_prd) REFERENCES tbl_prd(cd_prd);


--
-- TOC entry 7217 (class 2606 OID 975113)
-- Name: fk_prd; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_bpr
    ADD CONSTRAINT fk_prd FOREIGN KEY (cd_prd) REFERENCES tbl_prd(cd_prd);


--
-- TOC entry 7260 (class 2606 OID 1008663)
-- Name: fk_usr_cnc_rce; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_rce
    ADD CONSTRAINT fk_usr_cnc_rce FOREIGN KEY (cd_usr_cnc_rce) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7261 (class 2606 OID 1008668)
-- Name: fk_usr_inc_rce; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_rce
    ADD CONSTRAINT fk_usr_inc_rce FOREIGN KEY (cd_usr_inc_rce) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7262 (class 2606 OID 1008673)
-- Name: fk_usr_prc_rce; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_rce
    ADD CONSTRAINT fk_usr_prc_rce FOREIGN KEY (cd_usr_prc_rce) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7211 (class 2606 OID 893550)
-- Name: tbl_acr_cd_emc_fkey; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_acr
    ADD CONSTRAINT tbl_acr_cd_emc_fkey FOREIGN KEY (cd_emc) REFERENCES tbl_emc(cd_emc);


--
-- TOC entry 7218 (class 2606 OID 975118)
-- Name: tbl_bpr_cd_emc_fkey; Type: FK CONSTRAINT; Schema: sc_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_bpr
    ADD CONSTRAINT tbl_bpr_cd_emc_fkey FOREIGN KEY (cd_emc) REFERENCES tbl_emc(cd_emc);


SET search_path = sc_cbr, pg_catalog;

--
-- TOC entry 6788 (class 2606 OID 831207)
-- Name: fk_bac_usralt; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_bac
    ADD CONSTRAINT fk_bac_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6789 (class 2606 OID 831212)
-- Name: fk_bac_usrinc; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_bac
    ADD CONSTRAINT fk_bac_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6790 (class 2606 OID 831217)
-- Name: fk_blt; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_bac
    ADD CONSTRAINT fk_blt FOREIGN KEY (cd_blt) REFERENCES tbl_blt(cd_blt);


--
-- TOC entry 6792 (class 2606 OID 831222)
-- Name: fk_blt_ccb; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_blt
    ADD CONSTRAINT fk_blt_ccb FOREIGN KEY (cd_ccb) REFERENCES tbl_ccb(cd_ccb);


--
-- TOC entry 6793 (class 2606 OID 831227)
-- Name: fk_blt_drb; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_blt
    ADD CONSTRAINT fk_blt_drb FOREIGN KEY (cd_drb) REFERENCES tbl_drb(cd_drb);


--
-- TOC entry 6606 (class 2606 OID 831232)
-- Name: fk_ccb_bnc; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_ccb
    ADD CONSTRAINT fk_ccb_bnc FOREIGN KEY (cd_bnc) REFERENCES sc_fin.tbl_bnc(cd_bnc);


--
-- TOC entry 6607 (class 2606 OID 831237)
-- Name: fk_ccb_cdt; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_ccb
    ADD CONSTRAINT fk_ccb_cdt FOREIGN KEY (cd_cdt) REFERENCES tbl_cdt(cd_cdt);


--
-- TOC entry 6608 (class 2606 OID 831242)
-- Name: fk_ccb_tcb; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_ccb
    ADD CONSTRAINT fk_ccb_tcb FOREIGN KEY (cd_tcb) REFERENCES tbl_tcb(cd_tcb);


--
-- TOC entry 6609 (class 2606 OID 831247)
-- Name: fk_ccb_usralt; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_ccb
    ADD CONSTRAINT fk_ccb_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6610 (class 2606 OID 831252)
-- Name: fk_ccb_usrinc; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_ccb
    ADD CONSTRAINT fk_ccb_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6794 (class 2606 OID 831257)
-- Name: fk_cdt_cun; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_cdt
    ADD CONSTRAINT fk_cdt_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 6791 (class 2606 OID 831262)
-- Name: fk_crt; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_bac
    ADD CONSTRAINT fk_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6795 (class 2606 OID 831267)
-- Name: fk_darcg_harcg; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_darcg
    ADD CONSTRAINT fk_darcg_harcg FOREIGN KEY (cd_harcg) REFERENCES tbl_harcg(cd_harcg);


--
-- TOC entry 6796 (class 2606 OID 831272)
-- Name: fk_drb_hrb; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_drb
    ADD CONSTRAINT fk_drb_hrb FOREIGN KEY (cd_hrb) REFERENCES tbl_hrb(cd_hrb);


--
-- TOC entry 6799 (class 2606 OID 831277)
-- Name: fk_drc_hlsc; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_drc_u
    ADD CONSTRAINT fk_drc_hlsc FOREIGN KEY (cd_hlsc) REFERENCES tbl_hlsc(cd_hlsc);


--
-- TOC entry 6797 (class 2606 OID 831282)
-- Name: fk_drc_t_blt; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_drc_t
    ADD CONSTRAINT fk_drc_t_blt FOREIGN KEY (cd_blt) REFERENCES tbl_blt(cd_blt);


--
-- TOC entry 6800 (class 2606 OID 831287)
-- Name: fk_hadb_blt; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_hadb
    ADD CONSTRAINT fk_hadb_blt FOREIGN KEY (cd_blt) REFERENCES tbl_blt(cd_blt);


--
-- TOC entry 6801 (class 2606 OID 831292)
-- Name: fk_hadb_usrinc; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_hadb
    ADD CONSTRAINT fk_hadb_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6803 (class 2606 OID 831297)
-- Name: fk_hlsc_harc; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_hlsc
    ADD CONSTRAINT fk_hlsc_harc FOREIGN KEY (cd_harc) REFERENCES tbl_harc(cd_harc);


--
-- TOC entry 6804 (class 2606 OID 831302)
-- Name: fk_hrb_ccb; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_hrb
    ADD CONSTRAINT fk_hrb_ccb FOREIGN KEY (cd_ccb) REFERENCES tbl_ccb(cd_ccb);


--
-- TOC entry 6805 (class 2606 OID 831307)
-- Name: fk_hrb_usrinc; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_hrb
    ADD CONSTRAINT fk_hrb_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6806 (class 2606 OID 831312)
-- Name: fk_prc_blt; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_prc
    ADD CONSTRAINT fk_prc_blt FOREIGN KEY (cd_blt) REFERENCES tbl_blt(cd_blt);


--
-- TOC entry 6807 (class 2606 OID 831317)
-- Name: fk_prc_crt; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_prc
    ADD CONSTRAINT fk_prc_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6808 (class 2606 OID 831322)
-- Name: fk_prc_usrinc; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_prc
    ADD CONSTRAINT fk_prc_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6810 (class 2606 OID 831327)
-- Name: fk_tarcg_harcg; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_tarcg
    ADD CONSTRAINT fk_tarcg_harcg FOREIGN KEY (cd_harcg) REFERENCES tbl_harcg(cd_harcg);


--
-- TOC entry 6798 (class 2606 OID 831332)
-- Name: fk_tbl_drc_t_hlsc; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_drc_t
    ADD CONSTRAINT fk_tbl_drc_t_hlsc FOREIGN KEY (cd_hlsc) REFERENCES tbl_hlsc(cd_hlsc);


--
-- TOC entry 6809 (class 2606 OID 831337)
-- Name: fk_tlsc_harc; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_tarc
    ADD CONSTRAINT fk_tlsc_harc FOREIGN KEY (cd_harc) REFERENCES tbl_harc(cd_harc);


--
-- TOC entry 6811 (class 2606 OID 831342)
-- Name: fk_tlsc_hlsc; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_tlsc
    ADD CONSTRAINT fk_tlsc_hlsc FOREIGN KEY (cd_hlsc) REFERENCES tbl_hlsc(cd_hlsc);


--
-- TOC entry 6802 (class 2606 OID 831347)
-- Name: tbl_harcg_cd_ccb_fkey; Type: FK CONSTRAINT; Schema: sc_cbr; Owner: scan
--

ALTER TABLE ONLY tbl_harcg
    ADD CONSTRAINT tbl_harcg_cd_ccb_fkey FOREIGN KEY (cd_ccb) REFERENCES tbl_ccb(cd_ccb);


SET search_path = sc_ccb, pg_catalog;

--
-- TOC entry 7233 (class 2606 OID 885435)
-- Name: fk_csn; Type: FK CONSTRAINT; Schema: sc_ccb; Owner: scan
--

ALTER TABLE ONLY tbl_ccb
    ADD CONSTRAINT fk_csn FOREIGN KEY (cd_csn) REFERENCES tbl_csn(cd_csn);


--
-- TOC entry 7251 (class 2606 OID 909387)
-- Name: fk_csn_ant; Type: FK CONSTRAINT; Schema: sc_ccb; Owner: scan
--

ALTER TABLE ONLY tbl_ccb_ant
    ADD CONSTRAINT fk_csn_ant FOREIGN KEY (cd_csn) REFERENCES tbl_csn(cd_csn);


--
-- TOC entry 7231 (class 2606 OID 885402)
-- Name: fk_cun; Type: FK CONSTRAINT; Schema: sc_ccb; Owner: scan
--

ALTER TABLE ONLY tbl_csn
    ADD CONSTRAINT fk_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 7232 (class 2606 OID 885430)
-- Name: fk_opr; Type: FK CONSTRAINT; Schema: sc_ccb; Owner: scan
--

ALTER TABLE ONLY tbl_ccb
    ADD CONSTRAINT fk_opr FOREIGN KEY (cd_opr) REFERENCES sc_opr.tbl_opr(cd_opr);


--
-- TOC entry 7252 (class 2606 OID 909392)
-- Name: fk_opr_ant; Type: FK CONSTRAINT; Schema: sc_ccb; Owner: scan
--

ALTER TABLE ONLY tbl_ccb_ant
    ADD CONSTRAINT fk_opr_ant FOREIGN KEY (cd_opr) REFERENCES sc_opr.tbl_opr(cd_opr);


SET search_path = sc_cce, pg_catalog;

--
-- TOC entry 7317 (class 2606 OID 1630847)
-- Name: fk_cce; Type: FK CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_cce
    ADD CONSTRAINT fk_cce FOREIGN KEY (cd_ccb) REFERENCES sc_cbr.tbl_ccb(cd_ccb);


--
-- TOC entry 7315 (class 2606 OID 1630857)
-- Name: fk_cce_cnt; Type: FK CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_cce
    ADD CONSTRAINT fk_cce_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 7316 (class 2606 OID 1630852)
-- Name: fk_cce_cun; Type: FK CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_cce
    ADD CONSTRAINT fk_cce_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 7324 (class 2606 OID 1631835)
-- Name: fk_darc_harc; Type: FK CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_darc
    ADD CONSTRAINT fk_darc_harc FOREIGN KEY (cd_harc) REFERENCES tbl_harc(cd_harc);


--
-- TOC entry 7323 (class 2606 OID 1630923)
-- Name: fk_drb_hrb; Type: FK CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_drb
    ADD CONSTRAINT fk_drb_hrb FOREIGN KEY (cd_hrb) REFERENCES tbl_hrb(cd_hrb);


--
-- TOC entry 7322 (class 2606 OID 1630907)
-- Name: fk_hrb_cce; Type: FK CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_hrb
    ADD CONSTRAINT fk_hrb_cce FOREIGN KEY (cd_cce) REFERENCES tbl_cce(cd_cce);


--
-- TOC entry 7321 (class 2606 OID 1630912)
-- Name: fk_hrb_usrinc; Type: FK CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_hrb
    ADD CONSTRAINT fk_hrb_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7320 (class 2606 OID 1630888)
-- Name: fk_scd_cce; Type: FK CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_scd
    ADD CONSTRAINT fk_scd_cce FOREIGN KEY (cd_cce) REFERENCES tbl_cce(cd_cce);


--
-- TOC entry 7319 (class 2606 OID 1630893)
-- Name: fk_scd_cun; Type: FK CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_scd
    ADD CONSTRAINT fk_scd_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 7325 (class 2606 OID 1631853)
-- Name: fk_tarc_harc; Type: FK CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_tarc
    ADD CONSTRAINT fk_tarc_harc FOREIGN KEY (cd_harc) REFERENCES tbl_harc(cd_harc);


--
-- TOC entry 7318 (class 2606 OID 1630877)
-- Name: fk_tit_cce; Type: FK CONSTRAINT; Schema: sc_cce; Owner: scan
--

ALTER TABLE ONLY tbl_tit
    ADD CONSTRAINT fk_tit_cce FOREIGN KEY (cd_cce) REFERENCES tbl_cce(cd_cce);


SET search_path = sc_cci, pg_catalog;

--
-- TOC entry 6814 (class 2606 OID 831352)
-- Name: FK_CCI_EMC; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_cci
    ADD CONSTRAINT "FK_CCI_EMC" FOREIGN KEY (cd_emc) REFERENCES tbl_emc(cd_emc);


--
-- TOC entry 6815 (class 2606 OID 831357)
-- Name: FK_CCI_USRALT; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_cci
    ADD CONSTRAINT "FK_CCI_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6816 (class 2606 OID 831362)
-- Name: FK_CCI_USRINC; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_cci
    ADD CONSTRAINT "FK_CCI_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6819 (class 2606 OID 831367)
-- Name: FK_CCT_DCT; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_cct
    ADD CONSTRAINT "FK_CCT_DCT" FOREIGN KEY (cd_dct) REFERENCES tbl_dct(cd_dct);


--
-- TOC entry 6820 (class 2606 OID 831372)
-- Name: FK_CCT_EMC; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_cct
    ADD CONSTRAINT "FK_CCT_EMC" FOREIGN KEY (cd_emc) REFERENCES tbl_emc(cd_emc);


--
-- TOC entry 6828 (class 2606 OID 831377)
-- Name: PK_HCI_TCI; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_hci
    ADD CONSTRAINT "PK_HCI_TCI" FOREIGN KEY (cd_tci) REFERENCES tbl_tci(cd_tci);


--
-- TOC entry 6812 (class 2606 OID 831382)
-- Name: fk_act_emc; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_act
    ADD CONSTRAINT fk_act_emc FOREIGN KEY (cd_emc) REFERENCES tbl_emc(cd_emc);


--
-- TOC entry 6813 (class 2606 OID 831387)
-- Name: fk_ans_det; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_ans
    ADD CONSTRAINT fk_ans_det FOREIGN KEY (cd_det) REFERENCES sc_spc.tbl_det(cd_det);


--
-- TOC entry 6817 (class 2606 OID 831392)
-- Name: fk_cci_hcc; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_cci
    ADD CONSTRAINT fk_cci_hcc FOREIGN KEY (cd_hcc) REFERENCES tbl_hcc(cd_hcc);


--
-- TOC entry 6818 (class 2606 OID 831397)
-- Name: fk_cci_hci; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_cci
    ADD CONSTRAINT fk_cci_hci FOREIGN KEY (cd_hci) REFERENCES tbl_hci(cd_hci);


--
-- TOC entry 6821 (class 2606 OID 831402)
-- Name: fk_dct_act; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_dct
    ADD CONSTRAINT fk_dct_act FOREIGN KEY (cd_act) REFERENCES tbl_act(cd_act);


--
-- TOC entry 6822 (class 2606 OID 831407)
-- Name: fk_dct_crt; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_dct
    ADD CONSTRAINT fk_dct_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6823 (class 2606 OID 831412)
-- Name: fk_emc_cun; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_emc
    ADD CONSTRAINT fk_emc_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 6824 (class 2606 OID 831417)
-- Name: fk_emc_tci; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_emc
    ADD CONSTRAINT fk_emc_tci FOREIGN KEY (cd_tci) REFERENCES tbl_tci(cd_tci);


--
-- TOC entry 6825 (class 2606 OID 831422)
-- Name: fk_hcc_crt; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_hcc
    ADD CONSTRAINT fk_hcc_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6826 (class 2606 OID 831427)
-- Name: fk_hcc_usralt; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_hcc
    ADD CONSTRAINT fk_hcc_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_ucr(cd_ucr);


--
-- TOC entry 6827 (class 2606 OID 831432)
-- Name: fk_hcc_usrinc; Type: FK CONSTRAINT; Schema: sc_cci; Owner: scan
--

ALTER TABLE ONLY tbl_hcc
    ADD CONSTRAINT fk_hcc_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sc_cnt, pg_catalog;

--
-- TOC entry 6851 (class 2606 OID 831437)
-- Name: FK_TLC_USRALT; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tlc
    ADD CONSTRAINT "FK_TLC_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6852 (class 2606 OID 831442)
-- Name: FK_TLC_USRINC; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tlc
    ADD CONSTRAINT "FK_TLC_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6853 (class 2606 OID 831447)
-- Name: fg_tsr_usralt; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tsr
    ADD CONSTRAINT fg_tsr_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6854 (class 2606 OID 831452)
-- Name: fg_tsr_usrinc; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tsr
    ADD CONSTRAINT fg_tsr_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6829 (class 2606 OID 831457)
-- Name: fk_cnt_scn; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_cnt
    ADD CONSTRAINT fk_cnt_scn FOREIGN KEY (cd_scn) REFERENCES tbl_scn(cd_scn);


--
-- TOC entry 6830 (class 2606 OID 831462)
-- Name: fk_cnt_usralt; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_cnt
    ADD CONSTRAINT fk_cnt_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6831 (class 2606 OID 831467)
-- Name: fk_cnt_usrinc; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_cnt
    ADD CONSTRAINT fk_cnt_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6832 (class 2606 OID 831472)
-- Name: fk_lcn_cnt; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lcn
    ADD CONSTRAINT fk_lcn_cnt FOREIGN KEY (cd_cnt) REFERENCES tbl_cnt(cd_cnt);


--
-- TOC entry 6835 (class 2606 OID 831477)
-- Name: fk_lcn_cnt_exc; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lcn_exc
    ADD CONSTRAINT fk_lcn_cnt_exc FOREIGN KEY (cd_cnt) REFERENCES tbl_cnt(cd_cnt);


--
-- TOC entry 6833 (class 2606 OID 831482)
-- Name: fk_lcn_sst; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lcn
    ADD CONSTRAINT fk_lcn_sst FOREIGN KEY (cd_sst) REFERENCES tbl_sst(cd_sst);


--
-- TOC entry 6836 (class 2606 OID 831487)
-- Name: fk_lcn_sst_exc; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lcn_exc
    ADD CONSTRAINT fk_lcn_sst_exc FOREIGN KEY (cd_sst) REFERENCES tbl_sst(cd_sst);


--
-- TOC entry 6834 (class 2606 OID 831492)
-- Name: fk_lcn_tlc; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lcn
    ADD CONSTRAINT fk_lcn_tlc FOREIGN KEY (cd_tlc) REFERENCES tbl_tlc(cd_tlc);


--
-- TOC entry 6837 (class 2606 OID 831497)
-- Name: fk_lcn_tlc_exc; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lcn_exc
    ADD CONSTRAINT fk_lcn_tlc_exc FOREIGN KEY (cd_tlc) REFERENCES tbl_tlc(cd_tlc);


--
-- TOC entry 6838 (class 2606 OID 831502)
-- Name: fk_lpd_cd_cnt_crd; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lpd
    ADD CONSTRAINT fk_lpd_cd_cnt_crd FOREIGN KEY (cd_cnt_crd_lpd) REFERENCES tbl_cnt(cd_cnt);


--
-- TOC entry 6839 (class 2606 OID 831507)
-- Name: fk_lpd_cd_cnt_dbt; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_lpd
    ADD CONSTRAINT fk_lpd_cd_cnt_dbt FOREIGN KEY (cd_cnt_dbt_lpd) REFERENCES tbl_cnt(cd_cnt);


--
-- TOC entry 6840 (class 2606 OID 831512)
-- Name: fk_scn_scn; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_scn
    ADD CONSTRAINT fk_scn_scn FOREIGN KEY (pai_scn) REFERENCES tbl_scn(cd_scn);


--
-- TOC entry 6841 (class 2606 OID 831517)
-- Name: fk_sdc_cnt; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_sdc
    ADD CONSTRAINT fk_sdc_cnt FOREIGN KEY (cd_cnt) REFERENCES tbl_cnt(cd_cnt);


--
-- TOC entry 6842 (class 2606 OID 831522)
-- Name: fk_sds_scn; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_sds
    ADD CONSTRAINT fk_sds_scn FOREIGN KEY (cd_scn) REFERENCES tbl_scn(cd_scn);


--
-- TOC entry 6843 (class 2606 OID 831527)
-- Name: fk_sgc_gcn; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_sgc
    ADD CONSTRAINT fk_sgc_gcn FOREIGN KEY (cd_gcn) REFERENCES tbl_gcn(cd_gcn);


--
-- TOC entry 6846 (class 2606 OID 831532)
-- Name: fk_tbc_cnt_cnt; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tbc_cnt
    ADD CONSTRAINT fk_tbc_cnt_cnt FOREIGN KEY (cd_cnt) REFERENCES tbl_cnt(cd_cnt);


--
-- TOC entry 6847 (class 2606 OID 831537)
-- Name: fk_tbc_cnt_tbc; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tbc_cnt
    ADD CONSTRAINT fk_tbc_cnt_tbc FOREIGN KEY (cd_tbc) REFERENCES tbl_tbc(cd_tbc);


--
-- TOC entry 6848 (class 2606 OID 831542)
-- Name: fk_tbc_cnt_usralt; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tbc_cnt
    ADD CONSTRAINT fk_tbc_cnt_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6849 (class 2606 OID 831547)
-- Name: fk_tbc_cnt_usrinc; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tbc_cnt
    ADD CONSTRAINT fk_tbc_cnt_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6844 (class 2606 OID 831552)
-- Name: fk_tbc_usralt; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tbc
    ADD CONSTRAINT fk_tbc_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6845 (class 2606 OID 831557)
-- Name: fk_tbc_usrinc; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tbc
    ADD CONSTRAINT fk_tbc_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6855 (class 2606 OID 831562)
-- Name: fk_tsr_cnt; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tsr
    ADD CONSTRAINT fk_tsr_cnt FOREIGN KEY (cd_cnt) REFERENCES tbl_cnt(cd_cnt);


--
-- TOC entry 6856 (class 2606 OID 831567)
-- Name: fk_tsr_cnt_nr_trs; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tsr
    ADD CONSTRAINT fk_tsr_cnt_nr_trs FOREIGN KEY (cd_cnt_nr_trs_tsr) REFERENCES tbl_cnt(cd_cnt);


--
-- TOC entry 6850 (class 2606 OID 831572)
-- Name: pk_tcb_sgc; Type: FK CONSTRAINT; Schema: sc_cnt; Owner: scan
--

ALTER TABLE ONLY tbl_tcn
    ADD CONSTRAINT pk_tcb_sgc FOREIGN KEY (cd_sgc) REFERENCES tbl_sgc(cd_sgc);


SET search_path = sc_ctb, pg_catalog;

--
-- TOC entry 6617 (class 2606 OID 831577)
-- Name: fk_aec_usr_dwn; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_aec
    ADD CONSTRAINT fk_aec_usr_dwn FOREIGN KEY (cd_dwn_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6857 (class 2606 OID 831582)
-- Name: fk_cte_evt; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_cte
    ADD CONSTRAINT fk_cte_evt FOREIGN KEY (cd_evt) REFERENCES tbl_evt(cd_evt);


--
-- TOC entry 6858 (class 2606 OID 831587)
-- Name: fk_cte_tve; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_cte
    ADD CONSTRAINT fk_cte_tve FOREIGN KEY (cd_tve) REFERENCES tbl_tve(cd_tve);


--
-- TOC entry 6859 (class 2606 OID 831592)
-- Name: fk_cte_usr_alt; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_cte
    ADD CONSTRAINT fk_cte_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6860 (class 2606 OID 831597)
-- Name: fk_cte_usr_inc; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_cte
    ADD CONSTRAINT fk_cte_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6861 (class 2606 OID 831602)
-- Name: fk_daec_aec; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_daec
    ADD CONSTRAINT fk_daec_aec FOREIGN KEY (cd_aec) REFERENCES tbl_aec(cd_aec);


--
-- TOC entry 6618 (class 2606 OID 831607)
-- Name: fk_daec_cpl_daec_lcn; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_daec_cpl
    ADD CONSTRAINT fk_daec_cpl_daec_lcn FOREIGN KEY (cd_daec_lcn) REFERENCES tbl_daec_lcn(cd_daec_lcn);


--
-- TOC entry 6619 (class 2606 OID 831612)
-- Name: fk_daec_lcn_aec; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_daec_lcn
    ADD CONSTRAINT fk_daec_lcn_aec FOREIGN KEY (cd_aec) REFERENCES tbl_aec(cd_aec);


--
-- TOC entry 7255 (class 2606 OID 950022)
-- Name: fk_dwa; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_arq_ctb
    ADD CONSTRAINT fk_dwa FOREIGN KEY (cd_dwa) REFERENCES sc_dwn.tbl_dwa(cd_dwa);


--
-- TOC entry 6862 (class 2606 OID 831617)
-- Name: fk_evt_usr_alt; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_evt
    ADD CONSTRAINT fk_evt_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6863 (class 2606 OID 831622)
-- Name: fk_evt_usr_inc; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_evt
    ADD CONSTRAINT fk_evt_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6864 (class 2606 OID 831627)
-- Name: fk_tve_evt; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_tve
    ADD CONSTRAINT fk_tve_evt FOREIGN KEY (cd_evt) REFERENCES tbl_evt(cd_evt);


--
-- TOC entry 6865 (class 2606 OID 831632)
-- Name: fk_tve_usr_alt; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_tve
    ADD CONSTRAINT fk_tve_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6866 (class 2606 OID 831637)
-- Name: fk_tve_usr_inc; Type: FK CONSTRAINT; Schema: sc_ctb; Owner: scan
--

ALTER TABLE ONLY tbl_tve
    ADD CONSTRAINT fk_tve_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sc_dgt, pg_catalog;

--
-- TOC entry 7257 (class 2606 OID 999092)
-- Name: fk_cd_usr_alt; Type: FK CONSTRAINT; Schema: sc_dgt; Owner: scan
--

ALTER TABLE ONLY tbl_arq
    ADD CONSTRAINT fk_cd_usr_alt FOREIGN KEY (cd_usr_alt) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7256 (class 2606 OID 966401)
-- Name: fk_tar; Type: FK CONSTRAINT; Schema: sc_dgt; Owner: scan
--

ALTER TABLE ONLY tbl_arq
    ADD CONSTRAINT fk_tar FOREIGN KEY (cd_tar) REFERENCES tbl_tar(cd_tar);


SET search_path = sc_dsp, pg_catalog;

--
-- TOC entry 6867 (class 2606 OID 831642)
-- Name: fk_fdv_vds; Type: FK CONSTRAINT; Schema: sc_dsp; Owner: scan
--

ALTER TABLE ONLY tbl_fvd
    ADD CONSTRAINT fk_fdv_vds FOREIGN KEY (cd_vds) REFERENCES tbl_vds(cd_vds);


--
-- TOC entry 7228 (class 2606 OID 871436)
-- Name: fk_pai_mdp; Type: FK CONSTRAINT; Schema: sc_dsp; Owner: scan
--

ALTER TABLE ONLY tbl_mdp
    ADD CONSTRAINT fk_pai_mdp FOREIGN KEY (cd_pai_mdp) REFERENCES tbl_mdp(cd_mdp);


--
-- TOC entry 6868 (class 2606 OID 871465)
-- Name: fk_vds_mdp; Type: FK CONSTRAINT; Schema: sc_dsp; Owner: scan
--

ALTER TABLE ONLY tbl_vds
    ADD CONSTRAINT fk_vds_mdp FOREIGN KEY (cd_mdp) REFERENCES tbl_mdp(cd_mdp);


SET search_path = sc_dwn, pg_catalog;

--
-- TOC entry 6869 (class 2606 OID 944597)
-- Name: fk_dwa_tda; Type: FK CONSTRAINT; Schema: sc_dwn; Owner: scan
--

ALTER TABLE ONLY tbl_dwa
    ADD CONSTRAINT fk_dwa_tda FOREIGN KEY (cd_tda) REFERENCES tbl_tda(cd_tda);


SET search_path = sc_fcr, pg_catalog;

--
-- TOC entry 6888 (class 2606 OID 831652)
-- Name: FK_TPC_USRALT; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_tpc
    ADD CONSTRAINT "FK_TPC_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6889 (class 2606 OID 831657)
-- Name: FK_TPC_USRINC; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_tpc
    ADD CONSTRAINT "FK_TPC_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6870 (class 2606 OID 831662)
-- Name: fk_fcr_blt; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_fcr
    ADD CONSTRAINT fk_fcr_blt FOREIGN KEY (cd_blt) REFERENCES sc_cbr.tbl_blt(cd_blt);


--
-- TOC entry 6871 (class 2606 OID 831667)
-- Name: fk_fcr_crt; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_fcr
    ADD CONSTRAINT fk_fcr_crt FOREIGN KEY (cd_fcr) REFERENCES tbl_fcr(cd_fcr);


--
-- TOC entry 7273 (class 2606 OID 989092)
-- Name: fk_fcr_exc_blt; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: postgres
--

ALTER TABLE ONLY tbl_fcr_exc
    ADD CONSTRAINT fk_fcr_exc_blt FOREIGN KEY (cd_blt) REFERENCES sc_cbr.tbl_blt(cd_blt);


--
-- TOC entry 7274 (class 2606 OID 989097)
-- Name: fk_fcr_exc_crt; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: postgres
--

ALTER TABLE ONLY tbl_fcr_exc
    ADD CONSTRAINT fk_fcr_exc_crt FOREIGN KEY (cd_fcr) REFERENCES tbl_fcr(cd_fcr);


--
-- TOC entry 6872 (class 2606 OID 831672)
-- Name: fk_fcr_tlt_tlt; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_fcr_tlt
    ADD CONSTRAINT fk_fcr_tlt_tlt FOREIGN KEY (cd_tlt) REFERENCES sc_opr.tbl_tlt(cd_tlt);


--
-- TOC entry 6873 (class 2606 OID 989112)
-- Name: fk_fcr_top_top; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_fcr_top
    ADD CONSTRAINT fk_fcr_top_top FOREIGN KEY (cd_top) REFERENCES sc_opr.tbl_top(cd_top);


--
-- TOC entry 6874 (class 2606 OID 831687)
-- Name: fk_pfc_crt; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_pfc
    ADD CONSTRAINT fk_pfc_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6875 (class 2606 OID 831692)
-- Name: fk_pfc_fcr; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_pfc
    ADD CONSTRAINT fk_pfc_fcr FOREIGN KEY (cd_fcr) REFERENCES tbl_fcr(cd_fcr);


--
-- TOC entry 6880 (class 2606 OID 831697)
-- Name: fk_pfc_prc_pfc; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_pfc_prc
    ADD CONSTRAINT fk_pfc_prc_pfc FOREIGN KEY (cd_pfc) REFERENCES tbl_pfc(cd_pfc);


--
-- TOC entry 6881 (class 2606 OID 831702)
-- Name: fk_pfc_prc_prc; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_pfc_prc
    ADD CONSTRAINT fk_pfc_prc_prc FOREIGN KEY (cd_prc) REFERENCES tbl_prc(cd_prc);


--
-- TOC entry 6876 (class 2606 OID 831707)
-- Name: fk_pfc_tpc; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_pfc
    ADD CONSTRAINT fk_pfc_tpc FOREIGN KEY (cd_tpc) REFERENCES tbl_tpc(cd_tpc);


--
-- TOC entry 6877 (class 2606 OID 831712)
-- Name: fk_pfc_usr_cnc; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_pfc
    ADD CONSTRAINT fk_pfc_usr_cnc FOREIGN KEY (cd_cnc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6878 (class 2606 OID 831717)
-- Name: fk_pfc_usr_inc; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_pfc
    ADD CONSTRAINT fk_pfc_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6883 (class 2606 OID 831722)
-- Name: fk_prc_crt; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_prc
    ADD CONSTRAINT fk_prc_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6884 (class 2606 OID 831727)
-- Name: fk_prc_opr; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_prc
    ADD CONSTRAINT fk_prc_opr FOREIGN KEY (cd_opr) REFERENCES sc_opr.tbl_opr(cd_opr);


--
-- TOC entry 6885 (class 2606 OID 831732)
-- Name: fk_tfc_crtant; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_tfc
    ADD CONSTRAINT fk_tfc_crtant FOREIGN KEY (cd_ant_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6886 (class 2606 OID 831737)
-- Name: fk_tfc_crtatl; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_tfc
    ADD CONSTRAINT fk_tfc_crtatl FOREIGN KEY (cd_atl_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6887 (class 2606 OID 831742)
-- Name: fk_tfc_fcr; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_tfc
    ADD CONSTRAINT fk_tfc_fcr FOREIGN KEY (cd_fcr) REFERENCES tbl_fcr(cd_fcr);


--
-- TOC entry 6890 (class 2606 OID 831747)
-- Name: fk_tpc_cnt; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_tpc
    ADD CONSTRAINT fk_tpc_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6891 (class 2606 OID 831752)
-- Name: fk_tpc_tlc; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_tpc
    ADD CONSTRAINT fk_tpc_tlc FOREIGN KEY (cd_tlc) REFERENCES sc_cnt.tbl_tlc(cd_tlc);


--
-- TOC entry 6879 (class 2606 OID 831757)
-- Name: pk_pfc_cnt; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_pfc
    ADD CONSTRAINT pk_pfc_cnt FOREIGN KEY (cnt_org_pfc) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6882 (class 2606 OID 831762)
-- Name: pk_pfc_tlt_tlt; Type: FK CONSTRAINT; Schema: sc_fcr; Owner: scan
--

ALTER TABLE ONLY tbl_pfc_tlt
    ADD CONSTRAINT pk_pfc_tlt_tlt FOREIGN KEY (cd_tlt) REFERENCES sc_opr.tbl_tlt(cd_tlt);


SET search_path = sc_fep, pg_catalog;

--
-- TOC entry 6913 (class 2606 OID 831767)
-- Name: fk_fep_blt; Type: FK CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_fep
    ADD CONSTRAINT fk_fep_blt FOREIGN KEY (cd_blt) REFERENCES sc_cbr.tbl_blt(cd_blt);


--
-- TOC entry 6914 (class 2606 OID 831772)
-- Name: fk_fep_ctr; Type: FK CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_fep
    ADD CONSTRAINT fk_fep_ctr FOREIGN KEY (cd_ctr) REFERENCES sc_cad.tbl_ctr(cd_ctr);


--
-- TOC entry 6915 (class 2606 OID 831777)
-- Name: fk_fep_cun; Type: FK CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_fep
    ADD CONSTRAINT fk_fep_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 6916 (class 2606 OID 875882)
-- Name: fk_fep_usr_fg_vld_atr; Type: FK CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_fep
    ADD CONSTRAINT fk_fep_usr_fg_vld_atr FOREIGN KEY (cd_usr_fg_vld_atr_fep) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6917 (class 2606 OID 831782)
-- Name: fk_pfe_cnt; Type: FK CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_pfe
    ADD CONSTRAINT fk_pfe_cnt FOREIGN KEY (cnt_cd) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6918 (class 2606 OID 831787)
-- Name: fk_pfe_fep; Type: FK CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_pfe
    ADD CONSTRAINT fk_pfe_fep FOREIGN KEY (cd_fep) REFERENCES tbl_fep(cd_fep);


--
-- TOC entry 6919 (class 2606 OID 831792)
-- Name: fk_pfe_tpe; Type: FK CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_pfe
    ADD CONSTRAINT fk_pfe_tpe FOREIGN KEY (cd_tpe) REFERENCES tbl_tpe(cd_tpe);


--
-- TOC entry 6920 (class 2606 OID 831797)
-- Name: fk_tpe_cnt; Type: FK CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_tpe
    ADD CONSTRAINT fk_tpe_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6921 (class 2606 OID 831802)
-- Name: fk_tpe_tlc; Type: FK CONSTRAINT; Schema: sc_fep; Owner: scan
--

ALTER TABLE ONLY tbl_tpe
    ADD CONSTRAINT fk_tpe_tlc FOREIGN KEY (cd_tlc) REFERENCES sc_cnt.tbl_tlc(cd_tlc);


SET search_path = sc_fin, pg_catalog;

--
-- TOC entry 6922 (class 2606 OID 831807)
-- Name: fk_alr_cnt_dbt; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_alr
    ADD CONSTRAINT fk_alr_cnt_dbt FOREIGN KEY (cd_cnt_dbt_alr) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6923 (class 2606 OID 831812)
-- Name: fk_alr_drr; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_alr
    ADD CONSTRAINT fk_alr_drr FOREIGN KEY (cd_drr) REFERENCES tbl_drr(cd_drr);


--
-- TOC entry 6924 (class 2606 OID 831817)
-- Name: fk_alr_rrc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_alr
    ADD CONSTRAINT fk_alr_rrc FOREIGN KEY (cd_rrc) REFERENCES tbl_rrc(cd_rrc);


--
-- TOC entry 6925 (class 2606 OID 831822)
-- Name: fk_alr_tlc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_alr
    ADD CONSTRAINT fk_alr_tlc FOREIGN KEY (cd_tlc) REFERENCES sc_cnt.tbl_tlc(cd_tlc);


--
-- TOC entry 6926 (class 2606 OID 831827)
-- Name: fk_alr_usralt; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_alr
    ADD CONSTRAINT fk_alr_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6927 (class 2606 OID 831832)
-- Name: fk_alr_usrinc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_alr
    ADD CONSTRAINT fk_alr_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6928 (class 2606 OID 950288)
-- Name: fk_bla_blt; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_bla
    ADD CONSTRAINT fk_bla_blt FOREIGN KEY (cd_blt) REFERENCES sc_cbr.tbl_blt(cd_blt);


--
-- TOC entry 6598 (class 2606 OID 831842)
-- Name: fk_ccr_bnc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_ccr
    ADD CONSTRAINT fk_ccr_bnc FOREIGN KEY (cd_bnc) REFERENCES tbl_bnc(cd_bnc);


--
-- TOC entry 6599 (class 2606 OID 831847)
-- Name: fk_ccr_cnt; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_ccr
    ADD CONSTRAINT fk_ccr_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6930 (class 2606 OID 831852)
-- Name: fk_did_cnt; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_did
    ADD CONSTRAINT fk_did_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6931 (class 2606 OID 831857)
-- Name: fk_did_ctr; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_did
    ADD CONSTRAINT fk_did_ctr FOREIGN KEY (cd_ctr) REFERENCES sc_cad.tbl_ctr(cd_ctr);


--
-- TOC entry 6932 (class 2606 OID 831862)
-- Name: fk_did_emp; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_did
    ADD CONSTRAINT fk_did_emp FOREIGN KEY (cd_emp) REFERENCES sc_cad.tbl_emp(cd_emp);


--
-- TOC entry 6933 (class 2606 OID 831867)
-- Name: fk_did_usr_alt; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_did
    ADD CONSTRAINT fk_did_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6934 (class 2606 OID 831872)
-- Name: fk_did_usr_inc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_did
    ADD CONSTRAINT fk_did_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6935 (class 2606 OID 831877)
-- Name: fk_drr_ctr; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_drr
    ADD CONSTRAINT fk_drr_ctr FOREIGN KEY (cd_ctr) REFERENCES sc_cad.tbl_ctr(cd_ctr);


--
-- TOC entry 6936 (class 2606 OID 831882)
-- Name: fk_drr_emp; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_drr
    ADD CONSTRAINT fk_drr_emp FOREIGN KEY (cd_emp) REFERENCES sc_cad.tbl_emp(cd_emp);


--
-- TOC entry 6940 (class 2606 OID 831887)
-- Name: fk_drr_hfe_drr; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_drr_hfe
    ADD CONSTRAINT fk_drr_hfe_drr FOREIGN KEY (cd_drr) REFERENCES tbl_drr(cd_drr);


--
-- TOC entry 6941 (class 2606 OID 831892)
-- Name: fk_drr_hfe_hfe; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_drr_hfe
    ADD CONSTRAINT fk_drr_hfe_hfe FOREIGN KEY (cd_hfe) REFERENCES sc_adp.tbl_hfe(cd_hfe);


--
-- TOC entry 6937 (class 2606 OID 831897)
-- Name: fk_drr_rrc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_drr
    ADD CONSTRAINT fk_drr_rrc FOREIGN KEY (cd_rrc) REFERENCES tbl_rrc(cd_rrc);


--
-- TOC entry 6938 (class 2606 OID 831902)
-- Name: fk_drr_usr_alt; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_drr
    ADD CONSTRAINT fk_drr_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6939 (class 2606 OID 831907)
-- Name: fk_drr_usr_inc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_drr
    ADD CONSTRAINT fk_drr_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6929 (class 2606 OID 950293)
-- Name: fk_emp_fem; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_bla
    ADD CONSTRAINT fk_emp_fem FOREIGN KEY (cd_emp, cd_fem) REFERENCES sc_cad.tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 6942 (class 2606 OID 831917)
-- Name: fk_hadr_drr; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_hadr
    ADD CONSTRAINT fk_hadr_drr FOREIGN KEY (cd_drr) REFERENCES tbl_drr(cd_drr);


--
-- TOC entry 6943 (class 2606 OID 831922)
-- Name: fk_hadr_incusr; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_hadr
    ADD CONSTRAINT fk_hadr_incusr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6945 (class 2606 OID 831927)
-- Name: fk_idp_ccr; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_idp
    ADD CONSTRAINT fk_idp_ccr FOREIGN KEY (cd_ccr) REFERENCES tbl_ccr(cd_ccr);


--
-- TOC entry 6944 (class 2606 OID 1622980)
-- Name: fk_idp_hfe; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_idp
    ADD CONSTRAINT fk_idp_hfe FOREIGN KEY (cd_hfe) REFERENCES sc_adp.tbl_hfe(cd_hfe);


--
-- TOC entry 6946 (class 2606 OID 831932)
-- Name: fk_idp_rrc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_idp
    ADD CONSTRAINT fk_idp_rrc FOREIGN KEY (cd_rrc) REFERENCES tbl_rrc(cd_rrc);


--
-- TOC entry 6947 (class 2606 OID 831937)
-- Name: fk_idp_usr_alt; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_idp
    ADD CONSTRAINT fk_idp_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6948 (class 2606 OID 831942)
-- Name: fk_idp_usr_cnc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_idp
    ADD CONSTRAINT fk_idp_usr_cnc FOREIGN KEY (cd_cnc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6949 (class 2606 OID 831947)
-- Name: fk_idp_usr_inc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_idp
    ADD CONSTRAINT fk_idp_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6950 (class 2606 OID 831952)
-- Name: fk_idp_usr_prc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_idp
    ADD CONSTRAINT fk_idp_usr_prc FOREIGN KEY (cd_prc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6951 (class 2606 OID 831957)
-- Name: fk_rrc_cnt_crd; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_rrc
    ADD CONSTRAINT fk_rrc_cnt_crd FOREIGN KEY (cd_cnt_crd) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6952 (class 2606 OID 831962)
-- Name: fk_rrc_cnt_dbt; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_rrc
    ADD CONSTRAINT fk_rrc_cnt_dbt FOREIGN KEY (cd_cnt_dbt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6953 (class 2606 OID 831967)
-- Name: fk_rrc_emp; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_rrc
    ADD CONSTRAINT fk_rrc_emp FOREIGN KEY (cd_emp_old) REFERENCES sc_cad.tbl_emp(cd_emp);


--
-- TOC entry 6954 (class 2606 OID 831972)
-- Name: fk_rrc_fem; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_rrc
    ADD CONSTRAINT fk_rrc_fem FOREIGN KEY (cd_fem_old, cd_emp_old) REFERENCES sc_cad.tbl_fem(cd_fem, cd_emp);


--
-- TOC entry 6955 (class 2606 OID 831977)
-- Name: fk_rrc_gem; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_rrc
    ADD CONSTRAINT fk_rrc_gem FOREIGN KEY (cd_gem) REFERENCES sc_cad.tbl_gem(cd_gem);


--
-- TOC entry 6956 (class 2606 OID 831982)
-- Name: fk_rrc_trc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_rrc
    ADD CONSTRAINT fk_rrc_trc FOREIGN KEY (cd_trc) REFERENCES tbl_trc(cd_trc);


--
-- TOC entry 6611 (class 2606 OID 831987)
-- Name: fk_tec_cntdst; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_tec
    ADD CONSTRAINT fk_tec_cntdst FOREIGN KEY (cd_cnt_dst) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6612 (class 2606 OID 831992)
-- Name: fk_tec_cntorg; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_tec
    ADD CONSTRAINT fk_tec_cntorg FOREIGN KEY (cd_cnt_org) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6613 (class 2606 OID 831997)
-- Name: fk_tec_ttc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_tec
    ADD CONSTRAINT fk_tec_ttc FOREIGN KEY (cd_ttc) REFERENCES tbl_ttc(cd_ttc);


--
-- TOC entry 6614 (class 2606 OID 832002)
-- Name: fk_tec_usralt; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_tec
    ADD CONSTRAINT fk_tec_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6615 (class 2606 OID 832007)
-- Name: fk_tec_usrcnc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_tec
    ADD CONSTRAINT fk_tec_usrcnc FOREIGN KEY (cd_cnc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6616 (class 2606 OID 832012)
-- Name: fk_tec_usrinc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_tec
    ADD CONSTRAINT fk_tec_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6957 (class 2606 OID 832017)
-- Name: fk_trc_altusr; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_trc
    ADD CONSTRAINT fk_trc_altusr FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6958 (class 2606 OID 832022)
-- Name: fk_trc_incusr; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_trc
    ADD CONSTRAINT fk_trc_incusr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6959 (class 2606 OID 832027)
-- Name: fk_ttc_tlc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_ttc
    ADD CONSTRAINT fk_ttc_tlc FOREIGN KEY (cd_tlc) REFERENCES sc_cnt.tbl_tlc(cd_tlc);


--
-- TOC entry 6960 (class 2606 OID 832032)
-- Name: fk_ttc_usralt; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_ttc
    ADD CONSTRAINT fk_ttc_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6961 (class 2606 OID 832037)
-- Name: fk_ttc_usrinc; Type: FK CONSTRAINT; Schema: sc_fin; Owner: scan
--

ALTER TABLE ONLY tbl_ttc
    ADD CONSTRAINT fk_ttc_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sc_fsc, pg_catalog;

--
-- TOC entry 6963 (class 2606 OID 832042)
-- Name: fk_cnae; Type: FK CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_srv
    ADD CONSTRAINT fk_cnae FOREIGN KEY (cd_cnae, cd_itm_lst_cnae) REFERENCES tbl_cnae(cd_cnae, cd_itm_lst_cnae);


--
-- TOC entry 6964 (class 2606 OID 832047)
-- Name: fk_cnpj; Type: FK CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_srv
    ADD CONSTRAINT fk_cnpj FOREIGN KEY (cnpj_psr) REFERENCES tbl_psr(cnpj_psr);


--
-- TOC entry 6965 (class 2606 OID 832052)
-- Name: fk_cpj; Type: FK CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_srv
    ADD CONSTRAINT fk_cpj FOREIGN KEY (cpj_tsr) REFERENCES tbl_tsr(cpj_tsr);


--
-- TOC entry 6962 (class 2606 OID 832057)
-- Name: fk_srv; Type: FK CONSTRAINT; Schema: sc_fsc; Owner: scan
--

ALTER TABLE ONLY tbl_rps
    ADD CONSTRAINT fk_srv FOREIGN KEY (cd_srv) REFERENCES tbl_srv(cd_srv);


SET search_path = sc_ind, pg_catalog;

--
-- TOC entry 6966 (class 2606 OID 832062)
-- Name: fk_alt_ind_emp; Type: FK CONSTRAINT; Schema: sc_ind; Owner: scan
--

ALTER TABLE ONLY tbl_alt_ind
    ADD CONSTRAINT fk_alt_ind_emp FOREIGN KEY (cd_emp) REFERENCES sc_cad.tbl_emp(cd_emp);


SET search_path = sc_job, pg_catalog;

--
-- TOC entry 6969 (class 2606 OID 832067)
-- Name: FK_LJB_JOB; Type: FK CONSTRAINT; Schema: sc_job; Owner: scan
--

ALTER TABLE ONLY tbl_ljb
    ADD CONSTRAINT "FK_LJB_JOB" FOREIGN KEY (cd_job) REFERENCES tbl_job(cd_job);


--
-- TOC entry 7265 (class 2606 OID 975764)
-- Name: FK_LPJ_PLJ; Type: FK CONSTRAINT; Schema: sc_job; Owner: scan
--

ALTER TABLE ONLY tbl_lpj
    ADD CONSTRAINT "FK_LPJ_PLJ" FOREIGN KEY (cd_plj) REFERENCES tbl_plj(cd_plj);


--
-- TOC entry 6967 (class 2606 OID 832072)
-- Name: fk_job_usralt; Type: FK CONSTRAINT; Schema: sc_job; Owner: scan
--

ALTER TABLE ONLY tbl_job
    ADD CONSTRAINT fk_job_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6968 (class 2606 OID 832077)
-- Name: fk_job_usrinc; Type: FK CONSTRAINT; Schema: sc_job; Owner: scan
--

ALTER TABLE ONLY tbl_job
    ADD CONSTRAINT fk_job_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7263 (class 2606 OID 975746)
-- Name: fk_ljb_usr_alt; Type: FK CONSTRAINT; Schema: sc_job; Owner: scan
--

ALTER TABLE ONLY tbl_plj
    ADD CONSTRAINT fk_ljb_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7264 (class 2606 OID 975751)
-- Name: fk_ljb_usr_inc; Type: FK CONSTRAINT; Schema: sc_job; Owner: scan
--

ALTER TABLE ONLY tbl_plj
    ADD CONSTRAINT fk_ljb_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sc_mnt, pg_catalog;

--
-- TOC entry 7253 (class 2606 OID 927721)
-- Name: fg_dar_arm; Type: FK CONSTRAINT; Schema: sc_mnt; Owner: scan
--

ALTER TABLE ONLY tbl_dar
    ADD CONSTRAINT fg_dar_arm FOREIGN KEY (cd_arm) REFERENCES tbl_arm(cd_arm);


--
-- TOC entry 7230 (class 2606 OID 877676)
-- Name: fk_ads_pct; Type: FK CONSTRAINT; Schema: sc_mnt; Owner: scan
--

ALTER TABLE ONLY tbl_ads
    ADD CONSTRAINT fk_ads_pct FOREIGN KEY (cd_pct) REFERENCES tbl_pct(cd_pct);


--
-- TOC entry 7229 (class 2606 OID 927689)
-- Name: fk_mnt_crt; Type: FK CONSTRAINT; Schema: sc_mnt; Owner: scan
--

ALTER TABLE ONLY tbl_mnt
    ADD CONSTRAINT fk_mnt_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


SET search_path = sc_mrk, pg_catalog;

--
-- TOC entry 7275 (class 2606 OID 992922)
-- Name: fk_usr; Type: FK CONSTRAINT; Schema: sc_mrk; Owner: scan
--

ALTER TABLE ONLY tbl_bnn
    ADD CONSTRAINT fk_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7277 (class 2606 OID 992952)
-- Name: fk_usr; Type: FK CONSTRAINT; Schema: sc_mrk; Owner: scan
--

ALTER TABLE ONLY tbl_abn
    ADD CONSTRAINT fk_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7276 (class 2606 OID 992927)
-- Name: fk_usr_alt; Type: FK CONSTRAINT; Schema: sc_mrk; Owner: scan
--

ALTER TABLE ONLY tbl_bnn
    ADD CONSTRAINT fk_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7278 (class 2606 OID 992957)
-- Name: fk_usr_alt; Type: FK CONSTRAINT; Schema: sc_mrk; Owner: scan
--

ALTER TABLE ONLY tbl_abn
    ADD CONSTRAINT fk_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sc_msg, pg_catalog;

--
-- TOC entry 6970 (class 2606 OID 832082)
-- Name: fk_msg_tms; Type: FK CONSTRAINT; Schema: sc_msg; Owner: scan
--

ALTER TABLE ONLY tbl_msg
    ADD CONSTRAINT fk_msg_tms FOREIGN KEY (cd_tms) REFERENCES tbl_tms(cd_tms);


--
-- TOC entry 6971 (class 2606 OID 832087)
-- Name: fk_msg_usralt; Type: FK CONSTRAINT; Schema: sc_msg; Owner: scan
--

ALTER TABLE ONLY tbl_msg
    ADD CONSTRAINT fk_msg_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6972 (class 2606 OID 832092)
-- Name: fk_msg_usrinc; Type: FK CONSTRAINT; Schema: sc_msg; Owner: scan
--

ALTER TABLE ONLY tbl_msg
    ADD CONSTRAINT fk_msg_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sc_opr, pg_catalog;

--
-- TOC entry 6982 (class 2606 OID 832097)
-- Name: cd_eop_opr; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_eop
    ADD CONSTRAINT cd_eop_opr FOREIGN KEY (cd_opr) REFERENCES tbl_opr(cd_opr);


--
-- TOC entry 6973 (class 2606 OID 832102)
-- Name: fk_aal_crt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_aal_antiga
    ADD CONSTRAINT fk_aal_crt FOREIGN KEY (cd_crt) REFERENCES tbl_crt(cd_crt);


--
-- TOC entry 6974 (class 2606 OID 832107)
-- Name: fk_aal_tlt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_aal_antiga
    ADD CONSTRAINT fk_aal_tlt FOREIGN KEY (cd_tlt) REFERENCES tbl_tlt(cd_tlt);


--
-- TOC entry 6975 (class 2606 OID 832112)
-- Name: fk_cnt_crt_cnt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_cnt_crt
    ADD CONSTRAINT fk_cnt_crt_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6976 (class 2606 OID 832117)
-- Name: fk_cnt_crt_crt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_cnt_crt
    ADD CONSTRAINT fk_cnt_crt_crt FOREIGN KEY (cd_crt) REFERENCES tbl_crt(cd_crt);


--
-- TOC entry 6977 (class 2606 OID 832122)
-- Name: fk_cnt_crt_usrinc; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_cnt_crt
    ADD CONSTRAINT fk_cnt_crt_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6892 (class 2606 OID 832127)
-- Name: fk_crt_ctr; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_crt
    ADD CONSTRAINT fk_crt_ctr FOREIGN KEY (cd_ctr) REFERENCES sc_cad.tbl_ctr(cd_ctr);


--
-- TOC entry 7293 (class 2606 OID 1010409)
-- Name: fk_crt_exc_fcr; Type: FK CONSTRAINT; Schema: sc_opr; Owner: postgres
--

ALTER TABLE ONLY tbl_crt_exc
    ADD CONSTRAINT fk_crt_exc_fcr FOREIGN KEY (cd_fcr) REFERENCES sc_fcr.tbl_fcr(cd_fcr);


--
-- TOC entry 7294 (class 2606 OID 1010414)
-- Name: fk_crt_exc_fcr_ult; Type: FK CONSTRAINT; Schema: sc_opr; Owner: postgres
--

ALTER TABLE ONLY tbl_crt_exc
    ADD CONSTRAINT fk_crt_exc_fcr_ult FOREIGN KEY (cd_ult_fcr) REFERENCES sc_fcr.tbl_fcr(cd_fcr);


--
-- TOC entry 6893 (class 2606 OID 832132)
-- Name: fk_crt_fcr; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_crt
    ADD CONSTRAINT fk_crt_fcr FOREIGN KEY (cd_fcr) REFERENCES sc_fcr.tbl_fcr(cd_fcr);


--
-- TOC entry 6894 (class 2606 OID 832137)
-- Name: fk_crt_fcr_ult; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_crt
    ADD CONSTRAINT fk_crt_fcr_ult FOREIGN KEY (cd_ult_fcr) REFERENCES sc_fcr.tbl_fcr(cd_fcr);


--
-- TOC entry 6895 (class 2606 OID 832142)
-- Name: fk_crt_fnc; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_crt
    ADD CONSTRAINT fk_crt_fnc FOREIGN KEY (cd_fnc) REFERENCES sc_cad.tbl_fnc(cd_fnc);


--
-- TOC entry 7295 (class 2606 OID 1010419)
-- Name: fk_crt_fnc; Type: FK CONSTRAINT; Schema: sc_opr; Owner: postgres
--

ALTER TABLE ONLY tbl_crt_exc
    ADD CONSTRAINT fk_crt_fnc FOREIGN KEY (cd_fnc) REFERENCES sc_cad.tbl_fnc(cd_fnc);


--
-- TOC entry 6896 (class 2606 OID 832147)
-- Name: fk_crt_inc_usr; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_crt
    ADD CONSTRAINT fk_crt_inc_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7296 (class 2606 OID 1010424)
-- Name: fk_crt_inc_usr; Type: FK CONSTRAINT; Schema: sc_opr; Owner: postgres
--

ALTER TABLE ONLY tbl_crt_exc
    ADD CONSTRAINT fk_crt_inc_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6899 (class 2606 OID 892071)
-- Name: fk_crt_pcs; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_crt
    ADD CONSTRAINT fk_crt_pcs FOREIGN KEY (cd_pcs) REFERENCES sc_cad.tbl_pcs(cd_pcs);


--
-- TOC entry 7297 (class 2606 OID 1010429)
-- Name: fk_crt_pcs; Type: FK CONSTRAINT; Schema: sc_opr; Owner: postgres
--

ALTER TABLE ONLY tbl_crt_exc
    ADD CONSTRAINT fk_crt_pcs FOREIGN KEY (cd_pcs) REFERENCES sc_cad.tbl_pcs(cd_pcs);


--
-- TOC entry 6897 (class 2606 OID 832152)
-- Name: fk_crt_prd; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_crt
    ADD CONSTRAINT fk_crt_prd FOREIGN KEY (cd_prd) REFERENCES sc_cad.tbl_prd(cd_prd);


--
-- TOC entry 7298 (class 2606 OID 1010434)
-- Name: fk_crt_prd; Type: FK CONSTRAINT; Schema: sc_opr; Owner: postgres
--

ALTER TABLE ONLY tbl_crt_exc
    ADD CONSTRAINT fk_crt_prd FOREIGN KEY (cd_prd) REFERENCES sc_cad.tbl_prd(cd_prd);


--
-- TOC entry 6898 (class 2606 OID 832157)
-- Name: fk_crt_tvt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_crt
    ADD CONSTRAINT fk_crt_tvt FOREIGN KEY (cd_tvt) REFERENCES tbl_tvt(cd_tvt);


--
-- TOC entry 7299 (class 2606 OID 1010439)
-- Name: fk_crt_tvt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: postgres
--

ALTER TABLE ONLY tbl_crt_exc
    ADD CONSTRAINT fk_crt_tvt FOREIGN KEY (cd_tvt) REFERENCES tbl_tvt(cd_tvt);


--
-- TOC entry 6978 (class 2606 OID 832162)
-- Name: fk_ctc_opr; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_ctc
    ADD CONSTRAINT fk_ctc_opr FOREIGN KEY (cd_opr) REFERENCES tbl_opr(cd_opr);


--
-- TOC entry 6979 (class 2606 OID 832167)
-- Name: fk_dos_opr; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_dos
    ADD CONSTRAINT fk_dos_opr FOREIGN KEY (cd_opr) REFERENCES tbl_opr(cd_opr);


--
-- TOC entry 6980 (class 2606 OID 832172)
-- Name: fk_dtv_top; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_dtv
    ADD CONSTRAINT fk_dtv_top FOREIGN KEY (cd_top) REFERENCES tbl_top(cd_top);


--
-- TOC entry 6981 (class 2606 OID 832177)
-- Name: fk_dtv_tvt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_dtv
    ADD CONSTRAINT fk_dtv_tvt FOREIGN KEY (cd_tvt) REFERENCES tbl_tvt(cd_tvt);


--
-- TOC entry 6983 (class 2606 OID 832182)
-- Name: fk_exc_rst; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_exc
    ADD CONSTRAINT fk_exc_rst FOREIGN KEY (cd_rst) REFERENCES tbl_rst(cd_rst);


--
-- TOC entry 6984 (class 2606 OID 832187)
-- Name: fk_hlm_cdinc; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_hlm
    ADD CONSTRAINT fk_hlm_cdinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6985 (class 2606 OID 832192)
-- Name: fk_hlm_crt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_hlm
    ADD CONSTRAINT fk_hlm_crt FOREIGN KEY (cd_crt) REFERENCES tbl_crt(cd_crt);


--
-- TOC entry 6986 (class 2606 OID 832197)
-- Name: fk_hlm_tlt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_hlm
    ADD CONSTRAINT fk_hlm_tlt FOREIGN KEY (cd_tlt) REFERENCES tbl_tlt(cd_tlt);


--
-- TOC entry 6987 (class 2606 OID 832202)
-- Name: fk_lmt_crt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_lmt
    ADD CONSTRAINT fk_lmt_crt FOREIGN KEY (cd_crt) REFERENCES tbl_crt(cd_crt);


--
-- TOC entry 6988 (class 2606 OID 832207)
-- Name: fk_lmt_tlt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_lmt
    ADD CONSTRAINT fk_lmt_tlt FOREIGN KEY (cd_tlt) REFERENCES tbl_tlt(cd_tlt);


--
-- TOC entry 6989 (class 2606 OID 832212)
-- Name: fk_ocr_crt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_ocr
    ADD CONSTRAINT fk_ocr_crt FOREIGN KEY (cd_crt) REFERENCES tbl_crt(cd_crt);


--
-- TOC entry 6990 (class 2606 OID 832217)
-- Name: fk_ocr_inc_usr; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_ocr
    ADD CONSTRAINT fk_ocr_inc_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6991 (class 2606 OID 832222)
-- Name: fk_ocr_pls; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_ocr
    ADD CONSTRAINT fk_ocr_pls FOREIGN KEY (cd_pls) REFERENCES tbl_pls(cd_pls);


--
-- TOC entry 6992 (class 2606 OID 832227)
-- Name: fk_ocr_toc; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_ocr
    ADD CONSTRAINT fk_ocr_toc FOREIGN KEY (cd_toc) REFERENCES tbl_toc(cd_toc);


--
-- TOC entry 6900 (class 2606 OID 832232)
-- Name: fk_opr_aeo; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_opr
    ADD CONSTRAINT fk_opr_aeo FOREIGN KEY (cd_aeo) REFERENCES sc_aeo.tbl_aeo(cd_aeo);


--
-- TOC entry 6901 (class 2606 OID 832237)
-- Name: fk_opr_atm; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_opr
    ADD CONSTRAINT fk_opr_atm FOREIGN KEY (cd_atm) REFERENCES sc_rds.tbl_atm(cd_atm);


--
-- TOC entry 6902 (class 2606 OID 832242)
-- Name: fk_opr_cd_pai; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_opr
    ADD CONSTRAINT fk_opr_cd_pai FOREIGN KEY (cd_pai_opr) REFERENCES tbl_opr(cd_opr);


--
-- TOC entry 6903 (class 2606 OID 832247)
-- Name: fk_opr_pls; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_opr
    ADD CONSTRAINT fk_opr_pls FOREIGN KEY (cd_pls) REFERENCES tbl_pls(cd_pls);


--
-- TOC entry 6904 (class 2606 OID 832252)
-- Name: fk_opr_top; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_opr
    ADD CONSTRAINT fk_opr_top FOREIGN KEY (cd_top) REFERENCES tbl_top(cd_top);


--
-- TOC entry 6906 (class 2606 OID 832257)
-- Name: fk_pls_crt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_pls
    ADD CONSTRAINT fk_pls_crt FOREIGN KEY (cd_crt) REFERENCES tbl_crt(cd_crt);


--
-- TOC entry 6907 (class 2606 OID 832262)
-- Name: fk_pls_cun; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_pls
    ADD CONSTRAINT fk_pls_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 6908 (class 2606 OID 832267)
-- Name: fk_pls_mpl; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_pls
    ADD CONSTRAINT fk_pls_mpl FOREIGN KEY (cd_mpl) REFERENCES sc_ssp.tbl_mpl(cd_mpl);


--
-- TOC entry 6909 (class 2606 OID 832272)
-- Name: fk_pls_tbl; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_pls
    ADD CONSTRAINT fk_pls_tbl FOREIGN KEY (cd_tbl) REFERENCES tbl_tbl(cd_tbl);


--
-- TOC entry 6910 (class 2606 OID 832277)
-- Name: fk_pls_usrinc; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_pls
    ADD CONSTRAINT fk_pls_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6993 (class 2606 OID 832282)
-- Name: fk_rst_top; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_rst
    ADD CONSTRAINT fk_rst_top FOREIGN KEY (cd_top) REFERENCES tbl_top(cd_top);


--
-- TOC entry 6994 (class 2606 OID 832287)
-- Name: fk_sqm_crt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_sqm
    ADD CONSTRAINT fk_sqm_crt FOREIGN KEY (cd_crt) REFERENCES tbl_crt(cd_crt);


--
-- TOC entry 6995 (class 2606 OID 832292)
-- Name: fk_sqm_crt_opr; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_sqm
    ADD CONSTRAINT fk_sqm_crt_opr FOREIGN KEY (cd_crt_opr) REFERENCES tbl_crt(cd_crt);


--
-- TOC entry 6996 (class 2606 OID 832297)
-- Name: fk_sqm_usralt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_sqm
    ADD CONSTRAINT fk_sqm_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6997 (class 2606 OID 832302)
-- Name: fk_sqm_usrinc; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_sqm
    ADD CONSTRAINT fk_sqm_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7002 (class 2606 OID 832307)
-- Name: fk_tlt_top; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_top_tlt
    ADD CONSTRAINT fk_tlt_top FOREIGN KEY (cd_tlt) REFERENCES tbl_tlt(cd_tlt);


--
-- TOC entry 6998 (class 2606 OID 832312)
-- Name: fk_toc_alt_usr; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_toc
    ADD CONSTRAINT fk_toc_alt_usr FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6999 (class 2606 OID 832317)
-- Name: fk_toc_inc_usr; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_toc
    ADD CONSTRAINT fk_toc_inc_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7000 (class 2606 OID 832322)
-- Name: fk_top_atm_atm; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_top_atm
    ADD CONSTRAINT fk_top_atm_atm FOREIGN KEY (cd_atm) REFERENCES sc_rds.tbl_atm(cd_atm);


--
-- TOC entry 7001 (class 2606 OID 832327)
-- Name: fk_top_atm_top; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_top_atm
    ADD CONSTRAINT fk_top_atm_top FOREIGN KEY (cd_top) REFERENCES tbl_top(cd_top);


--
-- TOC entry 6911 (class 2606 OID 832332)
-- Name: fk_top_cnt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_top
    ADD CONSTRAINT fk_top_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 6912 (class 2606 OID 832337)
-- Name: fk_top_tlc; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_top
    ADD CONSTRAINT fk_top_tlc FOREIGN KEY (cd_tlc) REFERENCES sc_cnt.tbl_tlc(cd_tlc);


--
-- TOC entry 7003 (class 2606 OID 832342)
-- Name: fk_top_tlt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_top_tlt
    ADD CONSTRAINT fk_top_tlt FOREIGN KEY (cd_top) REFERENCES tbl_top(cd_top);


--
-- TOC entry 7004 (class 2606 OID 832347)
-- Name: fk_tvt_usr_alt; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_tvt
    ADD CONSTRAINT fk_tvt_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7005 (class 2606 OID 832352)
-- Name: fk_tvt_usr_inc; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_tvt
    ADD CONSTRAINT fk_tvt_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 6905 (class 2606 OID 832357)
-- Name: pk_opr_fet; Type: FK CONSTRAINT; Schema: sc_opr; Owner: scan
--

ALTER TABLE ONLY tbl_opr
    ADD CONSTRAINT pk_opr_fet FOREIGN KEY (cd_fet) REFERENCES sc_rdc.tbl_fet(cd_fet);


SET search_path = sc_pbl, pg_catalog;

--
-- TOC entry 7006 (class 2606 OID 832362)
-- Name: fk_frd_usralt; Type: FK CONSTRAINT; Schema: sc_pbl; Owner: scan
--

ALTER TABLE ONLY tbl_frd
    ADD CONSTRAINT fk_frd_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7007 (class 2606 OID 832367)
-- Name: fk_frd_usrinc; Type: FK CONSTRAINT; Schema: sc_pbl; Owner: scan
--

ALTER TABLE ONLY tbl_frd
    ADD CONSTRAINT fk_frd_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sc_pgc, pg_catalog;

--
-- TOC entry 7237 (class 2606 OID 892479)
-- Name: fk_cnc_sgt; Type: FK CONSTRAINT; Schema: sc_pgc; Owner: scan
--

ALTER TABLE ONLY tbl_cnc
    ADD CONSTRAINT fk_cnc_sgt FOREIGN KEY (cd_sgt) REFERENCES tbl_sgt(cd_sgt);


--
-- TOC entry 7282 (class 2606 OID 1004312)
-- Name: fk_lgt_pgt; Type: FK CONSTRAINT; Schema: sc_pgc; Owner: scan
--

ALTER TABLE ONLY tbl_lgt
    ADD CONSTRAINT fk_lgt_pgt FOREIGN KEY (cd_pgt) REFERENCES tbl_pgt(cd_pgt);


--
-- TOC entry 7312 (class 2606 OID 1034217)
-- Name: fk_pga_crr; Type: FK CONSTRAINT; Schema: sc_pgc; Owner: scan
--

ALTER TABLE ONLY tbl_pga
    ADD CONSTRAINT fk_pga_crr FOREIGN KEY (cd_crr) REFERENCES tbl_crr(cd_crr);


--
-- TOC entry 7313 (class 2606 OID 1034222)
-- Name: fk_pgt; Type: FK CONSTRAINT; Schema: sc_pgc; Owner: scan
--

ALTER TABLE ONLY tbl_pga
    ADD CONSTRAINT fk_pgt FOREIGN KEY (cd_pgt) REFERENCES tbl_pgt(cd_pgt);


--
-- TOC entry 7236 (class 2606 OID 1073708)
-- Name: fk_pgt_crr; Type: FK CONSTRAINT; Schema: sc_pgc; Owner: scan
--

ALTER TABLE ONLY tbl_pgt
    ADD CONSTRAINT fk_pgt_crr FOREIGN KEY (cd_crr) REFERENCES tbl_crr(cd_crr);


SET search_path = sc_ppr, pg_catalog;

--
-- TOC entry 7287 (class 2606 OID 1007377)
-- Name: fk_cun; Type: FK CONSTRAINT; Schema: sc_ppr; Owner: scan
--

ALTER TABLE ONLY tbl_dppr
    ADD CONSTRAINT fk_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 7288 (class 2606 OID 1007382)
-- Name: fk_ppr; Type: FK CONSTRAINT; Schema: sc_ppr; Owner: scan
--

ALTER TABLE ONLY tbl_dppr
    ADD CONSTRAINT fk_ppr FOREIGN KEY (cd_ppr) REFERENCES tbl_ppr(cd_ppr);


--
-- TOC entry 7284 (class 2606 OID 1007301)
-- Name: fk_usr_alt; Type: FK CONSTRAINT; Schema: sc_ppr; Owner: scan
--

ALTER TABLE ONLY tbl_ppr
    ADD CONSTRAINT fk_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7286 (class 2606 OID 1007362)
-- Name: fk_usr_alt; Type: FK CONSTRAINT; Schema: sc_ppr; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_ppr
    ADD CONSTRAINT fk_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7289 (class 2606 OID 1007387)
-- Name: fk_usr_alt; Type: FK CONSTRAINT; Schema: sc_ppr; Owner: scan
--

ALTER TABLE ONLY tbl_dppr
    ADD CONSTRAINT fk_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7283 (class 2606 OID 1007296)
-- Name: fk_usr_inc; Type: FK CONSTRAINT; Schema: sc_ppr; Owner: scan
--

ALTER TABLE ONLY tbl_ppr
    ADD CONSTRAINT fk_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7285 (class 2606 OID 1007357)
-- Name: fk_usr_inc; Type: FK CONSTRAINT; Schema: sc_ppr; Owner: scan
--

ALTER TABLE ONLY tbl_ctr_ppr
    ADD CONSTRAINT fk_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7290 (class 2606 OID 1007392)
-- Name: fk_usr_inc; Type: FK CONSTRAINT; Schema: sc_ppr; Owner: scan
--

ALTER TABLE ONLY tbl_dppr
    ADD CONSTRAINT fk_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sc_rcg, pg_catalog;

--
-- TOC entry 7008 (class 2606 OID 832372)
-- Name: fk_prd_opr; Type: FK CONSTRAINT; Schema: sc_rcg; Owner: scan
--

ALTER TABLE ONLY tbl_prd
    ADD CONSTRAINT fk_prd_opr FOREIGN KEY (cd_opr) REFERENCES tbl_opr(cd_opr);


--
-- TOC entry 7009 (class 2606 OID 832377)
-- Name: fk_rcg_crt; Type: FK CONSTRAINT; Schema: sc_rcg; Owner: scan
--

ALTER TABLE ONLY tbl_rcg
    ADD CONSTRAINT fk_rcg_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 7010 (class 2606 OID 832382)
-- Name: fk_rcg_prd; Type: FK CONSTRAINT; Schema: sc_rcg; Owner: scan
--

ALTER TABLE ONLY tbl_rcg
    ADD CONSTRAINT fk_rcg_prd FOREIGN KEY (cd_prd) REFERENCES tbl_prd(cd_prd);


--
-- TOC entry 7011 (class 2606 OID 832387)
-- Name: fk_rcg_usr; Type: FK CONSTRAINT; Schema: sc_rcg; Owner: scan
--

ALTER TABLE ONLY tbl_rcg
    ADD CONSTRAINT fk_rcg_usr FOREIGN KEY (cd_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sc_rct, pg_catalog;

--
-- TOC entry 7012 (class 2606 OID 832392)
-- Name: fk_rct_sst; Type: FK CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_rct
    ADD CONSTRAINT fk_rct_sst FOREIGN KEY (cd_sst) REFERENCES sc_cnt.tbl_sst(cd_sst);


--
-- TOC entry 7013 (class 2606 OID 832397)
-- Name: fk_rct_trt; Type: FK CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_rct
    ADD CONSTRAINT fk_rct_trt FOREIGN KEY (cd_trt) REFERENCES tbl_trt(cd_trt);


--
-- TOC entry 7014 (class 2606 OID 832402)
-- Name: fk_trt_sfe_sfe; Type: FK CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_trt_sfe
    ADD CONSTRAINT fk_trt_sfe_sfe FOREIGN KEY (cd_sfe) REFERENCES sc_fep.tbl_sfe(cd_sfe);


--
-- TOC entry 7015 (class 2606 OID 832407)
-- Name: fk_trt_sfe_trt; Type: FK CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_trt_sfe
    ADD CONSTRAINT fk_trt_sfe_trt FOREIGN KEY (cd_trt) REFERENCES tbl_trt(cd_trt);


--
-- TOC entry 7016 (class 2606 OID 832412)
-- Name: fk_trt_srv_srv; Type: FK CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_trt_srv
    ADD CONSTRAINT fk_trt_srv_srv FOREIGN KEY (cd_srv) REFERENCES sc_srv.tbl_srv(cd_srv);


--
-- TOC entry 7017 (class 2606 OID 832417)
-- Name: fk_trt_srv_trt; Type: FK CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_trt_srv
    ADD CONSTRAINT fk_trt_srv_trt FOREIGN KEY (cd_trt) REFERENCES tbl_trt(cd_trt);


--
-- TOC entry 7018 (class 2606 OID 832422)
-- Name: fk_trt_top_sst; Type: FK CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_trt_top
    ADD CONSTRAINT fk_trt_top_sst FOREIGN KEY (cd_sst) REFERENCES sc_cnt.tbl_sst(cd_sst);


--
-- TOC entry 7019 (class 2606 OID 832427)
-- Name: fk_trt_top_top; Type: FK CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_trt_top
    ADD CONSTRAINT fk_trt_top_top FOREIGN KEY (cd_top) REFERENCES sc_opr.tbl_top(cd_top);


--
-- TOC entry 7020 (class 2606 OID 832432)
-- Name: fk_trt_top_trt; Type: FK CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_trt_top
    ADD CONSTRAINT fk_trt_top_trt FOREIGN KEY (cd_trt) REFERENCES tbl_trt(cd_trt);


--
-- TOC entry 7021 (class 2606 OID 832437)
-- Name: fk_vrc_fcr; Type: FK CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_vrc
    ADD CONSTRAINT fk_vrc_fcr FOREIGN KEY (cd_fcr) REFERENCES sc_fcr.tbl_fcr(cd_fcr);


--
-- TOC entry 7022 (class 2606 OID 832442)
-- Name: fk_vrc_top; Type: FK CONSTRAINT; Schema: sc_rct; Owner: scan
--

ALTER TABLE ONLY tbl_vrc
    ADD CONSTRAINT fk_vrc_top FOREIGN KEY (cd_top) REFERENCES sc_opr.tbl_top(cd_top);


SET search_path = sc_rdc, pg_catalog;

--
-- TOC entry 7023 (class 2606 OID 1033491)
-- Name: fk_fet_cnt; Type: FK CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_fet
    ADD CONSTRAINT fk_fet_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 7024 (class 2606 OID 1033496)
-- Name: fk_fet_cun; Type: FK CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_fet
    ADD CONSTRAINT fk_fet_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 7025 (class 2606 OID 1033501)
-- Name: fk_fet_etb; Type: FK CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_fet
    ADD CONSTRAINT fk_fet_etb FOREIGN KEY (cd_etb) REFERENCES tbl_etb(cd_etb);


--
-- TOC entry 7026 (class 2606 OID 1033506)
-- Name: fk_fet_usralt; Type: FK CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_fet
    ADD CONSTRAINT fk_fet_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7027 (class 2606 OID 1033511)
-- Name: fk_fet_usrinc; Type: FK CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_fet
    ADD CONSTRAINT fk_fet_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7331 (class 2606 OID 1639039)
-- Name: fk_oet_fet; Type: FK CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_oet
    ADD CONSTRAINT fk_oet_fet FOREIGN KEY (cd_fet) REFERENCES tbl_fet(cd_fet);


--
-- TOC entry 7330 (class 2606 OID 1639044)
-- Name: fk_oet_usr; Type: FK CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_oet
    ADD CONSTRAINT fk_oet_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7028 (class 2606 OID 832482)
-- Name: fk_pet; Type: FK CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_pet
    ADD CONSTRAINT fk_pet FOREIGN KEY (cd_fet) REFERENCES tbl_fet(cd_fet);


--
-- TOC entry 7029 (class 2606 OID 832487)
-- Name: fk_pet_opr; Type: FK CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_pet
    ADD CONSTRAINT fk_pet_opr FOREIGN KEY (cd_opr) REFERENCES sc_opr.tbl_opr(cd_opr);


--
-- TOC entry 7030 (class 2606 OID 832492)
-- Name: fk_pet_rps; Type: FK CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_pet
    ADD CONSTRAINT fk_pet_rps FOREIGN KEY (cd_rps) REFERENCES tbl_rps(cd_rps);


--
-- TOC entry 7031 (class 2606 OID 832507)
-- Name: fk_rqs_fet; Type: FK CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_rps
    ADD CONSTRAINT fk_rqs_fet FOREIGN KEY (cd_fet) REFERENCES tbl_fet(cd_fet);


--
-- TOC entry 7332 (class 2606 OID 1648913)
-- Name: pk_rahp; Type: FK CONSTRAINT; Schema: sc_rdc; Owner: scan
--

ALTER TABLE ONLY tbl_rdah
    ADD CONSTRAINT pk_rahp FOREIGN KEY (cd_rahp) REFERENCES tbl_rahp(cd_rahp);


SET search_path = sc_rds, pg_catalog;

--
-- TOC entry 7032 (class 2606 OID 832517)
-- Name: FK_AAP_USRALT; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_aap
    ADD CONSTRAINT "FK_AAP_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7033 (class 2606 OID 832522)
-- Name: FK_AAP_USRINC; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_aap
    ADD CONSTRAINT "FK_AAP_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7043 (class 2606 OID 832527)
-- Name: FK_AEA_USRINC; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_aea
    ADD CONSTRAINT "FK_AEA_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7050 (class 2606 OID 832532)
-- Name: FK_AOP_USRALT; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_aop
    ADD CONSTRAINT "FK_AOP_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7051 (class 2606 OID 832537)
-- Name: FK_AOP_USRINC; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_aop
    ADD CONSTRAINT "FK_AOP_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7064 (class 2606 OID 832542)
-- Name: FK_DSP_ATM; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT "FK_DSP_ATM" FOREIGN KEY (cd_atm) REFERENCES tbl_atm(cd_atm);


--
-- TOC entry 7065 (class 2606 OID 832547)
-- Name: FK_DSP_EDA; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT "FK_DSP_EDA" FOREIGN KEY (cd_ult_eda) REFERENCES tbl_eda(cd_eda);


--
-- TOC entry 7066 (class 2606 OID 832552)
-- Name: FK_DSP_TDA; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT "FK_DSP_TDA" FOREIGN KEY (cd_tda) REFERENCES tbl_tda(cd_tda);


--
-- TOC entry 7067 (class 2606 OID 832557)
-- Name: FK_DSP_USRALT; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT "FK_DSP_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7068 (class 2606 OID 832562)
-- Name: FK_DSP_USRINC; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_dsp
    ADD CONSTRAINT "FK_DSP_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7072 (class 2606 OID 832567)
-- Name: FK_EDA_AAP_AAP; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_eda_aap
    ADD CONSTRAINT "FK_EDA_AAP_AAP" FOREIGN KEY (cd_aap) REFERENCES tbl_aap(cd_aap);


--
-- TOC entry 7073 (class 2606 OID 832572)
-- Name: FK_EDA_AAP_EDA; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_eda_aap
    ADD CONSTRAINT "FK_EDA_AAP_EDA" FOREIGN KEY (cd_eda) REFERENCES tbl_eda(cd_eda);


--
-- TOC entry 7074 (class 2606 OID 832577)
-- Name: FK_EDA_AOP_AOP; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_eda_aop
    ADD CONSTRAINT "FK_EDA_AOP_AOP" FOREIGN KEY (cd_aop) REFERENCES tbl_aop(cd_aop);


--
-- TOC entry 7075 (class 2606 OID 832582)
-- Name: FK_EDA_AOP_EDA; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_eda_aop
    ADD CONSTRAINT "FK_EDA_AOP_EDA" FOREIGN KEY (cd_eda) REFERENCES tbl_eda(cd_eda);


--
-- TOC entry 7069 (class 2606 OID 832587)
-- Name: FK_EDA_DSP; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_eda
    ADD CONSTRAINT "FK_EDA_DSP" FOREIGN KEY (cd_tda) REFERENCES tbl_tda(cd_tda);


--
-- TOC entry 7070 (class 2606 OID 832592)
-- Name: FK_EDA_USRALT; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_eda
    ADD CONSTRAINT "FK_EDA_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7071 (class 2606 OID 832597)
-- Name: FK_EDA_USRINC; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_eda
    ADD CONSTRAINT "FK_EDA_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7079 (class 2606 OID 832602)
-- Name: FK_LED_DSP; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_led
    ADD CONSTRAINT "FK_LED_DSP" FOREIGN KEY (cd_dsp) REFERENCES tbl_dsp(cd_dsp);


--
-- TOC entry 7080 (class 2606 OID 832607)
-- Name: FK_LED_EDA; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_led
    ADD CONSTRAINT "FK_LED_EDA" FOREIGN KEY (cd_eda) REFERENCES tbl_eda(cd_eda);


--
-- TOC entry 7083 (class 2606 OID 832612)
-- Name: FK_PDA_USRALT; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_pda
    ADD CONSTRAINT "FK_PDA_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7084 (class 2606 OID 832617)
-- Name: FK_PDA_USRINC; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_pda
    ADD CONSTRAINT "FK_PDA_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7085 (class 2606 OID 1004572)
-- Name: FK_POP_USRINC; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_pop
    ADD CONSTRAINT "FK_POP_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7090 (class 2606 OID 832627)
-- Name: FK_TDA_USRALT; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_tda
    ADD CONSTRAINT "FK_TDA_USRALT" FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7091 (class 2606 OID 832632)
-- Name: FK_TDA_USRINC; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_tda
    ADD CONSTRAINT "FK_TDA_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7034 (class 2606 OID 832637)
-- Name: fk_abs_atm; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_abs
    ADD CONSTRAINT fk_abs_atm FOREIGN KEY (cd_atm) REFERENCES tbl_atm(cd_atm);


--
-- TOC entry 7035 (class 2606 OID 832642)
-- Name: fk_abs_cnt; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_abs
    ADD CONSTRAINT fk_abs_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 7036 (class 2606 OID 832647)
-- Name: fk_abs_pop; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_abs
    ADD CONSTRAINT fk_abs_pop FOREIGN KEY (cd_pop) REFERENCES tbl_pop(cd_pop);


--
-- TOC entry 7037 (class 2606 OID 832652)
-- Name: fk_abs_usralt; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_abs
    ADD CONSTRAINT fk_abs_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7038 (class 2606 OID 832657)
-- Name: fk_abs_usrcnc; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_abs
    ADD CONSTRAINT fk_abs_usrcnc FOREIGN KEY (cd_cnc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7039 (class 2606 OID 832662)
-- Name: fk_abs_usrfnz; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_abs
    ADD CONSTRAINT fk_abs_usrfnz FOREIGN KEY (cd_fnz_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7040 (class 2606 OID 832667)
-- Name: fk_abs_usrinc; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_abs
    ADD CONSTRAINT fk_abs_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7041 (class 2606 OID 832672)
-- Name: fk_abs_usrlbr; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_abs
    ADD CONSTRAINT fk_abs_usrlbr FOREIGN KEY (cd_apr_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7042 (class 2606 OID 832677)
-- Name: fk_abs_usrret; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_abs
    ADD CONSTRAINT fk_abs_usrret FOREIGN KEY (cd_ret_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7044 (class 2606 OID 832682)
-- Name: fk_aea_atm; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_aea
    ADD CONSTRAINT fk_aea_atm FOREIGN KEY (cd_atm) REFERENCES tbl_atm(cd_atm);


--
-- TOC entry 7045 (class 2606 OID 832687)
-- Name: fk_alt_alt_usr; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_alt
    ADD CONSTRAINT fk_alt_alt_usr FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7046 (class 2606 OID 832692)
-- Name: fk_alt_atm; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_alt
    ADD CONSTRAINT fk_alt_atm FOREIGN KEY (cd_atm) REFERENCES tbl_atm(cd_atm);


--
-- TOC entry 7047 (class 2606 OID 832697)
-- Name: fk_alt_fch_usr; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_alt
    ADD CONSTRAINT fk_alt_fch_usr FOREIGN KEY (cd_fch_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7048 (class 2606 OID 832702)
-- Name: fk_alt_inc_usr; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_alt
    ADD CONSTRAINT fk_alt_inc_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7049 (class 2606 OID 832707)
-- Name: fk_alt_tal; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_alt
    ADD CONSTRAINT fk_alt_tal FOREIGN KEY (cd_tal) REFERENCES tbl_tal(cd_tal);


--
-- TOC entry 7052 (class 2606 OID 832712)
-- Name: fk_atm_cnt; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_atm
    ADD CONSTRAINT fk_atm_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 7053 (class 2606 OID 832717)
-- Name: fk_atm_cntdif; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_atm
    ADD CONSTRAINT fk_atm_cntdif FOREIGN KEY (cd_cnt_dif_atm) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 7060 (class 2606 OID 832722)
-- Name: fk_atm_css; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_css
    ADD CONSTRAINT fk_atm_css FOREIGN KEY (cd_atm) REFERENCES tbl_atm(cd_atm);


--
-- TOC entry 7054 (class 2606 OID 832727)
-- Name: fk_atm_edr; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_atm
    ADD CONSTRAINT fk_atm_edr FOREIGN KEY (cd_edr) REFERENCES sc_cad.tbl_edr(cd_edr);


--
-- TOC entry 7055 (class 2606 OID 832732)
-- Name: fk_atm_rds; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_atm
    ADD CONSTRAINT fk_atm_rds FOREIGN KEY (cd_tsr) REFERENCES sc_cnt.tbl_tsr(cd_tsr);


--
-- TOC entry 7056 (class 2606 OID 832737)
-- Name: fk_atm_usr_alt; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_atm
    ADD CONSTRAINT fk_atm_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7057 (class 2606 OID 832742)
-- Name: fk_atm_usr_inc; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_atm
    ADD CONSTRAINT fk_atm_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7058 (class 2606 OID 832747)
-- Name: fk_cda_usr; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_cda
    ADD CONSTRAINT fk_cda_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7062 (class 2606 OID 832752)
-- Name: fk_dab_abs; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_dab
    ADD CONSTRAINT fk_dab_abs FOREIGN KEY (cd_abs) REFERENCES tbl_abs(cd_abs);


--
-- TOC entry 7063 (class 2606 OID 832757)
-- Name: fk_drqa_rqa; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_drqa
    ADD CONSTRAINT fk_drqa_rqa FOREIGN KEY (cd_rqa) REFERENCES tbl_rqa(cd_rqa);


--
-- TOC entry 7076 (class 2606 OID 832762)
-- Name: fk_fca_atm; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_fca
    ADD CONSTRAINT fk_fca_atm FOREIGN KEY (cd_atm) REFERENCES tbl_atm(cd_atm);


--
-- TOC entry 7077 (class 2606 OID 832767)
-- Name: fk_fca_usr_inc; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_fca
    ADD CONSTRAINT fk_fca_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7078 (class 2606 OID 832772)
-- Name: fk_fva_vma; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_fva
    ADD CONSTRAINT fk_fva_vma FOREIGN KEY (cd_vma) REFERENCES tbl_vma(cd_vma);


--
-- TOC entry 7081 (class 2606 OID 832777)
-- Name: fk_oca_abs; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_oca
    ADD CONSTRAINT fk_oca_abs FOREIGN KEY (cd_abs) REFERENCES tbl_abs(cd_abs);


--
-- TOC entry 7082 (class 2606 OID 832782)
-- Name: fk_oca_usr; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_oca
    ADD CONSTRAINT fk_oca_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7086 (class 2606 OID 1004577)
-- Name: fk_pop_mpl; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_pop
    ADD CONSTRAINT fk_pop_mpl FOREIGN KEY (cd_mpl) REFERENCES sc_ssp.tbl_mpl(cd_mpl);


--
-- TOC entry 7087 (class 2606 OID 832792)
-- Name: fk_rqa_atm; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_rqa
    ADD CONSTRAINT fk_rqa_atm FOREIGN KEY (cd_atm) REFERENCES tbl_atm(cd_atm);


--
-- TOC entry 7224 (class 2606 OID 857783)
-- Name: fk_sfc_crt; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_sfc
    ADD CONSTRAINT fk_sfc_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 7225 (class 2606 OID 857788)
-- Name: fk_sfc_opr; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_sfc
    ADD CONSTRAINT fk_sfc_opr FOREIGN KEY (cd_opr) REFERENCES sc_opr.tbl_opr(cd_opr);


--
-- TOC entry 7226 (class 2606 OID 857793)
-- Name: fk_sfc_usralt; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_sfc
    ADD CONSTRAINT fk_sfc_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7227 (class 2606 OID 857798)
-- Name: fk_sfc_usrinc; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_sfc
    ADD CONSTRAINT fk_sfc_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7088 (class 2606 OID 832797)
-- Name: fk_tal_alt_usr; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_tal
    ADD CONSTRAINT fk_tal_alt_usr FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7089 (class 2606 OID 832802)
-- Name: fk_tal_inc_usr; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_tal
    ADD CONSTRAINT fk_tal_inc_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7061 (class 2606 OID 832807)
-- Name: fk_tbc_css; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_css
    ADD CONSTRAINT fk_tbc_css FOREIGN KEY (cd_tbc) REFERENCES tbl_tbc(cd_tbc);


--
-- TOC entry 7059 (class 2606 OID 832812)
-- Name: tbl_cda_cd_alt_usr_fkey; Type: FK CONSTRAINT; Schema: sc_rds; Owner: scan
--

ALTER TABLE ONLY tbl_cda
    ADD CONSTRAINT tbl_cda_cd_alt_usr_fkey FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sc_rnc, pg_catalog;

--
-- TOC entry 7101 (class 2606 OID 832817)
-- Name: FK_RPC_CRT; Type: FK CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rpc
    ADD CONSTRAINT "FK_RPC_CRT" FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 7102 (class 2606 OID 832822)
-- Name: FK_RPC_EMC; Type: FK CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rpc
    ADD CONSTRAINT "FK_RPC_EMC" FOREIGN KEY (cd_emc) REFERENCES sc_cci.tbl_emc(cd_emc);


--
-- TOC entry 7103 (class 2606 OID 832827)
-- Name: FK_RPC_USRINC; Type: FK CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rpc
    ADD CONSTRAINT "FK_RPC_USRINC" FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7092 (class 2606 OID 832832)
-- Name: fk_rnc_blt; Type: FK CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rnc
    ADD CONSTRAINT fk_rnc_blt FOREIGN KEY (cd_blt) REFERENCES sc_cbr.tbl_blt(cd_blt);


--
-- TOC entry 7098 (class 2606 OID 832837)
-- Name: fk_rnc_crt; Type: FK CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rnc_aux
    ADD CONSTRAINT fk_rnc_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 7093 (class 2606 OID 832842)
-- Name: fk_rnc_emc; Type: FK CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rnc
    ADD CONSTRAINT fk_rnc_emc FOREIGN KEY (cd_emc) REFERENCES sc_cci.tbl_emc(cd_emc);


--
-- TOC entry 7099 (class 2606 OID 832847)
-- Name: fk_rnc_emc; Type: FK CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rnc_aux
    ADD CONSTRAINT fk_rnc_emc FOREIGN KEY (cd_emc) REFERENCES sc_cci.tbl_emc(cd_emc);


--
-- TOC entry 7094 (class 2606 OID 832852)
-- Name: fk_rnc_usralt; Type: FK CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rnc
    ADD CONSTRAINT fk_rnc_usralt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7095 (class 2606 OID 832857)
-- Name: fk_rnc_usrcfc; Type: FK CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rnc
    ADD CONSTRAINT fk_rnc_usrcfc FOREIGN KEY (cd_cfc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7096 (class 2606 OID 832862)
-- Name: fk_rnc_usrcnc; Type: FK CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rnc
    ADD CONSTRAINT fk_rnc_usrcnc FOREIGN KEY (cd_cnc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7097 (class 2606 OID 832867)
-- Name: fk_rnc_usrinc; Type: FK CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rnc
    ADD CONSTRAINT fk_rnc_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7100 (class 2606 OID 832872)
-- Name: fk_rnc_usrinc; Type: FK CONSTRAINT; Schema: sc_rnc; Owner: scan
--

ALTER TABLE ONLY tbl_rnc_aux
    ADD CONSTRAINT fk_rnc_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sc_rsc, pg_catalog;

--
-- TOC entry 7104 (class 2606 OID 892898)
-- Name: fk_rsc_crt; Type: FK CONSTRAINT; Schema: sc_rsc; Owner: scan
--

ALTER TABLE ONLY tbl_rsc
    ADD CONSTRAINT fk_rsc_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


SET search_path = sc_scan_cbe, pg_catalog;

--
-- TOC entry 7272 (class 2606 OID 986074)
-- Name: fk_dql_dvd; Type: FK CONSTRAINT; Schema: sc_scan_cbe; Owner: scan
--

ALTER TABLE ONLY tbl_dlq
    ADD CONSTRAINT fk_dql_dvd FOREIGN KEY (cd_dvd) REFERENCES sc_cbe.tbl_dvd(cd_dvd);


SET search_path = sc_sgr, pg_catalog;

--
-- TOC entry 7249 (class 2606 OID 899390)
-- Name: fk_acs_rol; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_acs
    ADD CONSTRAINT fk_acs_rol FOREIGN KEY (cd_rol) REFERENCES tbl_rol(cd_rol);


--
-- TOC entry 7250 (class 2606 OID 899395)
-- Name: fk_acs_sis; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_acs
    ADD CONSTRAINT fk_acs_sis FOREIGN KEY (cd_sis) REFERENCES tbl_sis(cd_sis);


--
-- TOC entry 7248 (class 2606 OID 899385)
-- Name: fk_acs_usr; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_acs
    ADD CONSTRAINT fk_acs_usr FOREIGN KEY (cd_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7329 (class 2606 OID 1637546)
-- Name: fk_cli_sis; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_cli
    ADD CONSTRAINT fk_cli_sis FOREIGN KEY (cd_sis) REFERENCES tbl_sis(cd_sis);


--
-- TOC entry 7328 (class 2606 OID 1637551)
-- Name: fk_cli_usr_alt; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_cli
    ADD CONSTRAINT fk_cli_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7327 (class 2606 OID 1637556)
-- Name: fk_cli_usr_inc; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_cli
    ADD CONSTRAINT fk_cli_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7292 (class 2606 OID 1007418)
-- Name: fk_crt; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_cfv
    ADD CONSTRAINT fk_crt FOREIGN KEY (cd_crt_cfv) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 6763 (class 2606 OID 832882)
-- Name: fk_eus_usr; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_eus
    ADD CONSTRAINT fk_eus_usr FOREIGN KEY (cd_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 6764 (class 2606 OID 832887)
-- Name: fk_eus_usralt; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_eus
    ADD CONSTRAINT fk_eus_usralt FOREIGN KEY (cd_alt_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 6765 (class 2606 OID 832892)
-- Name: fk_eus_usrinc; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_eus
    ADD CONSTRAINT fk_eus_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7108 (class 2606 OID 832897)
-- Name: fk_grp_rol_grp; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_grp_rol
    ADD CONSTRAINT fk_grp_rol_grp FOREIGN KEY (cd_grp) REFERENCES tbl_grp(cd_grp);


--
-- TOC entry 7109 (class 2606 OID 832902)
-- Name: fk_grp_rol_rol; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_grp_rol
    ADD CONSTRAINT fk_grp_rol_rol FOREIGN KEY (cd_rol) REFERENCES tbl_rol(cd_rol);


--
-- TOC entry 7110 (class 2606 OID 832907)
-- Name: fk_grp_rol_usr_alt; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_grp_rol
    ADD CONSTRAINT fk_grp_rol_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7111 (class 2606 OID 832912)
-- Name: fk_grp_rol_usr_inc; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_grp_rol
    ADD CONSTRAINT fk_grp_rol_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7105 (class 2606 OID 832917)
-- Name: fk_grp_sis; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_grp
    ADD CONSTRAINT fk_grp_sis FOREIGN KEY (cd_sis) REFERENCES tbl_sis(cd_sis);


--
-- TOC entry 7106 (class 2606 OID 832922)
-- Name: fk_grp_usr_alt; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_grp
    ADD CONSTRAINT fk_grp_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7107 (class 2606 OID 832927)
-- Name: fk_grp_usr_inc; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_grp
    ADD CONSTRAINT fk_grp_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7112 (class 2606 OID 832932)
-- Name: fk_menu_menupai; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_menu
    ADD CONSTRAINT fk_menu_menupai FOREIGN KEY (cd_pai_menu) REFERENCES tbl_menu(cd_menu);


--
-- TOC entry 7113 (class 2606 OID 832937)
-- Name: fk_menu_rol; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_menu
    ADD CONSTRAINT fk_menu_rol FOREIGN KEY (cd_rol) REFERENCES tbl_rol(cd_rol);


--
-- TOC entry 7114 (class 2606 OID 832942)
-- Name: fk_menu_sis; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_menu
    ADD CONSTRAINT fk_menu_sis FOREIGN KEY (cd_sis) REFERENCES tbl_sis(cd_sis);


--
-- TOC entry 7115 (class 2606 OID 832947)
-- Name: fk_menu_usralt; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_menu
    ADD CONSTRAINT fk_menu_usralt FOREIGN KEY (cd_alt_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7116 (class 2606 OID 832952)
-- Name: fk_menu_usrinc; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_menu
    ADD CONSTRAINT fk_menu_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7119 (class 2606 OID 832957)
-- Name: fk_rol_sis_rol; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_rol_sis
    ADD CONSTRAINT fk_rol_sis_rol FOREIGN KEY (cd_rol) REFERENCES tbl_rol(cd_rol);


--
-- TOC entry 7120 (class 2606 OID 832962)
-- Name: fk_rol_sis_sis; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_rol_sis
    ADD CONSTRAINT fk_rol_sis_sis FOREIGN KEY (cd_sis) REFERENCES tbl_sis(cd_sis);


--
-- TOC entry 7121 (class 2606 OID 832967)
-- Name: fk_rol_sis_usralt; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_rol_sis
    ADD CONSTRAINT fk_rol_sis_usralt FOREIGN KEY (cd_alt_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7122 (class 2606 OID 832972)
-- Name: fk_rol_sis_usrinc; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_rol_sis
    ADD CONSTRAINT fk_rol_sis_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7117 (class 2606 OID 832977)
-- Name: fk_rol_usr_alt; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_rol
    ADD CONSTRAINT fk_rol_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7118 (class 2606 OID 832982)
-- Name: fk_rol_usr_inc; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_rol
    ADD CONSTRAINT fk_rol_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7125 (class 2606 OID 832987)
-- Name: fk_sis_usr_sis; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_sis_usr
    ADD CONSTRAINT fk_sis_usr_sis FOREIGN KEY (cd_sis) REFERENCES tbl_sis(cd_sis);


--
-- TOC entry 7126 (class 2606 OID 832992)
-- Name: fk_sis_usr_usr; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_sis_usr
    ADD CONSTRAINT fk_sis_usr_usr FOREIGN KEY (cd_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7127 (class 2606 OID 832997)
-- Name: fk_sis_usr_usralt; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_sis_usr
    ADD CONSTRAINT fk_sis_usr_usralt FOREIGN KEY (cd_alt_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7128 (class 2606 OID 833002)
-- Name: fk_sis_usr_usrinc; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_sis_usr
    ADD CONSTRAINT fk_sis_usr_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7123 (class 2606 OID 833007)
-- Name: fk_sis_usralt; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_sis
    ADD CONSTRAINT fk_sis_usralt FOREIGN KEY (cd_alt_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7124 (class 2606 OID 833012)
-- Name: fk_sis_usrinc; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_sis
    ADD CONSTRAINT fk_sis_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7326 (class 2606 OID 1637533)
-- Name: fk_tkn_usr; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_tkn
    ADD CONSTRAINT fk_tkn_usr FOREIGN KEY (cd_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7235 (class 2606 OID 889070)
-- Name: fk_ucr; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_ucc
    ADD CONSTRAINT fk_ucr FOREIGN KEY (cd_ucr) REFERENCES tbl_ucr(cd_ucr);


--
-- TOC entry 7291 (class 2606 OID 1007413)
-- Name: fk_ucr; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_cfv
    ADD CONSTRAINT fk_ucr FOREIGN KEY (cd_ucr) REFERENCES tbl_ucr(cd_ucr);


--
-- TOC entry 7129 (class 2606 OID 833017)
-- Name: fk_ucr_crt; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_ucr
    ADD CONSTRAINT fk_ucr_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 7238 (class 2606 OID 889160)
-- Name: fk_ucr_crt_old; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_ucr_old
    ADD CONSTRAINT fk_ucr_crt_old FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 7239 (class 2606 OID 889180)
-- Name: fk_ucr_old; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_ucc_old
    ADD CONSTRAINT fk_ucr_old FOREIGN KEY (cd_ucr) REFERENCES tbl_ucr_old(cd_ucr);


--
-- TOC entry 7258 (class 2606 OID 973929)
-- Name: fk_usr; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_epl
    ADD CONSTRAINT fk_usr FOREIGN KEY (cd_usr_alt) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7130 (class 2606 OID 833022)
-- Name: fk_usr_cun; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_usr
    ADD CONSTRAINT fk_usr_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 7131 (class 2606 OID 833027)
-- Name: fk_usr_grp_grp; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_usr_grp
    ADD CONSTRAINT fk_usr_grp_grp FOREIGN KEY (cd_grp) REFERENCES tbl_grp(cd_grp);


--
-- TOC entry 7132 (class 2606 OID 833032)
-- Name: fk_usr_grp_usr; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_usr_grp
    ADD CONSTRAINT fk_usr_grp_usr FOREIGN KEY (cd_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7133 (class 2606 OID 833037)
-- Name: fk_usr_grp_usr_alt; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_usr_grp
    ADD CONSTRAINT fk_usr_grp_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES tbl_usr(cd_usr);


--
-- TOC entry 7134 (class 2606 OID 833042)
-- Name: fk_usr_grp_usr_inc; Type: FK CONSTRAINT; Schema: sc_sgr; Owner: scan
--

ALTER TABLE ONLY tbl_usr_grp
    ADD CONSTRAINT fk_usr_grp_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES tbl_usr(cd_usr);


SET search_path = sc_spc, pg_catalog;

--
-- TOC entry 7138 (class 2606 OID 833047)
-- Name: fg_drcs_hrs; Type: FK CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_drcs
    ADD CONSTRAINT fg_drcs_hrs FOREIGN KEY (cd_hrs) REFERENCES tbl_hrs(cd_hrs);


--
-- TOC entry 7139 (class 2606 OID 833052)
-- Name: fg_drss_hrs; Type: FK CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_drss
    ADD CONSTRAINT fg_drss_hrs FOREIGN KEY (cd_hrs) REFERENCES tbl_hrs(cd_hrs);


--
-- TOC entry 7135 (class 2606 OID 833057)
-- Name: fk_det_hdr; Type: FK CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_det
    ADD CONSTRAINT fk_det_hdr FOREIGN KEY (cd_hdr) REFERENCES tbl_hdr(cd_hdr);


--
-- TOC entry 7136 (class 2606 OID 833062)
-- Name: fk_det_ret_cns; Type: FK CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_det
    ADD CONSTRAINT fk_det_ret_cns FOREIGN KEY (cd_ret_cns_det) REFERENCES tbl_ret(cd_ret);


--
-- TOC entry 7137 (class 2606 OID 833067)
-- Name: fk_det_ret_spc; Type: FK CONSTRAINT; Schema: sc_spc; Owner: scan
--

ALTER TABLE ONLY tbl_det
    ADD CONSTRAINT fk_det_ret_spc FOREIGN KEY (cd_ret_spc_det) REFERENCES tbl_ret(cd_ret);


SET search_path = sc_srv, pg_catalog;

--
-- TOC entry 7140 (class 2606 OID 833072)
-- Name: fk_cap_new_has; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_cap
    ADD CONSTRAINT fk_cap_new_has FOREIGN KEY (cd_new_has) REFERENCES tbl_has(cd_has);


--
-- TOC entry 7141 (class 2606 OID 833077)
-- Name: fk_cap_pag_has; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_cap
    ADD CONSTRAINT fk_cap_pag_has FOREIGN KEY (cd_pag_has) REFERENCES tbl_has(cd_has);


--
-- TOC entry 7142 (class 2606 OID 833082)
-- Name: fk_cap_sgr; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_cap
    ADD CONSTRAINT fk_cap_sgr FOREIGN KEY (cd_sgr) REFERENCES tbl_sgr(cd_sgr);


--
-- TOC entry 7143 (class 2606 OID 833087)
-- Name: fk_drc_hrc; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_drc
    ADD CONSTRAINT fk_drc_hrc FOREIGN KEY (cd_hrc) REFERENCES tbl_hrc(cd_hrc);


--
-- TOC entry 7144 (class 2606 OID 833092)
-- Name: fk_scr_alt_usr; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_scr
    ADD CONSTRAINT fk_scr_alt_usr FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7145 (class 2606 OID 833097)
-- Name: fk_scr_crt; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_scr
    ADD CONSTRAINT fk_scr_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 7146 (class 2606 OID 833102)
-- Name: fk_scr_inc_usr; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_scr
    ADD CONSTRAINT fk_scr_inc_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7147 (class 2606 OID 833107)
-- Name: fk_scr_srv; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_scr
    ADD CONSTRAINT fk_scr_srv FOREIGN KEY (cd_srv) REFERENCES tbl_srv(cd_srv);


--
-- TOC entry 7148 (class 2606 OID 833112)
-- Name: fk_sga_cnt; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_sga
    ADD CONSTRAINT fk_sga_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 7149 (class 2606 OID 833117)
-- Name: fk_sga_inc_alt; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_sga
    ADD CONSTRAINT fk_sga_inc_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7150 (class 2606 OID 833122)
-- Name: fk_sga_inc_usr; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_sga
    ADD CONSTRAINT fk_sga_inc_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7151 (class 2606 OID 833127)
-- Name: fk_sgr_cnc_has; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_sgr
    ADD CONSTRAINT fk_sgr_cnc_has FOREIGN KEY (cd_cnc_has) REFERENCES tbl_has(cd_has);


--
-- TOC entry 7152 (class 2606 OID 833132)
-- Name: fk_sgr_cnc_usr; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_sgr
    ADD CONSTRAINT fk_sgr_cnc_usr FOREIGN KEY (cd_cnc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7153 (class 2606 OID 833137)
-- Name: fk_sgr_csg; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_sgr
    ADD CONSTRAINT fk_sgr_csg FOREIGN KEY (cd_csg) REFERENCES sc_svg.tbl_csg(cd_csg);


--
-- TOC entry 7154 (class 2606 OID 833142)
-- Name: fk_sgr_fnc; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_sgr
    ADD CONSTRAINT fk_sgr_fnc FOREIGN KEY (cd_fnc) REFERENCES sc_cad.tbl_fnc(cd_fnc);


--
-- TOC entry 7155 (class 2606 OID 833147)
-- Name: fk_sgr_has; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_sgr
    ADD CONSTRAINT fk_sgr_has FOREIGN KEY (cd_has) REFERENCES tbl_has(cd_has);


--
-- TOC entry 7156 (class 2606 OID 833152)
-- Name: fk_sgr_scr; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_sgr
    ADD CONSTRAINT fk_sgr_scr FOREIGN KEY (cd_scr) REFERENCES tbl_scr(cd_scr);


--
-- TOC entry 7157 (class 2606 OID 833157)
-- Name: fk_sgr_sga; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_sgr
    ADD CONSTRAINT fk_sgr_sga FOREIGN KEY (cd_sga) REFERENCES tbl_sga(cd_sga);


--
-- TOC entry 7158 (class 2606 OID 833162)
-- Name: fk_srv_cnt; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_srv
    ADD CONSTRAINT fk_srv_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 7159 (class 2606 OID 833167)
-- Name: fk_srv_tlc; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_srv
    ADD CONSTRAINT fk_srv_tlc FOREIGN KEY (cd_tlc) REFERENCES sc_cnt.tbl_tlc(cd_tlc);


--
-- TOC entry 7160 (class 2606 OID 833172)
-- Name: fk_trc_hrc; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_trc
    ADD CONSTRAINT fk_trc_hrc FOREIGN KEY (cd_trc) REFERENCES tbl_hrc(cd_hrc);


--
-- TOC entry 7161 (class 2606 OID 833177)
-- Name: fk_tsc_altusr; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_tsc
    ADD CONSTRAINT fk_tsc_altusr FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7162 (class 2606 OID 833182)
-- Name: fk_tsc_cnt; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_tsc
    ADD CONSTRAINT fk_tsc_cnt FOREIGN KEY (cd_cnt) REFERENCES sc_cnt.tbl_cnt(cd_cnt);


--
-- TOC entry 7163 (class 2606 OID 833187)
-- Name: fk_tsc_crt; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_tsc
    ADD CONSTRAINT fk_tsc_crt FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 7164 (class 2606 OID 833192)
-- Name: fk_tsc_incusr; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_tsc
    ADD CONSTRAINT fk_tsc_incusr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7165 (class 2606 OID 833197)
-- Name: fk_tsc_opr; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_tsc
    ADD CONSTRAINT fk_tsc_opr FOREIGN KEY (cd_opr) REFERENCES sc_opr.tbl_opr(cd_opr);


--
-- TOC entry 7166 (class 2606 OID 833202)
-- Name: fk_tsc_srv; Type: FK CONSTRAINT; Schema: sc_srv; Owner: scan
--

ALTER TABLE ONLY tbl_tsc
    ADD CONSTRAINT fk_tsc_srv FOREIGN KEY (cd_srv) REFERENCES tbl_srv(cd_srv);


SET search_path = sc_ssp, pg_catalog;

--
-- TOC entry 7167 (class 2606 OID 833207)
-- Name: fk_caep_emp; Type: FK CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_caep
    ADD CONSTRAINT fk_caep_emp FOREIGN KEY (cd_emp) REFERENCES sc_cad.tbl_emp(cd_emp);


--
-- TOC entry 7168 (class 2606 OID 833212)
-- Name: fk_caep_haep; Type: FK CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_caep
    ADD CONSTRAINT fk_caep_haep FOREIGN KEY (cd_haep) REFERENCES tbl_haep(cd_haep);


--
-- TOC entry 7169 (class 2606 OID 833217)
-- Name: fk_caep_mpl; Type: FK CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_caep
    ADD CONSTRAINT fk_caep_mpl FOREIGN KEY (cd_mpl) REFERENCES tbl_mpl(cd_mpl);


--
-- TOC entry 7170 (class 2606 OID 833222)
-- Name: fk_daep_caep; Type: FK CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_daep
    ADD CONSTRAINT fk_daep_caep FOREIGN KEY (cd_caep) REFERENCES tbl_caep(cd_caep);


--
-- TOC entry 7171 (class 2606 OID 833227)
-- Name: fk_daep_faep; Type: FK CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_daep
    ADD CONSTRAINT fk_daep_faep FOREIGN KEY (cd_faep) REFERENCES tbl_faep(cd_faep);


--
-- TOC entry 7172 (class 2606 OID 833232)
-- Name: fk_daep_haep; Type: FK CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_daep
    ADD CONSTRAINT fk_daep_haep FOREIGN KEY (cd_haep) REFERENCES tbl_haep(cd_haep);


--
-- TOC entry 7173 (class 2606 OID 833237)
-- Name: fk_daep_pls; Type: FK CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_daep
    ADD CONSTRAINT fk_daep_pls FOREIGN KEY (cd_pls) REFERENCES sc_opr.tbl_pls(cd_pls);


--
-- TOC entry 7175 (class 2606 OID 833242)
-- Name: fk_faep_fem; Type: FK CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_faep
    ADD CONSTRAINT fk_faep_fem FOREIGN KEY (cd_emp, cd_fem) REFERENCES sc_cad.tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 7176 (class 2606 OID 833247)
-- Name: fk_ssp_mpl; Type: FK CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_ssp
    ADD CONSTRAINT fk_ssp_mpl FOREIGN KEY (cd_mpl) REFERENCES tbl_mpl(cd_mpl);


--
-- TOC entry 7177 (class 2606 OID 833252)
-- Name: fk_ssp_pls; Type: FK CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_ssp
    ADD CONSTRAINT fk_ssp_pls FOREIGN KEY (cd_pls) REFERENCES sc_opr.tbl_pls(cd_pls);


--
-- TOC entry 7178 (class 2606 OID 833257)
-- Name: fk_ssp_pop; Type: FK CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_ssp
    ADD CONSTRAINT fk_ssp_pop FOREIGN KEY (cd_pop) REFERENCES sc_rds.tbl_pop(cd_pop);


--
-- TOC entry 7174 (class 2606 OID 833262)
-- Name: fk_ssp_pop; Type: FK CONSTRAINT; Schema: sc_ssp; Owner: scan
--

ALTER TABLE ONLY tbl_daep
    ADD CONSTRAINT fk_ssp_pop FOREIGN KEY (cd_pop) REFERENCES sc_rds.tbl_pop(cd_pop);


SET search_path = sc_svg, pg_catalog;

--
-- TOC entry 7179 (class 2606 OID 833267)
-- Name: fk_ars_csg; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_ars
    ADD CONSTRAINT fk_ars_csg FOREIGN KEY (cd_csg) REFERENCES tbl_csg(cd_csg);


--
-- TOC entry 7180 (class 2606 OID 902314)
-- Name: fk_csg_sga; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_csg
    ADD CONSTRAINT fk_csg_sga FOREIGN KEY (cd_sga) REFERENCES sc_srv.tbl_sga(cd_sga);


--
-- TOC entry 7181 (class 2606 OID 902319)
-- Name: fk_csg_usr_alt; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_csg
    ADD CONSTRAINT fk_csg_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7182 (class 2606 OID 902324)
-- Name: fk_csg_usr_inc; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_csg
    ADD CONSTRAINT fk_csg_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7183 (class 2606 OID 902329)
-- Name: fk_cvg_grt; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_csg
    ADD CONSTRAINT fk_cvg_grt FOREIGN KEY (cd_grt) REFERENCES sc_cad.tbl_grt(cd_grt);


--
-- TOC entry 7184 (class 2606 OID 833292)
-- Name: fk_drs_ars; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_drs
    ADD CONSTRAINT fk_drs_ars FOREIGN KEY (cd_ars) REFERENCES tbl_ars(cd_ars);


--
-- TOC entry 7185 (class 2606 OID 942547)
-- Name: fk_fem_csg_csg; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_fem_csg
    ADD CONSTRAINT fk_fem_csg_csg FOREIGN KEY (cd_csg) REFERENCES tbl_csg(cd_csg);


--
-- TOC entry 7186 (class 2606 OID 942552)
-- Name: fk_fem_csg_usr_alt; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_fem_csg
    ADD CONSTRAINT fk_fem_csg_usr_alt FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7187 (class 2606 OID 942557)
-- Name: fk_fem_csg_usr_inc; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_fem_csg
    ADD CONSTRAINT fk_fem_csg_usr_inc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7188 (class 2606 OID 942562)
-- Name: fk_fem_svg_emp; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_fem_csg
    ADD CONSTRAINT fk_fem_svg_emp FOREIGN KEY (cd_emp) REFERENCES sc_cad.tbl_emp(cd_emp);


--
-- TOC entry 7189 (class 2606 OID 942567)
-- Name: fk_fem_svg_fem; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_fem_csg
    ADD CONSTRAINT fk_fem_svg_fem FOREIGN KEY (cd_emp, cd_fem) REFERENCES sc_cad.tbl_fem(cd_emp, cd_fem);


--
-- TOC entry 7190 (class 2606 OID 932653)
-- Name: fk_osg_sgr; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_osg
    ADD CONSTRAINT fk_osg_sgr FOREIGN KEY (cd_osg) REFERENCES tbl_osg(cd_osg);


--
-- TOC entry 7191 (class 2606 OID 932658)
-- Name: fk_osg_tos; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_osg
    ADD CONSTRAINT fk_osg_tos FOREIGN KEY (cd_tos) REFERENCES tbl_tos(cd_tos);


--
-- TOC entry 7192 (class 2606 OID 932663)
-- Name: fk_osg_usr; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_osg
    ADD CONSTRAINT fk_osg_usr FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7193 (class 2606 OID 833337)
-- Name: fk_psg_sgr; Type: FK CONSTRAINT; Schema: sc_svg; Owner: scan
--

ALTER TABLE ONLY tbl_psg
    ADD CONSTRAINT fk_psg_sgr FOREIGN KEY (cd_sgr) REFERENCES sc_srv.tbl_sgr(cd_sgr);


SET search_path = sc_tem, pg_catalog;

--
-- TOC entry 7194 (class 2606 OID 833342)
-- Name: fk_ads_cun; Type: FK CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_ads
    ADD CONSTRAINT fk_ads_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 7195 (class 2606 OID 833347)
-- Name: fk_altusr_ads; Type: FK CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_ads
    ADD CONSTRAINT fk_altusr_ads FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7198 (class 2606 OID 833352)
-- Name: fk_altusr_css; Type: FK CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_css
    ADD CONSTRAINT fk_altusr_css FOREIGN KEY (cd_alt_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7196 (class 2606 OID 833357)
-- Name: fk_crt_ads; Type: FK CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_ads
    ADD CONSTRAINT fk_crt_ads FOREIGN KEY (cd_crt) REFERENCES sc_opr.tbl_crt(cd_crt);


--
-- TOC entry 7199 (class 2606 OID 833362)
-- Name: fk_css_cun; Type: FK CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_css
    ADD CONSTRAINT fk_css_cun FOREIGN KEY (cd_cun) REFERENCES sc_cad.tbl_cun(cd_cun);


--
-- TOC entry 7201 (class 2606 OID 833367)
-- Name: fk_oca_ads; Type: FK CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_oca
    ADD CONSTRAINT fk_oca_ads FOREIGN KEY (cd_ads) REFERENCES tbl_ads(cd_ads);


--
-- TOC entry 7202 (class 2606 OID 833372)
-- Name: fk_oca_usrinc; Type: FK CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_oca
    ADD CONSTRAINT fk_oca_usrinc FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7203 (class 2606 OID 833377)
-- Name: fk_prc_ads; Type: FK CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_prc
    ADD CONSTRAINT fk_prc_ads FOREIGN KEY (cd_ads) REFERENCES tbl_ads(cd_ads);


--
-- TOC entry 7204 (class 2606 OID 833382)
-- Name: fk_prc_rqs; Type: FK CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_prc
    ADD CONSTRAINT fk_prc_rqs FOREIGN KEY (cd_rqs) REFERENCES tbl_rqs(cd_rqs);


--
-- TOC entry 7197 (class 2606 OID 833387)
-- Name: fk_usrinc_ads; Type: FK CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_ads
    ADD CONSTRAINT fk_usrinc_ads FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


--
-- TOC entry 7200 (class 2606 OID 833392)
-- Name: fk_usrinc_css; Type: FK CONSTRAINT; Schema: sc_tem; Owner: scan
--

ALTER TABLE ONLY tbl_css
    ADD CONSTRAINT fk_usrinc_css FOREIGN KEY (cd_inc_usr) REFERENCES sc_sgr.tbl_usr(cd_usr);


SET search_path = sqlj, pg_catalog;

--
-- TOC entry 7205 (class 2606 OID 833397)
-- Name: classpath_entry_jarid_fkey; Type: FK CONSTRAINT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY classpath_entry
    ADD CONSTRAINT classpath_entry_jarid_fkey FOREIGN KEY (jarid) REFERENCES jar_repository(jarid) ON DELETE CASCADE;


--
-- TOC entry 7206 (class 2606 OID 833402)
-- Name: jar_entry_jarid_fkey; Type: FK CONSTRAINT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY jar_entry
    ADD CONSTRAINT jar_entry_jarid_fkey FOREIGN KEY (jarid) REFERENCES jar_repository(jarid) ON DELETE CASCADE;


--
-- TOC entry 7207 (class 2606 OID 833407)
-- Name: jar_repository_deploymentdesc_fkey; Type: FK CONSTRAINT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY jar_repository
    ADD CONSTRAINT jar_repository_deploymentdesc_fkey FOREIGN KEY (deploymentdesc) REFERENCES jar_entry(entryid) ON DELETE SET NULL;


--
-- TOC entry 7208 (class 2606 OID 833412)
-- Name: jar_repository_deploymentdesc_fkey1; Type: FK CONSTRAINT; Schema: sqlj; Owner: scan
--

ALTER TABLE ONLY jar_repository
    ADD CONSTRAINT jar_repository_deploymentdesc_fkey1 FOREIGN KEY (deploymentdesc) REFERENCES jar_entry(entryid) ON DELETE SET NULL;


--
-- TOC entry 7461 (class 0 OID 0)
-- Dependencies: 49
-- Name: public; Type: ACL; Schema: -; Owner: postgres
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT ALL ON SCHEMA public TO PUBLIC;


--
-- TOC entry 7497 (class 0 OID 0)
-- Dependencies: 50
-- Name: sqlj; Type: ACL; Schema: -; Owner: scan
--

REVOKE ALL ON SCHEMA sqlj FROM PUBLIC;
REVOKE ALL ON SCHEMA sqlj FROM scan;
GRANT ALL ON SCHEMA sqlj TO scan;
GRANT USAGE ON SCHEMA sqlj TO PUBLIC;


SET search_path = public, pg_catalog;

--
-- TOC entry 7498 (class 0 OID 0)
-- Dependencies: 1488
-- Name: dblink_connect_u(text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION dblink_connect_u(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION dblink_connect_u(text) FROM postgres;
GRANT ALL ON FUNCTION dblink_connect_u(text) TO postgres;


--
-- TOC entry 7499 (class 0 OID 0)
-- Dependencies: 1489
-- Name: dblink_connect_u(text, text); Type: ACL; Schema: public; Owner: postgres
--

REVOKE ALL ON FUNCTION dblink_connect_u(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION dblink_connect_u(text, text) FROM postgres;
GRANT ALL ON FUNCTION dblink_connect_u(text, text) TO postgres;


SET search_path = sqlj, pg_catalog;

--
-- TOC entry 10175 (class 0 OID 0)
-- Dependencies: 761
-- Name: classpath_entry; Type: ACL; Schema: sqlj; Owner: scan
--

REVOKE ALL ON TABLE classpath_entry FROM PUBLIC;
REVOKE ALL ON TABLE classpath_entry FROM scan;
GRANT ALL ON TABLE classpath_entry TO scan;
GRANT SELECT ON TABLE classpath_entry TO PUBLIC;


--
-- TOC entry 10176 (class 0 OID 0)
-- Dependencies: 762
-- Name: jar_entry; Type: ACL; Schema: sqlj; Owner: scan
--

REVOKE ALL ON TABLE jar_entry FROM PUBLIC;
REVOKE ALL ON TABLE jar_entry FROM scan;
GRANT ALL ON TABLE jar_entry TO scan;
GRANT SELECT ON TABLE jar_entry TO PUBLIC;


--
-- TOC entry 10178 (class 0 OID 0)
-- Dependencies: 764
-- Name: jar_repository; Type: ACL; Schema: sqlj; Owner: scan
--

REVOKE ALL ON TABLE jar_repository FROM PUBLIC;
REVOKE ALL ON TABLE jar_repository FROM scan;
GRANT ALL ON TABLE jar_repository TO scan;
GRANT SELECT ON TABLE jar_repository TO PUBLIC;


--
-- TOC entry 10180 (class 0 OID 0)
-- Dependencies: 766
-- Name: typemap_entry; Type: ACL; Schema: sqlj; Owner: scan
--

REVOKE ALL ON TABLE typemap_entry FROM PUBLIC;
REVOKE ALL ON TABLE typemap_entry FROM scan;
GRANT ALL ON TABLE typemap_entry TO scan;
GRANT SELECT ON TABLE typemap_entry TO PUBLIC;


-- Completed on 2019-11-08 10:38:08

--
-- PostgreSQL database dump complete
--

